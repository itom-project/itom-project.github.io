<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>dataIO &mdash; itom Documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/breathe.css" type="text/css" />
    <link rel="stylesheet" href="../_static/breathe.css" type="text/css" />
    <link rel="stylesheet" href="../_static/breathe.css" type="text/css" />
    <link rel="stylesheet" href="../_static/breathe.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     'e29f2f4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="itom Documentation" href="../index.html" />
    <link rel="up" title="itom Script Reference" href="reference.html" />
    <link rel="next" title="actuator" href="actuator.html" />
    <link rel="prev" title="itom.plot" href="generated/itom.plot.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="actuator.html" title="actuator"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="generated/itom.plot.html" title="itom.plot"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">itom</a> &raquo;</li>
          <li><a href="../structure.html" >Structure of the manual</a> &raquo;</li>
          <li><a href="reference.html" accesskey="U">itom Script Reference</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="dataio">
<h1>dataIO<a class="headerlink" href="#dataio" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="itom.dataIO">
<em class="property">class </em><tt class="descclassname">itom.</tt><tt class="descname">dataIO</tt><a class="headerlink" href="#itom.dataIO" title="Permalink to this definition">¶</a></dt>
<dd><p>dataIO(name[, mandparams, optparams]) -&gt; creates new instance of dataIO plugin &#8216;name&#8217;</p>
<p>This is the constructor for a <a class="reference internal" href="#itom.dataIO" title="itom.dataIO"><tt class="xref py py-obj docutils literal"><span class="pre">dataIO</span></tt></a> plugin. It initializes an new instance of the plugin specified by &#8216;name&#8217;. 
The initialisation parameters are parsed and unnamed parameters are used in their incoming order to fill first 
mandatory parameters and afterwards optional parameters. Parameters may be passed with name as well but after 
the first named parameter no more unnamed parameters are allowed.</p>
<p>See pluginHelp(name) for detail information about the specific initialisation parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>name</strong> : {str}</p>
<blockquote>
<div><p>is the fullname (case sensitive) of an &#8216;actuator&#8217;-plugin as specified in the plugin-window.</p>
</div></blockquote>
<p><strong>mandparams</strong> : {variant(s)}</p>
<blockquote>
<div><p>arguments corresponding the mandatory initialization parameters. The number of arguments and their order must fit the the required mandatory parameters</p>
</div></blockquote>
<p><strong>optparams</strong> : {variant(s)}, optional</p>
<blockquote>
<div><p>argument corresponding to the optional initialization parameters. If unnamed arguments are used, their order must correspond to the order of the optional parameters, keyword-based parameters are allowed as well.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>inst</strong> : {dataIO}</p>
<blockquote class="last">
<div><p>new instance of the dataIO-plugin</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="itom.dataIO.acquire">
<tt class="descname">acquire</tt><big>(</big><em>trigger=dataIO.TRIGGER_SOFTWARE</em><big>)</big> &rarr; triggers a new the camera acquisition<a class="headerlink" href="#itom.dataIO.acquire" title="Permalink to this definition">¶</a></dt>
<dd><p>This method triggers a new data acquisition. This method immediately returns even if the acquisition is not finished yet. 
Use <a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><tt class="xref py py-obj docutils literal"><span class="pre">getVal</span></tt></a> or <a class="reference internal" href="#itom.dataIO.copyVal" title="itom.dataIO.copyVal"><tt class="xref py py-obj docutils literal"><span class="pre">copyVal</span></tt></a> to get the acquired data. Both methods block until the data is available.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>trigger</strong> : {int}, optional</p>
<blockquote class="last">
<div><p>Type of the trigger:</p>
<ul class="simple">
<li><em class="xref py py-obj">dataIO.TRIGGER_SOFTWARE = 0</em> : a software trigger is started, hence, the acquisition is immediately started when calling this method</li>
<li>others : depending on your camera, this parameter can be used to set other triggers, like hardware trigger with raising or falling edges...</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.copyVal">
<tt class="descname">copyVal</tt><big>(</big><em>dataObject</em><big>)</big> &rarr; gets deep copy of data of this plugin, stored in the given data object.<a class="headerlink" href="#itom.dataIO.copyVal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deep copy of the recently acquired data (for grabber and ADDA only) of the camera or AD-converter device. 
The deep copy sometimes requires one copy operation more than the similar command <a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><tt class="xref py py-obj docutils literal"><span class="pre">getVal</span></tt></a>. However, <a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><tt class="xref py py-obj docutils literal"><span class="pre">getVal</span></tt></a> only returns 
a reference to the plugin internal data structure whose values might be changed if another data acquisition is started.</p>
<p>If no acquisition has been triggered, this method raises a RuntimeError. If the acquisition is not finished yet, this method 
blocks and waits until the end of the acquisition.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dataObject</strong> : {<a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><tt class="xref py py-obj docutils literal"><span class="pre">dataObject</span></tt></a>}</p>
<blockquote>
<div><p><a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><tt class="xref py py-obj docutils literal"><span class="pre">dataObject</span></tt></a> where the plugin data is copied to. Either provide an empty <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><tt class="xref py py-obj docutils literal"><span class="pre">dataObject</span></tt></a> or a <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><tt class="xref py py-obj docutils literal"><span class="pre">dataObject</span></tt></a> whose size (or region of interest) 
exactly has the same size than the available data of the plugin. Therefore you can allocate a 3D data object, set a region of interest 
to one plane such that the data from the plugin is copied into this plane.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong> :</p>
<blockquote class="last">
<div><p>if the dataIO plugin is anything else than ADDA or grabber
or if no acquisition has been triggered</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><tt class="xref py py-obj docutils literal"><span class="pre">getVal</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.disableAutoGrabbing">
<tt class="descname">disableAutoGrabbing</tt><big>(</big><big>)</big> &rarr; Disable auto grabbing for the grabber (camera...),<a class="headerlink" href="#itom.dataIO.disableAutoGrabbing" title="Permalink to this definition">¶</a></dt>
<dd><p>If the auto grabbing flag is set, the camera acquisition is automatically and continuously triggered if at least one live image is 
connected. This is an undesired behaviour if a measurement is started where the acquisition should be controlled by a specific 
script or something similar. Then disable the auto grabbing property. All connected live images will then get new images when 
<a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><tt class="xref py py-obj docutils literal"><span class="pre">getVal</span></tt></a> or <a class="reference internal" href="#itom.dataIO.copyVal" title="itom.dataIO.copyVal"><tt class="xref py py-obj docutils literal"><span class="pre">copyVal</span></tt></a> is called by the script. The live image timer is disabled.</p>
<p>This method disables the auto grabbing flag.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataIO.setAutoGrabbing" title="itom.dataIO.setAutoGrabbing"><tt class="xref py py-obj docutils literal"><span class="pre">setAutoGrabbing</span></tt></a>, <a class="reference internal" href="#itom.dataIO.disableAutoGrabbing" title="itom.dataIO.disableAutoGrabbing"><tt class="xref py py-obj docutils literal"><span class="pre">disableAutoGrabbing</span></tt></a>, <a class="reference internal" href="#itom.dataIO.getAutoGrabbing" title="itom.dataIO.getAutoGrabbing"><tt class="xref py py-obj docutils literal"><span class="pre">getAutoGrabbing</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.enableAutoGrabbing">
<tt class="descname">enableAutoGrabbing</tt><big>(</big><big>)</big> &rarr; enable auto grabbing for the grabber (camera...),<a class="headerlink" href="#itom.dataIO.enableAutoGrabbing" title="Permalink to this definition">¶</a></dt>
<dd><p>If the auto grabbing flag is set, the camera acquisition is automatically and continuously triggered if at least one live image is 
connected. This is an undesired behaviour if a measurement is started where the acquisition should be controlled by a specific 
script or something similar. Then disable the auto grabbing property. All connected live images will then get new images when 
<a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><tt class="xref py py-obj docutils literal"><span class="pre">getVal</span></tt></a> or <a class="reference internal" href="#itom.dataIO.copyVal" title="itom.dataIO.copyVal"><tt class="xref py py-obj docutils literal"><span class="pre">copyVal</span></tt></a> is called by the script. The live image timer is disabled.</p>
<p>This method enables the auto grabbing flag.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataIO.setAutoGrabbing" title="itom.dataIO.setAutoGrabbing"><tt class="xref py py-obj docutils literal"><span class="pre">setAutoGrabbing</span></tt></a>, <a class="reference internal" href="#itom.dataIO.disableAutoGrabbing" title="itom.dataIO.disableAutoGrabbing"><tt class="xref py py-obj docutils literal"><span class="pre">disableAutoGrabbing</span></tt></a>, <a class="reference internal" href="#itom.dataIO.getAutoGrabbing" title="itom.dataIO.getAutoGrabbing"><tt class="xref py py-obj docutils literal"><span class="pre">getAutoGrabbing</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.exec">
<tt class="descname">exec</tt><big>(</big><em>funcName</em><span class="optional">[</span>, <em>param1</em>, <em>...</em><span class="optional">]</span><big>)</big> &rarr; invoke the function 'funcName' registered as execFunc within the plugin.<a class="headerlink" href="#itom.dataIO.exec" title="Permalink to this definition">¶</a></dt>
<dd><p>Every plugin can define further functions that can for instance be used in order to call specific calibration routines 
of cameras or actuators. This general method is used to call one of these specific functions registered under <em class="xref py py-obj">funcName</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>funcName</strong> : {str}</p>
<blockquote>
<div><p>The name of the function</p>
</div></blockquote>
<p><strong>param1</strong> : {variant}, optional</p>
<blockquote>
<div><p>Further parameters depending on the requirements of the specific function.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : {variant, list of variants}.</p>
<blockquote class="last">
<div><p>The return values depend on the function itself.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-obj docutils literal"><span class="pre">execFuncsInfo</span></tt></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.getAutoGrabbing">
<tt class="descname">getAutoGrabbing</tt><big>(</big><big>)</big> &rarr; return the status of the auto grabbing flag.<a class="headerlink" href="#itom.dataIO.getAutoGrabbing" title="Permalink to this definition">¶</a></dt>
<dd><p>If the auto grabbing flag is set, the camera acquisition is automatically and continuously triggered if at least one live image is 
connected. This is an undesired behaviour if a measurement is started where the acquisition should be controlled by a specific 
script or something similar. Then disable the auto grabbing property. All connected live images will then get new images when 
<a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><tt class="xref py py-obj docutils literal"><span class="pre">getVal</span></tt></a> or <a class="reference internal" href="#itom.dataIO.copyVal" title="itom.dataIO.copyVal"><tt class="xref py py-obj docutils literal"><span class="pre">copyVal</span></tt></a> is called by the script. The live image timer is disabled.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>auto grabbing flag</strong> : {bool}</p>
<blockquote class="last">
<div><ul class="simple">
<li>False = auto grabbing off</li>
<li>True = auto grabbing on.</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataIO.enableAutoGrabbing" title="itom.dataIO.enableAutoGrabbing"><tt class="xref py py-obj docutils literal"><span class="pre">enableAutoGrabbing</span></tt></a>, <a class="reference internal" href="#itom.dataIO.disableAutoGrabbing" title="itom.dataIO.disableAutoGrabbing"><tt class="xref py py-obj docutils literal"><span class="pre">disableAutoGrabbing</span></tt></a>, <a class="reference internal" href="#itom.dataIO.setAutoGrabbing" title="itom.dataIO.setAutoGrabbing"><tt class="xref py py-obj docutils literal"><span class="pre">setAutoGrabbing</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.getExecFuncsInfo">
<tt class="descname">getExecFuncsInfo</tt><big>(</big><span class="optional">[</span><em>funcName</em><span class="optional">[</span>, <em>detailLevel</em><span class="optional">]</span><span class="optional">]</span><big>)</big> &rarr; plots a list of available execFuncs or a detailed description of the specified execFunc.<a class="headerlink" href="#itom.dataIO.getExecFuncsInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Every plugin can define further functions, that are called by plugin.exec(&#8216;funcName&#8217; [,param1, param2...]). This can for  
instance be used in order to call specific calibration routines of cameras or actuators. This method allows printing 
information about available functions of this type.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>funcName</strong> : {str}, optional</p>
<blockquote>
<div><p>is the fullname or a part of any execFunc-name which should be displayed. 
If funcName is none or no execFunc matches funcName casesensitiv a list with all suitable execFuncs is given.</p>
</div></blockquote>
<p><strong>detailLevel</strong> : {dict}, optional</p>
<blockquote>
<div><p>if <em class="xref py py-obj">detailLevel == 1</em>, function returns a dictionary with parameters [default: 0].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : {None or dict}</p>
<blockquote class="last">
<div><p>depending on the value of <em>detailLevel</em>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataIO.exec" title="itom.dataIO.exec"><tt class="xref py py-obj docutils literal"><span class="pre">exec</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.getParam">
<tt class="descname">getParam</tt><big>(</big><em>name</em><big>)</big> &rarr; current value of the plugin parameter 'name'.<a class="headerlink" href="#itom.dataIO.getParam" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current value of the internal plugin parameter with &#8216;name&#8217;. The type of the returned value depends on the 
real type of the internal plugin, which may be:</p>
<ul class="simple">
<li>String -&gt; str</li>
<li>Char, Integer -&gt; int</li>
<li>Double -&gt; float</li>
<li>CharArray, IntegerArray -&gt; tuple of int</li>
<li>DoubleArray -&gt; tuple of float</li>
<li>DataObject -&gt; dataObject</li>
<li>PolygonMesh -&gt; polygonMesh</li>
<li>PointCloud -&gt; pointCloud</li>
<li>Another plugin instance -&gt; dataIO or actuator</li>
</ul>
<p>The name of the parameter must have the following form:</p>
<ul class="simple">
<li>name</li>
<li>name:additionalTag (additionalTag can be a special feature of some plugins)</li>
<li>name[index] (only possible if parameter is an array type and you only want to get one single value, specified by the integer index [0,nrOfArrayItems-1])</li>
<li>name[index]:additionalTag</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>name</strong> : {str}</p>
<blockquote>
<div><p>name of the requested parameter</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : {variant}</p>
<blockquote>
<div><p>value of the parameter</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>ValueError</strong> :</p>
<blockquote class="last">
<div><p>if parameter does not exist</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataIO.setParam" title="itom.dataIO.setParam"><tt class="xref py py-obj docutils literal"><span class="pre">setParam</span></tt></a>, <a class="reference internal" href="#itom.dataIO.getParamList" title="itom.dataIO.getParamList"><tt class="xref py py-obj docutils literal"><span class="pre">getParamList</span></tt></a>, <a class="reference internal" href="#itom.dataIO.getParamListInfo" title="itom.dataIO.getParamListInfo"><tt class="xref py py-obj docutils literal"><span class="pre">getParamListInfo</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.getParamList">
<tt class="descname">getParamList</tt><big>(</big><big>)</big> &rarr; returns a list of the names of the internal parameters of the plugin<a class="headerlink" href="#itom.dataIO.getParamList" title="Permalink to this definition">¶</a></dt>
<dd><p>Each plugin defines a set of parameters, where each parameter has got a name and maps to any value. The value is represented by 
the C++ class ito::ParamBase and can have one of the following types:</p>
<ul class="simple">
<li>String</li>
<li>Char</li>
<li>Integer</li>
<li>Double</li>
<li>CharArray</li>
<li>IntegerArray</li>
<li>DoubleArray</li>
<li>DataObject</li>
<li>PolygonMesh</li>
<li>PointCloud</li>
<li>Another plugin instance</li>
</ul>
<p>Using one of the parameter names, its current value can be obtained by <em class="xref py py-obj">getParam(&#8216;name&#8217;)</em> and 
is writable by <em class="xref py py-obj">setParam(&#8216;name&#8217;, newValue)</em> (if not read-only)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : {list}</p>
<blockquote class="last">
<div><p>list of parameter names</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataIO.getParam" title="itom.dataIO.getParam"><tt class="xref py py-obj docutils literal"><span class="pre">getParam</span></tt></a>, <a class="reference internal" href="#itom.dataIO.setParam" title="itom.dataIO.setParam"><tt class="xref py py-obj docutils literal"><span class="pre">setParam</span></tt></a>, <a class="reference internal" href="#itom.dataIO.getParamListInfo" title="itom.dataIO.getParamListInfo"><tt class="xref py py-obj docutils literal"><span class="pre">getParamListInfo</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.getParamListInfo">
<tt class="descname">getParamListInfo</tt><big>(</big><span class="optional">[</span><em>detailLevel</em><span class="optional">]</span><big>)</big> &rarr; prints detailed information about all plugin parameters.<a class="headerlink" href="#itom.dataIO.getParamListInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Each plugin defines a set of parameters, where each parameter has got a name and maps to any value. The value is represented by 
the C++ class ito::ParamBase and can have one of the following types:</p>
<ul class="simple">
<li>String</li>
<li>Char</li>
<li>Integer</li>
<li>Double</li>
<li>CharArray</li>
<li>IntegerArray</li>
<li>DoubleArray</li>
<li>DataObject</li>
<li>PolygonMesh</li>
<li>PointCloud</li>
<li>Another plugin instance</li>
</ul>
<p>Using one of the parameter names, its current value can be obtained by <em class="xref py py-obj">getParam(&#8216;name&#8217;)</em> and 
is writable by <em class="xref py py-obj">setParam(&#8216;name&#8217;, newValue)</em> (if not read-only)</p>
<p>This method prints a detailed table with the name, current value, description string and further meta information of every plugin parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>detailLevel</strong> : {dict}, optional</p>
<blockquote>
<div><p>if <em class="xref py py-obj">detailLevel == 1</em>, function returns a dictionary with parameters, else None is returned [default]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : {None, dict}</p>
<blockquote class="last">
<div><p>If <em class="xref py py-obj">detailLevel == 1</em>, a dictionary containing all printed information is returned</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataIO.getParam" title="itom.dataIO.getParam"><tt class="xref py py-obj docutils literal"><span class="pre">getParam</span></tt></a>, <a class="reference internal" href="#itom.dataIO.setParam" title="itom.dataIO.setParam"><tt class="xref py py-obj docutils literal"><span class="pre">setParam</span></tt></a>, <a class="reference internal" href="#itom.dataIO.getParamList" title="itom.dataIO.getParamList"><tt class="xref py py-obj docutils literal"><span class="pre">getParamList</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.getType">
<tt class="descname">getType</tt><big>(</big><big>)</big> &rarr; returns dataIO type<a class="headerlink" href="#itom.dataIO.getType" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="itom.dataIO.getVal">
<tt class="descname">getVal</tt><big>(</big><em>buffer=`dataObject`|`bytearray`|`bytes`</em><span class="optional">[</span>, <em>length=maxlength</em><span class="optional">]</span><big>)</big> &rarr; returns shallow copy of internal camera image if `dataObject`-buffer is provided. Else values from plugin are copied to given byte or byte-array buffer.<a class="headerlink" href="#itom.dataIO.getVal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference (shallow copy) of the recently acquired image (located in the internal memory if the plugin) if the plugin is a grabber or camera and the buffer is a <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><tt class="xref py py-obj docutils literal"><span class="pre">dataObject</span></tt></a>. 
Please consider that the values of the <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><tt class="xref py py-obj docutils literal"><span class="pre">dataObject</span></tt></a> might change if a new image is acquired since it is only a reference. Therefore consider copying the <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><tt class="xref py py-obj docutils literal"><span class="pre">dataObject</span></tt></a> or directly use 
<a class="reference internal" href="#itom.dataIO.copyVal" title="itom.dataIO.copyVal"><tt class="xref py py-obj docutils literal"><span class="pre">copyVal</span></tt></a>.</p>
<p>If no acquisition has been triggered, this method raises a RuntimeError. If the acquisition is not finished yet, this method 
blocks and waits until the end of the acquisition.</p>
<p>If the plugin is another type than a grabber or camera (e.g. serialIO), this method requires any buffer-object that is preallocated with a reasonable size. Then, the currently available 
data is copied into this buffer object and the size of the copied data is returned. If the buffer is too small, only the data that fits into the buffer is copied. Another call to 
<a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><tt class="xref py py-obj docutils literal"><span class="pre">getVal</span></tt></a> will copy the rest.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>buffer</strong> : {<a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><tt class="xref py py-obj docutils literal"><span class="pre">dataObject</span></tt></a>, <em class="xref py py-obj">bytearray</em>, <em class="xref py py-obj">bytes</em> or <em class="xref py py-obj">str</em>}</p>
<blockquote>
<div><p>this parameter depends on the type of dataIO-instance:</p>
<ul class="simple">
<li>cameras, grabber: the buffer must be a <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><tt class="xref py py-obj docutils literal"><span class="pre">dataObject</span></tt></a> (no length parameter): A reference (shallow copy) to the internal memory of the camera plugin is set to the given data object.     Therefore its content may change if a new image is being acquired by the camera. Consider taking a deep copy if the image (<a class="reference internal" href="dataObject.html#itom.dataObject.copy" title="itom.dataObject.copy"><tt class="xref py py-obj docutils literal"><span class="pre">dataObject.copy</span></tt></a>) or use the method <a class="reference internal" href="#itom.dataIO.copyVal" title="itom.dataIO.copyVal"><tt class="xref py py-obj docutils literal"><span class="pre">copyVal</span></tt></a>.</li>
<li>other IO-devices (AD-converters): The buffer must be an object of type bytearray, bytes or unicode string. The length parameter is then set to the size of the buffers. The effective     size of the used memory in buffer is returned.</li>
</ul>
</div></blockquote>
<p><strong>length</strong> : {int}, optional</p>
<blockquote>
<div><p>size of the given buffer. This value is usually automatically determined and must not be given.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : {None or int}</p>
<blockquote class="last">
<div><p>None or size of used buffer if buffer is no <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><tt class="xref py py-obj docutils literal"><span class="pre">dataObject</span></tt></a></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataIO.copyVal" title="itom.dataIO.copyVal"><tt class="xref py py-obj docutils literal"><span class="pre">copyVal</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.hideToolbox">
<tt class="descname">hideToolbox</tt><big>(</big><big>)</big> &rarr; hides toolbox of the plugin<a class="headerlink" href="#itom.dataIO.hideToolbox" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong> :</p>
<blockquote class="last">
<div><p>if plugin does not provide a toolbox</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataIO.showToolbox" title="itom.dataIO.showToolbox"><tt class="xref py py-obj docutils literal"><span class="pre">showToolbox</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.name">
<tt class="descname">name</tt><big>(</big><big>)</big> &rarr; returns the plugin name<a class="headerlink" href="#itom.dataIO.name" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>name</strong> : {str}</p>
<blockquote class="last">
<div><p>name of the plugin, which corresponds to <em class="xref py py-obj">getParam(&#8216;name&#8217;)</em></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataIO.getParam" title="itom.dataIO.getParam"><tt class="xref py py-obj docutils literal"><span class="pre">getParam</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.setAutoGrabbing">
<tt class="descname">setAutoGrabbing</tt><big>(</big><em>on</em><big>)</big> &rarr; Set auto grabbing of the grabber device to on or off<a class="headerlink" href="#itom.dataIO.setAutoGrabbing" title="Permalink to this definition">¶</a></dt>
<dd><p>If the auto grabbing flag is set, the camera acquisition is automatically and continuously triggered if at least one live image is 
connected. This is an undesired behaviour if a measurement is started where the acquisition should be controlled by a specific 
script or something similar. Then disable the auto grabbing property. All connected live images will then get new images when 
<a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><tt class="xref py py-obj docutils literal"><span class="pre">getVal</span></tt></a> or <a class="reference internal" href="#itom.dataIO.copyVal" title="itom.dataIO.copyVal"><tt class="xref py py-obj docutils literal"><span class="pre">copyVal</span></tt></a> is called by the script. The live image timer is disabled.</p>
<p>This method allows setting this flag.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>on</strong> : {bool}</p>
<blockquote class="last">
<div><ul class="simple">
<li>TRUE = on</li>
<li>FALSE = off</li>
</ul>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataIO.enableAutoGrabbing" title="itom.dataIO.enableAutoGrabbing"><tt class="xref py py-obj docutils literal"><span class="pre">enableAutoGrabbing</span></tt></a>, <a class="reference internal" href="#itom.dataIO.disableAutoGrabbing" title="itom.dataIO.disableAutoGrabbing"><tt class="xref py py-obj docutils literal"><span class="pre">disableAutoGrabbing</span></tt></a>, <a class="reference internal" href="#itom.dataIO.getAutoGrabbing" title="itom.dataIO.getAutoGrabbing"><tt class="xref py py-obj docutils literal"><span class="pre">getAutoGrabbing</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.setParam">
<tt class="descname">setParam</tt><big>(</big><em>name</em>, <em>value</em><big>)</big> &rarr; sets parameter 'name' to the given value.<a class="headerlink" href="#itom.dataIO.setParam" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the internal plugin parameter with &#8216;name&#8217; to a new value. The plugin itsself can decide whether the given value is 
accepted as new value. This may depend on the type of the given value, but also on the allowed value range indicated by 
further meta information of the internal parameter. Parameters that have the read-only flag set can not be reset.</p>
<p>The name of the parameter must have the following form:</p>
<ul class="simple">
<li>name</li>
<li>name:additionalTag (additionalTag can be a special feature of some plugins)</li>
<li>name[index] (only possible if parameter is an array type and you only want to get one single value, specified by the integer index [0,nrOfArrayItems-1])</li>
<li>name[index]:additionalTag</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>name</strong> : {str}</p>
<blockquote>
<div><p>name of the parameter</p>
</div></blockquote>
<p><strong>value</strong> : {str, int, double, ...}</p>
<blockquote class="last">
<div><p>value that will be set. Only the name and existance of the parameter is checked before passing the request to the plugin. 
The plugin itsself is responsible for further validations (including read-only attribute).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataIO.getParam" title="itom.dataIO.getParam"><tt class="xref py py-obj docutils literal"><span class="pre">getParam</span></tt></a>, <a class="reference internal" href="#itom.dataIO.getParamList" title="itom.dataIO.getParamList"><tt class="xref py py-obj docutils literal"><span class="pre">getParamList</span></tt></a>, <a class="reference internal" href="#itom.dataIO.getParamListInfo" title="itom.dataIO.getParamListInfo"><tt class="xref py py-obj docutils literal"><span class="pre">getParamListInfo</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.setVal">
<tt class="descname">setVal</tt><big>(</big><em>dataObjectOrBuffer</em><span class="optional">[</span>, <em>length=1</em><span class="optional">]</span><big>)</big> &rarr; transfer given `dataObject` to ADDA plugin or further buffer to other dataIO plugin.<a class="headerlink" href="#itom.dataIO.setVal" title="Permalink to this definition">¶</a></dt>
<dd><p>If the dataIO plugin has the subtype ADDA, this method is used to send data to one or more analog outputs of the device. 
In this case a <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><tt class="xref py py-obj docutils literal"><span class="pre">dataObject</span></tt></a> must be given as first argument and the second argument <em class="xref py py-obj">length</em> must be 1.</p>
<p>For other dataIO plugins, the first argument must be any buffer object, like <em class="xref py py-obj">bytearray</em>, <em class="xref py py-obj">bytes</em> or <em class="xref py py-obj">unicode string</em>. The length is then extracted 
from this value. However it is also possible to define a user-defined size using the &#8216;length&#8217; argument.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dataObjectOrBuffer</strong> : {<a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><tt class="xref py py-obj docutils literal"><span class="pre">dataObject</span></tt></a>, <em class="xref py py-obj">bytearray</em>, <em class="xref py py-obj">bytes</em>, <em class="xref py py-obj">str</em>}</p>
<blockquote>
<div><p>value to send to plugin. For an ADDA plugin, a <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><tt class="xref py py-obj docutils literal"><span class="pre">dataObject</span></tt></a> is required whose content is sent to the analogous outputs of the device. For other dataIO 
plugins buffer values like <em class="xref py py-obj">bytearray</em>, <em class="xref py py-obj">bytes</em> or <em class="xref py py-obj">unicode string</em> is required.</p>
</div></blockquote>
<p><strong>length</strong> : {int}, optional</p>
<blockquote class="last">
<div><p>usually this value is not required, since the length of the buffer is automatically extracted from the given objects and 1 for a <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><tt class="xref py py-obj docutils literal"><span class="pre">dataObject</span></tt></a></p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.showConfiguration">
<tt class="descname">showConfiguration</tt><big>(</big><big>)</big> &rarr; show configuration dialog of the plugin<a class="headerlink" href="#itom.dataIO.showConfiguration" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong> :</p>
<blockquote class="last">
<div><p>if plugin does not provide a configuration dialog</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.showToolbox">
<tt class="descname">showToolbox</tt><big>(</big><big>)</big> &rarr; open toolbox of the plugin<a class="headerlink" href="#itom.dataIO.showToolbox" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError</strong> :</p>
<blockquote class="last">
<div><p>if plugin does not provide a toolbox</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataIO.hideToolbox" title="itom.dataIO.hideToolbox"><tt class="xref py py-obj docutils literal"><span class="pre">hideToolbox</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.startDevice">
<tt class="descname">startDevice</tt><big>(</big><span class="optional">[</span><em>count=1</em><span class="optional">]</span><big>)</big> &rarr; starts the given dataIO-plugin.<a class="headerlink" href="#itom.dataIO.startDevice" title="Permalink to this definition">¶</a></dt>
<dd><p>This command starts the dataIO plugin such that it is ready for data acquisition. Call this method before you start 
using commands like acquire, <a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><tt class="xref py py-obj docutils literal"><span class="pre">getVal</span></tt></a> or <a class="reference internal" href="#itom.dataIO.copyVal" title="itom.dataIO.copyVal"><tt class="xref py py-obj docutils literal"><span class="pre">copyVal</span></tt></a>. If the device already is started, an internal start-counter is incremented 
by the parameter &#8216;count&#8217;. The corresponding <a class="reference internal" href="#itom.dataIO.stopDevice" title="itom.dataIO.stopDevice"><tt class="xref py py-obj docutils literal"><span class="pre">stopDevice</span></tt></a> method then decrements this counter and finally stops the device once 
the counter drops to zero again.</p>
<p>The counter is necessary, since every connected live image needs to start the device without knownledge about any 
previous start. No acquisition is possible, if the device has not been started, hence the counter is 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>count</strong> : {int}, optional</p>
<blockquote class="last">
<div><p>Number of increments to the internal start-counter [default:1]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataIO.stopDevice" title="itom.dataIO.stopDevice"><tt class="xref py py-obj docutils literal"><span class="pre">stopDevice</span></tt></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataIO.stopDevice">
<tt class="descname">stopDevice</tt><big>(</big><span class="optional">[</span><em>count=1</em><span class="optional">]</span><big>)</big> &rarr; stops the given dataIO-plugin.<a class="headerlink" href="#itom.dataIO.stopDevice" title="Permalink to this definition">¶</a></dt>
<dd><p>If this method is called as many times as the corresponding <a class="reference internal" href="#itom.dataIO.startDevice" title="itom.dataIO.startDevice"><tt class="xref py py-obj docutils literal"><span class="pre">startDevice</span></tt></a> (or if the counts are equal), the 
dataIO device is stopped (not deleted) and it is not possible to acquire further data.</p>
<p>Once a live image is connected to a camera, <a class="reference internal" href="#itom.dataIO.startDevice" title="itom.dataIO.startDevice"><tt class="xref py py-obj docutils literal"><span class="pre">startDevice</span></tt></a> is automatically called at start of the live acquisition 
and <a class="reference internal" href="#itom.dataIO.stopDevice" title="itom.dataIO.stopDevice"><tt class="xref py py-obj docutils literal"><span class="pre">stopDevice</span></tt></a> at shutdown.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>count</strong> : {int}, optional</p>
<blockquote>
<div><p>default = 1
if count &gt; 1, <a class="reference internal" href="#itom.dataIO.stopDevice" title="itom.dataIO.stopDevice"><tt class="xref py py-obj docutils literal"><span class="pre">stopDevice</span></tt></a> is executed &#8216;count&#8217; times, in order to decrement the grabber internal start counter. 
You can also use -1 as count argument, then <a class="reference internal" href="#itom.dataIO.stopDevice" title="itom.dataIO.stopDevice"><tt class="xref py py-obj docutils literal"><span class="pre">stopDevice</span></tt></a> is repeated until the internal start counter is 0. The number of effective counts is then returned</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>counts</strong> : {None or int}</p>
<blockquote class="last">
<div><p>If <em class="xref py py-obj">count == -1</em> the number of required counts to finally stop the device is returned. Else: None</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataIO.startDevice" title="itom.dataIO.startDevice"><tt class="xref py py-obj docutils literal"><span class="pre">startDevice</span></tt></a></p>
</div>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="generated/itom.plot.html"
                        title="previous chapter">itom.plot</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="actuator.html"
                        title="next chapter">actuator</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/09_reference/dataIO.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="actuator.html" title="actuator"
             >next</a> |</li>
        <li class="right" >
          <a href="generated/itom.plot.html" title="itom.plot"
             >previous</a> |</li>
        <li><a href="../index.html">itom</a> &raquo;</li>
          <li><a href="../structure.html" >Structure of the manual</a> &raquo;</li>
          <li><a href="reference.html" >itom Script Reference</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2013, Institut fuer Technische Optik (ITO), University Stuttgart. Bug report: https://bitbucket.org/itom/itom/issues.
      Last updated on May 26, 2014.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.1.
    </div>
  </body>
</html>