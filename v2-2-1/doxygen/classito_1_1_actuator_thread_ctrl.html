<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>itom: ito::ActuatorThreadCtrl Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="itomLogo2_48.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">itom&#160;<span id="projectnumber">2.2.1</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classito_1_1_actuator_thread_ctrl.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">ito::ActuatorThreadCtrl Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="ito::ActuatorThreadCtrl" --><!-- doxytag: inherits="ito::PluginThreadCtrl" -->
<p>Helper class to give plugin developers an easy access to actuators in other threads.  
 <a href="classito_1_1_actuator_thread_ctrl.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="plugin_thread_ctrl_8h_source.html">pluginThreadCtrl.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ito::ActuatorThreadCtrl:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classito_1_1_actuator_thread_ctrl.png" usemap="#ito::ActuatorThreadCtrl_map" alt=""/>
  <map id="ito::ActuatorThreadCtrl_map" name="ito::ActuatorThreadCtrl_map">
<area href="classito_1_1_plugin_thread_ctrl.html" title="Base class for DataIOThreadCtrl and ActuatorThreadCtrl." alt="ito::PluginThreadCtrl" shape="rect" coords="0,0,139,24"/>
</map>
 </div></div>

<p><a href="classito_1_1_actuator_thread_ctrl-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38e2a83d6d3ed43257c8c6a19a94314e"></a><!-- doxytag: member="ito::ActuatorThreadCtrl::ActuatorThreadCtrl" ref="a38e2a83d6d3ed43257c8c6a19a94314e" args="()" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_actuator_thread_ctrl.html#a38e2a83d6d3ed43257c8c6a19a94314e">ActuatorThreadCtrl</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor. No actuator instance is currently under control. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_actuator_thread_ctrl.html#a52baf5ccacd319d6976dc3489a0f1532">ActuatorThreadCtrl</a> (const <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &amp;pluginParameter, <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> *retval=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the control object for an actuator plugin instance.  <a href="#a52baf5ccacd319d6976dc3489a0f1532"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_actuator_thread_ctrl.html#a55e20a8fbf8c0ae283828973d7a75b58">ActuatorThreadCtrl</a> (<a class="el" href="classito_1_1_add_in_actuator.html">ito::AddInActuator</a> *plugin, <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> *retval=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the control object for a actuator plugin instance.  <a href="#a55e20a8fbf8c0ae283828973d7a75b58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8c916e1a5e6e67cf1d9fc482cbf3638"></a><!-- doxytag: member="ito::ActuatorThreadCtrl::ActuatorThreadCtrl" ref="ad8c916e1a5e6e67cf1d9fc482cbf3638" args="(const ActuatorThreadCtrl &amp;other)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_actuator_thread_ctrl.html#ad8c916e1a5e6e67cf1d9fc482cbf3638">ActuatorThreadCtrl</a> (const <a class="el" href="classito_1_1_actuator_thread_ctrl.html">ActuatorThreadCtrl</a> &amp;other)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor. The reference counter of the covered plugin by other will be incremented another time. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ea680aaea7e685358599a4e66512e2e"></a><!-- doxytag: member="ito::ActuatorThreadCtrl::~ActuatorThreadCtrl" ref="a5ea680aaea7e685358599a4e66512e2e" args="()" -->
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_actuator_thread_ctrl.html#a5ea680aaea7e685358599a4e66512e2e">~ActuatorThreadCtrl</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor. Decrements the reference counter of the covered plugin and deletes it, if it drops to zero. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_actuator_thread_ctrl.html#a54937aadbf15aa511aec1765837ad6e9">setPosRel</a> (const QVector&lt; int &gt; &amp;axes, const QVector&lt; double &gt; &amp;relPositions, int timeOutMS=PLUGINWAIT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_actuator_thread_ctrl.html#afdab2ff8ecd59ccd387fe56ca407d8bc">setPosAbs</a> (const QVector&lt; int &gt; &amp;axes, const QVector&lt; double &gt; &amp;absPositions, int timeOutMS=PLUGINWAIT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_actuator_thread_ctrl.html#a30e6d638bfc29c3500f88e635e305f7f">setPosRel</a> (int axis, double relPosition, int timeOutMS=PLUGINWAIT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_actuator_thread_ctrl.html#acd9578e9ee8f90dce8ddc80690008517">setPosAbs</a> (int axis, double absPosition, int timeOutMS=PLUGINWAIT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_actuator_thread_ctrl.html#a417bdaa0c0445b0102a43bd0676f9f16">getPos</a> (QVector&lt; int &gt; axes, QVector&lt; double &gt; &amp;positions, int timeOutMS=PLUGINWAIT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_actuator_thread_ctrl.html#a2a3ea1379399095f5703da91a654de6e">getPos</a> (int axis, double &amp;position, int timeOutMS=PLUGINWAIT)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_actuator_thread_ctrl.html#aa21e49d984b777d15a59d8380bb456e2">checkAxis</a> (int axisNum)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a630d04885f808dcb8632cc15e0ec283a"></a><!-- doxytag: member="ito::ActuatorThreadCtrl::m_numAxes" ref="a630d04885f808dcb8632cc15e0ec283a" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_numAxes</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Helper class to give plugin developers an easy access to actuators in other threads. </p>
<p>The ActuatorThreadCtrl-Class can be used in filters and algorithms when an actuator plugin should be controlled by another thread. To create this controlling instance, at first, create an instance of the actuator plugin itself, then, pass it to the constructor of <a class="el" href="classito_1_1_actuator_thread_ctrl.html" title="Helper class to give plugin developers an easy access to actuators in other threads.">ActuatorThreadCtrl</a>. In the following example, an instance of DummyMotor is passed as first mandatory argument to the init method of your plugin. You would like to create an easy thread control wrapper around this actuator plugin:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="classito_1_1_ret_val.html" title="Class for managing status values (like errors or warning)">ito::RetVal</a> retval;
<a class="code" href="classito_1_1_actuator_thread_ctrl.html#a38e2a83d6d3ed43257c8c6a19a94314e" title="default constructor. No actuator instance is currently under control.">ActuatorThreadCtrl</a> motSave(paramsMand-&gt;at(0), &amp;retval);
</pre></div><p>Using this class, all main methods of the actuator plugin can be directly called with an optional timeout value (in ms). The thread control, timeout checks... is then done by this helper class.</p>
<p>Use getPos to obtain the current position (in mm or degree) for one multiple axes. Inversely, setPosRel or setPosAbs will set the absolute or relative position(s) of one or multiple axes. Usually, setPosXXX will only return after the position has been reached. If you want to continue within your code while the actuator is still moving, check if your specific actuator has the 'async' parameter defined. If so, set it to 1 (see example below):</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">double</span> position;
motSave.setParam(<a class="code" href="classito_1_1_param_base.html">ito::ParamBase</a>(<span class="stringliteral">&quot;async&quot;</span>, ito::ParamBase::Int, 1))
motSave.getPos(0, position);
motSave.setPosAbs(0, 10.5); <span class="comment">//long movement</span>

<span class="comment">//since the movement is asynchrone, setPosAbs</span>
<span class="comment">//will immediately return. However, every subsequent</span>
<span class="comment">//call to the motSave instance will block until the previous</span>
<span class="comment">//movement is finished. E.g. another call of getPos will wait</span>
<span class="comment">//for this and you can therefore check if the movement has been</span>
<span class="comment">//done:</span>
motSave.getPos(0, position);
</pre></div> </div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a52baf5ccacd319d6976dc3489a0f1532"></a><!-- doxytag: member="ito::ActuatorThreadCtrl::ActuatorThreadCtrl" ref="a52baf5ccacd319d6976dc3489a0f1532" args="(const ito::ParamBase &amp;pluginParameter, ito::RetVal *retval=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ito::ActuatorThreadCtrl::ActuatorThreadCtrl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &amp;&#160;</td>
          <td class="paramname"><em>pluginParameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> *&#160;</td>
          <td class="paramname"><em>retval</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates the control object for an actuator plugin instance. </p>
<p>This implementation gets the controlled instance from a <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> object of param type ito::ParamBase::HWRef. Use this version, if the controlled plugin is passed to an algorithm or other plugin via a vector of mandatory or optional parameters in terms of <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> objects.</p>
<p>This constructor increments the reference of the controlled plugin such that the plugin is not deleted until the reference has been decremented in the destructor of this class.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pluginParameter</td><td>is a plugin parameter of type ito::ParamBase::HWRef. </td></tr>
    <tr><td class="paramname">retval</td><td>is an optional pointer to <a class="el" href="classito_1_1_ret_val.html" title="Class for managing status values (like errors or warning)">ito::RetVal</a>. An error is set to this retval if the given plugin is no valid actuator plugin instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55e20a8fbf8c0ae283828973d7a75b58"></a><!-- doxytag: member="ito::ActuatorThreadCtrl::ActuatorThreadCtrl" ref="a55e20a8fbf8c0ae283828973d7a75b58" args="(ito::AddInActuator *plugin, ito::RetVal *retval=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ito::ActuatorThreadCtrl::ActuatorThreadCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_actuator.html">ito::AddInActuator</a> *&#160;</td>
          <td class="paramname"><em>plugin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> *&#160;</td>
          <td class="paramname"><em>retval</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates the control object for a actuator plugin instance. </p>
<p>This implementation gets the controlled instance from the real pointer to a ito::Actuator instance.</p>
<p>This constructor increments the reference of the controlled plugin such that the plugin is not deleted until the reference has been decremented in the destructor of this class.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">plugin</td><td>is the pointer to the controlled plugin. </td></tr>
    <tr><td class="paramname">retval</td><td>is an optional pointer to <a class="el" href="classito_1_1_ret_val.html" title="Class for managing status values (like errors or warning)">ito::RetVal</a>. An error is set to this retval if the given plugin is no valid actuator plugin instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa21e49d984b777d15a59d8380bb456e2"></a><!-- doxytag: member="ito::ActuatorThreadCtrl::checkAxis" ref="aa21e49d984b777d15a59d8380bb456e2" args="(int axisNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::ActuatorThreadCtrl::checkAxis </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axisNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if an axis is within the axis-range</p>
<p>Check if a specific axis is within the axisSpace of this actuator</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axisNum</td><td>axis index to be checked</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk or retError </dd></dl>

</div>
</div>
<a class="anchor" id="a2a3ea1379399095f5703da91a654de6e"></a><!-- doxytag: member="ito::ActuatorThreadCtrl::getPos" ref="a2a3ea1379399095f5703da91a654de6e" args="(int axis, double &amp;position, int timeOutMS=PLUGINWAIT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::ActuatorThreadCtrl::getPos </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeOutMS</em> = <code>PLUGINWAIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the position of a single axis</p>
<p>Get the position of a single axis specified by axis.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>Number of the axis </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pos</td><td>position of the axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeOutMS</td><td>TimeOut for the semaphore-wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk or retError </dd></dl>

</div>
</div>
<a class="anchor" id="a417bdaa0c0445b0102a43bd0676f9f16"></a><!-- doxytag: member="ito::ActuatorThreadCtrl::getPos" ref="a417bdaa0c0445b0102a43bd0676f9f16" args="(QVector&lt; int &gt; axes, QVector&lt; double &gt; &amp;positions, int timeOutMS=PLUGINWAIT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::ActuatorThreadCtrl::getPos </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeOutMS</em> = <code>PLUGINWAIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the position of more than one axis</p>
<p>Get the position of a number of axis specified by axisVec.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axisVec</td><td>Number of the axis </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">posVec</td><td>Vecotr with position of the axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeOutMS</td><td>TimeOut for the semaphore-wait</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk or retError </dd></dl>

</div>
</div>
<a class="anchor" id="acd9578e9ee8f90dce8ddc80690008517"></a><!-- doxytag: member="ito::ActuatorThreadCtrl::setPosAbs" ref="acd9578e9ee8f90dce8ddc80690008517" args="(int axis, double absPosition, int timeOutMS=PLUGINWAIT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::ActuatorThreadCtrl::setPosAbs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>absPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeOutMS</em> = <code>PLUGINWAIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move a single axi absolute</p>
<p>Move a single axis specified by axis to the position pos. After the invoke-command this thread must wait / synchronize with the actuator-thread. Therefore the semaphore-&gt;wait is called via the function threadActuator::waitForSemaphore(timeOutMS) To enable the algorithm to process data during movement, the waitForSemaphore(timeOutMS) can be skipped by callWait = false. The threadActuator::waitForSemaphore(timeOutMS)-function must than be called by the algorithms afterwards / before the next command is send to the actuator.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>Number of the axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>New position of the axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeOutMS</td><td>TimeOut for the semaphore-wait, if (0) the waitForSemaphore is not called and must be called seperate by the algorithm</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk or retError </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_actuator_thread_ctrl.html#a54937aadbf15aa511aec1765837ad6e9">ActuatorThreadCtrl::setPosRel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afdab2ff8ecd59ccd387fe56ca407d8bc"></a><!-- doxytag: member="ito::ActuatorThreadCtrl::setPosAbs" ref="afdab2ff8ecd59ccd387fe56ca407d8bc" args="(const QVector&lt; int &gt; &amp;axes, const QVector&lt; double &gt; &amp;absPositions, int timeOutMS=PLUGINWAIT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::ActuatorThreadCtrl::setPosAbs </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>absPositions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeOutMS</em> = <code>PLUGINWAIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move more than on axis absolute</p>
<p>Move the axis in axisVec to the positions given in posVec. The axisVec and posVec must be same size. After the invoke-command this thread must wait / synchronize with the actuator-thread. Therefore the semaphore-&gt;wait is called via the function threadActuator::waitForSemaphore(timeOutMS) To enable the algorithm to process data during movement, the waitForSemaphore(timeOutMS) can be skipped by callWait = false. The threadActuator::waitForSemaphore(timeOutMS)-function must than be called by the algorithms afterwards / before the next command is send to the actuator.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axisVec</td><td>Vector with the axis to move </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">posVec</td><td>Vector with the new absolute positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeOutMS</td><td>TimeOut for the semaphore-wait, if (0) the waitForSemaphore is not called and must be called seperate by the algorithm</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk or retError </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_actuator_thread_ctrl.html#a54937aadbf15aa511aec1765837ad6e9">ActuatorThreadCtrl::setPosRel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a30e6d638bfc29c3500f88e635e305f7f"></a><!-- doxytag: member="ito::ActuatorThreadCtrl::setPosRel" ref="a30e6d638bfc29c3500f88e635e305f7f" args="(int axis, double relPosition, int timeOutMS=PLUGINWAIT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::ActuatorThreadCtrl::setPosRel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeOutMS</em> = <code>PLUGINWAIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move a single axis relativ to current position</p>
<p>Move a single axis specified by axis with a distance defined in stepSize relative to current position. After the invoke-command this thread must wait / synchronize with the actuator-thread. Therefore the semaphore-&gt;wait is called via the function threadActuator::waitForSemaphore(timeOutMS) To enable the algorithm to process data during movement, the waitForSemaphore(timeOutMS) can be skipped by callWait = false. The threadActuator::waitForSemaphore(timeOutMS)-function must than be called by the algorithms afterwards / before the next command is send to the actuator.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>Number of the axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepSize</td><td>Distances from current position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeOutMS</td><td>TimeOut for the semaphore-wait, if (0) the waitForSemaphore is not called and must be called seperate by the algorithm</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk or retError </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_actuator_thread_ctrl.html#afdab2ff8ecd59ccd387fe56ca407d8bc">ActuatorThreadCtrl::setPosAbs</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a54937aadbf15aa511aec1765837ad6e9"></a><!-- doxytag: member="ito::ActuatorThreadCtrl::setPosRel" ref="a54937aadbf15aa511aec1765837ad6e9" args="(const QVector&lt; int &gt; &amp;axes, const QVector&lt; double &gt; &amp;relPositions, int timeOutMS=PLUGINWAIT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::ActuatorThreadCtrl::setPosRel </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>relPositions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>timeOutMS</em> = <code>PLUGINWAIT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move more than on axis relativ to current position</p>
<p>Move the axis in axisVec with a distance defined in stepSizeVec relative to current position. The axisVec and stepSizeVec must be same size. After the invoke-command this thread must wait / synchronize with the actuator-thread. Therefore the semaphore-&gt;wait is called via the function threadActuator::waitForSemaphore(timeOutMS) To enable the algorithm to process data during movement, the waitForSemaphore(timeOutMS) can be skipped by callWait = false. The threadActuator::waitForSemaphore(timeOutMS)-function must than be called by the algorithms afterwards / before the next command is send to the actuator.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">axisVec</td><td>Vector with the axis to move </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stepSizeVec</td><td>Vector with the distances for every axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeOutMS</td><td>TimeOut for the semaphore-wait, if (0) the waitForSemaphore is not called and must be called seperate by the algorithm</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk or retError </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_actuator_thread_ctrl.html#afdab2ff8ecd59ccd387fe56ca407d8bc">ActuatorThreadCtrl::setPosAbs</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>K:/git-itom/sources/itom/common/<a class="el" href="plugin_thread_ctrl_8h_source.html">pluginThreadCtrl.h</a></li>
<li>K:/git-itom/sources/itom/common/sources/pluginThreadCtrl.cpp</li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceito.html">ito</a>      </li>
      <li class="navelem"><a class="el" href="classito_1_1_actuator_thread_ctrl.html">ActuatorThreadCtrl</a>      </li>
      <li class="footer">Generated on Fri Oct 14 2016 11:21:43 for itom by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
