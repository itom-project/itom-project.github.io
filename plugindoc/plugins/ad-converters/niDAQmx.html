
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>4.5. NI-DAQmx &#8212; itom Plugins</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/html.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'plugins/ad-converters/niDAQmx';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="4.6. Thorlabs Power Meter" href="thorlabsPowerMeter.html" />
    <link rel="prev" title="4.4. Thorlabs KCube Position Aligner" href="ThorlabsKCubePA.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
    <meta name="docbuild:last-update" content="Nov 09, 2024"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">itom Plugins</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../grabbers.html">
    Camera/ Grabber
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../actuators.html">
    Motors/ Actuators
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../GDIO.html">
    General Data IO
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="../adconv.html">
    AD-Converters
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../algorithms.html">
    Algorithms/ Filters
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/itom-project/plugins" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.ito.uni-stuttgart.de/" title="ITO" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../_static/ITO_Logo_neu_II.png" class="icon-link-image" alt="ITO"/></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../grabbers.html">
    Camera/ Grabber
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../actuators.html">
    Motors/ Actuators
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../GDIO.html">
    General Data IO
  </a>
</li>


<li class="nav-item current active">
  <a class="nav-link nav-internal" href="../adconv.html">
    AD-Converters
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../algorithms.html">
    Algorithms/ Filters
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/itom-project/plugins" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://www.ito.uni-stuttgart.de/" title="ITO" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><img src="../../_static/ITO_Logo_neu_II.png" class="icon-link-image" alt="ITO"/></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"><ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="HBMSpider8.html">4.1. HBMSpider8</a></li>
<li class="toctree-l1"><a class="reference internal" href="MeasurementComputing.html">4.2. MeasurementComputing</a></li>
<li class="toctree-l1"><a class="reference internal" href="OphirPowermeter.html">4.3. OphirPowermeter</a></li>
<li class="toctree-l1"><a class="reference internal" href="ThorlabsKCubePA.html">4.4. Thorlabs KCube Position Aligner</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">4.5. NI-DAQmx</a></li>
<li class="toctree-l1"><a class="reference internal" href="thorlabsPowerMeter.html">4.6. Thorlabs Power Meter</a></li>
</ul>
</div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../adconv.html" class="nav-link"><span class="section-number">4. </span>AD-Converters</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span...</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="ni-daqmx">
<h1><span class="section-number">4.5. </span>NI-DAQmx<a class="headerlink" href="#ni-daqmx" title="Link to this heading">#</a></h1>
<div class="pst-scrollable-table-container"><table class="table">
<tbody>
<tr class="row-odd"><td><p><strong>Summary</strong>:</p></td>
<td><p><span>Analog and digital input and output tasks for National Instruments devices, based on NI DAQmx.</span></p></td>
</tr>
<tr class="row-even"><td><p><strong>Type</strong>:</p></td>
<td><p><span>DataIO</span></p></td>
</tr>
<tr class="row-odd"><td><p><strong>License</strong>:</p></td>
<td><p><span>Licensed under LGPL.</span></p></td>
</tr>
<tr class="row-even"><td><p><strong>Platforms</strong>:</p></td>
<td><p>Windows, Linux (NI officially only supports RRM installers for Red Hat, SUSE, CentOS)</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Devices</strong>:</p></td>
<td><p>Nation Instruments Analog and digital I/O devices</p></td>
</tr>
<tr class="row-even"><td><p><strong>Author</strong>:</p></td>
<td><p><span>Martin Hoppe, ITO, Universität Stuttgart; Dan Nessett, Unaffiliated; Marc Gronle, Unaffiliated</span></p></td>
</tr>
<tr class="row-odd"><td><p><strong>Requires</strong>:</p></td>
<td><p>NI-DAQmx driver from National Instruments</p></td>
</tr>
</tbody>
</table>
</div>
<section id="overview">
<h2><span class="section-number">4.5.1. </span>Overview<a class="headerlink" href="#overview" title="Link to this heading">#</a></h2>
<p>The plugin implements the DAQmx functions for analog and digital I/O devices from National Instruments.
The installation needs the NI-DAQmx Library that can be downloaded from the NI website
(<a class="reference external" href="https://www.ni.com/en-us/support/downloads/drivers/download.ni-daqmx.html">https://www.ni.com/en-us/support/downloads/drivers/download.ni-daqmx.html</a>).</p>
<p>This plugin has mainly be tested with simulated NI I/O devices under Windows (using the NI Measurement and
Automation Explorer software - NI MAX). Simulated tested devices were: NI PCIe-6321, NI PCI-6220, NI PCI-6111,
NI PCIe-6323 and NI PCI-6520.</p>
</section>
<section id="driver-installation">
<h2><span class="section-number">4.5.2. </span>Driver Installation<a class="headerlink" href="#driver-installation" title="Link to this heading">#</a></h2>
<p>In order to run the <strong>NI-DAQmx</strong> plugin in <em>itom</em>, the <strong>NI-DAQmx</strong> driver from National Instruments
has to be installed on the computer (considering the right bitness 32bit or 64bit).</p>
<section id="windows">
<h3><span class="section-number">4.5.2.1. </span>Windows<a class="headerlink" href="#windows" title="Link to this heading">#</a></h3>
<p>Download and install the latest NI-DAQmx driver from
<a class="reference external" href="https://www.ni.com/en-us/support/downloads/drivers/download.ni-daqmx.html#346240">https://www.ni.com/en-us/support/downloads/drivers/download.ni-daqmx.html#346240</a></p>
<p>The major part of this driver is usually installed under <strong>C:/Program Files/National Instruments</strong> and
<strong>C:/Program Files (x86)/National Instruments</strong>. Some important libraries are also copied to the
<strong>C:/Windows/System32</strong>, where they are found from the itom plugin.</p>
<p>If you choose a different installation folder but the defaulft, please set the <strong>NIDAQMX_ROOT</strong>
environment variable to the equivalent “C:/Program Files (x86)/National Instruments”
folder.</p>
<p>Please be aware that multiple driver versions exists, some of which lead to linker errors
during the build process. For the latest build the binary and header files at
<strong>[NiDAQmx-Foleder]/Shared/ExternalCompilerSupport/C</strong> are used.</p>
<p>If you also want to compile the plugin, make sure that you enable the option
<strong>Applications Development Supports / ANSI C Support</strong> in the installer. This can also be done
by modifying the installation using the tab <strong>Program and Features</strong> in the Windows Control Panel
(see <a class="reference external" href="https://knowledge.ni.com/KnowledgeArticleDetails?id=kA00Z000000P9udSAC">https://knowledge.ni.com/KnowledgeArticleDetails?id=kA00Z000000P9udSAC</a> ).</p>
<p>The itom <strong>niDAQmx</strong> plugin has mainly been developed and tested using <strong>NI-DAQmx 18.06.0</strong>.</p>
</section>
<section id="linux">
<h3><span class="section-number">4.5.2.2. </span>Linux<a class="headerlink" href="#linux" title="Link to this heading">#</a></h3>
<p>National Instruments has only a limited support for Linux operating systems, such that
the <strong>NI-DAQmx</strong> driver is only available as RPM-package for Red Hat, SUSE and CentOS.</p>
<p>See this knowledge base entry (<a class="reference external" href="https://knowledge.ni.com/KnowledgeArticleDetails?id=kA00Z00000159XISAY">https://knowledge.ni.com/KnowledgeArticleDetails?id=kA00Z00000159XISAY</a>)
and see the links, where to download the linux driver and how to install it.</p>
</section>
</section>
<section id="initialization">
<h2><span class="section-number">4.5.3. </span>Initialization<a class="headerlink" href="#initialization" title="Link to this heading">#</a></h2>
<p>The plugin is initialized with a set of mandatory and optional parameters:</p>
<blockquote>
<div><ul>
<li><dl>
<dt><strong>taskType</strong>: str</dt><dd><p>type of the task related to this instance of the NI-DAQmx plugin (analogInput, digitalInput, analogOutput, digitalOutput)</p>
<p><em>Match: [“analogInput”, “digitalInput”, “analogOutput”, “digitalOutput”], Default: “analogInput”</em></p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>taskName</strong>: str, optional</dt><dd><p>desired name of the underlying NI task (this might be changed by the NI task creation method)</p>
<p><em>default: “”</em></p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>taskMode</strong>: str, optional</dt><dd><p>mode of the task recording / data generation: finite, continuous</p>
<p><em>Match: [“finite”, “continuous”], Default: “finite”</em></p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>samplingRate</strong>: float, optional</dt><dd><p>The sampling rate in samples per second per channel. If you use an external source for the Sample Clock, set this value to the maximum expected rate of that clock.</p>
<p><em>Value range: [0, 1e+08], Default: 100</em></p>
</dd>
</dl>
</li>
<li><dl>
<dt><strong>samplesPerChannel</strong>: int, optional</dt><dd><p>The number of samples to acquire or generate for each channel in the task (if taskMode is ‘finite’). If taskMode is ‘continuous’, NI-DAQmx uses this value to determine the buffer size.</p>
<p><em>Value range: [0, inf], Default: 20000</em></p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p>If the <strong>taskName</strong> is not given or an empty string, a default task name is given. All
parameters can be changed during the runtime of the instance, besides the major <strong>task type</strong>
and <strong>task mode</strong>. That means, that every instance of this plugin can be operated with one of the
following combinations (of course multiple instances can be run in parallel):</p>
<ul class="simple">
<li><p>Analog input task with a finite number of acquired samples (per run)</p></li>
<li><p>Analog input task with continuous acquisition (from start to stop signal)</p></li>
<li><p>Analog output task with a finite number of written samples (per run)</p></li>
<li><p>Analog output task with continuous write (from start to stop signal)</p></li>
<li><p>Digital input task with a finite number of acquired samples (per run)</p></li>
<li><p>Digital input task with continuous acquisition (from start to stop signal)</p></li>
<li><p>Digital output task with a finite number of written samples (per run)</p></li>
<li><p>Digital output task with continuous write (from start to stop signal)</p></li>
</ul>
<p>All analog tasks are created as voltage tasks, only. Transforming voltages into other physical units
must be done within the script.</p>
<p>It is not possible to combine analog and digital ports within one task, hence, once instance
of the plugin. Finite input tasks can also have a <strong>reference trigger</strong>, that is usually used
to stop the acquisition upon a certain input trigger. If this <strong>refTriggerMode</strong> is set, the
finite task behaves like a continuous task (see examples below) and acquires data from the start
signal until all conditions of the reference trigger are fulfilled.</p>
</section>
<section id="parameters">
<h2><span class="section-number">4.5.4. </span>Parameters<a class="headerlink" href="#parameters" title="Link to this heading">#</a></h2>
<p>These parameters are available and can be used to configure the <strong>NI-DAQmx</strong> instance.
During the runtime of an instance, the values of these parameters are obtained by the method <em>getParam</em>,
writeable parameters can be changed using <em>setParam</em>.</p>
<dl class="simple">
<dt><strong>availableDevices</strong>: {str}, read-only</dt><dd><p>comma-separated list of all detected and available devices</p>
</dd>
<dt><strong>availableTerminals</strong>: {str}, read-only</dt><dd><p>comma-separated list of all detected and available terminals (e.g. for
‘sampleClockSource’ or ‘startTriggerSource’). The standard sample clock source
‘OnboardClock’ is not contained in this list.</p>
</dd>
<dt><strong>bufferSize</strong>: {int}</dt><dd><p>Sets and changes the automatic input / output buffer allocation mode. If -1 (default),
the automatic allocation is enabled. Else defines the number of samples the buffer can
hold for each channel (only recommended for continuous acquisition). In automatic mode
and continuous acquisition, the standard is a buffer size of 1 kS for a sampling rate
&lt; 100 S/s, 10 kS for 100-10000 S/s, 100 kS for 10-1000 kS/s and 1 MS else. For input
tasks, this size changes the input buffer size of the device, else the output buffer
size.</p>
</dd>
<dt><strong>channels</strong>: {str}</dt><dd><p>semicolon-separated list of all channels that should be part of this task. Every item is
a comma separated string that defines and parameterizes every channel.</p>
</dd>
<dt><strong>loggingActive</strong>: {int}, read-only</dt><dd><p>Indicates if TDMS file logging has been enabled and which mode was accepted by the
device. The value has the same meaning than ‘loggingMode’.</p>
</dd>
<dt><strong>loggingFilePath</strong>: {str}</dt><dd><p>The path to the TDMS file to which you want to log data.</p>
</dd>
<dt><strong>loggingGroupName</strong>: {str}</dt><dd><p>The name of the group to create within the TDMS file for data from this task. If empty,
the task name is taken. If data is appended to a TDMS file, a number symbol (e.g. Task
#1, Task #2…) is added at each run.</p>
</dd>
<dt><strong>loggingMode</strong>: {int}</dt><dd><p>0: logging is disabled (default), 1: logging is enabled with disabled read (fast, but no
data can simultaneously read via getVal/copyVal), 2: logging is enabled with allowed
reading of data.</p>
</dd>
<dt><strong>loggingOperation</strong>: {str}</dt><dd><p>Specifies how to open the TDMS file. ‘open’: Always appends data to an existing TDMS
file. If it does not exist yet, the task start operation will return with an error;
‘openOrCreate’: Creates a new TDMS file or appends data to the existing
one;’createOrReplace’ (default): Creates a new TDMS file or replaces an existing one;
‘create’: Newly creates the TDMS file. If it already exists a task start operation will
return with an error.</p>
</dd>
<dt><strong>name</strong>: {str}, read-only</dt><dd><p>NI-DAQmx</p>
</dd>
<dt><strong>readTimeout</strong>: {float}</dt><dd><p>Timeout when reading up to ‘samplesPerChannel’ values (per channel) in seconds. If -1.0
(default), the timeout is set to infinity (recommended for finite tasks). If 0.0,
getVal/copyVal will return all values which have been recorded up to this call.</p>
</dd>
<dt><strong>refTriggerLevel</strong>: {float}</dt><dd><p>Only for ‘refTriggerMode’ == ‘analogEdge’: The threshold at which to stop acquiring
samples. Specify this value in the units of the measurement or generation.</p>
</dd>
<dt><strong>refTriggerMode</strong>: {str}</dt><dd><p>A reference trigger can be enabled to stop an acquisition when the device acquired all
pre-trigger samples, an analog or digital signal reaches a specified level and and the
device acquired all post-trigger samples. ‘off’: no reference trigger, ‘digitalEdge’:
The trigger event is given if ‘refTriggerSource’ is activated (based on
‘refTriggerRisingEdge’), ‘analogEdge’: similar to ‘digitalEdge’, but the analog input
‘refTriggerSource’ has to pass the value ‘refTriggerLevel’. A reference trigger can only
be set for finite, input tasks. The reference trigger can only be enabled for finite
input tasks. However these tasks then behave like continuous tasks, but the stop command
is automatically generated by the reference trigger event (plus additional post trigger
values)</p>
</dd>
<dt><strong>refTriggerPreTriggerSamples</strong>: {int}</dt><dd><p>The minimum number of samples per channel to acquire before recognizing the Reference
Trigger. The number of posttrigger samples per channel is equal to ‘samplesPerChannel’
minus this value.</p>
</dd>
<dt><strong>refTriggerRisingEdge</strong>: {int}</dt><dd><p>Specifies on which slope of the signal to stop acquiring samples. 1: rising edge
(default), 0: falling edge.</p>
</dd>
<dt><strong>refTriggerSource</strong>: {str}</dt><dd><p>The source terminal of the trigger source (if ‘refTriggerMode’ is set to ‘digitalEdge’
or ‘analogEdge’).</p>
</dd>
<dt><strong>sampleClockRisingEdge</strong>: {int}</dt><dd><p>If 1, samples are acquired on a rising edge of the sample clock (default), else they are
acquired on a falling edge.</p>
</dd>
<dt><strong>sampleClockSource</strong>: {str}</dt><dd><p>The source terminal of the Sample Clock. To use the internal clock of the device, use an
empty string or ‘OnboardClock’ (default). An example for an external clock source is
‘PFI0’ or PFI1’.</p>
</dd>
<dt><strong>samplesPerChannel</strong>: {int}</dt><dd><p>The number of samples to acquire or generate for each channel in the task (if taskMode
is ‘finite’). If taskMode is ‘continuous’, NI-DAQmx uses this value to determine the
buffer size. This parameter is ignored for output tasks.If ‘samplesPerChannel’ is 1, one
single value is read or written by asoftware trigger only. The parameters
‘samplingRate’, ‘bufferSize’, ‘sampleClockSource’ and ‘sampleClockRisingEdge’ are
ignored then.</p>
</dd>
<dt><strong>samplingRate</strong>: {float}</dt><dd><p>The sampling rate in samples per second per channel. If you use an external source for
the Sample Clock, set this value to the maximum expected rate of that clock.</p>
</dd>
<dt><strong>setValWaitForFinish</strong>: {int}</dt><dd><p>If 1, the <strong>setVal</strong> call will block until all data has been written (only valid for finite
tasks). If 0, setVal will return immediately, then use ‘taskStarted’ to verify if the
operation has been finished.</p>
</dd>
<dt><strong>startTriggerLevel</strong>: {float}</dt><dd><p>Only for ‘startTriggerMode’ == ‘analogEdge’: The threshold at which to start acquiring
or generating samples. Specify this value in the units of the measurement or generation.</p>
</dd>
<dt><strong>startTriggerMode</strong>: {str}</dt><dd><p>Specifies the start trigger mode. ‘off’: software-based start trigger, ‘digitalEdge’:
The start of acquiring or generating samples is given if the ‘startTriggerSource’ is
activated (based on ‘startTriggerRisingEdge’), ‘analogEdge’: similar to ‘digitalEdge’,
but the analog input ‘startTriggerSource’ has to pass the value ‘startTriggerLevel’.</p>
</dd>
<dt><strong>startTriggerRisingEdge</strong>: {int}</dt><dd><p>Specifies on which slope of the signal to start acquiring or generating samples. 1:
rising edge (default), 0: falling edge.</p>
</dd>
<dt><strong>startTriggerSource</strong>: {str}</dt><dd><p>The source terminal of the trigger source (if ‘startTriggerMode’ is set to ‘digitalEdge’
or ‘analogEdge’).</p>
</dd>
<dt><strong>supportedChannels</strong>: {str}, read-only</dt><dd><p>comma-separated list of all detected and supported channels with respect to the task
type. Every item consists of the device name / channel name</p>
</dd>
<dt><strong>taskConfigured</strong>: {int}, read-only</dt><dd><p>Indicates if the task is properly configured (1, all task related parameters where
accepted) or not (0).</p>
</dd>
<dt><strong>taskMode</strong>: {str}</dt><dd><p>mode of the task recording / data generation: finite, continuous</p>
</dd>
<dt><strong>taskName</strong>: {str}, read-only</dt><dd><p>name of the NI task that is related to this instance</p>
</dd>
<dt><strong>taskStarted</strong>: {int}, read-only</dt><dd><p>Indicates if the task is currently running (1) or stopped / inactive (0).</p>
</dd>
<dt><strong>taskType</strong>: {str}, read-only</dt><dd><p>task type: analogInput, analogOutput, digitalInput, digitalOutput</p>
</dd>
</dl>
</section>
<section id="usage">
<h2><span class="section-number">4.5.5. </span>Usage<a class="headerlink" href="#usage" title="Link to this heading">#</a></h2>
<section id="channels">
<h3><span class="section-number">4.5.5.1. </span>Channels<a class="headerlink" href="#channels" title="Link to this heading">#</a></h3>
<p>Every task can consist of one or multiple channels, that are given as semicolon-separated list in the
<strong>channels</strong> parameter. Please note, that a digital task can only consist of digital channels and analog tasks
only of analog channels. Read the parameter <strong>supportedChannels</strong> to get all available channel names for
your task.</p>
<p>Every channel item in the semicolon-separated list consists of a configuration string (see examples below),
whose exact meaning depend on the task mode and type. The configuration string is a comma-separated list of items.
The first item is always the physical name of the channel, that usually consists of the device name (e.g. Dev1),
followed by a slash and the port name (e.g. AI0). For digital tasks, the physical name can also consist of
the device name, the port name and the line name (divided by slashes) if one single line (pin) of a port should
be used only (e.g. Dev0/port0/line1). All possible physical names are listed in <strong>supportedChannels</strong>.</p>
<p>For analog input and output tasks, a certain minimum and maximum voltage must be given (as integer or floating point number).</p>
<p>Analog input tasks have an additional parameter <strong>ConfigMode</strong>, that defines the input terminal configuration
of the channel. Possible values are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DAQmx_Val_Cfg_Default</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="n">DAQmx_Val_Diff</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="n">DAQmx_Val_RSE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="n">DAQmx_Val_NRSE</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="n">DAQmx_Val_PseudoDiff</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div>
</div>
<p>The possible configuration strings for one channel are:</p>
<ul class="simple">
<li><p><strong>Analog input channel</strong>: PhysicalName,ConfigMode,MinVoltage,MaxVoltage</p></li>
<li><p><strong>Analog output channel</strong>: PhysicalName,MinVoltage,MaxVoltage</p></li>
<li><p><strong>Digital input channel</strong>: PhysicalName</p></li>
<li><p><strong>Digital output channel</strong>: PhysicalName</p></li>
</ul>
</section>
<section id="data-types">
<h3><span class="section-number">4.5.5.2. </span>Data Types<a class="headerlink" href="#data-types" title="Link to this heading">#</a></h3>
<p>Analog input or output tasks are always based on 2-dimensional dataObjects of dtype <strong>float64</strong>.
The rows corresponds to the channels in the active task and the columns correspond to the acquired samples.</p>
<p>Digital input or output tasks are always based on 2-dimensional dataObjects of dtypes <strong>uint8</strong>, <strong>uint16</strong> or
<strong>int32</strong>. The type <strong>int32</strong> is internally casted to <strong>uint32</strong> (however uint32 is not officially supported for
dataObjects). The correct bitdepth depend on whether a channel is assigned to a single line or an entire port.
In the first case, the datatype is usually <strong>uint8</strong>, in the latter case, the bitdepth depend on the number of
lines, that are covered by the port. If the wrong datatype is used, an appropriate error message will appear,
that indicates the desired bitdepth.</p>
</section>
<section id="general">
<h3><span class="section-number">4.5.5.3. </span>General<a class="headerlink" href="#general" title="Link to this heading">#</a></h3>
<p>The general approach to use a NI I/O device can be seen in one of the examples below. In general, it is
recommended to configure a plugin instance as far as possible. Then the task will be created and configured using
the <strong>startDevice</strong> command. In case of invalid parameters, <strong>startDevice</strong> will raise an exception, whose
error message usually gives detailed information about an invalid parameterization and possible different solutions.</p>
<p>The task can finally be deleted using <strong>stopDevice</strong>.</p>
<p>Input tasks will always be started using <strong>acquire</strong>. If a start trigger is given, the real acquisition will
be started if the trigger event is signalled (but after having called <strong>acquire</strong>). Finite tasks will automatically be
stopped if the requested number of samples per channel (<strong>samplesPerChannel</strong>) are acquired (if no reference
trigger is given). The values can then be obtained via <strong>getVal</strong> or <strong>copyVal</strong> (like for any other grabber or
dataIO device).</p>
<p>The acquisition of <strong>continuous</strong> tasks is also started by <strong>acquire</strong> (and an optional start trigger). Then all
data is temporarily stored into an internal buffer of the NI driver. The buffer size is usually automatically
determined based on <strong>samplesPerChannel</strong> (as far as this value is big enough, else NI determines its own internal
buffer size; see also the parameter <strong>bufferSize</strong>). As far as no fast TDMS logging is enabled, you have to
continuously receive the latest data via <strong>getVal</strong> or <strong>copyVal</strong> in order to avoid that the internal buffer
overflows. The continuous task is then stopped via <strong>stop</strong>.</p>
<p>For output tasks, a <strong>MxN</strong> data object must be passed to <strong>setVal</strong>, where <strong>M</strong> must correspond to the number
of channels in the task. <strong>N</strong> are the number of samples. However <strong>N</strong> is <strong>not</strong> the number that defines the
number of transmitted samples per channel. This is again defined by the parameter <strong>samplesPerChannel</strong>. If
<strong>samplesPerChannel</strong> is smaller than <strong>N</strong>, only the <strong>samplesPerChannel</strong> columns are written to the output
channels (using the sampling rate or sample clock). If <strong>samplesPerChannel</strong> is bigger than <strong>N</strong>, the write
operation restarts at the first column once the last column of the dataObject has been written.</p>
<p>For <strong>finite output tasks</strong>, it is possible to block the call of <strong>setVal</strong> until all samples have been
written by setting <strong>setValWaitForFinish</strong> to 1. Else <strong>setVal</strong> will return immediately. The end of the task
can then be continuously checked by getting the parameter <strong>taskStarted</strong> and check if it drops to 0 again.</p>
<p>Continuous output tasks will continuously write the columns and restart from the beginning until the task
will be stopped via <strong>stop</strong>.</p>
</section>
<section id="reference-trigger">
<h3><span class="section-number">4.5.5.4. </span>Reference Trigger<a class="headerlink" href="#reference-trigger" title="Link to this heading">#</a></h3>
<p>The reference trigger can be configured in order to stop a task upon a certain trigger signal. This
reference trigger can only be applied to finite input tasks. Although the parameter <strong>refTriggerMode</strong> can
only be set to something else than <strong>off</strong> for finite input tasks, such a task will then behave like a continuous
input task. That means, that the task will be started via <strong>acquire</strong> and data will be continuously recorded
until the stop trigger condition is fulfilled (or the internal buffer overflows). To avoid the latter, it is
again necessary to continuously get intermediate data via <strong>getVal</strong> / <strong>copyVal</strong> or enable a fast TDMS logging.</p>
<p>The reference trigger listens to either a falling or raising edge of a digital line, or when an analog trigger
input jumps over (or below) a certain threshold value. However the task is only stopped if three different conditions
are met:</p>
<ol class="arabic simple">
<li><p>The trigger must be signalled (see <strong>refTriggerSource</strong>, <strong>refTriggerMode</strong>, <strong>refTriggerRisingEdge</strong> and <strong>refTriggerLevel</strong>)</p></li>
<li><p>A certain number of samples per channel must have been recorded (see <strong>refTriggerPreTriggerSamples</strong>)</p></li>
<li><p>If cond 1 and 2 are met, a certain number of post trigger samples will be recorded before stopping the task.
This number is defined by <strong>samplesPerChannel</strong> - <strong>refTriggerPreTriggerSamples</strong>.</p></li>
</ol>
</section>
</section>
<section id="tdms-logging">
<h2><span class="section-number">4.5.6. </span>TDMS Logging<a class="headerlink" href="#tdms-logging" title="Link to this heading">#</a></h2>
<p>NI provides a possibility to record all acquired values from all <strong>input tasks</strong> in the NI file format <strong>TDMS</strong>
(see <a class="reference external" href="https://www.ni.com/en-US/support/documentation/supplemental/07/tdms-file-format-internal-structure.html">https://www.ni.com/en-US/support/documentation/supplemental/07/tdms-file-format-internal-structure.html</a>).</p>
<p>The filename of the tdms file, that should be used for the upcoming logging can be set by the parameter
<strong>loggingFilePath</strong>. The TDMS file format can contain multiple arrays from different recordings. Each array
is a two dimensional array, where each row belongs to one channel and the columns are the recorded samples.
Each array is stored under a certain path, where each node of the path is denoted as group.
Separate the different group names by a single slash, to provide a full path. The group name of the upcoming
recording is set via <strong>loggingGroupName</strong>. If the group name already exists in the tdms file, a suffix <strong>#1</strong>, <strong>#2</strong>, …
is added to the leaf group name.
There are different options how to open or create a <strong>TDMS</strong> file. These can be set via <strong>loggingOperation</strong>.
It is for instance possible to always create a new file, to append data to an existing file among others.</p>
<p>The logging itself must be enabled by the parameter <strong>loggingMode</strong>. Set this value to 0 in order to disable logging.
Set it to 1 in order to enable a fast logging. Then all data is automatically logged into the TDMS file after
having called <strong>acquire</strong>, but it is not possible to simultaneously get the recorded data via <strong>getVal</strong> or <strong>copyVal</strong>.
The recording is done via background thread in the NI driver. The last possible value is 2. Then the task is
started like an ordinary task and whenever data is received via <strong>getVal</strong> or <strong>copyVal</strong>, the same data is
stored into TDMS file, too. No data is recorded if <strong>getVal</strong> or <strong>copyVal</strong> are not called.</p>
<p>It is recommended to set all logging parameters before calling <strong>startDevice</strong>. If one of these parameters
is changed later, the device is internally stopped, then the parameters are changed and the device is
reconfigured with the new logging properties.</p>
<p>If the logging is activated, the parameter <strong>loggingActive</strong> will be set to the currently active <strong>loggingMode</strong>.</p>
<p>See the example <strong>demo_ai_tdms_logging.py</strong> for a demo about the TDMS logging.</p>
<p>A TDMS file can for instance be read via the Python package <strong>npTDMS</strong> (<a class="reference external" href="https://pypi.org/project/npTDMS">https://pypi.org/project/npTDMS</a>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># coding=utf8</span>

<span class="sd">&quot;&quot;&quot;Demo to load and read a TDMS file</span>

<span class="sd">Here, we read the TMDS files, that have been created</span>
<span class="sd">by the ai_continuous and di_continuous demo scripts.</span>

<span class="sd">This script requires the Python package npTDMS</span>
<span class="sd">(https://pypi.org/project/npTDMS).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">nptdms</span> <span class="k">as</span> <span class="nn">tdms</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># step 1: read the file demo_ai_continuous.tdms</span>

<span class="n">file</span> <span class="o">=</span> <span class="n">tdms</span><span class="o">.</span><span class="n">TdmsFile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;D:\temp\demo_ai_continuous.tdms&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Available groups:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>

<span class="c1"># access group object</span>
<span class="n">groupObject</span><span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">object</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">groups</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>


<span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">file</span><span class="o">.</span><span class="n">group_channels</span><span class="p">(</span><span class="s1">&#39;group1&#39;</span><span class="p">):</span>
    <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

<span class="n">total2</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">plot1</span><span class="p">(</span><span class="n">total2</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="configuration-dialog-and-toolbox">
<h2><span class="section-number">4.5.7. </span>Configuration Dialog and Toolbox<a class="headerlink" href="#configuration-dialog-and-toolbox" title="Link to this heading">#</a></h2>
<p>The plugin provides both a configuration dialog as well as a toolbox.</p>
<p>The toolbox comes with an overview panel, that shows some basic information about connected channels
and about the current run state of the task. In a 2nd tab, a general list of all parameters is displayed
by means of a generic parameter widget.</p>
<p>The configuration dialog let you configure all channels as well as provide access to all major
parameters, separated into different groups (like start trigger, reference trigger, sample clock etc.).</p>
</section>
<section id="compilation">
<h2><span class="section-number">4.5.8. </span>Compilation<a class="headerlink" href="#compilation" title="Link to this heading">#</a></h2>
<p>To compile this plugin, make sure that the <strong>ANSI C Support</strong> of the NI-DAQmx driver
has been installed, too (see <em>driver</em> section above).</p>
<p>Then enable the option <strong>PLUGIN_niDAQmx</strong> in the CMake configuration of the plugins repository.
If the NI-DAQmx driver has been installed to default directories, CMake should automatically
detect the include and library path of the NI-DAQmx driver. Else, try to set</p>
<p><strong>NIDAQMX_DIR</strong> to the main directory of the NI-DAQ driver (e.g. the directory, that contains
the <em>include</em> folder with the <em>NIDAQmx.h</em> file. Alternatively directly set the following
variables:</p>
<p><strong>NIDAQMX_INCLUDE_DIR</strong> must point to the include directory of the NI-DAQmx driver. This is
the directory, that contains the file <strong>NIDAQmx.h</strong> and <strong>NIDAQMX_LIBRARY</strong> must point to the
linkable library of NIDAQmx, e.g. <strong>NIDAQmx.lib</strong> under Windows.</p>
</section>
<section id="examples">
<h2><span class="section-number">4.5.9. </span>Examples<a class="headerlink" href="#examples" title="Link to this heading">#</a></h2>
<p>All these examples can also be found in the <strong>demo</strong> folder of the <strong>niDAQmx</strong> plugin sources:</p>
<section id="analog-input-tasks">
<h3><span class="section-number">4.5.9.1. </span>Analog Input Tasks<a class="headerlink" href="#analog-input-tasks" title="Link to this heading">#</a></h3>
<p><strong>demo_ai_finite.py</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># coding=utf8</span>

<span class="sd">&quot;&quot;&quot;Finite analog input task.</span>

<span class="sd">Demo script for acquiring a finite set of analog</span>
<span class="sd">values with a National Instruments DAQ device.</span>

<span class="sd">To test this script, the NI MAX (Measurement &amp; Automation</span>
<span class="sd">Explorer) has been used to create simulated devices.</span>

<span class="sd">In this test, a simulated device NI PCIe-6321 with 16 analog input (AI)</span>
<span class="sd">ports was created and named &quot;Dev1&quot;.</span>

<span class="sd">Additionally, one other device NI PCI-6111 with 2 analog input (AI)</span>
<span class="sd">ports was added in NI-MAX with the name &quot;Dev3&quot;.</span>

<span class="sd">The channel configuration string for analog input tasks always</span>
<span class="sd">follows this pattern:</span>

<span class="sd">DeviceName/PortName,ConfigMode,MinVoltage,MaxVoltage</span>

<span class="sd">where ConfigMode is an integer from this list</span>
<span class="sd">(see also argument terminalConfig from command</span>
<span class="sd">DAQmxCreateAIVoltageChan):</span>

<span class="sd">DAQmx_Val_Cfg_Default = 0,</span>
<span class="sd">DAQmx_Val_Diff = 1,</span>
<span class="sd">DAQmx_Val_RSE = 2,</span>
<span class="sd">DAQmx_Val_NRSE = 3,</span>
<span class="sd">DAQmx_Val_PseudoDiff = 4</span>

<span class="sd">Hint: It depends on the NI DAQ devices, if they allow</span>
<span class="sd">integrating different devices into the same measurement</span>
<span class="sd">task or not. Many devices do not allow this.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># Demo 1: Analog input task, finite acquisition, 80 samples / sec</span>
<span class="n">plugin</span> <span class="o">=</span> <span class="n">dataIO</span><span class="p">(</span>
    <span class="s2">&quot;NI-DAQmx&quot;</span><span class="p">,</span>
    <span class="s2">&quot;analogInput&quot;</span><span class="p">,</span>
    <span class="n">taskName</span><span class="o">=</span><span class="s2">&quot;myTaskName&quot;</span><span class="p">,</span>
    <span class="n">taskMode</span><span class="o">=</span><span class="s2">&quot;finite&quot;</span><span class="p">,</span>
    <span class="n">samplingRate</span><span class="o">=</span><span class="mi">80</span>
<span class="p">)</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">showToolbox</span><span class="p">()</span>

<span class="c1"># A total number of 800 samples should be acquired from each port</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">800</span><span class="p">)</span>

<span class="c1"># Configure the channels (semicolon-separated list of single channel config strings):</span>
<span class="c1"># Ch1: Dev1, AI0, connection type 2 (RSE), -10V..+10V</span>
<span class="c1"># Ch2: Dev1, AI2, connection type 0 (Default), -5V..+5V</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev1/ai0,2,-10.0,10.0;Dev1/ai2,0,-5,5&quot;</span><span class="p">)</span>

<span class="c1"># enable a start trigger: here acquisition starts with a falling</span>
<span class="c1"># edge on the digital trigger input PFI0 (simulated devices will</span>
<span class="c1"># automatically send this trigger).</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;startTriggerMode&quot;</span><span class="p">,</span> <span class="s2">&quot;digitalEdge&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;startTriggerSource&quot;</span><span class="p">,</span> <span class="s2">&quot;PFI0&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;startTriggerRisingEdge&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># enable the on-board clock as continuous trigger</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;sampleClockSource&quot;</span><span class="p">,</span> <span class="s2">&quot;OnboardClock&quot;</span><span class="p">)</span>

<span class="c1"># after having configured the task, start the device.</span>
<span class="c1"># The task is then configured in the device. It will be</span>
<span class="c1"># started with plugin.acquire() later.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># repeat the configured acquisition task 5x.</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">):</span>
    <span class="c1"># modify the sampling rate to different values (Hz)</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplingRate&quot;</span><span class="p">,</span> <span class="mi">1000</span> <span class="o">+</span> <span class="n">i</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1"># start the acquisition of the given number of samples per channel.</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
    <span class="n">d</span><span class="o">=</span><span class="n">dataObject</span><span class="p">()</span>
    <span class="c1"># getVal will return if all samples have been acquired (or timeout)</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">getVal</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># plot the acquired values from both channels from the last run.</span>
<span class="c1"># the output dataObject already contains the correct axes units,</span>
<span class="c1"># descriptions etc...</span>
<span class="n">plot1</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
      <span class="n">properties</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;legendPosition&quot;</span><span class="p">:</span> <span class="s2">&quot;Right&quot;</span><span class="p">,</span> <span class="s2">&quot;legendTitles&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;AI0&quot;</span><span class="p">,</span> <span class="s2">&quot;AI2&quot;</span><span class="p">)})</span>

<span class="c1"># stop and remove the configured task</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">stopDevice</span><span class="p">()</span>

<span class="c1"># change the analog input task to another channel and</span>
<span class="c1"># another trigger condition.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev3/ai1,4,-6,8&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;startTriggerMode&quot;</span><span class="p">,</span> <span class="s2">&quot;off&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;startTriggerSource&quot;</span><span class="p">,</span> <span class="s2">&quot;PFI0&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;startTriggerRisingEdge&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># restart the task and do another finite measurement.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">getVal</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">stopDevice</span><span class="p">()</span>
<span class="n">plot1</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>demo_ai_continuous.py</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># coding=utf8</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="sd">&quot;&quot;&quot;Continuous analog input task with optional logging (TDMS files).</span>

<span class="sd">Demo script for acquiring a continuous set of analog</span>
<span class="sd">values with a National Instruments DAQ device.</span>

<span class="sd">To test this script, the NI MAX (Measurement &amp; Automation</span>
<span class="sd">Explorer) has been used to create simulated devices.</span>

<span class="sd">In this test, a simulated device NI PCIe-6321 with 16 analog input (AI)</span>
<span class="sd">ports was created and named &quot;Dev1&quot;.</span>

<span class="sd">The channel configuration string for analog input tasks always</span>
<span class="sd">follows this pattern:</span>

<span class="sd">DeviceName/PortName,ConfigMode,MinVoltage,MaxVoltage</span>

<span class="sd">where ConfigMode is an integer from this list</span>
<span class="sd">(see also argument terminalConfig from command</span>
<span class="sd">DAQmxCreateAIVoltageChan):</span>

<span class="sd">DAQmx_Val_Cfg_Default = 0,</span>
<span class="sd">DAQmx_Val_Diff = 1,</span>
<span class="sd">DAQmx_Val_RSE = 2,</span>
<span class="sd">DAQmx_Val_NRSE = 3,</span>
<span class="sd">DAQmx_Val_PseudoDiff = 4</span>

<span class="sd">Hint: It depends on the NI DAQ devices, if they allow</span>
<span class="sd">integrating different devices into the same measurement</span>
<span class="sd">task or not. Many devices do not allow this.</span>

<span class="sd">Data from a continuous task can be obtained by regularly</span>
<span class="sd">calling getVal / copyVal or by enabling the TDMS file logging</span>
<span class="sd">technique.</span>

<span class="sd">Reading TDMS files via Python is possible by the package npTDMS</span>
<span class="sd">(https://pypi.org/project/npTDMS).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># initialize the plugin for continuous analog input tasks</span>
<span class="n">plugin</span> <span class="o">=</span> <span class="n">dataIO</span><span class="p">(</span>
    <span class="s2">&quot;NI-DAQmx&quot;</span><span class="p">,</span>
    <span class="s2">&quot;analogInput&quot;</span><span class="p">,</span>
    <span class="n">taskName</span><span class="o">=</span><span class="s2">&quot;demoAiContinuous&quot;</span><span class="p">,</span>
    <span class="n">taskMode</span><span class="o">=</span><span class="s2">&quot;continuous&quot;</span><span class="p">,</span>
    <span class="n">samplingRate</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="c1"># The NI-DAQ device uses the &#39;samplesPerChannel&#39; in case of continuous</span>
<span class="c1"># tasks to define the internal buffer size. However if the number of</span>
<span class="c1"># samples, obtained by &#39;samplesPerChannel&#39; * noOfChannels is lower</span>
<span class="c1"># than the values in the following table, NI-DAQ uses the values from</span>
<span class="c1"># the table:</span>
<span class="c1">#</span>
<span class="c1"># no sampling rate:      10000 samples</span>
<span class="c1"># 0 - 100 samples / sec: 1 kS</span>
<span class="c1"># 101 - 10000 S/s:       10 kS</span>
<span class="c1"># 10001 - 1000000 S/s:   100 kS</span>
<span class="c1"># else:                  1 MS</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span>

<span class="c1"># if this value is -1, the NI-DAQ device will calculate the internal</span>
<span class="c1"># buffer size depending on the samplingRate and the parameter</span>
<span class="c1"># &#39;samplesPerChannel&#39;. Else, the internal buffer size can be overwritten</span>
<span class="c1"># by this parameter.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;bufferSize&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># the readTimeout is important for continuous acquisitions.</span>
<span class="c1"># It is considered during getVal/copyVal.</span>
<span class="c1"># If it is set to -1.0, each getVal/copyVal command will wait</span>
<span class="c1"># until &#39;samplesPerChannel&#39; samples have been received for each channel.</span>
<span class="c1"># This cannot be stopped.</span>
<span class="c1"># If it is set to 0.0, getVal/copyVal will always return immediately</span>
<span class="c1"># and return up to &#39;samplesPerChannel&#39; values per channel. The dataObject</span>
<span class="c1"># argument can also have less number of columns after these calls.</span>
<span class="c1"># Values &gt; 0.0 are considered as real timeout. If the requested</span>
<span class="c1"># number of samples per channel are not received within this timeout,</span>
<span class="c1"># an error is raised (Status Code: -200284).</span>
<span class="c1"># In this example, the immediate return is used, but getVal will be</span>
<span class="c1"># called after a certain delay to wait for a certain number of values</span>
<span class="c1"># before getting them.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;readTimeout&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="c1"># assign some channels</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev1/ai0,0,-10,10;Dev1/ai1,0,-8,8&quot;</span><span class="p">)</span>

<span class="c1"># configure the task based on the configurations above.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="c1"># 1. sub-demo: Start the continuous task and get all new values</span>
<span class="c1">#    every 500ms. Update a plot with the new values. Repeat this</span>
<span class="c1">#    10 times and then stop the task. Afterwards concatenate all</span>
<span class="c1">#    intermediate results and display them in a new plot.</span>
<span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># open an empty 1D plot</span>
<span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">plot1</span><span class="p">(</span><span class="n">dataObject</span><span class="p">())</span>

<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Run </span><span class="si">{</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/2...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># start the task</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># the following sleep must not be too long, since NI raises</span>
        <span class="c1"># an exception if the internal intermediate buffer gets full.</span>
        <span class="c1"># The programmer has to assure, that this buffer is continuously</span>
        <span class="c1"># read out using getVal or copyVal.</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">()</span>
        <span class="c1"># getVal will only return a reference to the internal object.</span>
        <span class="c1"># since we want to store the intermediate result for later</span>
        <span class="c1"># processing, we would like to get an unmutable array. Therefore: copyVal.</span>
        <span class="n">plugin</span><span class="o">.</span><span class="n">copyVal</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;, step </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/5 in %.2f s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">h</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>  <span class="c1"># update the plot</span>
        <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="c1"># stop the task</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; done&quot;</span><span class="p">)</span>

<span class="c1"># print the shapes of all subobjects</span>
<span class="nb">print</span><span class="p">([</span><span class="n">i</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">])</span>

<span class="c1"># concatenate the intermediate results and plot them.</span>
<span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
<span class="n">plot1</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>

<span class="c1"># 2. sub-demo: It is also possible to enable a logging of the task</span>
<span class="c1">#    into NIs own TDMS file format. Then, all values, which are acquired</span>
<span class="c1">#    during a running task will be written into the TDMS file. It is</span>
<span class="c1">#    also possible to get the values to python during logging (depending</span>
<span class="c1">#    on the configuration). However, it is not necessary to continuously</span>
<span class="c1">#    getVal/copyVal values in order to not raise a timeout / insufficient</span>
<span class="c1">#    buffer size error.</span>
<span class="c1">#</span>
<span class="c1">#    The logging is enabled via the parameters &#39;loggingMode&#39;,</span>
<span class="c1">#    &#39;loggingFilePath&#39;, &#39;loggingGroupName&#39; and &#39;loggingOperation&#39;:</span>
<span class="c1">#</span>
<span class="c1">#    loggingMode: 0 -&gt; disable logging</span>
<span class="c1">#                 1 -&gt; enable fast mode logging</span>
<span class="c1">#                      (no simultaneous read via getVal/copyVal allowed),</span>
<span class="c1">#                 2 -&gt; standard logging enabled (getVal/copyVal is possible,</span>
<span class="c1">#                      however data will only streamed to file if it has been</span>
<span class="c1">#                      obtained via getVal/copyVal).</span>
<span class="c1">#    filePath: path to output tdms file.</span>
<span class="c1">#    groupName: The name of the group to create within the TDMS file</span>
<span class="c1">#    operation (optional, default: createOrReplace):</span>
<span class="c1">#                 open: an existing tdms file is opened and new data is appended</span>
<span class="c1">#                       Raises an exception during task start if the file</span>
<span class="c1">#                       does not exist.</span>
<span class="c1">#                 openOrCreate: data is appended to an existing file or a new</span>
<span class="c1">#                       file is created.</span>
<span class="c1">#                 createOrReplace: always create a new file. An existing one</span>
<span class="c1">#                       will be deleted first.</span>
<span class="c1">#                 create: create a new file and raises an exception if it</span>
<span class="c1">#                       already exists.</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;loggingMode&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;loggingFilePath&quot;</span><span class="p">,</span> <span class="s2">&quot;D:/temp/demo_ai_continuous.tdms&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;loggingGroupName&quot;</span><span class="p">,</span> <span class="s2">&quot;group1&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;loggingOperation&quot;</span><span class="p">,</span> <span class="s2">&quot;createOrReplace&quot;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;logged acquisition </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/3: &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># start the continuous task again</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

    <span class="c1"># wait for 3 seconds (data are acquired and stored into the file)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># stop the task</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; done&quot;</span><span class="p">)</span>

<span class="c1"># stop the device (if there are still running \</span>
<span class="c1"># tasks, they will also be stopped here)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">stopDevice</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>demo_ai_single_value.py</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># coding=utf8</span>

<span class="sd">&quot;&quot;&quot;Finite analog input task for single value acquisitions.</span>

<span class="sd">Demo script for acquiring exactly one analog value</span>
<span class="sd">per channel per acquire() command</span>
<span class="sd">with a National Instruments DAQ device.</span>

<span class="sd">To test this script, the NI MAX (Measurement &amp; Automation</span>
<span class="sd">Explorer) has been used to create simulated devices.</span>

<span class="sd">In this test, a simulated device NI PCIe-6321 with 16 analog input (AI)</span>
<span class="sd">ports was created and named &quot;Dev1&quot;.</span>

<span class="sd">The channel configuration string for analog input tasks always</span>
<span class="sd">follows this pattern:</span>

<span class="sd">DeviceName/PortName,ConfigMode,MinVoltage,MaxVoltage</span>

<span class="sd">where ConfigMode is an integer from this list</span>
<span class="sd">(see also argument terminalConfig from command</span>
<span class="sd">DAQmxCreateAIVoltageChan):</span>

<span class="sd">DAQmx_Val_Cfg_Default = 0,</span>
<span class="sd">DAQmx_Val_Diff = 1,</span>
<span class="sd">DAQmx_Val_RSE = 2,</span>
<span class="sd">DAQmx_Val_NRSE = 3,</span>
<span class="sd">DAQmx_Val_PseudoDiff = 4</span>

<span class="sd">Hint: It depends on the NI DAQ devices, if they allow</span>
<span class="sd">integrating different devices into the same measurement</span>
<span class="sd">task or not. Many devices do not allow this.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># Demo 1: Analog input task, finite acquisition</span>
<span class="c1"># the sampling rate is unimportant</span>
<span class="n">plugin</span> <span class="o">=</span> <span class="n">dataIO</span><span class="p">(</span>
    <span class="s2">&quot;NI-DAQmx&quot;</span><span class="p">,</span>
    <span class="s2">&quot;analogInput&quot;</span><span class="p">,</span>
    <span class="n">taskName</span><span class="o">=</span><span class="s2">&quot;myTaskName&quot;</span><span class="p">,</span>
    <span class="n">taskMode</span><span class="o">=</span><span class="s2">&quot;finite&quot;</span>
<span class="p">)</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">showToolbox</span><span class="p">()</span>

<span class="c1"># A total number of 1 samples should be acquired from each port</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Configure the channels (semicolon-separated list of single channel config strings):</span>
<span class="c1"># Ch1: Dev1, AI0, connection type 2 (RSE), -10V..+10V</span>
<span class="c1"># Ch2: Dev1, AI2, connection type 0 (Default), -5V..+5V</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev1/ai0,2,-10.0,10.0;Dev1/ai2,0,-5,5&quot;</span><span class="p">)</span>

<span class="c1"># If single values are acquired (samplesPerChannel=1), the start</span>
<span class="c1"># trigger must be off, since this acquisition on demand only operates</span>
<span class="c1"># upon a software trigger.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;startTriggerMode&quot;</span><span class="p">,</span> <span class="s2">&quot;off&quot;</span><span class="p">)</span>


<span class="c1"># after having configured the task, start the device.</span>
<span class="c1"># The task is then configured in the device. It will be</span>
<span class="c1"># started with plugin.acquire() later.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span> <span class="s1">&#39;float64&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="c1"># repeat the configured acquisition task 5x.</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">):</span>
    <span class="c1"># start the acquisition of the given number of samples per channel.</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

    <span class="c1"># getVal will return if all samples have been acquired (or timeout)</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">copyVal</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>

<span class="c1"># plot the acquired values from both channels from the last run.</span>
<span class="c1"># the output dataObject already contains the correct axes units,</span>
<span class="c1"># descriptions etc...</span>
<span class="n">plot1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span>
      <span class="n">properties</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;legendPosition&quot;</span><span class="p">:</span> <span class="s2">&quot;Right&quot;</span><span class="p">,</span> <span class="s2">&quot;legendTitles&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;AI0&quot;</span><span class="p">,</span> <span class="s2">&quot;AI2&quot;</span><span class="p">)})</span>

<span class="c1"># stop and remove the configured task</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">stopDevice</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>demo_ai_finite_ref_trigger.py</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># coding=utf8</span>

<span class="sd">&quot;&quot;&quot;Finite analog input task with a reference trigger.</span>

<span class="sd">Demo script for acquiring a finite (but unknown) number of analog</span>
<span class="sd">values with a National Instruments DAQ device, where both the start</span>
<span class="sd">and end of the acquisition is given by triggers.</span>

<span class="sd">To test this script, the NI MAX (Measurement &amp; Automation</span>
<span class="sd">Explorer) has been used to create simulated devices.</span>

<span class="sd">In this test, a simulated device NI PCIe-6321 with 16 analog input (AI)</span>
<span class="sd">ports was created and named &quot;Dev1&quot;.</span>

<span class="sd">The start trigger can watch a raising or falling edge of an analog</span>
<span class="sd">or digital signal. If an analog signal is chosen, a certain threshold</span>
<span class="sd">value has to be given, too (see parameter &#39;startTriggerLevel&#39;).</span>

<span class="sd">The stop trigger is given by a so called reference trigger. This</span>
<span class="sd">can only be enabled for finite, input tasks. However, such a trigger</span>
<span class="sd">will implicitly let the finite task behave like a continuous task.</span>
<span class="sd">This means, that you have to continuously retrieve the newest data using</span>
<span class="sd">&#39;getVal&#39; or &#39;copyVal&#39; such that the internal buffer does not overflow.</span>
<span class="sd">The stop event for the task is defined by three conditions, that have</span>
<span class="sd">to be met: At first, a certain number of samples (refTriggerPreTriggerSamples)</span>
<span class="sd">have to be acquired, before the raising or falling edge of the given</span>
<span class="sd">refTriggerSource is monitored. Then, this source must have the requested</span>
<span class="sd">signal change. Once, this change is detected, the task will record further</span>
<span class="sd">samples, whose number is called postTriggerSamples. They are calculated by</span>
<span class="sd">&quot;samplesPerChannel&quot; - &quot;refTriggerPreTriggerSamples&quot;. Then, the task is</span>
<span class="sd">stopped and the parameter &quot;taskStarted&quot; becomes 0.</span>

<span class="sd">Hint: It depends on the NI DAQ devices, if they allow</span>
<span class="sd">integrating different devices into the same measurement</span>
<span class="sd">task or not. Many devices do not allow this.</span>

<span class="sd">Hint: The reference trigger could only be tested by the developer</span>
<span class="sd">by a simulated NI device. This immediately fires the refTriggerSources, such</span>
<span class="sd">that a 100% testing could not be executed.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># Demo 1: Analog input task, finite acquisition, 80 samples / sec</span>
<span class="n">plugin</span> <span class="o">=</span> <span class="n">dataIO</span><span class="p">(</span>
    <span class="s2">&quot;NI-DAQmx&quot;</span><span class="p">,</span>
    <span class="s2">&quot;analogInput&quot;</span><span class="p">,</span>
    <span class="n">taskName</span><span class="o">=</span><span class="s2">&quot;myTaskName&quot;</span><span class="p">,</span>
    <span class="n">taskMode</span><span class="o">=</span><span class="s2">&quot;finite&quot;</span><span class="p">,</span>
    <span class="n">samplingRate</span><span class="o">=</span><span class="mi">200</span>
<span class="p">)</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">showToolbox</span><span class="p">()</span>

<span class="c1"># Each getVal / copyVal command will retrieve 800 samples per</span>
<span class="c1"># channel. This is also the number used to calculate the post-trigger</span>
<span class="c1"># samples (&quot;samplesPerChannel&quot; - &quot;refTriggerPreTriggerSamples&quot;)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">800</span><span class="p">)</span>

<span class="c1"># Configure the channels:</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev1/ai0,2,-10.0,10.0;Dev1/ai2,0,-5,5&quot;</span><span class="p">)</span>

<span class="c1"># enable a start trigger: here acquisition starts with a raising</span>
<span class="c1"># edge on the digital trigger input PFI0 (simulated devices will</span>
<span class="c1"># automatically send this trigger).</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;startTriggerMode&quot;</span><span class="p">,</span> <span class="s2">&quot;digitalEdge&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;startTriggerSource&quot;</span><span class="p">,</span> <span class="s2">&quot;PFI0&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;startTriggerRisingEdge&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="c1"># enable a reference trigger using a digital, falling edge of PFI0 as</span>
<span class="c1"># trigger signal. The task is only stopped, if the trigger has been</span>
<span class="c1"># detected, at least pre-trigger samples have been acquired and after</span>
<span class="c1"># the trigger signal, another (&quot;samplesPerChannel&quot; - preTriggerSamples)</span>
<span class="c1"># will be acquired.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;refTriggerMode&quot;</span><span class="p">,</span> <span class="s2">&quot;digitalEdge&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;refTriggerSource&quot;</span><span class="p">,</span> <span class="s2">&quot;PFI0&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;refTriggerRisingEdge&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;refTriggerPreTriggerSamples&quot;</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

<span class="c1"># enable the on-board clock as continuous trigger</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;sampleClockSource&quot;</span><span class="p">,</span> <span class="s2">&quot;OnboardClock&quot;</span><span class="p">)</span>

<span class="c1"># after having configured the task, start the device.</span>
<span class="c1"># The task is then configured in the device. It will be</span>
<span class="c1"># started with plugin.acquire() later.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="c1"># start the acquisition</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>

<span class="c1"># continuously obtain new data until the task is not started</span>
<span class="c1"># any more (since the ref. trigger conditions are all met):</span>
<span class="k">while</span> <span class="n">plugin</span><span class="o">.</span><span class="n">getParam</span><span class="p">(</span><span class="s2">&quot;taskStarted&quot;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;retrieve subset of data...&quot;</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">()</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">copyVal</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The ref. trigger conditions are fulfilled.&quot;</span><span class="p">)</span>

<span class="c1"># plot the acquired values from both channels from the last run.</span>
<span class="c1"># the output dataObject already contains the correct axes units,</span>
<span class="c1"># descriptions etc...</span>
<span class="n">plot1</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
      <span class="n">properties</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;legendPosition&quot;</span><span class="p">:</span> <span class="s2">&quot;Right&quot;</span><span class="p">,</span> <span class="s2">&quot;legendTitles&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;AI0&quot;</span><span class="p">,</span> <span class="s2">&quot;AI2&quot;</span><span class="p">)})</span>

<span class="c1"># stop and remove the configured task</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">stopDevice</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>demo_ai_tdms_logging.py</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># coding=utf8</span>

<span class="sd">&quot;&quot;&quot;Continuous analog input task with optional logging (TDMS files).</span>

<span class="sd">Demo script for acquiring a continuous set of analog</span>
<span class="sd">values with a National Instruments DAQ device.</span>

<span class="sd">To test this script, the NI MAX (Measurement &amp; Automation</span>
<span class="sd">Explorer) has been used to create simulated devices.</span>

<span class="sd">In this test, a simulated device NI PCIe-6321 with 16 analog input (AI)</span>
<span class="sd">ports was created and named &quot;Dev1&quot;.</span>

<span class="sd">The channel configuration string for analog input tasks always</span>
<span class="sd">follows this pattern:</span>

<span class="sd">DeviceName/PortName,ConfigMode,MinVoltage,MaxVoltage</span>

<span class="sd">where ConfigMode is an integer from this list</span>
<span class="sd">(see also argument terminalConfig from command</span>
<span class="sd">DAQmxCreateAIVoltageChan):</span>

<span class="sd">DAQmx_Val_Cfg_Default = 0,</span>
<span class="sd">DAQmx_Val_Diff = 1,</span>
<span class="sd">DAQmx_Val_RSE = 2,</span>
<span class="sd">DAQmx_Val_NRSE = 3,</span>
<span class="sd">DAQmx_Val_PseudoDiff = 4</span>

<span class="sd">Hint: It depends on the NI DAQ devices, if they allow</span>
<span class="sd">integrating different devices into the same measurement</span>
<span class="sd">task or not. Many devices do not allow this.</span>

<span class="sd">Data from a continuous task can be obtained by regularly</span>
<span class="sd">calling getVal / copyVal or by enabling the TDMS file logging</span>
<span class="sd">technique.</span>

<span class="sd">Reading TDMS files via Python is possible by the package npTDMS</span>
<span class="sd">(https://pypi.org/project/npTDMS).</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># initialize the plugin for continuous analog input tasks</span>
<span class="n">plugin</span> <span class="o">=</span> <span class="n">dataIO</span><span class="p">(</span>
    <span class="s2">&quot;NI-DAQmx&quot;</span><span class="p">,</span>
    <span class="s2">&quot;analogInput&quot;</span><span class="p">,</span>
    <span class="n">taskName</span><span class="o">=</span><span class="s2">&quot;demoAiContinuous&quot;</span><span class="p">,</span>
    <span class="n">taskMode</span><span class="o">=</span><span class="s2">&quot;continuous&quot;</span><span class="p">,</span>
    <span class="n">samplingRate</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">showToolbox</span><span class="p">()</span>

<span class="c1"># The NI-DAQ device uses the &#39;samplesPerChannel&#39; in case of continuous</span>
<span class="c1"># tasks to define the internal buffer size. However if the number of</span>
<span class="c1"># samples, obtained by &#39;samplesPerChannel&#39; * noOfChannels is lower</span>
<span class="c1"># than the values in the following table, NI-DAQ uses the values from</span>
<span class="c1"># the table:</span>
<span class="c1">#</span>
<span class="c1"># no sampling rate:      10000 samples</span>
<span class="c1"># 0 - 100 samples / sec: 1 kS</span>
<span class="c1"># 101 - 10000 S/s:       10 kS</span>
<span class="c1"># 10001 - 1000000 S/s:   100 kS</span>
<span class="c1"># else:                  1 MS</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span>

<span class="c1"># if this value is -1, the NI-DAQ device will calculate the internal</span>
<span class="c1"># buffer size depending on the samplingRate and the parameter</span>
<span class="c1"># &#39;samplesPerChannel&#39;. Else, the internal buffer size can be overwritten</span>
<span class="c1"># by this parameter.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;bufferSize&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># the readTimeout is important for continuous acquisitions.</span>
<span class="c1"># It is considered during getVal/copyVal.</span>
<span class="c1"># If it is set to -1.0, each getVal/copyVal command will wait</span>
<span class="c1"># until &#39;samplesPerChannel&#39; samples have been received for each channel.</span>
<span class="c1"># This cannot be stopped.</span>
<span class="c1"># If it is set to 0.0, getVal/copyVal will always return immediately</span>
<span class="c1"># and return up to &#39;samplesPerChannel&#39; values per channel. The dataObject</span>
<span class="c1"># argument can also have less number of columns after these calls.</span>
<span class="c1"># Values &gt; 0.0 are considered as real timeout. If the requested</span>
<span class="c1"># number of samples per channel are not received within this timeout,</span>
<span class="c1"># an error is raised (Status Code: -200284).</span>
<span class="c1"># In this example, the immediate return is used, but getVal will be</span>
<span class="c1"># called after a certain delay to wait for a certain number of values</span>
<span class="c1"># before getting them.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;readTimeout&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="c1"># assign some channels</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev1/ai0,0,-10,10;Dev1/ai1,0,-8,8&quot;</span><span class="p">)</span>

<span class="c1"># Step 1: LoggingMode is a fast logging, in this mode, all acquired samples</span>
<span class="c1"># are automatically logged into the given tdms file. You must not use</span>
<span class="c1"># getVal or copyVal in this logging mode.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;loggingMode&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;loggingFilePath&quot;</span><span class="p">,</span> <span class="s2">&quot;D:/temp/demo_ai_continuous.tdms&quot;</span><span class="p">)</span>

<span class="c1"># when opening a tdms file in append mode and if the group name</span>
<span class="c1"># already exists, a new group with a &#39;#number&#39; suffix will be appended</span>
<span class="c1"># to the group name.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;loggingGroupName&quot;</span><span class="p">,</span> <span class="s2">&quot;group1&quot;</span><span class="p">)</span>

<span class="c1"># &#39;open&#39;: Always appends data to an existing TDMS file. If it does not exist</span>
<span class="c1">#         yet, the task start operation will return with an error.</span>
<span class="c1"># &#39;openOrCreate&#39;: Creates a new TDMS file or appends data to the existing one.</span>
<span class="c1"># &#39;createOrReplace&#39; (default): Creates a new TDMS file or replaces an existing</span>
<span class="c1">#                              one.</span>
<span class="c1"># &#39;create&#39;: Newly creates the TDMS file. If it already exists, a task start</span>
<span class="c1">#           operation will return with an error.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;loggingOperation&quot;</span><span class="p">,</span> <span class="s2">&quot;createOrReplace&quot;</span><span class="p">)</span>

<span class="c1"># configure the task based on the configurations above.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fast, direct logging run </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/10...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="c1"># start the continuous task again</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

    <span class="c1"># wait for 1 seconds (data are acquired and stored into the file)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># stop the task</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; done in </span><span class="si">%.3f</span><span class="s2"> s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>



<span class="c1"># Step 2: choose another logging type. Usually it is recommended to</span>
<span class="c1"># stop the device before changing the logging modes. However,</span>
<span class="c1"># it the device is still started if the logging parameters</span>
<span class="c1"># will be changed, it will automatically be stopped and restarted</span>
<span class="c1"># again.</span>

<span class="c1"># switch to loggingMode 2: Here only data that has been received</span>
<span class="c1"># via getVal / copyVal is additionally stored in the tdms file</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;loggingMode&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;loggingFilePath&quot;</span><span class="p">,</span> <span class="s2">&quot;D:/temp/demo_ai_continuous2.tdms&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;loggingOperation&quot;</span><span class="p">,</span> <span class="s2">&quot;createOrReplace&quot;</span><span class="p">)</span>


<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Simultaneous logging during getVal/copyVal (5sec)...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="c1"># start the continuous task again</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
    <span class="c1"># wait a little bit</span>

    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="c1"># receive data that is automatically stored in the file, too</span>
    <span class="c1"># getVal has to be called faster than the internal buffer of</span>
    <span class="c1"># the device will exceed.</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">getVal</span><span class="p">(</span><span class="n">dataObject</span><span class="p">())</span>


<span class="c1"># stop the task</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot; done in </span><span class="si">%.2f</span><span class="s2"> s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>

<span class="c1"># stop the device (if there are still running \</span>
<span class="c1"># tasks, they will also be stopped here)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">stopDevice</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="analog-output-tasks">
<h3><span class="section-number">4.5.9.2. </span>Analog Output Tasks<a class="headerlink" href="#analog-output-tasks" title="Link to this heading">#</a></h3>
<p><strong>demo_ao_finite.py</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># coding=utf8</span>

<span class="sd">&quot;&quot;&quot;Finite analog output task.</span>

<span class="sd">Demo script for sending a series of number to different</span>
<span class="sd">channels of a National Instruments DAQ device.</span>

<span class="sd">To test this script, the NI MAX (Measurement &amp; Automation</span>
<span class="sd">Explorer) has been used to create simulated devices.</span>

<span class="sd">In this test, a simulated device NI PCIe-6323 with 4 analog output (AO)</span>
<span class="sd">ports was created and named &quot;Dev4&quot;.</span>

<span class="sd">Values are always written by a float64 dataObject, that is passed</span>
<span class="sd">as argument to the &#39;setVal&#39; method. This dataObject must be 2 dimensional</span>
<span class="sd">and the number of rows must be equal to the number of channels.</span>

<span class="sd">The number of samples that is written to each channel for each setVal</span>
<span class="sd">command is mainly determined by the &#39;samplesPerChannel&#39; argument.</span>

<span class="sd">There are two cases to handle:</span>

<span class="sd">1. If the dataObject has one column OR &#39;samplesPerChannel&#39; is equal</span>
<span class="sd">   to 1, an unbuffered, single write operation is executed. This</span>
<span class="sd">   operation does not allow a hardware based start trigger.</span>

<span class="sd">2. If the dataObject has more than one column, a buffered write</span>
<span class="sd">   operation is executed and any start trigger source is possible).</span>
<span class="sd">   If &#39;samplesPerChannel&#39; is &lt;= number of columns, the first columns</span>
<span class="sd">   will be send, until &#39;samplesPerChannel&#39; samples have been sent to</span>
<span class="sd">   each channel. If its value is bigger than the number of columns,</span>
<span class="sd">   the dataObject will be repeated until the desired number of samples</span>
<span class="sd">   have been sent.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># create the plugin instance</span>
<span class="n">plugin</span> <span class="o">=</span> <span class="n">dataIO</span><span class="p">(</span>
    <span class="s2">&quot;NI-DAQmx&quot;</span><span class="p">,</span>
    <span class="s2">&quot;analogOutput&quot;</span><span class="p">,</span>
    <span class="n">taskName</span><span class="o">=</span><span class="s2">&quot;analogOutput&quot;</span><span class="p">,</span>
    <span class="n">taskMode</span><span class="o">=</span><span class="s2">&quot;finite&quot;</span><span class="p">,</span>
    <span class="n">samplingRate</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

<span class="c1"># select three channels.</span>
<span class="c1"># The channel description for an analog output</span>
<span class="c1"># channel description is: dev-name,min-output-voltage,max-output-voltage</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev4/ao0,-10,10;Dev4/ao1,-5,5;Dev4/ao2,-5,5&quot;</span><span class="p">)</span>

<span class="c1"># show the toolbox</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">showToolbox</span><span class="p">()</span>

<span class="c1"># 1. First demo: send 2 times 400 samples to all three channels.</span>
<span class="c1">#    The setVal command is not blocked and returns directly after</span>
<span class="c1">#    having started the write operation. The finish state can</span>
<span class="c1">#    be read via getParam(&quot;taskStarted&quot;)</span>

<span class="c1">#    A start hardware trigger (falling digital edge of source PFIO)</span>
<span class="c1">#    is set:</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;startTriggerMode&quot;</span><span class="p">,</span> <span class="s2">&quot;digitalEdge&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;startTriggerSource&quot;</span><span class="p">,</span> <span class="s2">&quot;PFI0&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;startTriggerRisingEdge&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1"># non-blocking setVal command</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;setValWaitForFinish&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="c1"># generate a random object</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">randN</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">400</span><span class="p">],</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>

<span class="c1"># It is very important to the samplesPerChannel accordingly,</span>
<span class="c1"># since the columns of the dataObject to write will be repeated</span>
<span class="c1"># during one setVal operation until the number of samples per</span>
<span class="c1"># channel have been written.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">setVal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;run </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/2 &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="c1"># check if already finished...</span>
    <span class="k">while</span><span class="p">(</span><span class="n">plugin</span><span class="o">.</span><span class="n">getParam</span><span class="p">(</span><span class="s2">&quot;taskStarted&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;done in </span><span class="si">%.2f</span><span class="s2"> s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>

    <span class="c1"># a finite task with more than one sample per channel</span>
    <span class="c1"># is automatically stopped at the end. It is not</span>
    <span class="c1"># necessary to call stop() again.</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

<span class="c1"># 2. Second demo: send 100x times 1 sample to all three channels.</span>
<span class="c1">#    The setVal command will block until every sample has been written.</span>
<span class="c1">#    Sending 1 sample per channel is an unbuffer operation. A hardware start</span>
<span class="c1">#    trigger is therefore not possible.</span>

<span class="c1"># the setVal command will now block until all</span>
<span class="c1"># &#39;samplesPerChannel&#39; values have been written</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;setValWaitForFinish&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;startTriggerMode&quot;</span><span class="p">,</span> <span class="s2">&quot;off&quot;</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">randN</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>
<span class="c1"># &#39;samplesPerChannel&#39; must also be equal to 1.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">):</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">setVal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;done in </span><span class="si">%.2f</span><span class="s2"> s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>

<span class="c1"># 2. Third demo: send 5 times 200 samples to all three channels.</span>
<span class="c1">#    However the input object only has 2 columns, such that this</span>
<span class="c1">#    object will be repeated 100 times per setVal command to send all</span>
<span class="c1">#    6 requested values per channel.</span>
<span class="c1">#    The setVal command is still a blocking command.</span>
<span class="c1">#    Hint: Repeating the input dataObject is only possible if it</span>
<span class="c1">#    has more than one column. Else a single value, unbuffered,</span>
<span class="c1">#    write operation is assumed.</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">randN</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;float64&#39;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">setVal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;done in </span><span class="si">%.2f</span><span class="s2"> s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">stopDevice</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>demo_ao_continuous.py</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># coding=utf8</span>

<span class="sd">&quot;&quot;&quot;Continuous analog output task.</span>

<span class="sd">Demo script for sending a series of number to different</span>
<span class="sd">channels of a National Instruments DAQ device.</span>

<span class="sd">To test this script, the NI MAX (Measurement &amp; Automation</span>
<span class="sd">Explorer) has been used to create simulated devices.</span>

<span class="sd">In this test, a simulated device NI PCIe-6323 with 4 analog output (AO)</span>
<span class="sd">ports was created and named &quot;Dev4&quot;.</span>

<span class="sd">Values are always written by a uint8, uint16 or int32 dataObject, that is passed</span>
<span class="sd">as argument to the &#39;setVal&#39; method. This dataObject must be 2-dimensional</span>
<span class="sd">and the number of rows must be equal to the number of channels. The int32</span>
<span class="sd">object is internally casted to uint32 (however int32 is no valid dataObject</span>
<span class="sd">data type). The datatype itself depends on the number of lines of each</span>
<span class="sd">selected port. If the port has 0-8 lines, uint8 is required, for 9-16 lines</span>
<span class="sd">uint16, else int32.</span>

<span class="sd">The number of samples that is written to each channel for each setVal</span>
<span class="sd">command is mainly determined by the &#39;samplesPerChannel&#39; argument.</span>

<span class="sd">There are two cases to handle:</span>

<span class="sd">1. If the dataObject has one column OR &#39;samplesPerChannel&#39; is equal</span>
<span class="sd">   to 1, an unbuffered, single write operation is executed. This</span>
<span class="sd">   operation does not allow a hardware based start trigger.</span>

<span class="sd">2. If the dataObject has more than one column, a buffered write</span>
<span class="sd">   operation is executed and any start trigger source is possible).</span>
<span class="sd">   If &#39;samplesPerChannel&#39; is &lt;= number of columns, the first columns</span>
<span class="sd">   will be send, until &#39;samplesPerChannel&#39; samples have been sent to</span>
<span class="sd">   each channel. If its value is bigger than the number of columns,</span>
<span class="sd">   the dataObject will be repeated until the desired number of samples</span>
<span class="sd">   have been sent.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># create the plugin instance</span>
<span class="n">plugin</span> <span class="o">=</span> <span class="n">dataIO</span><span class="p">(</span>
    <span class="s2">&quot;NI-DAQmx&quot;</span><span class="p">,</span>
    <span class="s2">&quot;analogOutput&quot;</span><span class="p">,</span>
    <span class="n">taskName</span><span class="o">=</span><span class="s2">&quot;analogOutput&quot;</span><span class="p">,</span>
    <span class="n">taskMode</span><span class="o">=</span><span class="s2">&quot;continuous&quot;</span><span class="p">,</span>
    <span class="n">samplingRate</span><span class="o">=</span><span class="mi">800</span><span class="p">)</span>

<span class="c1"># select three channels.</span>
<span class="c1"># The channel description for an analog output</span>
<span class="c1"># channel description is: dev-name</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev4/ao0,-10,10;Dev4/ao1,-5,5;Dev4/ao2,-5,5&quot;</span><span class="p">)</span>

<span class="c1"># show the toolbox</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">showToolbox</span><span class="p">()</span>

<span class="c1"># The NI-DAQ device uses the &#39;samplesPerChannel&#39; in case of continuous</span>
<span class="c1"># tasks to define the internal buffer size. However if the number of</span>
<span class="c1"># samples, obtained by &#39;samplesPerChannel&#39; * noOfChannels is lower</span>
<span class="c1"># than the values in the following table, NI-DAQ uses the values from</span>
<span class="c1"># the table:</span>
<span class="c1">#</span>
<span class="c1"># no sampling rate:      10000 samples</span>
<span class="c1"># 0 - 100 samples / sec: 1 kS</span>
<span class="c1"># 101 - 10000 S/s:       10 kS</span>
<span class="c1"># 10001 - 1000000 S/s:   100 kS</span>
<span class="c1"># else:                  1 MS</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span>

<span class="c1"># if this value is -1, the NI-DAQ device will calculate the internal</span>
<span class="c1"># buffer size depending on the samplingRate and the parameter</span>
<span class="c1"># &#39;samplesPerChannel&#39;. Else, the internal buffer size can be overwritten</span>
<span class="c1"># by this parameter.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;bufferSize&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">randN</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">800</span><span class="p">],</span> <span class="s1">&#39;float64&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">setVal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;run </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/3: write for 3 sec&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; done&quot;</span><span class="p">)</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>demo_ao_single_value.py</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># coding=utf8</span>

<span class="sd">&quot;&quot;&quot;Finite analog output task for single value output.</span>

<span class="sd">Demo script for sending single values to different</span>
<span class="sd">channels of a National Instruments DAQ device.</span>

<span class="sd">To test this script, the NI MAX (Measurement &amp; Automation</span>
<span class="sd">Explorer) has been used to create simulated devices.</span>

<span class="sd">In this test, a simulated device NI PCIe-6323 with 4 analog output (AO)</span>
<span class="sd">ports was created and named &quot;Dev4&quot;.</span>

<span class="sd">Values are always written by a float64 dataObject, that is passed</span>
<span class="sd">as argument to the &#39;setVal&#39; method. This dataObject must be 2 dimensional</span>
<span class="sd">and the number of rows must be equal to the number of channels.</span>

<span class="sd">The number of samples that is written to each channel for each setVal</span>
<span class="sd">command is mainly determined by the &#39;samplesPerChannel&#39; argument.</span>

<span class="sd">For creating a single value write, &#39;samplesPerChannel&#39; must</span>
<span class="sd">be 1 such that an unbuffered single write operation is executed upon</span>
<span class="sd">each call of &#39;setVal&#39;. This operation does not allow a hardware based</span>
<span class="sd">start trigger.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># create the plugin instance</span>
<span class="n">plugin</span> <span class="o">=</span> <span class="n">dataIO</span><span class="p">(</span>
    <span class="s2">&quot;NI-DAQmx&quot;</span><span class="p">,</span>
    <span class="s2">&quot;analogOutput&quot;</span><span class="p">,</span>
    <span class="n">taskName</span><span class="o">=</span><span class="s2">&quot;analogOutput&quot;</span><span class="p">,</span>
    <span class="n">taskMode</span><span class="o">=</span><span class="s2">&quot;finite&quot;</span><span class="p">,</span>
    <span class="n">samplingRate</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

<span class="c1"># select three channels.</span>
<span class="c1"># The channel description for an analog output</span>
<span class="c1"># channel description is: dev-name,min-output-voltage,max-output-voltage</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev4/ao0,-10,10;Dev4/ao1,-5,5;Dev4/ao2,-5,5&quot;</span><span class="p">)</span>

<span class="c1"># show the toolbox</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">showToolbox</span><span class="p">()</span>

<span class="c1"># Single value writes requires a disabled start trigger (software trigger only)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;startTriggerMode&quot;</span><span class="p">,</span> <span class="s2">&quot;off&quot;</span><span class="p">)</span>

<span class="c1"># the number of samples per channel must be 1</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="c1"># generate a random object</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">randN</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span>


<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;run </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/2 ... &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">):</span>
        <span class="n">plugin</span><span class="o">.</span><span class="n">setVal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;done in </span><span class="si">%.2f</span><span class="s2"> s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>

    <span class="c1"># a finite task with more than one sample per channel</span>
    <span class="c1"># is automatically stopped at the end. It is not</span>
    <span class="c1"># necessary to call stop() again.</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">stopDevice</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="digital-input-tasks">
<h3><span class="section-number">4.5.9.3. </span>Digital Input Tasks<a class="headerlink" href="#digital-input-tasks" title="Link to this heading">#</a></h3>
<p><strong>demo_di_finite.py</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># coding=utf8</span>

<span class="sd">&quot;&quot;&quot;Finite digital input task.</span>

<span class="sd">Demo script for acquiring a finite set of digital</span>
<span class="sd">values with a National Instruments DAQ device.</span>

<span class="sd">To test this script, the NI MAX (Measurement &amp; Automation</span>
<span class="sd">Explorer) has been used to create simulated devices.</span>

<span class="sd">In this test, a simulated device NI PCI-6220 (Dev2) with 3x8 digital</span>
<span class="sd">inputs is used. These inputs are distributed over 3 ports</span>
<span class="sd">(ports0, ports1, ports2). Every port has 8 bit (line0-line7).</span>

<span class="sd">You can either record an entire port, such that the obtained</span>
<span class="sd">number is a bitmask of all lines in the port, or you record</span>
<span class="sd">selected lines only. Then, every line is acquired into a</span>
<span class="sd">different row of the obtained dataObject.</span>

<span class="sd">The channel configuration string for digital input tasks always</span>
<span class="sd">follows this pattern:</span>

<span class="sd">DeviceName/PortName</span>

<span class="sd">or</span>

<span class="sd">DeviceName/PortName/LineName</span>

<span class="sd">If an entire port is read, the data type is either uint8, uint16 or int32,</span>
<span class="sd">depending on the number of lines per port (usually uint8). If single lines</span>
<span class="sd">are read, each line is written to one row (usually to an uint8 dataObject, too).</span>

<span class="sd">Hint: It depends on the NI DAQ devices, if they allow</span>
<span class="sd">integrating different devices into the same measurement</span>
<span class="sd">task or not. Many devices do not allow this.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># create a new plugin instance, configured</span>
<span class="c1"># as finite digital input task with a freq. of 800 samples per second.</span>
<span class="n">plugin</span> <span class="o">=</span> <span class="n">dataIO</span><span class="p">(</span><span class="s2">&quot;NI-DAQmx&quot;</span><span class="p">,</span> <span class="s2">&quot;digitalInput&quot;</span><span class="p">,</span> <span class="n">taskName</span><span class="o">=</span><span class="s2">&quot;myDigitalInputTask&quot;</span><span class="p">,</span>
              <span class="n">taskMode</span><span class="o">=</span><span class="s2">&quot;finite&quot;</span><span class="p">,</span> <span class="n">samplingRate</span><span class="o">=</span><span class="mi">800</span><span class="p">)</span>

<span class="c1"># print a list of supported channels:</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Channels:&quot;</span><span class="p">,</span> <span class="n">plugin</span><span class="o">.</span><span class="n">getParam</span><span class="p">(</span><span class="s2">&quot;supportedChannels&quot;</span><span class="p">))</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev2/port0&quot;</span><span class="p">)</span>

<span class="c1"># number of finite samples: 800</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">800</span><span class="p">)</span>

<span class="c1"># this is the trigger source for the internal clock.</span>
<span class="c1"># In this case the PFI1 trigger input of Dev2 is used, however</span>
<span class="c1"># it would also be possible to use the &quot;OnboardClock&quot;. Only,</span>
<span class="c1"># the demo device NI PCI-6220 does not support the OnboardClock here.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;sampleClockSource&quot;</span><span class="p">,</span> <span class="s2">&quot;/Dev2/PFI1&quot;</span><span class="p">)</span>

<span class="c1"># configure the task in the device</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="c1"># acquire 5x 800 samples with 800 samples / second</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;acquire 5x800 samples...&quot;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;run </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/5...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="c1"># start the finite task</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">()</span>

    <span class="c1"># getVal waits for the finite task to be finished and reads out the values.</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">getVal</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;done in </span><span class="si">%.2f</span><span class="s2"> s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;datatype:&quot;</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">plot1</span><span class="p">(</span><span class="n">dataObject</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">properties</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;curveStyle&quot;</span><span class="p">:</span> <span class="s2">&quot;Steps&quot;</span><span class="p">})</span>


<span class="c1"># change some parameters on the fly...</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;sampleClockSource&quot;</span><span class="p">,</span> <span class="s2">&quot;PFI0&quot;</span><span class="p">)</span>

<span class="c1"># do not acquire an entire port, but single lines.</span>
<span class="c1"># this leads to an acquired dataObject whose row count is</span>
<span class="c1"># equal to the number of connected lines.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev2/port0/line6;Dev2/port0/line5;Dev2/port0/line1&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplingRate&quot;</span><span class="p">,</span> <span class="mi">1600</span><span class="p">)</span>

<span class="c1"># the device is still started (however due to the change of channels,</span>
<span class="c1"># it was internally stopped and restarted)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;acquire run </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/10...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">getVal</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; done&quot;</span><span class="p">)</span>

<span class="n">plot1</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

<span class="c1"># stops and terminates the task</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">stopDevice</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>demo_di_continuous.py</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># coding=utf8</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="sd">&quot;&quot;&quot;Continuous digital input task with optional logging (TDMS files).</span>

<span class="sd">Demo script for acquiring a continuous set of digital</span>
<span class="sd">values with a National Instruments DAQ device.</span>

<span class="sd">For understanding this demo, one is referred to the documentations</span>
<span class="sd">in the scripts demo_di_finite.py and demo_ai_continuous.py. Together, they are</span>
<span class="sd">very similar to this script.</span>

<span class="sd">Data from a continuous task can be obtained by regularly</span>
<span class="sd">calling getVal / copyVal or by enabling the TDMS file logging</span>
<span class="sd">technique.</span>

<span class="sd">If an entire port is read, the data type is either uint8, uint16 or int32,</span>
<span class="sd">depending on the number of lines per port (usually uint8). If single lines</span>
<span class="sd">are read, each line is written to one row (usually to an uint8 dataObject, too).</span>

<span class="sd">Reading TDMS files via Python is possible by the package npTDMS</span>
<span class="sd">(https://pypi.org/project/npTDMS).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">plugin</span> <span class="o">=</span> <span class="n">dataIO</span><span class="p">(</span>
    <span class="s2">&quot;NI-DAQmx&quot;</span><span class="p">,</span>
    <span class="s2">&quot;digitalInput&quot;</span><span class="p">,</span>
    <span class="n">taskName</span><span class="o">=</span><span class="s2">&quot;myDigitalInputTask&quot;</span><span class="p">,</span>
    <span class="n">taskMode</span><span class="o">=</span><span class="s2">&quot;continuous&quot;</span><span class="p">,</span>
    <span class="n">samplingRate</span><span class="o">=</span><span class="mi">800</span>
<span class="p">)</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">800</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev1/line0;Dev1/line1&quot;</span><span class="p">)</span>

<span class="c1"># configure the task</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="c1"># start the task</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="n">alldata</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">()</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">copyVal</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">alldata</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">stopDevice</span><span class="p">()</span>

<span class="n">plot1</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">alldata</span><span class="p">))</span>


<span class="c1"># 2. sub-demo: It is also possible to enable a logging of the task</span>
<span class="c1">#    into NIs own TDMS file format. Then, all values, which are acquired</span>
<span class="c1">#    during a running task will be written into the TDMS file. It is</span>
<span class="c1">#    also possible to get the values to python during logging (depending</span>
<span class="c1">#    on the configuration). However, it is not necessary to continuously</span>
<span class="c1">#    getVal/copyVal values in order to not raise a timeout / insufficient</span>
<span class="c1">#    buffer size error.</span>
<span class="c1">#</span>
<span class="c1">#    The logging is enabled via the parameters &#39;loggingMode&#39;,</span>
<span class="c1">#    &#39;loggingFilePath&#39;, &#39;loggingGroupName&#39; and &#39;loggingOperation&#39;:</span>
<span class="c1">#</span>
<span class="c1">#    loggingMode: 0 -&gt; disable logging</span>
<span class="c1">#                 1 -&gt; enable fast mode logging</span>
<span class="c1">#                      (no simultaneous read via getVal/copyVal allowed),</span>
<span class="c1">#                 2 -&gt; standard logging enabled (getVal/copyVal is possible,</span>
<span class="c1">#                      however data will only streamed to file if it has been</span>
<span class="c1">#                      obtained via getVal/copyVal).</span>
<span class="c1">#    filePath: path to output tdms file.</span>
<span class="c1">#    groupName: The name of the group to create within the TDMS file</span>
<span class="c1">#    operation (optional, default: createOrReplace):</span>
<span class="c1">#                 open: an existing tdms file is opened and new data is appended</span>
<span class="c1">#                       Raises an exception during task start if the file</span>
<span class="c1">#                       does not exist.</span>
<span class="c1">#                 openOrCreate: data is appended to an existing file or a new</span>
<span class="c1">#                       file is created.</span>
<span class="c1">#                 createOrReplace: always create a new file. An existing one</span>
<span class="c1">#                       will be deleted first.</span>
<span class="c1">#                 create: create a new file and raises an exception if it</span>
<span class="c1">#                       already exists.</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;loggingMode&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;loggingFilePath&quot;</span><span class="p">,</span> <span class="s2">&quot;D:/temp/demo_di_continuous.tdms&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;loggingOperation&quot;</span><span class="p">,</span> <span class="s2">&quot;createOrReplace&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;loggingGroupName&quot;</span><span class="p">,</span> <span class="s2">&quot;group1&quot;</span><span class="p">)</span>

<span class="c1"># create and configure the task</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="c1"># start the continuous task again</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

<span class="c1"># wait for 5 seconds (data are acquired and stored into the file)</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># stop the task</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

<span class="c1"># stop the device (if there are still running \</span>
<span class="c1"># tasks, they will also be stopped here)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">stopDevice</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>demo_di_single_value.py</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># coding=utf8</span>

<span class="sd">&quot;&quot;&quot;Finite digital input task for single value input.</span>

<span class="sd">Demo script for acquiring exactly one digital value</span>
<span class="sd">per channel per acquire() command</span>
<span class="sd">with a National Instruments DAQ device.</span>

<span class="sd">To test this script, the NI MAX (Measurement &amp; Automation</span>
<span class="sd">Explorer) has been used to create simulated devices.</span>

<span class="sd">In this test, a simulated device NI PCIe-6321 with 3x8 digital input (DI)</span>
<span class="sd">ports was created and named &quot;Dev1&quot;.</span>

<span class="sd">At the end of this demo, &quot;Dev5&quot; (NI PCI-6520) with 1 digital input</span>
<span class="sd">port (port 0) and 1 digital output port (port 1) 0 is used. This device</span>
<span class="sd">is very simple and only supports on demand inputs. In this case, this</span>
<span class="sd">is a single value acquisition with a software trigger.</span>

<span class="sd">The channel configuration string for digital input tasks always</span>
<span class="sd">follows this pattern:</span>

<span class="sd">DeviceName/PortName</span>

<span class="sd">or</span>

<span class="sd">DeviceName/PortName/LineName</span>

<span class="sd">Hint: It depends on the NI DAQ devices, if they allow</span>
<span class="sd">integrating different devices into the same measurement</span>
<span class="sd">task or not. Many devices do not allow this.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># Demo 1: Analog input task, finite acquisition</span>
<span class="c1"># the sampling rate is unimportant</span>
<span class="n">plugin</span> <span class="o">=</span> <span class="n">dataIO</span><span class="p">(</span>
    <span class="s2">&quot;NI-DAQmx&quot;</span><span class="p">,</span>
    <span class="s2">&quot;digitalInput&quot;</span><span class="p">,</span>
    <span class="n">taskName</span><span class="o">=</span><span class="s2">&quot;myTaskName&quot;</span><span class="p">,</span>
    <span class="n">taskMode</span><span class="o">=</span><span class="s2">&quot;finite&quot;</span>
<span class="p">)</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">showToolbox</span><span class="p">()</span>

<span class="c1"># A total number of 1 samples should be acquired from each port</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Configure the channels (semicolon-separated list of single channel config strings):</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev1/port0;Dev1/port1&quot;</span><span class="p">)</span>

<span class="c1"># If single values are acquired (samplesPerChannel=1), the start</span>
<span class="c1"># trigger must be off, since this acquisition on demand only operates</span>
<span class="c1"># upon a software trigger.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;startTriggerMode&quot;</span><span class="p">,</span> <span class="s2">&quot;off&quot;</span><span class="p">)</span>


<span class="c1"># after having configured the task, start the device.</span>
<span class="c1"># The task is then configured in the device. It will be</span>
<span class="c1"># started with plugin.acquire() later.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">500</span><span class="p">],</span> <span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="c1"># repeat the configured acquisition task 5x.</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">500</span><span class="p">):</span>
    <span class="c1"># start the acquisition of the given number of samples per channel.</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
    <span class="n">d</span><span class="o">=</span><span class="n">dataObject</span><span class="p">()</span>
    <span class="c1"># getVal will return if all samples have been acquired (or timeout)</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">copyVal</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>

<span class="c1"># plot the acquired values from both channels from the last run.</span>
<span class="c1"># the output dataObject already contains the correct axes units,</span>
<span class="c1"># descriptions etc...</span>
<span class="n">plot1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span>
      <span class="n">properties</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;legendPosition&quot;</span><span class="p">:</span> <span class="s2">&quot;Right&quot;</span><span class="p">,</span> <span class="s2">&quot;legendTitles&quot;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;DI0&quot;</span><span class="p">,</span> <span class="s2">&quot;DI2&quot;</span><span class="p">)})</span>

<span class="c1"># stop and remove the configured task</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">stopDevice</span><span class="p">()</span>


<span class="c1"># Switch now to the simple device Dev5 and acquire 8 lines from port0</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev5/port0&quot;</span><span class="p">)</span>

<span class="c1"># number of finite samples: 1</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># configure the task in the device</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="c1"># acquire 500 x 1 samples</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;acquire 500x 1 sample from Dev5/port0...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">):</span>
    <span class="c1"># start the finite task</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">()</span>

    <span class="c1"># getVal waits for the finite task to be finished and reads out the values.</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">copyVal</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot; done in </span><span class="si">%.2f</span><span class="s2"> sec&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>

<span class="n">plot1</span><span class="p">(</span><span class="n">dataObject</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">properties</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;curveStyle&quot;</span><span class="p">:</span> <span class="s2">&quot;Steps&quot;</span><span class="p">})</span>

<span class="c1"># Switch now to the simple device Dev5 and acquire lines 3 and 6 from port 0</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev5/port0/line3;Dev5/port0/line6&quot;</span><span class="p">)</span>

<span class="c1"># number of finite samples: 1</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># configure the task in the device</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="c1"># acquire 500 x 1 samples</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;acquire 500x 1 sample from Dev5/port0/line3 and line6...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">):</span>
    <span class="c1"># start the finite task</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">()</span>

    <span class="c1"># getVal waits for the finite task to be finished and reads out the values.</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">copyVal</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot; done in </span><span class="si">%.2f</span><span class="s2"> sec&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>

<span class="n">plot1</span><span class="p">(</span><span class="n">dataObject</span><span class="o">.</span><span class="n">dstack</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">properties</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;curveStyle&quot;</span><span class="p">:</span> <span class="s2">&quot;Steps&quot;</span><span class="p">})</span>
</pre></div>
</div>
</section>
<section id="digital-output-tasks">
<h3><span class="section-number">4.5.9.4. </span>Digital Output Tasks<a class="headerlink" href="#digital-output-tasks" title="Link to this heading">#</a></h3>
<p><strong>demo_do_finite.py</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># coding=utf8</span>

<span class="sd">&quot;&quot;&quot;Finite digital output task.</span>

<span class="sd">Demo script for sending a series of number to different</span>
<span class="sd">channels of a National Instruments DAQ device.</span>

<span class="sd">To test this script, the NI MAX (Measurement &amp; Automation</span>
<span class="sd">Explorer) has been used to create simulated devices.</span>

<span class="sd">In this test, a simulated device NI PCIe-6323 with 1 digital port (DO)</span>
<span class="sd">ports was created and named &quot;Dev4&quot;.</span>

<span class="sd">Values are always written by a uint8, uint16 or int32 dataObject, that is passed</span>
<span class="sd">as argument to the &#39;setVal&#39; method. This dataObject must be 2-dimensional</span>
<span class="sd">and the number of rows must be equal to the number of channels. The int32</span>
<span class="sd">object is internally casted to uint32 (however int32 is no valid dataObject</span>
<span class="sd">data type). The datatype itself depends on the number of lines of each</span>
<span class="sd">selected port. If the port has 0-8 lines, uint8 is required, for 9-16 lines</span>
<span class="sd">uint16, else int32 (usually uint8).</span>

<span class="sd">The number of samples that are written to each channel for each setVal</span>
<span class="sd">command is mainly determined by the &#39;samplesPerChannel&#39; argument.</span>

<span class="sd">There are two cases to handle:</span>

<span class="sd">1. If the dataObject has one column OR &#39;samplesPerChannel&#39; is equal</span>
<span class="sd">   to 1, an unbuffered, single write operation is executed. This</span>
<span class="sd">   operation does not allow a hardware based start trigger.</span>

<span class="sd">2. If the dataObject has more than one column, a buffered write</span>
<span class="sd">   operation is executed and any start trigger source is possible).</span>
<span class="sd">   If &#39;samplesPerChannel&#39; is &lt;= number of columns, the first columns</span>
<span class="sd">   will be send, until &#39;samplesPerChannel&#39; samples have been sent to</span>
<span class="sd">   each channel. If its value is bigger than the number of columns,</span>
<span class="sd">   the dataObject will be repeated until the desired number of samples</span>
<span class="sd">   have been sent.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># create the plugin instance</span>
<span class="n">plugin</span> <span class="o">=</span> <span class="n">dataIO</span><span class="p">(</span>
    <span class="s2">&quot;NI-DAQmx&quot;</span><span class="p">,</span>
    <span class="s2">&quot;digitalOutput&quot;</span><span class="p">,</span>
    <span class="n">taskName</span><span class="o">=</span><span class="s2">&quot;digitalOutput&quot;</span><span class="p">,</span>
    <span class="n">taskMode</span><span class="o">=</span><span class="s2">&quot;finite&quot;</span><span class="p">,</span>
    <span class="n">samplingRate</span><span class="o">=</span><span class="mi">800</span><span class="p">)</span>

<span class="c1"># Select port0 (32 lines from Dev4)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev4/port0&quot;</span><span class="p">)</span>

<span class="c1"># show the toolbox</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">showToolbox</span><span class="p">()</span>


<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;startTriggerMode&quot;</span><span class="p">,</span> <span class="s2">&quot;off&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;setValWaitForFinish&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="c1"># Example 1: Non-blocking setVal command</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">randN</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="s1">&#39;int32&#39;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setVal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="k">while</span><span class="p">(</span><span class="n">plugin</span><span class="o">.</span><span class="n">getParam</span><span class="p">(</span><span class="s2">&quot;taskStarted&quot;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Example 1:done&quot;</span><span class="p">)</span>

<span class="c1"># Example 2: blocking setVal command</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;setValWaitForFinish&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">randN</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span> <span class="s1">&#39;int32&#39;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setVal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Example 2: done&quot;</span><span class="p">)</span>

<span class="c1"># Example 3: single value setVal</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;setValWaitForFinish&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">randN</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">setVal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Example 3: done&quot;</span><span class="p">)</span>

<span class="c1"># Example 4: single line output</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev4/port0/line0&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;setValWaitForFinish&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">randN</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">],</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setVal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Example 4: done&quot;</span><span class="p">)</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">stopDevice</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>demo_do_continuous.py</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># coding=utf8</span>

<span class="sd">&quot;&quot;&quot;Continuous digital output task.</span>

<span class="sd">Demo script for sending a series of number to different</span>
<span class="sd">channels of a National Instruments DAQ device.</span>

<span class="sd">To test this script, the NI MAX (Measurement &amp; Automation</span>
<span class="sd">Explorer) has been used to create simulated devices.</span>

<span class="sd">In this test, a simulated device NI PCIe-6323 (Dev4) with 1 digital output</span>
<span class="sd">port (DO) with 32 lines (buffered) and two other ports (port 1 and port 2), that</span>
<span class="sd">support only unbuffered outputs.</span>

<span class="sd">Values are always written by a uint8, uint16 or int32 dataObject, that is passed</span>
<span class="sd">as argument to the &#39;setVal&#39; method. This dataObject must be 2-dimensional</span>
<span class="sd">and the number of rows must be equal to the number of channels. The int32</span>
<span class="sd">object is internally casted to uint32 (however int32 is no valid dataObject</span>
<span class="sd">data type). The datatype itself depends on the number of lines of each</span>
<span class="sd">selected port. If the port has 0-8 lines, uint8 is required, for 9-16 lines</span>
<span class="sd">uint16, else int32.</span>

<span class="sd">The number of samples that is written to each channel for each setVal</span>
<span class="sd">command is mainly determined by the &#39;samplesPerChannel&#39; argument.</span>

<span class="sd">There are two cases to handle:</span>

<span class="sd">1. If the dataObject has one column OR &#39;samplesPerChannel&#39; is equal</span>
<span class="sd">   to 1, an unbuffered, single write operation is executed. This</span>
<span class="sd">   operation does not allow a hardware based start trigger.</span>

<span class="sd">2. If the dataObject has more than one column, a buffered write</span>
<span class="sd">   operation is executed and any start trigger source is possible).</span>
<span class="sd">   If &#39;samplesPerChannel&#39; is &lt;= number of columns, the first columns</span>
<span class="sd">   will be send, until &#39;samplesPerChannel&#39; samples have been sent to</span>
<span class="sd">   each channel. If its value is bigger than the number of columns,</span>
<span class="sd">   the dataObject will be repeated until the desired number of samples</span>
<span class="sd">   have been sent.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># create the plugin instance</span>
<span class="n">plugin</span> <span class="o">=</span> <span class="n">dataIO</span><span class="p">(</span>
    <span class="s2">&quot;NI-DAQmx&quot;</span><span class="p">,</span>
    <span class="s2">&quot;digitalOutput&quot;</span><span class="p">,</span>
    <span class="n">taskName</span><span class="o">=</span><span class="s2">&quot;digitalOutput&quot;</span><span class="p">,</span>
    <span class="n">taskMode</span><span class="o">=</span><span class="s2">&quot;continuous&quot;</span><span class="p">,</span>
    <span class="n">samplingRate</span><span class="o">=</span><span class="mi">800</span><span class="p">)</span>

<span class="c1"># select port 0 (32 lines) from Dev4.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev4/port0&quot;</span><span class="p">)</span>

<span class="c1"># show the toolbox</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">showToolbox</span><span class="p">()</span>

<span class="c1"># The NI-DAQ device uses the &#39;samplesPerChannel&#39; in case of continuous</span>
<span class="c1"># tasks to define the internal buffer size. However if the number of</span>
<span class="c1"># samples, obtained by &#39;samplesPerChannel&#39; * noOfChannels is lower</span>
<span class="c1"># than the values in the following table, NI-DAQ uses the values from</span>
<span class="c1"># the table:</span>
<span class="c1">#</span>
<span class="c1"># no sampling rate:      10000 samples</span>
<span class="c1"># 0 - 100 samples / sec: 1 kS</span>
<span class="c1"># 101 - 10000 S/s:       10 kS</span>
<span class="c1"># 10001 - 1000000 S/s:   100 kS</span>
<span class="c1"># else:                  1 MS</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span>

<span class="c1"># if this value is -1, the NI-DAQ device will calculate the internal</span>
<span class="c1"># buffer size depending on the samplingRate and the parameter</span>
<span class="c1"># &#39;samplesPerChannel&#39;. Else, the internal buffer size can be overwritten</span>
<span class="c1"># by this parameter.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;bufferSize&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">randN</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">],</span> <span class="s1">&#39;int32&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">plugin</span><span class="o">.</span><span class="n">setVal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Run </span><span class="si">{</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/2, iteration </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/3: write for 3 sec &quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; done&quot;</span><span class="p">)</span>
        <span class="n">plugin</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>demo_do_single_value.py</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># coding=utf8</span>

<span class="sd">&quot;&quot;&quot;Finite digital output task for software triggered single value output.</span>

<span class="sd">Demo script for writing exactly one digital value</span>
<span class="sd">per channel per setVal() command</span>
<span class="sd">with a National Instruments DAQ device.</span>

<span class="sd">To test this script, the NI MAX (Measurement &amp; Automation</span>
<span class="sd">Explorer) has been used to create simulated devices.</span>

<span class="sd">In this test, a simulated device NI PCIe-6321 with 3x8 digital output (DO)</span>
<span class="sd">ports was created and named &quot;Dev1&quot;.</span>

<span class="sd">At the end of this demo, &quot;Dev5&quot; (NI PCI-6520) with 1 digital input</span>
<span class="sd">port (port 0) and 1 digital output port (port 1) 0 is used. This device</span>
<span class="sd">is very simple and only supports on demand inputs. In this case, this</span>
<span class="sd">is a single value acquisition with a software trigger.</span>

<span class="sd">The channel configuration string for digital input tasks always</span>
<span class="sd">follows this pattern:</span>

<span class="sd">DeviceName/PortName</span>

<span class="sd">or</span>

<span class="sd">DeviceName/PortName/LineName</span>

<span class="sd">Hint: It depends on the NI DAQ devices, if they allow</span>
<span class="sd">integrating different devices into the same measurement</span>
<span class="sd">task or not. Many devices do not allow this.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># Demo 1: Analog input task, finite acquisition</span>
<span class="c1"># the sampling rate is unimportant</span>
<span class="n">plugin</span> <span class="o">=</span> <span class="n">dataIO</span><span class="p">(</span>
    <span class="s2">&quot;NI-DAQmx&quot;</span><span class="p">,</span>
    <span class="s2">&quot;digitalOutput&quot;</span><span class="p">,</span>
    <span class="n">taskName</span><span class="o">=</span><span class="s2">&quot;myTaskName&quot;</span><span class="p">,</span>
    <span class="n">taskMode</span><span class="o">=</span><span class="s2">&quot;finite&quot;</span>
<span class="p">)</span>

<span class="n">plugin</span><span class="o">.</span><span class="n">showToolbox</span><span class="p">()</span>

<span class="c1"># A total number of 1 samples should be acquired from each port</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Configure the channels (semicolon-separated list of single channel config strings):</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev1/port0;Dev1/port1&quot;</span><span class="p">)</span>

<span class="c1"># If single values are acquired (samplesPerChannel=1), the start</span>
<span class="c1"># trigger must be off, since this acquisition on demand only operates</span>
<span class="c1"># upon a software trigger.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;startTriggerMode&quot;</span><span class="p">,</span> <span class="s2">&quot;off&quot;</span><span class="p">)</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;setValWaitForFinish&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="c1"># after having configured the task, start the device.</span>
<span class="c1"># The task is then configured in the device. It will be</span>
<span class="c1"># started with plugin.acquire() later.</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">randN</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="c1"># repeat the configured acquisition task 5x.</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">500</span><span class="p">):</span>
    <span class="c1"># start the single value output</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">setVal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Write 500 values to two ports in </span><span class="si">%.2f</span><span class="s2"> s&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>


<span class="c1"># stop and remove the configured task</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">stopDevice</span><span class="p">()</span>


<span class="c1"># Switch now to the simple device Dev5 and write 8 lines to port1</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev5/port1&quot;</span><span class="p">)</span>

<span class="c1"># number of finite samples: 1</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># configure the task in the device</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="c1"># write 500 x 1 samples</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">randN</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;write 500 x 1 sample to Dev5/port1...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">):</span>
    <span class="c1"># start the finite task</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">setVal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="c1"># single value write task is always automatically stopped</span>
    <span class="c1"># after setVal.</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot; done in </span><span class="si">%.2f</span><span class="s2"> sec&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>


<span class="c1"># Switch now to the simple device Dev5 and write to lines 3 and 6 from port 1</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;channels&quot;</span><span class="p">,</span> <span class="s2">&quot;Dev5/port1/line3;Dev5/port1/line6&quot;</span><span class="p">)</span>

<span class="c1"># number of finite samples: 1</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">setParam</span><span class="p">(</span><span class="s2">&quot;samplesPerChannel&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># configure the task in the device</span>
<span class="n">plugin</span><span class="o">.</span><span class="n">startDevice</span><span class="p">()</span>

<span class="c1"># write 500 x 1 samples</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">randN</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;write 500 x 1 sample to Dev5/port1/line3 and line6...&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">):</span>
    <span class="c1"># start the finite task</span>
    <span class="n">plugin</span><span class="o">.</span><span class="n">setVal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot; done in </span><span class="si">%.2f</span><span class="s2"> sec&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">))</span>
</pre></div>
</div>
</section>
</section>
<section id="known-issues">
<h2><span class="section-number">4.5.10. </span>Known Issues<a class="headerlink" href="#known-issues" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>Counter tasks are not implemented yet.</p></li>
<li><p>The development has only been tested based on simulated NI I/O devices. Therefore hardware-based start
and reference triggers, as well as clock sources could not fully be tested, since they are all
emulated as software triggers.</p></li>
</ul>
</section>
<section id="changelog">
<h2><span class="section-number">4.5.11. </span>Changelog<a class="headerlink" href="#changelog" title="Link to this heading">#</a></h2>
<ul class="simple">
<li><p>itom setup 3.1.0: This plugin has been compiled using the NI-DAQmx 18.1.0 (Linux)</p></li>
<li><p>itom setup 3.1.0: This plugin has been compiled using the NI-DAQmx 18.6.0 (Windows)</p></li>
<li><p>itom setup 4.0.0: Complete renewed plugin implementation. This plugin is incompatible to earlier version of
this plugin and provides much more features. It has been compiled using NI-DAQmx 19.6.0 (Windows)</p></li>
<li><p>itom setup 4.1.0: This plugin has been compiled using the NI-DAQmx 19.6.0 (Windows)</p></li>
<li><p>itom setup 4.3.0: This plugin has been compiled using the NI-DAQmx 2024 Q1 (Windows)</p></li>
</ul>
</section>
</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="ThorlabsKCubePA.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">4.4. </span>Thorlabs KCube Position Aligner</p>
      </div>
    </a>
    <a class="right-next"
       href="thorlabsPowerMeter.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">4.6. </span>Thorlabs Power Meter</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#overview">4.5.1. Overview</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#driver-installation">4.5.2. Driver Installation</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#windows">4.5.2.1. Windows</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#linux">4.5.2.2. Linux</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#initialization">4.5.3. Initialization</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#parameters">4.5.4. Parameters</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#usage">4.5.5. Usage</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#channels">4.5.5.1. Channels</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#data-types">4.5.5.2. Data Types</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#general">4.5.5.3. General</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reference-trigger">4.5.5.4. Reference Trigger</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tdms-logging">4.5.6. TDMS Logging</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#configuration-dialog-and-toolbox">4.5.7. Configuration Dialog and Toolbox</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#compilation">4.5.8. Compilation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#examples">4.5.9. Examples</a><ul class="visible nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#analog-input-tasks">4.5.9.1. Analog Input Tasks</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#analog-output-tasks">4.5.9.2. Analog Output Tasks</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#digital-input-tasks">4.5.9.3. Digital Input Tasks</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#digital-output-tasks">4.5.9.4. Digital Output Tasks</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#known-issues">4.5.10. Known Issues</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#changelog">4.5.11. Changelog</a></li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item">

  <div class="tocsection sourcelink">
    <a href="../../_sources/plugins/ad-converters/niDAQmx.rst.txt">
      <i class="fa-solid fa-file-lines"></i> Show Source
    </a>
  </div>
</div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2011-2024, Institut für Technische Optik (ITO), University Stuttgart. Bug report: https://github.com/itom-project/plugins/issues.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.0.2.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.4.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>