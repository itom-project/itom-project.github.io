<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>OpenCV Filters &mdash; itom</title>
    
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="itom" href="../../index.html" />
    <link rel="up" title="Plugins" href="../../plugins.html" />
    <link rel="next" title="PclTools" href="pclTools.html" />
    <link rel="prev" title="Fitting Filters" href="fittingFilters.html" />
 


  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="pclTools.html" title="PclTools"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="fittingFilters.html" title="Fitting Filters"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">itom</a> &raquo;</li>
          <li><a href="../../plugins.html" accesskey="U">Plugins</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/itomlogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../download.html">Downloads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../documentation.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../media.html">Media</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../features.html">Features</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../plugins.html">Plugins</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../plugins.html#add-a-plugin-to-itom">Add a plugin to itom</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../plugins.html#available-plugins">Available plugins</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../plugins.html#cameras-grabbers-ad-converter">Cameras / Grabbers / AD-Converter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../plugins.html#motors-actuators">Motors / Actuators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../plugins.html#further-hardware-devices">Further hardware devices</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../../plugins.html#algorithms">Algorithms</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="basicFilters.html">Basic Filters</a></li>
<li class="toctree-l4"><a class="reference internal" href="dataObjectArithmetic.html">DataObject Arithmetic</a></li>
<li class="toctree-l4"><a class="reference internal" href="dataObjectIO.html">DataObjectIO</a></li>
<li class="toctree-l4"><a class="reference internal" href="fittingFilters.html">Fitting Filters</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="">OpenCV Filters</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l5"><a class="reference internal" href="#filters">Filters</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="pclTools.html">PclTools</a></li>
<li class="toctree-l4"><a class="reference internal" href="x3p.html">X3P Input Output</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../plugins.html#plugin-development">Plugin Development</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../screenshots.html">Screenshots</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="fittingFilters.html"
                        title="previous chapter">Fitting Filters</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pclTools.html"
                        title="next chapter">PclTools</a></p>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="opencv-filters">
<h1>OpenCV Filters<a class="headerlink" href="#opencv-filters" title="Permalink to this headline">¶</a></h1>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="87%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Summary</strong>:</td>
<td><span>Wrapped algorithms from OpenCV</span></td>
</tr>
<tr class="row-even"><td><strong>Type</strong>:</td>
<td><span>Algorithm</span></td>
</tr>
<tr class="row-odd"><td><strong>License</strong>:</td>
<td><span>LGPL</span></td>
</tr>
<tr class="row-even"><td><strong>Platforms</strong>:</td>
<td>Windows, Linux</td>
</tr>
<tr class="row-odd"><td><strong>Author</strong>:</td>
<td><span>W. Lyda, M. Gronle, ITO, University Stuttgart</span></td>
</tr>
</tbody>
</table>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>This plugin provides wrappers for various OpenCV algorithms. These are for instance:</p>
<ul class="simple">
<li>morphological filters (dilation, erosion)</li>
<li>image filtering (blur, median blur...)</li>
<li>1d and 2d fft and ifft</li>
<li>histogram determination</li>
<li>feature detections (circles, chessboard corners...)</li>
</ul>
<p>This plugin not only requires access to the core library of OpenCV but also to further libraries like imgproc and calib3d.</p>
<p>These filters are defined in the plugin:</p>
<ol class="arabic simple">
<li><a class="reference internal" href="#cvFFT2D" title="cvFFT2D"><tt class="xref pyitom pyitom-filt docutils literal"><span class="pre">cvFFT2D</span></tt></a></li>
<li><a class="reference internal" href="#cvFFT1D" title="cvFFT1D"><tt class="xref pyitom pyitom-filt docutils literal"><span class="pre">cvFFT1D</span></tt></a></li>
<li><a class="reference internal" href="#cvBlur" title="cvBlur"><tt class="xref pyitom pyitom-filt docutils literal"><span class="pre">cvBlur</span></tt></a></li>
<li><a class="reference internal" href="#cvRemoveSpikes" title="cvRemoveSpikes"><tt class="xref pyitom pyitom-filt docutils literal"><span class="pre">cvRemoveSpikes</span></tt></a></li>
<li><a class="reference internal" href="#cvFlipLeftRight" title="cvFlipLeftRight"><tt class="xref pyitom pyitom-filt docutils literal"><span class="pre">cvFlipLeftRight</span></tt></a></li>
<li><a class="reference internal" href="#cvIFFT2D" title="cvIFFT2D"><tt class="xref pyitom pyitom-filt docutils literal"><span class="pre">cvIFFT2D</span></tt></a></li>
<li><a class="reference internal" href="#cvFindChessboardCorners" title="cvFindChessboardCorners"><tt class="xref pyitom pyitom-filt docutils literal"><span class="pre">cvFindChessboardCorners</span></tt></a></li>
<li><a class="reference internal" href="#cvMedianBlur" title="cvMedianBlur"><tt class="xref pyitom pyitom-filt docutils literal"><span class="pre">cvMedianBlur</span></tt></a></li>
<li><a class="reference internal" href="#cvCornerSubPix" title="cvCornerSubPix"><tt class="xref pyitom pyitom-filt docutils literal"><span class="pre">cvCornerSubPix</span></tt></a></li>
<li><a class="reference internal" href="#cvFindCircles" title="cvFindCircles"><tt class="xref pyitom pyitom-filt docutils literal"><span class="pre">cvFindCircles</span></tt></a></li>
<li><a class="reference internal" href="#cvDilate" title="cvDilate"><tt class="xref pyitom pyitom-filt docutils literal"><span class="pre">cvDilate</span></tt></a></li>
<li><a class="reference internal" href="#cvErode" title="cvErode"><tt class="xref pyitom pyitom-filt docutils literal"><span class="pre">cvErode</span></tt></a></li>
<li><a class="reference internal" href="#cvFlipUpDown" title="cvFlipUpDown"><tt class="xref pyitom pyitom-filt docutils literal"><span class="pre">cvFlipUpDown</span></tt></a></li>
<li><a class="reference internal" href="#cvIFFT1D" title="cvIFFT1D"><tt class="xref pyitom pyitom-filt docutils literal"><span class="pre">cvIFFT1D</span></tt></a></li>
</ol>
</div>
<div class="section" id="filters">
<h2>Filters<a class="headerlink" href="#filters" title="Permalink to this headline">¶</a></h2>
<p>Detailed overview about all defined filters:</p>
<dl class="filter">
<dt id="cvFFT2D">
<em class="property">itom.filter</em><big>(</big><tt class="descname">&quot;cvFFT2D&quot;</tt><em class="property">,</em><em>sourceImage</em><big>)</big><a class="headerlink" href="#cvFFT2D" title="Permalink to this definition">¶</a></dt>
<dd><p>2D-dimentional fourier-transformation using cv::DFT.</p>
<p>This filter tries to perform an inplace FFT for a given 2D-dataObject. The FFT is calculated planewise.The result is a complex-dataObject. The axis-scales and units are invertes and modified.</p>
<p>This filter internally calls the ito::dObjHelper::calcCVDFT(dObjImages, false, false, false)-function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Mandatory parameters:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><strong>sourceImage</strong> (<em>dataObject</em>) &#8211; Input Object handle, must be a single plane</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="filter">
<dt id="cvFFT1D">
<em class="property">itom.filter</em><big>(</big><tt class="descname">&quot;cvFFT1D&quot;</tt><em class="property">,</em><em>sourceImage</em><big>)</big><a class="headerlink" href="#cvFFT1D" title="Permalink to this definition">¶</a></dt>
<dd><p>1D-dimentional fourier-transformation using cv::DFT.</p>
<p>This filter tries to perform an inplace FFT for a given line or 2D-dataObject. The FFT is calculated linewise.The result is a complex-dataObject. The axis-scales and units are invertes and modified.</p>
<p>This filter internally calls the ito::dObjHelper::calcCVDFT(dObjImages, false, false, true)-function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Mandatory parameters:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><strong>sourceImage</strong> (<em>dataObject</em>) &#8211; Input Object handle, must be a single plane</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="filter">
<dt id="cvBlur">
<em class="property">itom.filter</em><big>(</big><tt class="descname">&quot;cvBlur&quot;</tt><em class="property">,</em><em>sourceImage</em>, <em>destinationImage</em><span class="optional">[</span>, <em>kernelSizeX</em>, <em>kernelSizeY</em>, <em>anchor</em>, <em>borderType</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvBlur" title="Permalink to this definition">¶</a></dt>
<dd><p>Planewise median blur filter.</p>
<p>This filter applies the method cv::blur to every plane in the source data object. The function smoothes the images by a simple mean-filter. Theresult is contained in the destination object. It can handle data objects of type uint8, uint16, int16, ito::tInt32, float32 and float64 only.</p>
<p>The cv::blur interally calls the cv::boxfilter()-method.</p>
<p>The itom-wrapping does not work inplace currently. A new dataObject is allocated.</p>
<p>borderType: This string defines how the filter should hande pixels at the border of the matrix.Allowed is CONSTANT [default], REPLICATE, REFLECT, WRAP, REFLECT_101. In case of a constant border, only pixels inside of the element mask are considered (morphologyDefaultBorderValue)
Warning: NaN-handling for floats not verified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Mandatory parameters:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><ul class="first simple">
<li><strong>sourceImage</strong> (<em>dataObject</em>) &#8211; All types except complex64 and complex128 are accepted</li>
<li><strong>destinationImage</strong> (<em>dataObject</em>) &#8211; Empty object handle. Image will be of src-type</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional parameters:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><ul class="first last simple">
<li><strong>kernelSizeX</strong> (<em>int (int)</em>) &#8211; Kernelsize for x-axis</li>
<li><strong>kernelSizeY</strong> (<em>int (int)</em>) &#8211; Kernelsize for y-axis</li>
<li><strong>anchor</strong> (<em>dataObject</em>) &#8211; Position of the kernel anchor, see openCV-Help</li>
<li><strong>borderType</strong> (<em>str (char*)</em>) &#8211; border mode used to extrapolate pixels outside of the image</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="filter">
<dt id="cvRemoveSpikes">
<em class="property">itom.filter</em><big>(</big><tt class="descname">&quot;cvRemoveSpikes&quot;</tt><em class="property">,</em><em>sourceObject</em>, <em>destinationObject</em><span class="optional">[</span>, <em>kernelSize</em>, <em>lowestValue</em>, <em>highestValue</em>, <em>newValue</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvRemoveSpikes" title="Permalink to this definition">¶</a></dt>
<dd><p>Set single spikes at measurement edges to a new value.</p>
<p>This filter creates a binary mask for the input object. The value of mask(y,x) will be 1 if value of input(y,x) is within the specified range and is finite.The mask is eroded and than dilated by kernel size using openCV cv::erode and cv::dilate with a single iteration. In the last step the value of output(y,x) is set to newValue if mask(y,x) is 0.</p>
<p>It is allowed to let the filter work inplace if you give the same source and destination data object, else the destination data object is verified if it fits to the size and type of the source data object and if not a new one is allocated and the input data is copied to the new object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Mandatory parameters:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><ul class="first simple">
<li><strong>sourceObject</strong> (<em>dataObject</em>) &#8211; 32 or 64 bit floating point input image</li>
<li><strong>destinationObject</strong> (<em>dataObject</em>) &#8211; 32 or 64 bit floating point output image</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional parameters:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><ul class="first last simple">
<li><strong>kernelSize</strong> (<em>int (int)</em>) &#8211; N defines the N x N kernel</li>
<li><strong>lowestValue</strong> (<em>float (double)</em>) &#8211; Lowest value to consider as valid</li>
<li><strong>highestValue</strong> (<em>float (double)</em>) &#8211; Highest value to consider as valid</li>
<li><strong>newValue</strong> (<em>float (double)</em>) &#8211; Replacement value for spike elements</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="filter">
<dt id="cvFlipLeftRight">
<em class="property">itom.filter</em><big>(</big><tt class="descname">&quot;cvFlipLeftRight&quot;</tt><em class="property">,</em><em>scrImage</em>, <em>destImage</em><big>)</big><a class="headerlink" href="#cvFlipLeftRight" title="Permalink to this definition">¶</a></dt>
<dd><p>This filter flips the image left to right.</p>
<p>This filter applies the flip method cvFlip of OpenCV with the flipCode &gt; 0 to a 2D source data object. The result is contained in the destination object</p>
<p>It is allowed to let the filter work inplace if you give the same input than destination data object, else the output data object is verified if it fits to the size and type of the source data object and if not a new one is allocated
.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Mandatory parameters:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><ul class="first last simple">
<li><strong>scrImage</strong> (<em>dataObject</em>) &#8211; Input image</li>
<li><strong>destImage</strong> (<em>dataObject</em>) &#8211; Output image</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="filter">
<dt id="cvIFFT2D">
<em class="property">itom.filter</em><big>(</big><tt class="descname">&quot;cvIFFT2D&quot;</tt><em class="property">,</em><em>sourceImage</em><big>)</big><a class="headerlink" href="#cvIFFT2D" title="Permalink to this definition">¶</a></dt>
<dd><p>2D-dimentional inverse fourier-transformation using cv::DFT.</p>
<p>This filter tries to perform an inplace FFT for a given 2D-dataObject. The FFT is calculated planewise.The result is a real-dataObject. The axis-scales and units are invertes and modified.</p>
<p>This filter internally calls the ito::dObjHelper::calcCVDFT(dObjImages, true, true, false)-function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Mandatory parameters:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><strong>sourceImage</strong> (<em>dataObject</em>) &#8211; Input Object handle, must be a single plane</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="filter">
<dt id="cvFindChessboardCorners">
<em class="property">itom.filter</em><big>(</big><tt class="descname">&quot;cvFindChessboardCorners&quot;</tt><em class="property">,</em><em>dataObject</em>, <em>pointsPerRow</em>, <em>pointsPerColumn</em>, <em>corners</em><span class="optional">[</span>, <em>flags</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvFindChessboardCorners" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the positions of internal corners of the chessboard.</p>
<p>This filter is a wrapper for the cv::method cv::findChessboardCorners.
The openCV-function attempts to determine whether the input image is a view of the chessboard pattern and locate the internal chessboard corners. The function returns a non-zero value if all of the corners are found and they are placed in a certain order (row by row, left to right in every row). Otherwise, if the function fails to find all the corners or reorder them, it returns 0. For example, a regular chessboard has 8 x 8 squares and 7 x 7 internal corners, that is, points where the black squares touch each other. The detected coordinates are approximate, and to determine their positions more accurately, the function calls cornerSubPix().</p>
<p>Remark 1: This function gives only a rough estimation of the positions. For a higher resolutions, you should usethe function cornerSubPix() with different parameters if returned coordinates are not accurate enough.This function is wrapped to itom by the filter &#8216;cvCornerSubPix&#8217;.</p>
<p>Remark 2: The outer frame of the dataObject / the image should not be white but have approximately the same gray value than the bright field.</p>
<p>Remark 3: The bright fields should be free of darker dirt or dust and you should apply a corse shading correction to improve the results.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Mandatory parameters:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><ul class="first simple">
<li><strong>dataObject</strong> (<em>dataObject</em>) &#8211; 8bit grayscale input image</li>
<li><strong>pointsPerRow</strong> (<em>int (int)</em>) &#8211; number of inner corners per chessboard row</li>
<li><strong>pointsPerColumn</strong> (<em>int (int)</em>) &#8211; number of inner corners per chessboard column</li>
<li><strong>corners</strong> (<em>dataObject</em>) &#8211; output: float32-dataObject, [2 x n] with the coordinates of n detected corner points</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional parameters:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first"><strong>flags</strong> (<em>int (int)</em>) &#8211; additional flags (OR-combination), see openCV-docu</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>result</strong> (<em>int (int)</em>) &#8211; 0: detection failed, 1: detection has been successful</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="filter">
<dt id="cvMedianBlur">
<em class="property">itom.filter</em><big>(</big><tt class="descname">&quot;cvMedianBlur&quot;</tt><em class="property">,</em><em>sourceImage</em>, <em>destinationImage</em><span class="optional">[</span>, <em>kernelSize</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvMedianBlur" title="Permalink to this definition">¶</a></dt>
<dd><p>Planewise median blur filter.</p>
<p>The function smoothes an image using the median filter with the kernel-size x kernel-size aperture. Each channel of a multi-channel image is processed independently. It can handle data objects of type uint8, uint16, int16, ito::tInt32, float32 and float64 only.</p>
<p>The itom-wrapping does not work inplace currently. A new dataObject is allocated.</p>
<p>Warning: NaN-handling for floats not verified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Mandatory parameters:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><ul class="first simple">
<li><strong>sourceImage</strong> (<em>dataObject</em>) &#8211; Image of type Integer or float32</li>
<li><strong>destinationImage</strong> (<em>dataObject</em>) &#8211; Empty dataObject-hanlde. Destination is of source type</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional parameters:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last"><strong>kernelSize</strong> (<em>int (int)</em>) &#8211; Kernelsize in x/y</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="filter">
<dt id="cvCornerSubPix">
<em class="property">itom.filter</em><big>(</big><tt class="descname">&quot;cvCornerSubPix&quot;</tt><em class="property">,</em><em>image</em>, <em>corners</em>, <em>winSize</em><span class="optional">[</span>, <em>zeroZone</em>, <em>maxCount</em>, <em>epsilon</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvCornerSubPix" title="Permalink to this definition">¶</a></dt>
<dd><p>Refines the corner locations e.g. from cvFindChessboardCorners.</p>
<p>This filter is a wrapper for the cv::method cv::cornerSubPix. Check the openCV-doku for more details</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Mandatory parameters:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><ul class="first simple">
<li><strong>image</strong> (<em>dataObject</em>) &#8211; 8bit grayscale input image</li>
<li><strong>corners</strong> (<em>dataObject</em>) &#8211; initial coordinates of the input corners and refined coordinates provided for output</li>
<li><strong>winSize</strong> (<em>int seq. (int*)</em>) &#8211; Half of the side length of the search window. Example: (5,5) leads to a (11x11) search window</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional parameters:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><ul class="first last simple">
<li><strong>zeroZone</strong> (<em>int seq. (int*)</em>) &#8211; Half of the size of the dead region in the middle of the search zone over which the summation is not done. (-1,-1) indicates that there is no such a size</li>
<li><strong>maxCount</strong> (<em>int (int)</em>) &#8211; position refinement stops after this maximum number of iterations</li>
<li><strong>epsilon</strong> (<em>float (double)</em>) &#8211; position refinement stops when the corner position moves by less than this value</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="filter">
<dt id="cvFindCircles">
<em class="property">itom.filter</em><big>(</big><em>Image, Circles [,dp, Min Distance, threshold, accumulator threshold, Min Radius [px], Max Radius [px]]</em><big>)</big><a class="headerlink" href="#cvFindCircles" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds circles in a grayscale image using the Hough transform.</p>
<p>This filter is a wrapper for the openCV-function cv::HoughCircles.he function finds circles in a grayscale image using a modification of the Hough transform.Based on this filter, circles are identified and located.The result is dataObject with rows = (n-Circles) and cols = (x,y,r).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Mandatory parameters:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><ul class="first simple">
<li><strong>Image</strong> (<em>dataObject</em>) &#8211; Must be 8bit</li>
<li><strong>Circles</strong> (<em>dataObject</em>) &#8211; </li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional parameters:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><ul class="first last simple">
<li><strong>dp</strong> (<em>float (double)</em>) &#8211; dp: Inverse ratio of the accumulator resolution to the image resolution.</li>
<li><strong>Distance</strong> (<em>Min</em>) &#8211; Minimum center distance of the circles.</li>
<li><strong>threshold</strong> (<em>accumulator</em>) &#8211; The higher threshold of the two passed to the Canny() edge detector (the lower one is twice smaller).</li>
<li><strong>threshold</strong> &#8211; The accumulator threshold for the circle centers at the detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first.</li>
<li><strong>Radius [px]</strong> (<em>Max</em>) &#8211; Min Radius in x/y</li>
<li><strong>Radius [px]</strong> &#8211; Max Radius in x/y</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="filter">
<dt id="cvDilate">
<em class="property">itom.filter</em><big>(</big><tt class="descname">&quot;cvDilate&quot;</tt><em class="property">,</em><em>sourceObj</em>, <em>destinationObj</em><span class="optional">[</span>, <em>element</em>, <em>anchor</em>, <em>iterations</em>, <em>borderType</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvDilate" title="Permalink to this definition">¶</a></dt>
<dd><p>Dilates every plane of a data object by using a specific structuring element.</p>
<p>This filter applies the dialation method cvDilate of OpenCV to every plane in the source data object. The result is contained in the destination object. It can handle data objects of type uint8, uint16, int16, float32 and float64 only.</p>
<p>It is allowed to let the filter work inplace if you give the same input than destination data object, else the output data object is verified if it fits to the size and type of the source data object and if not a new one is allocated.</p>
<p>The dilation is executed using a structuring element which is (if not otherwise stated) a 3x3 kernel filled with ones. Else you can give an two-dimensional uint8 data object. Then, the function dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken:</p>
<p>dst(x,y) = max_{(x&#8217;,y&#8217;):element(x&#8217;,y&#8217;)!=0} src(x+x&#8217;,y+y&#8217;)</p>
<p>Dilation can be applied several times (parameter &#8216;iterations&#8217;).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Mandatory parameters:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><ul class="first simple">
<li><strong>sourceObj</strong> (<em>dataObject</em>) &#8211; input data object of type uint8, uint16, int16, float32, float64</li>
<li><strong>destinationObj</strong> (<em>dataObject</em>) &#8211; output image with the same type and size than input (inplace allowed)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional parameters:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><ul class="first last simple">
<li><strong>element</strong> (<em>dataObject</em>) &#8211; structuring element used for the morpholocial operation (default: None, a 3x3 rectangular structuring element is used). Else: An uint8 data object where values &gt; 0 are considered for the operation.</li>
<li><strong>anchor</strong> (<em>int seq. (int*)</em>) &#8211; position of the anchor within the element. If not given or if (-1,-1), the anchor is at the element center [default].</li>
<li><strong>iterations</strong> (<em>int (int)</em>) &#8211; number of times the morpholocial operation is applied [default: 1]</li>
<li><strong>borderType</strong> (<em>str (char*)</em>) &#8211; This string defines how the filter should hande pixels at the border of the matrix. Allowed is CONSTANT [default], REPLICATE, REFLECT, WRAP, REFLECT_101. In case of a constant border, only pixels inside of the element mask are considered (morphologyDefaultBorderValue)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="filter">
<dt id="cvErode">
<em class="property">itom.filter</em><big>(</big><tt class="descname">&quot;cvErode&quot;</tt><em class="property">,</em><em>sourceObj</em>, <em>destinationObj</em><span class="optional">[</span>, <em>element</em>, <em>anchor</em>, <em>iterations</em>, <em>borderType</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#cvErode" title="Permalink to this definition">¶</a></dt>
<dd><p>Erodes every plane of a data object by using a specific structuring element.</p>
<p>This filter applies the erosion method cvErode of OpenCV to every plane in the source data object. The result is contained in the destination object. It can handle data objects of type uint8, uint16, int16, float32 and float64 only.</p>
<p>It is allowed to let the filter work inplace if you give the same input than destination data object, else the output data object is verified if it fits to the size and type of the source data object and if not a new one is allocated.</p>
<p>The erosion is executed using a structuring element which is (if not otherwise stated) a 3x3 kernel filled with ones. Else you can give an two-dimensional uint8 data object. Then, the function dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken:</p>
<p>dst(x,y) = min_{(x&#8217;,y&#8217;):element(x&#8217;,y&#8217;)!=0} src(x+x&#8217;,y+y&#8217;)</p>
<p>Erosion can be applied several times (parameter &#8216;iterations&#8217;).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Mandatory parameters:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><ul class="first simple">
<li><strong>sourceObj</strong> (<em>dataObject</em>) &#8211; input data object of type uint8, uint16, int16, float32, float64</li>
<li><strong>destinationObj</strong> (<em>dataObject</em>) &#8211; output image with the same type and size than input (inplace allowed)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Optional parameters:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><ul class="first last simple">
<li><strong>element</strong> (<em>dataObject</em>) &#8211; structuring element used for the morpholocial operation (default: None, a 3x3 rectangular structuring element is used). Else: An uint8 data object where values &gt; 0 are considered for the operation.</li>
<li><strong>anchor</strong> (<em>int seq. (int*)</em>) &#8211; position of the anchor within the element. If not given or if (-1,-1), the anchor is at the element center [default].</li>
<li><strong>iterations</strong> (<em>int (int)</em>) &#8211; number of times the morpholocial operation is applied [default: 1]</li>
<li><strong>borderType</strong> (<em>str (char*)</em>) &#8211; This string defines how the filter should hande pixels at the border of the matrix. Allowed is CONSTANT [default], REPLICATE, REFLECT, WRAP, REFLECT_101. In case of a constant border, only pixels inside of the element mask are considered (morphologyDefaultBorderValue)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="filter">
<dt id="cvFlipUpDown">
<em class="property">itom.filter</em><big>(</big><tt class="descname">&quot;cvFlipUpDown&quot;</tt><em class="property">,</em><em>scrImage</em>, <em>destImage</em><big>)</big><a class="headerlink" href="#cvFlipUpDown" title="Permalink to this definition">¶</a></dt>
<dd><p>This filter flips the image upside down.</p>
<p>This filter applies the flip method cvFlip of OpenCV with the flipCode = 0 to a 2D source data object. The result is contained in the destination object.</p>
<p>It is allowed to let the filter work inplace if you give the same input than destination data object, else the output data object is verified if it fits to the size and type of the source data object and if not a new one is allocated
.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Mandatory parameters:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><ul class="first last simple">
<li><strong>scrImage</strong> (<em>dataObject</em>) &#8211; Input image</li>
<li><strong>destImage</strong> (<em>dataObject</em>) &#8211; Output image</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="filter">
<dt id="cvIFFT1D">
<em class="property">itom.filter</em><big>(</big><tt class="descname">&quot;cvIFFT1D&quot;</tt><em class="property">,</em><em>sourceImage</em><big>)</big><a class="headerlink" href="#cvIFFT1D" title="Permalink to this definition">¶</a></dt>
<dd><p>1D-dimentional inverse fourier-transformation using cv::DFT.</p>
<p>This filter tries to perform an inplace FFT for a given line or 2D-dataObject. The FFT is calculated linewise.The result is a real-dataObject. The axis-scales and units are invertes and modified.</p>
<p>This filter internally calls the ito::dObjHelper::calcCVDFT(dObjImages, true, true, true)-function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">Mandatory parameters:</th></tr>
<tr class="field-odd field"><td>&nbsp;</td><td class="field-body"><strong>sourceImage</strong> (<em>dataObject</em>) &#8211; Input Object handle, must be a single plane</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="pclTools.html" title="PclTools"
             >next</a></li>
        <li class="right" >
          <a href="fittingFilters.html" title="Fitting Filters"
             >previous</a> |</li>
        <li><a href="../../index.html">itom</a> &raquo;</li>
          <li><a href="../../plugins.html" >Plugins</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer">
        &copy; Copyright 2014, Institut für Technische Optik, Universität Stuttgart.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.1.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40524649-1', 'bitbucket.org');
  ga('send', 'pageview');

</script>
</div>

  </body>
</html>