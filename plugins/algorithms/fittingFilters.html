<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Fitting Filters &mdash; itom</title>
    
    <link rel="stylesheet" href="../../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/breathe.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/breathe.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '2.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="itom" href="../../index.html" />
    <link rel="up" title="Plugins" href="../../plugins.html" />
    <link rel="next" title="OpenCV Filters" href="openCVFilters.html" />
    <link rel="prev" title="DataObjectIO" href="dataObjectIO.html" />
 


  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="openCVFilters.html" title="OpenCV Filters"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="dataObjectIO.html" title="DataObjectIO"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">itom</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../plugins.html" accesskey="U">Plugins</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/itomlogo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../download.html">Downloads</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../documentation.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../media.html">Publications and Presentations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../faq.html">Known bugs, issues and workarounds</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../plugins.html">Plugins</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../plugins.html#add-a-plugin-to-itom">Add a plugin to itom</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../plugins.html#available-plugins">Available plugins</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../../plugins.html#cameras-grabbers-ad-converter">Cameras / Grabbers / AD-Converter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../plugins.html#motors-actuators">Motors / Actuators</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../plugins.html#further-hardware-devices">Further hardware devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../plugins.html#ad-converters">AD-Converters</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../../plugins.html#algorithms">Algorithms</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="basicFilters.html">Basic Filters</a></li>
<li class="toctree-l4"><a class="reference internal" href="dataObjectArithmetic.html">DataObject Arithmetic</a></li>
<li class="toctree-l4"><a class="reference internal" href="dataObjectIO.html">DataObjectIO</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Fitting Filters</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l5"><a class="reference internal" href="#filters">Filters</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="openCVFilters.html">OpenCV Filters</a></li>
<li class="toctree-l4"><a class="reference internal" href="openCVFiltersNonFree.html">OpenCV Filters (non free)</a></li>
<li class="toctree-l4"><a class="reference internal" href="pclTools.html">PclTools</a></li>
<li class="toctree-l4"><a class="reference internal" href="rawImport.html">RawImport filters</a></li>
<li class="toctree-l4"><a class="reference internal" href="roughness.html">Roughness</a></li>
<li class="toctree-l4"><a class="reference internal" href="x3pio.html">X3P Input Output</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../plugins.html#plugin-development">Plugin Development</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../screenshots.html">Screenshots</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../collaboration.html">Collaboration</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="dataObjectIO.html"
                        title="previous chapter">DataObjectIO</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="openCVFilters.html"
                        title="next chapter">OpenCV Filters</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="fitting-filters">
<h1>Fitting Filters<a class="headerlink" href="#fitting-filters" title="Permalink to this headline">¶</a></h1>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="87%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>Summary</strong>:</td>
<td><span>Plugin with fitting algorithms.</span></td>
</tr>
<tr class="row-even"><td><strong>Type</strong>:</td>
<td><span>Algorithm</span></td>
</tr>
<tr class="row-odd"><td><strong>License</strong>:</td>
<td><span>licensed under LPGL</span></td>
</tr>
<tr class="row-even"><td><strong>Platforms</strong>:</td>
<td>Windows, Linux</td>
</tr>
<tr class="row-odd"><td><strong>Author</strong>:</td>
<td><span>M. Gronle, ITO, University Stuttgart</span></td>
</tr>
</tbody>
</table>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>This plugin contains algorithms for fitting planes and other two dimensional polynomials to dataObjects mainly using the method of least-squares. Some of the included algorithms can also be called with weighted values, such that more precise fitting results are achievable.</p>
<p>Furthermore this plugin also contains methods to finally subtract or reconstruct the fitted surfaces.</p>
<p>These filters are defined in the plugin:</p>
<ol class="arabic simple">
<li>polyval2DSinglePoints</li>
<li>fitPolynom2D</li>
<li>fillInvalidAreas</li>
<li>fitPlane</li>
<li>polyfitWeighted2D</li>
<li>subtractRegressionPlane</li>
<li>fitPolynom1D_Z</li>
<li>polyfitWeighted2DSinglePoints</li>
<li>getInterpolatedValues</li>
<li>subtractPlane</li>
<li>polyval2D</li>
<li>subtract1DRegression</li>
</ol>
</div>
<div class="section" id="filters">
<h2>Filters<a class="headerlink" href="#filters" title="Permalink to this headline">¶</a></h2>
<p>Detailed overview about all defined filters:</p>
<dl class="function">
<dt id="polyval2DSinglePoints">
<code class="descname">polyval2DSinglePoints</code><span class="sig-paren">(</span><em>dataX</em>, <em>dataY</em>, <em>dataZ</em>, <em>coefficients</em>, <em>orderX</em>, <em>orderY</em><span class="sig-paren">)</span><a class="headerlink" href="#polyval2DSinglePoints" title="Permalink to this definition">¶</a></dt>
<dd><p>This method evaluates a two-dimensional polynom for every x- and y- coordinate given in xData in yData</p>
<p>For every single pixel whose x- and y-coordinate is given by corresponding values in xData and yData the polynomial (given by its coefficients) is evaluated and stored in zData (float64, same size than xData and yData).
The polynomial coefficients (p0, p1, ...) are those returned by the filter &#8216;fitPolynom2D&#8217; and depend on the polynomial order in X and Y direction:</p>
<blockquote>
<div><dl class="docutils">
<dt>if (orderX &lt;= orderY):</dt>
<dd>f(x,y) = sum_{i=0}^orderX sum_{j=0}^{orderY-i} p_{ij} x^i y^j</dd>
<dt>else:</dt>
<dd>f(x,y) = sum_{j=0}^orderY sum_{i=0}^{orderX-i} p_{ij} x^i y^j</dd>
</dl>
</div></blockquote>
<p>The coefficients p_ij are stored in the coefficients vector in the order they appear in the equation above.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dataX</strong> (<em>dataObject</em>) &#8211; data object with x-coordinates (interpreted as float64).</li>
<li><strong>dataY</strong> (<em>dataObject</em>) &#8211; data object with y-coordinates (interpreted as float64).</li>
<li><strong>dataZ</strong> (<em>dataObject</em>) &#8211; This data object is finally filled with the evaluated polynomial function (float64)</li>
<li><strong>coefficients</strong> (<em>seq. of float</em>) &#8211; polynom coefficients as they come from polyfitWeighted2D</li>
<li><strong>orderX</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; polynomial order in x-direction</li>
<li><strong>orderY</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; polynomial order in y-direction</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="fitPolynom2D">
<code class="descname">fitPolynom2D</code><span class="sig-paren">(</span><em>sourceImage</em>, <em>fittedImage</em>, <em>orderX</em>, <em>orderY</em><span class="optional">[</span>, <em>replaceNaN</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#fitPolynom2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a polynomial p(x,y) of order (orderX, orderY) in x- and y-direction.</p>
<p>The fit function always looks like this:</p>
<p>f(x,y) = sum_{m=0}^{M} sum_{n=0}^{N} ( p_nm * x^n * y^m )</p>
<p>This definition is slightly different from the polynomial fitted by the similar function &#8216;polyfitWeighted2d&#8217;.</p>
<p>Puts the fitted points into the data object &#8216;fittedImage&#8217;. This method does not weight the input values and does not
return the coefficients for the polynomial. Use polyfitWeighted2d if you want to have an enhanced fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sourceImage</strong> (<em>dataObject</em>) &#8211; source image data object</li>
<li><strong>fittedImage</strong> (<em>dataObject</em>) &#8211; destination data object with fitted values</li>
<li><strong>orderX</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; order of the fitting polynomial in x-direction</li>
<li><strong>orderY</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; order of the fitting polynomial y-direction</li>
<li><strong>replaceNaN</strong> (<em>int - optional</em>) &#8211; if 0 infinite values in input image will be copied to output</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">sigma - Variance value <em>sigma</em> of polynomial fit.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)">float</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="fillInvalidAreas">
<code class="descname">fillInvalidAreas</code><span class="sig-paren">(</span><em>inputObject</em>, <em>outputObject</em><span class="optional">[</span>, <em>method</em>, <em>regionType</em>, <em>regionExtend</em>, <em>maxAreaSize</em>, <em>validPointProbability</em>, <em>allowedErrorProbability</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#fillInvalidAreas" title="Permalink to this definition">¶</a></dt>
<dd><p>This filter can be used to fill NaN areas in a float32 or float64 input object with interpolated values.</p>
<p>This filter processes independently every plane of the input object. For every plane the following steps are done:</p>
<ol class="arabic simple">
<li>Locate connected areas with NaN values (using OpenCVs method &#8216;connectedComponentsWithStats&#8217;).</li>
<li>For every area whose size does not exceed &#8216;maxAreaSize&#8217;:<ul>
<li>depending on &#8216;regionType&#8217; and &#8216;regionExtend&#8217; an enlarged area around the NaN area is taken</li>
<li>depending on &#8216;method&#8217; an interpolation plane or single value is calculated using all valid values within the enlarged area</li>
<li>The NaN values within the area are filled with the interpolated plane value of the interpolated scalar</li>
</ul>
</li>
</ol>
<p><strong>RegionType</strong></p>
<ul class="simple">
<li>Per default, the region type is &#8216;BoundingBox&#8217;. Then, a rectangular bounding box is set around each area of invalid values and the size of the bounding box.
is increased in all directions by the parameter &#8216;regionExtend&#8217; (different value possible for horizontal and vertical extend). &#8216;BoundingBox&#8217; is the fastest
method, however may produce very varying results, if the shape of the areas is different from simple rectangles.</li>
<li>ErodeRect: Around the invalid area, an erosion is calculated with a rectangle element. The interpolation is only done with values within the eroded ribbon.
The extend is the maximum horizontal and vertical distance from a edge element of the invalid area, e.g. (1,1) is a 1-pixel ribbon whose valid values are used for interpolation.</li>
<li>ErodeEllipse: This is the same than &#8216;ErodeRect&#8217;, however the element has an ellipse form and not a rectangle making the ribbon more smooth.</li>
</ul>
<p><strong>Method</strong></p>
<ul class="simple">
<li>LeastSquaresPlane: A plane is fitted into the valid values of the region using the least squares fit approach.</li>
<li>LMedSPlane: A plane is fitted into the valid values of the region using the approach to minimize the median of the squared distances.</li>
<li>Mean: A mean value of a valid values of the region replaces the invalid values within the region.</li>
<li>Median: A median value of a valid values of the region replaces the invalid values within the region.</li>
</ul>
<p>Currently, the filter does not work inplace such that the output object is always a newly allocated dataObject of the same type and size than the input object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>inputObject</strong> (<em>dataObject</em>) &#8211; input real-valued data object with possible NaN values (float32, float64).</li>
<li><strong>outputObject</strong> (<em>dataObject</em>) &#8211; output real-valued data object that equals &#8216;inputObject&#8217; but NaN values are filled with interpolated values (float32, float64).</li>
<li><strong>method</strong> (<em>str - optional</em>) &#8211; LeastSquaresPlane (default), LMedSPlane (Least median of squares), Median, Mean</li>
<li><strong>regionType</strong> (<em>str - optional</em>) &#8211; BoundingBox (default): a bounding box is set around each invalid area and the interpolation is done over all valid values within the bounding box. For other region types see the description of this filter.</li>
<li><strong>regionExtend</strong> (<em>seq. of int - optional</em>) &#8211; The invalid region is extend by the &#8216;regionType&#8217;. The size of the extend in x- and y- direction is given by this parameter as tuple (dx,dy).</li>
<li><strong>maxAreaSize</strong> (<em>int - optional</em>) &#8211; Only invalid area whose number of pixels is below this value are filled by interpolated values.</li>
<li><strong>validPointProbability</strong> (<em>float - optional</em>) &#8211; probability that 3 randomly selected point of all points only contain trustful (valid) points. (only important for leastMedianFitPlane)</li>
<li><strong>allowedErrorProbability</strong> (<em>float - optional</em>) &#8211; allowed probability that the fit is based on a possible outlier (non correct fit). (only important for leastMedianFitPlane)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="fitPlane">
<code class="descname">fitPlane</code><span class="sig-paren">(</span><em>sourceImage</em><span class="optional">[</span>, <em>method</em>, <em>validPointProbability</em>, <em>allowedErrorProbability</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#fitPlane" title="Permalink to this definition">¶</a></dt>
<dd><p>fits plane in 2D-dataObject and returns plane-parameters A,B,C (z=A+Bx+Cy)</p>
<p>This fit can be executed by different fit strategies:
- leastSquareFit minimizes the sum of  the squared distances of all valid points to the plane (direct solution)
- leastSquareFitSVD does the same using a svd algorithm
- leastMedianFit minimizes the median of the absolute distances of all valid points to the plane</p>
<p>The probability values are only important for the least median fit and determine the number of iterations for the
a random search using the equation</p>
<p>iterations &gt;= ceil(log(allowedErrorProbability)/log(1-validPointProbability)))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sourceImage</strong> (<em>dataObject</em>) &#8211; source image data object</li>
<li><strong>method</strong> (<em>str - optional</em>) &#8211; fitting method (leastSquareFit [default], leastSquareFitSVD, leastMedianFit)</li>
<li><strong>validPointProbability</strong> (<em>float - optional</em>) &#8211; probability that 3 randomly selected point of all points only contain trustful (valid) points. (only important for leastMedianFit)</li>
<li><strong>allowedErrorProbability</strong> (<em>float - optional</em>) &#8211; allowed probability that the fit is based on a possible outlier (non correct fit). (only important for leastMedianFit)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A - Parameter A of regression plane z = A + Bx + Cy</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)">float</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">B - Parameter B of regression plane z = A + Bx + Cy</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first"><a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)">float</a></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">C - Parameter C of regression plane z = A + Bx + Cy</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)">float</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="polyfitWeighted2D">
<code class="descname">polyfitWeighted2D</code><span class="sig-paren">(</span><em>inputData</em>, <em>orderX</em>, <em>orderY</em><span class="optional">[</span>, <em>weights</em>, <em>reduceFactor</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#polyfitWeighted2D" title="Permalink to this definition">¶</a></dt>
<dd><p>This method fits a two-dimensional polynomial of given order in x- and y-direction to the data &#8216;inputData&#8217;.</p>
<p>For the fit, the optional scale and offset values of the input data object are considered. The fit is executed in double precision, such that the input is converted to float64 (if not yet done). NaN values in the input data object are ignored. Optionally, you can give a weighting data object (needs to have the same dimension and size than inputData) such that the values are weighted with the values of the data object &#8216;weights&#8217;. Values with corresponding weights &lt;= 0 are ignored as well.</p>
<p>Depending on the orders, the fitted polynomial, whose coefficients are returned by this filter, has the following form:</p>
<blockquote>
<div><dl class="docutils">
<dt>if (orderX &lt;= orderY):</dt>
<dd>f(x,y) = sum_{i=0}^orderX sum_{j=0}^{orderY-i} p_{ij} x^i y^j</dd>
<dt>else:</dt>
<dd>f(x,y) = sum_{j=0}^orderY sum_{i=0}^{orderX-i} p_{ij} x^i y^j</dd>
</dl>
</div></blockquote>
<p>The coefficients p_ij are stored in the coefficients vector in the order they appear in the equation above.</p>
<p>The solver uses a Vandermonde matrix V as solving strategy and tries to solve V*p=Z, where Z are the valid values of the input data object. The overdetermined system of linear equations is finally solved using a QR factorization of V. If this module is compiled with LAPACK, its solvers are used, else the solve-command of OpenCV (slower) is called. In order to speed up the calculation you can use the parameter &#8216;reduceFactor&#8217;. If it is set to any value &gt;= 1, The input plane is divided into a grid of (orderY+1)*reduceFactor x (orderX+1)*reduceFactor rectangles. In every rectangle an arbitrary valid value is selected and used for the determination only. If no valid value could be found after a certain number of new random values, no value is taken from this rectangle. The algorithm returns an error if less values could have been selected than are needed for the fit of given orders.</p>
<p>The definition of the polynomial function is slightly different than the one used in the similar fitting function &#8216;fitPolynom2D&#8217;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inputData</strong> (<em>dataObject</em>) &#8211; input data object, the fit is based on the regular grid (x,y) defined by the scaling and offset of this data object</li>
<li><strong>orderX</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; polynomial order in x-direction</li>
<li><strong>orderY</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; polynomial order in y-direction</li>
<li><strong>weights</strong> (<em>dataObject - optional</em>) &#8211; weights, if not given all values are equally weighted</li>
<li><strong>reduceFactor</strong> (<em>float - optional</em>) &#8211; If this factor is &gt;= 1.0, every plane of the data object is divided into fields (reduceFactor * (orderXorY+1)) in x-direction and y-direction respectively, where one random, valid value is picked. If &lt; 1.0 (e.g. -1.0 [default]) all valid points are picked</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">coefficients - fitted polynomial coefficients</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">seq. of float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="subtractRegressionPlane">
<code class="descname">subtractRegressionPlane</code><span class="sig-paren">(</span><em>sourceImage</em>, <em>destinationImage</em><span class="optional">[</span>, <em>method</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#subtractRegressionPlane" title="Permalink to this definition">¶</a></dt>
<dd><p>subtracts a fitted regression plane from the given 2D input dataObject .</p>
<p>This method firstly executes the filter <em>fitPlane</em> followed by <em>subtractPlane</em>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sourceImage</strong> (<em>dataObject</em>) &#8211; source image data object</li>
<li><strong>destinationImage</strong> (<em>dataObject</em>) &#8211; destination image data object</li>
<li><strong>method</strong> (<em>str - optional</em>) &#8211; fitting method (leastSquareFit [default], leastSquareFitSVD)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="fitPolynom1D_Z">
<code class="descname">fitPolynom1D_Z</code><span class="sig-paren">(</span><em>data</em>, <em>polynoms</em>, <em>order</em><span class="optional">[</span>, <em>weights</em>, <em>xVals</em>, <em>numThreads</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#fitPolynom1D_Z" title="Permalink to this definition">¶</a></dt>
<dd><p>One-dimensional polynomial fit in z-direction for a 3D - data object.</p>
<p>The input data object must be three-dimensional and is internally casted to float64 (if not yet done). The resulting polynomial parameters per pixel are stored in the output data object &#8216;polynoms&#8217; whose z-dimension is equal to (order+2). The first (order+1) planes contain the coefficients p0...pn and the last plane contain the pixel wise residual error.</p>
<p>The polynomial is y(x) = p0 + x*p1 ... + x^n*pn
The residual is the sum of the quadratical errors from each valid pixel to the fitted polynomial.</p>
<p>If no &#8216;xVals&#8217; are assigned, the x-values for each plane are calculated using the offset and scale of the data-object in z-direction, such that an equally spaced vector of (0,1,2,3...) is the default.</p>
<p>You can additionally give a weight data object (same dimension than &#8216;data&#8217;) for weighting the values. NaN values in &#8216;data&#8217; and weights &lt;= 0 are ignored. If a fit cannot be done due to too less or degenerated values, NaN is returned in &#8216;polynoms&#8217; at this pixel.</p>
<p>For a first order fit, a direct least squares solution is used which is very fast, for the other orders a system of linear equations is solved (using a SVD decomposition) which can be slower. On a multi-core processor you can assign a number of threads that are used to parallely compute the approximations for each pixel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> (<em>dataObject</em>) &#8211; input data object (3 dimensions).</li>
<li><strong>polynoms</strong> (<em>dataObject</em>) &#8211; </li>
<li><strong>order</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; polynomial order</li>
<li><strong>weights</strong> (<em>dataObject - optional</em>) &#8211; weights (same dimensions than data)</li>
<li><strong>xVals</strong> (<em>seq. of float - optional</em>) &#8211; x-value vector (length must be the same than z-size of data) [default: equally spaced values are assumed using scale and offset of the data object in z-direction]</li>
<li><strong>numThreads</strong> (<em>int - optional</em>) &#8211; number of threads used for the parallel determination</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="polyfitWeighted2DSinglePoints">
<code class="descname">polyfitWeighted2DSinglePoints</code><span class="sig-paren">(</span><em>xData</em>, <em>yData</em>, <em>zData</em>, <em>orderX</em>, <em>orderY</em><span class="optional">[</span>, <em>weights</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#polyfitWeighted2DSinglePoints" title="Permalink to this definition">¶</a></dt>
<dd><p>This method fits a two-dimensional polynomial of given order in x- and y-direction to the points whose x, y and z coordinates are given in &#8216;xData&#8217;, &#8216;yData&#8217; and &#8216;zData&#8217;.</p>
<p>The fit is executed in double precision, such that the input is converted to float64 (if not yet done). NaN values in the x, y or z data objects are ignored. Optionally, you can give a weighting data object (needs to have the same dimension and size than inputData) such that the values are weighted with the values of the data object &#8216;weights&#8217;. Values with corresponding weights &lt;= 0 are ignored as well.</p>
<p>All input data objects must have the same size.</p>
<p>Depending on the orders, the fitted polynomial, whose coefficients are returned by this filter, has the following form:</p>
<blockquote>
<div><dl class="docutils">
<dt>if (orderX &lt;= orderY):</dt>
<dd>z = f(x,y) = sum_{i=0}^orderX sum_{j=0}^{orderY-i} p_{ij} x^i y^j</dd>
<dt>else:</dt>
<dd>z = f(x,y) = sum_{j=0}^orderY sum_{i=0}^{orderX-i} p_{ij} x^i y^j</dd>
</dl>
</div></blockquote>
<p>The coefficients p_ij are stored in the coefficients vector in the order they appear in the equation above.</p>
<p>The solver uses a Vandermonde matrix V as solving strategy and tries to solve V*p=Z, where Z are the valid values of the input data object. The overdetermined system of linear equations is finally solved using a QR factorization of V. If this module is compiled with LAPACK, its solvers are used, else the solve-command of OpenCV (slower) is called.</p>
<p>The definition of the polynomial function is slightly different than the one used in the similar fitting function &#8216;fitPolynom2D&#8217;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>xData</strong> (<em>dataObject</em>) &#8211; input data object with x-coordinates of points</li>
<li><strong>yData</strong> (<em>dataObject</em>) &#8211; input data object with y-coordinates of points</li>
<li><strong>zData</strong> (<em>dataObject</em>) &#8211; input data object with z-coordinates of points</li>
<li><strong>orderX</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; polynomial order in x-direction</li>
<li><strong>orderY</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; polynomial order in y-direction</li>
<li><strong>weights</strong> (<em>dataObject - optional</em>) &#8211; weights, if not given all values are equally weighted</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">coefficients - fitted polynomial coefficients</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">seq. of float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="getInterpolatedValues">
<code class="descname">getInterpolatedValues</code><span class="sig-paren">(</span><em>dataObj</em>, <em>coordsSubPix</em><span class="optional">[</span>, <em>searchRect</em>, <em>method</em>, <em>validPointProbability</em>, <em>allowedErrorProbability</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#getInterpolatedValues" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the linearly interpolated values of a given input dataObject at specific 2D point coordinates.</p>
<p>The given input data object must be a real valued object with two dimensions or a region of interest that only contains one plane (e.g. 1xMxN).
The point coordinates (coordsSubPix) is a Nx2 floating point data object where each row is the row and column coordinate (sub-pixel) of the desired value. The values must be given
in the coordinates of the data object (scale values).
The resulting interpolated values are returned as &#8216;values&#8217; list. The input data object is allowed to contain non-finite values.</p>
<p>For the interpolation a search rectangle whose height and width is given by &#8216;searchRect&#8217; is centered at the rounded coordinate and a plane is robustly fitted into the valid
values that lie within the rectangle. The value is then determined using the coefficients of the fitted plane. Infinite values are ignored for the determination of the plane.
The plane is calculated by least-squares fit. If the rectangle exceeds the boundaries of the given matrix, it moved inside of the matrix such that the searched coordinate still lies within
the rectangle. If this is not possible, NaN is returned as value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dataObj</strong> (<em>dataObject</em>) &#8211; input real-valued data object (2D or ROI containing only one plane).</li>
<li><strong>coordsSubPix</strong> (<em>dataObject</em>) &#8211; input Nx2 data object containing the sub-pixel (column,row) coordinates of each point (given in scale value of dataObj).</li>
<li><strong>searchRect</strong> (<em>seq. of int - optional</em>) &#8211; [height, width] of the search rectangle for the linear interpolation. A plane fit is executed for all finite values within the rectangle and the output value is determined based on the plane coefficients. If the size if even, its size drifts towards the trend direction given by the coordinate value.</li>
<li><strong>method</strong> (<em>str - optional</em>) &#8211; LeastSquares (default), LMedS (Least median of squares)</li>
<li><strong>validPointProbability</strong> (<em>float - optional</em>) &#8211; probability that 3 randomly selected point of all points only contain trustful (valid) points. (only important for leastMedianFit)</li>
<li><strong>allowedErrorProbability</strong> (<em>float - optional</em>) &#8211; allowed probability that the fit is based on a possible outlier (non correct fit). (only important for leastMedianFit)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">values - output vector of type ito::float64 containing the interpolated values (NaN if no value could be found)</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">seq. of float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="subtractPlane">
<code class="descname">subtractPlane</code><span class="sig-paren">(</span><em>sourceImage</em>, <em>destinationImage</em>, <em>A</em>, <em>B</em>, <em>C</em><span class="sig-paren">)</span><a class="headerlink" href="#subtractPlane" title="Permalink to this definition">¶</a></dt>
<dd><p>subtracts plane from 2D-dataObject given by plane-parameters A,B,C (z=A+Bx+Cy)</p>
<p>If the destinationImage is not the same than the sourceImage, the destinationImage finally is a new data object with the same size and type than the sourceImage and contains the data of the sourceImage subtracted by the given plane. If both are the same, the subtraction is executed in-place.</p>
<p>If the input dataObject contains more than one plane, the subtraction is executed separately for each plane.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>sourceImage</strong> (<em>dataObject</em>) &#8211; source image data object</li>
<li><strong>destinationImage</strong> (<em>dataObject</em>) &#8211; destination image data object</li>
<li><strong>A</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; Parameter A of regression plane z = A + Bx + Cy, which is subtracted</li>
<li><strong>B</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; Parameter B of regression plane z = A + Bx + Cy, which is subtracted</li>
<li><strong>C</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; Parameter C of regression plane z = A + Bx + Cy, which is subtracted</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="polyval2D">
<code class="descname">polyval2D</code><span class="sig-paren">(</span><em>dataZ</em>, <em>coefficients</em>, <em>orderX</em>, <em>orderY</em><span class="sig-paren">)</span><a class="headerlink" href="#polyval2D" title="Permalink to this definition">¶</a></dt>
<dd><p>This method evaluates a two-dimensional polynom for every point in a given data object</p>
<p>For every single pixel in the input data object &#8216;dataZ&#8217;, its physical coordinate (using scale and offset of the data object) is taken and the polynomial (given by its coefficients) is evaluated and stored in the pixel. The data object is hereby converted to float64.</p>
<dl class="docutils">
<dt>The polynomial coefficients (p0, p1, ...) are those returned by the filter &#8216;fitPolynom2D&#8217; and depend on the polynomial order in X and Y direction:</dt>
<dd><dl class="first last docutils">
<dt>if (orderX &lt;= orderY):</dt>
<dd>f(x,y) = sum_{i=0}^orderX sum_{j=0}^{orderY-i} p_{ij} x^i y^j</dd>
<dt>else:</dt>
<dd>f(x,y) = sum_{j=0}^orderY sum_{i=0}^{orderX-i} p_{ij} x^i y^j</dd>
</dl>
</dd>
</dl>
<p>The coefficients p_ij are stored in the coefficients vector in the order they appear in the equation above.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>dataZ</strong> (<em>dataObject</em>) &#8211; data object with given size and data type including scale and offset value. Depending on these values, this data object is finally filled with the evaluated polynomial function</li>
<li><strong>coefficients</strong> (<em>seq. of float</em>) &#8211; polynom coefficients as they come from polyfitWeighted2D</li>
<li><strong>orderX</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; polynomial order in x-direction</li>
<li><strong>orderY</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; polynomial order in y-direction</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="subtract1DRegression">
<code class="descname">subtract1DRegression</code><span class="sig-paren">(</span><em>input</em>, <em>output</em>, <em>order</em><span class="optional">[</span>, <em>axis</em>, <em>numThreads</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#subtract1DRegression" title="Permalink to this definition">¶</a></dt>
<dd><p>subtracts a one-dimensional fitted polynom (along a given axis) from the values in the given 1D or 2D data object.</p>
<p>This filter operates inplace and subtracts from fitted one-dimensional polynoms from the values in the given 2D data object &#8216;data&#8217;. The polynoms are either fitted along the
vertical or horizontal axis. You can choose a polynomial order between 1 (line) and 7. The values are uniformly weighted for the fit. The algorithm uses a fast, direct solution
for the line regression fits and a singular value decomposition for all other cases (see fitPolynom1D_Z). The fit is done in double precision while the type of &#8216;data&#8217; is not changed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>input</strong> (<em>dataObject</em>) &#8211; real valued input object (1D or 2D)</li>
<li><strong>output</strong> (<em>dataObject</em>) &#8211; resulting output object (same than input is allowed, else output has the same type and size than input)</li>
<li><strong>order</strong> (<a class="reference external" href="http://docs.python.org/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; polynomial order</li>
<li><strong>axis</strong> (<em>int - optional</em>) &#8211; axis index along which the 1d regressions are independently determined and subtracted (0: vertical, 1: horizontal).</li>
<li><strong>numThreads</strong> (<em>int - optional</em>) &#8211; number of threads used for the parallel determination</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="openCVFilters.html" title="OpenCV Filters"
             >next</a></li>
        <li class="right" >
          <a href="dataObjectIO.html" title="DataObjectIO"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">itom</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../../plugins.html" >Plugins</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Institut für Technische Optik, Universität Stuttgart.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.2.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-51395951-1', 'bitbucket.org');
  ga('send', 'pageview');

</script>
</div>

  </body>
</html>