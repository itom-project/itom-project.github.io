

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>10.5. dataIO &mdash; itom Documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="10.6. dataObject" href="dataObject.html" />
    <link rel="prev" title="10.4. autoInterval" href="autoInterval.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> itom Documentation
          

          
          </a>

          
            
            
              <div class="version">
                4.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../00_releaseNotes/whats-new.html">1. Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../01_introduction/introduction.html">2. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_installation/install.html">3. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_gettingStarted/getting-started.html">4. Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_itom_gui/gui.html">5. The itom User Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_plots/plots.html">6. Plots and Figures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_extended_gui/extended_gui.html">7. Extending the user interface of <strong>itom</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_plugins/plugins.html">8. Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_scriptLanguage/script-language.html">9. Python scripting language</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="reference.html">10. itom Script Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="itom_general.html">10.1. itom methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="actuator.html">10.2. actuator</a></li>
<li class="toctree-l2"><a class="reference internal" href="algo.html">10.3. Algorithms, Widgets and Filters</a></li>
<li class="toctree-l2"><a class="reference internal" href="autoInterval.html">10.4. autoInterval</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">10.5. dataIO</a></li>
<li class="toctree-l2"><a class="reference internal" href="dataObject.html">10.6. dataObject</a></li>
<li class="toctree-l2"><a class="reference internal" href="figure.html">10.7. figure</a></li>
<li class="toctree-l2"><a class="reference internal" href="font.html">10.8. font</a></li>
<li class="toctree-l2"><a class="reference internal" href="plotItem.html">10.9. plotItem</a></li>
<li class="toctree-l2"><a class="reference internal" href="point.html">10.10. point</a></li>
<li class="toctree-l2"><a class="reference internal" href="pointCloud.html">10.11. pointCloud</a></li>
<li class="toctree-l2"><a class="reference internal" href="polygonMesh.html">10.12. polygonMesh</a></li>
<li class="toctree-l2"><a class="reference internal" href="progressObserver.html">10.13. progressObserver</a></li>
<li class="toctree-l2"><a class="reference internal" href="region.html">10.14. region</a></li>
<li class="toctree-l2"><a class="reference internal" href="rgba.html">10.15. rgba</a></li>
<li class="toctree-l2"><a class="reference internal" href="shape.html">10.16. shape</a></li>
<li class="toctree-l2"><a class="reference internal" href="timer.html">10.17. timer</a></li>
<li class="toctree-l2"><a class="reference internal" href="itom_GUI.html">10.18. ui-elements (ui, uiItem)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10_miscellaneous/miscellaneous.html">11. Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_test-scripts/test-scripts.html">12. Demo scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_tutorials/tutorials.html">13. Python tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_contributing/contributing.html">14. Contributing</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">itom Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="reference.html"><span class="section-number">10. </span>itom Script Reference</a> &raquo;</li>
        
      <li><span class="section-number">10.5. </span>dataIO</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/09_reference/dataIO.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="dataio">
<h1><span class="section-number">10.5. </span>dataIO<a class="headerlink" href="#dataio" title="Permalink to this headline">¶</a></h1>
<p>This section contains the script reference to the class <em>dataIO</em>, used to access any dataIO hardware in itom (e.g.
cameras, AD-converters or further data communcation plugins). Read the <a class="reference internal" href="../07_plugins/getstart-hardware.html#getstarthardware"><span class="std std-ref">overview document</span></a> for more
details about the Python interface of the class <em>dataIO</em>.</p>
<dl class="py class">
<dt id="itom.dataIO">
<em class="property">class </em><code class="sig-prename descclassname">itom.</code><code class="sig-name descname">dataIO</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">*mandparams</em>, <em class="sig-param">*optparams</em><span class="sig-paren">)</span> &#x2192; creates new instance of dataIO plugin ‘name’<a class="headerlink" href="#itom.dataIO" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the constructor for a <a class="reference internal" href="#itom.dataIO" title="itom.dataIO"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dataIO</span></code></a> plugin. It initializes an new instance of the plugin specified by ‘name’. 
The initialisation parameters are parsed and unnamed parameters are used in their incoming order to fill first 
mandatory parameters and afterwards optional parameters. Parameters may be passed with name as well but after 
the first named parameter no more unnamed parameters are allowed.</p>
<p>See pluginHelp(name) for detail information about the specific initialisation parameters.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> : {str}</p>
<blockquote>
<div><p>is the fullname (case sensitive) of an ‘actuator’-plugin as specified in the plugin-window.</p>
</div></blockquote>
<p><strong>mandparams</strong> : {variant(s)}</p>
<blockquote>
<div><p>arguments corresponding the mandatory initialization parameters. The number of arguments and their order must fit the the required mandatory parameters</p>
</div></blockquote>
<p><strong>optparams</strong> : {variant(s)}, optional</p>
<blockquote>
<div><p>argument corresponding to the optional initialization parameters. If unnamed arguments are used, their order must correspond to the order of the optional parameters, keyword-based parameters are allowed as well.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>inst</strong> : {dataIO}</p>
<blockquote>
<div><p>new instance of the dataIO-plugin</p>
</div></blockquote>
</dd>
</dl>
<dl class="py method">
<dt id="itom.dataIO.acquire">
<code class="sig-name descname">acquire</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">trigger</span><span class="o">=</span><span class="default_value">dataIO.TRIGGER_SOFTWARE</span></em><span class="sig-paren">)</span> &#x2192; triggers a new the camera acquisition<a class="headerlink" href="#itom.dataIO.acquire" title="Permalink to this definition">¶</a></dt>
<dd><p>This method triggers a new data acquisition. This method immediately returns even if the acquisition is not finished yet. 
Use <a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getVal</span></code></a> or <a class="reference internal" href="#itom.dataIO.copyVal" title="itom.dataIO.copyVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copyVal</span></code></a> to get the acquired data. Both methods block until the data is available.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>trigger</strong> : {int}, optional</p>
<blockquote>
<div><p>Type of the trigger:</p>
<ul class="simple">
<li><p><em class="xref py py-obj">dataIO.TRIGGER_SOFTWARE = 0</em> : a software trigger is started, hence, the acquisition is immediately started when calling this method</p></li>
<li><p>others : depending on your camera, this parameter can be used to set other triggers, like hardware trigger with raising or falling edges…</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.connect">
<code class="sig-name descname">connect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signalSignature</span></em>, <em class="sig-param"><span class="n">callableMethod</span></em>, <em class="sig-param"><span class="n">minRepeatInterval</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span> &#x2192; connects the signal of the actuator with the given callable python method<a class="headerlink" href="#itom.dataIO.connect" title="Permalink to this definition">¶</a></dt>
<dd><p>This instance of <em>dataIO</em> wraps a dataIO device (ADDA, grabber or rawIO), that is defined by a C++ - class, that is finally derived from <em>QObject</em>. 
Every dataIO can send various signals. Use this method to connect any signal to any 
callable python method(bounded or unbounded).This method must have the same number of arguments than the signal and the types of the 
signal definition must be convertable into a python object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>signalSignature</strong> : {str}</p>
<blockquote>
<div><p>This must be the valid signature, known from the Qt - method <em>connect</em> (e.g. ‘reachedTarget(bool)’)</p>
</div></blockquote>
<p><strong>callableMethod</strong> : {python method or function}</p>
<blockquote>
<div><p>valid method or function that is called if the signal is emitted.</p>
</div></blockquote>
<p><strong>minRepeatInterval</strong> : {int}, optional</p>
<blockquote>
<div><p>If &gt; 0, the same signal only invokes a slot once within the given interval (in ms). Default: 0 (all signals will invoke the callable python method.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.disconnect" title="itom.dataIO.disconnect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">disconnect</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.copyVal">
<code class="sig-name descname">copyVal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">destObject</span></em><span class="sig-paren">)</span> &#x2192; gets deep copy of data of this plugin, stored in the given data object.<a class="headerlink" href="#itom.dataIO.copyVal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a deep copy of the recently acquired data (for grabber and ADDA only) of the camera or AD-converter device. 
The deep copy sometimes requires one copy operation more than the similar command <a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getVal</span></code></a>. However, <a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getVal</span></code></a> only returns 
a reference to the plugin internal data structure whose values might be changed if another data acquisition is started.</p>
<p>If no acquisition has been triggered, this method raises a RuntimeError. If the acquisition is not finished yet, this method 
blocks and waits until the end of the acquisition.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>destObject</strong> : {dataObject}</p>
<blockquote>
<div><p><a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dataObject</span></code></a> where the plugin data is copied to. Either provide an empty <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dataObject</span></code></a> or a <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dataObject</span></code></a> whose size (or region of interest) 
exactly has the same size than the available data of the plugin. Therefore you can allocate a 3D data object, set a region of interest 
to one plane such that the data from the plugin is copied into this plane.</p>
</div></blockquote>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError</strong> :</p>
<blockquote>
<div><p>if the dataIO plugin is anything else than ADDA or grabber
or if no acquisition has been triggered</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getVal</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.disableAutoGrabbing">
<code class="sig-name descname">disableAutoGrabbing</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Disable auto grabbing for the grabber (camera…),<a class="headerlink" href="#itom.dataIO.disableAutoGrabbing" title="Permalink to this definition">¶</a></dt>
<dd><p>If the auto grabbing flag is set, the camera acquisition is automatically and continuously triggered if at least one live image is 
connected. This is an undesired behaviour if a measurement is started where the acquisition should be controlled by a specific 
script or something similar. Then disable the auto grabbing property. All connected live images will then get new images when 
<a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getVal</span></code></a> or <a class="reference internal" href="#itom.dataIO.copyVal" title="itom.dataIO.copyVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copyVal</span></code></a> is called by the script. The live image timer is disabled.</p>
<p>This method disables the auto grabbing flag.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.setAutoGrabbing" title="itom.dataIO.setAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setAutoGrabbing</span></code></a>, <a class="reference internal" href="#itom.dataIO.disableAutoGrabbing" title="itom.dataIO.disableAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">disableAutoGrabbing</span></code></a>, <a class="reference internal" href="#itom.dataIO.getAutoGrabbing" title="itom.dataIO.getAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getAutoGrabbing</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.disconnect">
<code class="sig-name descname">disconnect</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">signalSignature</span></em>, <em class="sig-param"><span class="n">callableMethod</span></em><span class="sig-paren">)</span> &#x2192; disconnects a connection which must have been established with exactly the same parameters.<a class="headerlink" href="#itom.dataIO.disconnect" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>signalSignature</strong> : {str}</p>
<blockquote>
<div><p>This must be the valid signature, known from the Qt-method <em>connect</em> (e.g. ‘clicked(bool)’)</p>
</div></blockquote>
<p><strong>callableMethod</strong> : {python method or function}</p>
<blockquote>
<div><p>valid method or function, that should not be called any more, if the given signal is emitted.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.connect" title="itom.dataIO.connect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">connect</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.enableAutoGrabbing">
<code class="sig-name descname">enableAutoGrabbing</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; enable auto grabbing for the grabber (camera…),<a class="headerlink" href="#itom.dataIO.enableAutoGrabbing" title="Permalink to this definition">¶</a></dt>
<dd><p>If the auto grabbing flag is set, the camera acquisition is automatically and continuously triggered if at least one live image is 
connected. This is an undesired behaviour if a measurement is started where the acquisition should be controlled by a specific 
script or something similar. Then disable the auto grabbing property. All connected live images will then get new images when 
<a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getVal</span></code></a> or <a class="reference internal" href="#itom.dataIO.copyVal" title="itom.dataIO.copyVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copyVal</span></code></a> is called by the script. The live image timer is disabled.</p>
<p>This method enables the auto grabbing flag.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.setAutoGrabbing" title="itom.dataIO.setAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setAutoGrabbing</span></code></a>, <a class="reference internal" href="#itom.dataIO.disableAutoGrabbing" title="itom.dataIO.disableAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">disableAutoGrabbing</span></code></a>, <a class="reference internal" href="#itom.dataIO.getAutoGrabbing" title="itom.dataIO.getAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getAutoGrabbing</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.exec">
<code class="sig-name descname">exec</code><span class="sig-paren">(</span><em class="sig-param">funcName</em><span class="optional">[</span>, <em class="sig-param">param1</em>, <em class="sig-param">...</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; invoke the function ‘funcName’ registered as execFunc within the plugin.<a class="headerlink" href="#itom.dataIO.exec" title="Permalink to this definition">¶</a></dt>
<dd><p>Every plugin can define further functions that can for instance be used in order to call specific calibration routines 
of cameras or actuators. This general method is used to call one of these specific functions registered under <em class="xref py py-obj">funcName</em>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>funcName</strong> : {str}</p>
<blockquote>
<div><p>The name of the function</p>
</div></blockquote>
<p><strong>param1</strong> : {variant}, optional</p>
<blockquote>
<div><p>Further parameters depending on the requirements of the specific function.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> : {variant, list of variants}.</p>
<blockquote>
<div><p>The return values depend on the function itself.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.getExecFuncsInfo" title="itom.dataIO.getExecFuncsInfo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getExecFuncsInfo</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.getAutoGrabbing">
<code class="sig-name descname">getAutoGrabbing</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; return the status of the auto grabbing flag.<a class="headerlink" href="#itom.dataIO.getAutoGrabbing" title="Permalink to this definition">¶</a></dt>
<dd><p>If the auto grabbing flag is set, the camera acquisition is automatically and continuously triggered if at least one live image is 
connected. This is an undesired behaviour if a measurement is started where the acquisition should be controlled by a specific 
script or something similar. Then disable the auto grabbing property. All connected live images will then get new images when 
<a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getVal</span></code></a> or <a class="reference internal" href="#itom.dataIO.copyVal" title="itom.dataIO.copyVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copyVal</span></code></a> is called by the script. The live image timer is disabled.</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>auto grabbing flag</strong> : {bool}</p>
<blockquote>
<div><ul class="simple">
<li><p>False = auto grabbing off</p></li>
<li><p>True = auto grabbing on.</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.enableAutoGrabbing" title="itom.dataIO.enableAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">enableAutoGrabbing</span></code></a>, <a class="reference internal" href="#itom.dataIO.disableAutoGrabbing" title="itom.dataIO.disableAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">disableAutoGrabbing</span></code></a>, <a class="reference internal" href="#itom.dataIO.setAutoGrabbing" title="itom.dataIO.setAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setAutoGrabbing</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.getAutoGrabbingInterval">
<code class="sig-name descname">getAutoGrabbingInterval</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Returns the current auto grabbing interval (in ms), even if auto grabbing is disabled<a class="headerlink" href="#itom.dataIO.getAutoGrabbingInterval" title="Permalink to this definition">¶</a></dt>
<dd><p>If auto grabbing is enabled for a grabber device, a timer is set that continuously acquires data or images from the devices and sends it 
to all connected windows or listeners. The timer event will occur with a certain interval (in ms). However, if the image acquisition 
requires more time than the interval, several events can be omitted, such that the next image is only acquired if the grabber device 
is in an idle state. Hence, the interval is considered to be a minimum value.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.enableAutoGrabbing" title="itom.dataIO.enableAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">enableAutoGrabbing</span></code></a>, <a class="reference internal" href="#itom.dataIO.disableAutoGrabbing" title="itom.dataIO.disableAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">disableAutoGrabbing</span></code></a>, <a class="reference internal" href="#itom.dataIO.getAutoGrabbing" title="itom.dataIO.getAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getAutoGrabbing</span></code></a>, <a class="reference internal" href="#itom.dataIO.setAutoGrabbing" title="itom.dataIO.setAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setAutoGrabbing</span></code></a>, <a class="reference internal" href="#itom.dataIO.setAutoGrabbingInterval" title="itom.dataIO.setAutoGrabbingInterval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setAutoGrabbingInterval</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.getExecFuncsInfo">
<code class="sig-name descname">getExecFuncsInfo</code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">funcName</em><span class="optional">[</span>, <em class="sig-param">detailLevel</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; plots a list of available execFuncs or a detailed description of the specified execFunc.<a class="headerlink" href="#itom.dataIO.getExecFuncsInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Every plugin can define further functions, that are called by plugin.exec(‘funcName’ [,param1, param2…]). This can for  
instance be used in order to call specific calibration routines of cameras or actuators. This method allows printing 
information about available functions of this type.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>funcName</strong> : {str}, optional</p>
<blockquote>
<div><p>is the fullname or a part of any execFunc-name which should be displayed. 
If funcName is none or no execFunc matches funcName casesensitiv a list with all suitable execFuncs is given.</p>
</div></blockquote>
<p><strong>detailLevel</strong> : {dict}, optional</p>
<blockquote>
<div><p>if <em class="xref py py-obj">detailLevel == 1</em>, function returns a dictionary with parameters, else information is print to the command line [default: 0].</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> : {None or dict}</p>
<blockquote>
<div><p>depending on the value of <em>detailLevel</em>.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.exec" title="itom.dataIO.exec"><code class="xref py py-obj docutils literal notranslate"><span class="pre">exec</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.getExecFuncsList">
<code class="sig-name descname">getExecFuncsList</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; returns a list of the names of the additional Functions of this plugin<a class="headerlink" href="#itom.dataIO.getExecFuncsList" title="Permalink to this definition">¶</a></dt>
<dd><p>Each plugin may define a set of functions, extending the standard interface. These functions are not common to plugins of the same type. 
These functions are executed using instance.exec(“funcname”,params)
to check exact function call use instance.getExecFuncsInfo()getExecFuncsInfo</p>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.getParam">
<code class="sig-name descname">getParam</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span> &#x2192; current value of the plugin parameter ‘name’.<a class="headerlink" href="#itom.dataIO.getParam" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current value of the internal plugin parameter with ‘name’. The type of the returned value depends on the 
real type of the internal plugin, which may be:</p>
<ul class="simple">
<li><p>String -&gt; str</p></li>
<li><p>Char, Integer -&gt; int</p></li>
<li><p>Double -&gt; float</p></li>
<li><p>CharArray, IntegerArray -&gt; tuple of int</p></li>
<li><p>DoubleArray -&gt; tuple of float</p></li>
<li><p>DataObject -&gt; dataObject</p></li>
<li><p>PolygonMesh -&gt; polygonMesh</p></li>
<li><p>PointCloud -&gt; pointCloud</p></li>
<li><p>Another plugin instance -&gt; dataIO or actuator</p></li>
</ul>
<p>The name of the parameter must have the following form:</p>
<ul class="simple">
<li><p>name</p></li>
<li><p>name:additionalTag (additionalTag can be a special feature of some plugins)</p></li>
<li><p>name[index] (only possible if parameter is an array type and you only want to get one single value, specified by the integer index [0,nrOfArrayItems-1])</p></li>
<li><p>name[index]:additionalTag</p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> : {str}</p>
<blockquote>
<div><p>name of the requested parameter</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> : {variant}</p>
<blockquote>
<div><p>value of the parameter</p>
</div></blockquote>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> :</p>
<blockquote>
<div><p>if parameter does not exist</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.setParam" title="itom.dataIO.setParam"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setParam</span></code></a>, <a class="reference internal" href="#itom.dataIO.getParamList" title="itom.dataIO.getParamList"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getParamList</span></code></a>, <a class="reference internal" href="#itom.dataIO.getParamListInfo" title="itom.dataIO.getParamListInfo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getParamListInfo</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.getParamInfo">
<code class="sig-name descname">getParamInfo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span> &#x2192; returns dictionary with meta information of parameter ‘name’.<a class="headerlink" href="#itom.dataIO.getParamInfo" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="itom.dataIO.getParamList">
<code class="sig-name descname">getParamList</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; returns a list of the names of the internal parameters of the plugin<a class="headerlink" href="#itom.dataIO.getParamList" title="Permalink to this definition">¶</a></dt>
<dd><p>Each plugin defines a set of parameters, where each parameter has got a name and maps to any value. The value is represented by 
the C++ class ito::ParamBase and can have one of the following types:</p>
<ul class="simple">
<li><p>String</p></li>
<li><p>Char</p></li>
<li><p>Integer</p></li>
<li><p>Double</p></li>
<li><p>CharArray</p></li>
<li><p>IntegerArray</p></li>
<li><p>DoubleArray</p></li>
<li><p>DataObject</p></li>
<li><p>PolygonMesh</p></li>
<li><p>PointCloud</p></li>
<li><p>Another plugin instance</p></li>
</ul>
<p>Using one of the parameter names, its current value can be obtained by <em class="xref py py-obj">getParam(‘name’)</em> and 
is writable by <em class="xref py py-obj">setParam(‘name’, newValue)</em> (if not read-only)</p>
<dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>out</strong> : {list}</p>
<blockquote>
<div><p>list of parameter names</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.getParam" title="itom.dataIO.getParam"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getParam</span></code></a>, <a class="reference internal" href="#itom.dataIO.setParam" title="itom.dataIO.setParam"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setParam</span></code></a>, <a class="reference internal" href="#itom.dataIO.getParamListInfo" title="itom.dataIO.getParamListInfo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getParamListInfo</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.getParamListInfo">
<code class="sig-name descname">getParamListInfo</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">detailLevel</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span> &#x2192; prints detailed information about all plugin parameters.<a class="headerlink" href="#itom.dataIO.getParamListInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Each plugin defines a set of parameters, where each parameter has got a name and maps to any value. The value is represented by 
the C++ class ito::ParamBase and can have one of the following types:</p>
<ul class="simple">
<li><p>String</p></li>
<li><p>Char</p></li>
<li><p>Integer</p></li>
<li><p>Double</p></li>
<li><p>CharArray</p></li>
<li><p>IntegerArray</p></li>
<li><p>DoubleArray</p></li>
<li><p>DataObject</p></li>
<li><p>PolygonMesh</p></li>
<li><p>PointCloud</p></li>
<li><p>Another plugin instance</p></li>
</ul>
<p>Using one of the parameter names, its current value can be obtained by <em class="xref py py-obj">getParam(‘name’)</em> and 
is writable by <em class="xref py py-obj">setParam(‘name’, newValue)</em> (if not read-only)</p>
<p>This method prints a detailed table with the name, current value, description string and further meta information of every plugin parameter. 
Additionally, the column R/W indicates if this parameter is writable or read-only.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>detailLevel</strong> : {dict}, optional</p>
<blockquote>
<div><p>if <em class="xref py py-obj">detailLevel == 1</em>, function returns a dictionary with parameters, else None is returned and the output is printed in a readable form to the console [default]</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> : {None, dict}</p>
<blockquote>
<div><p>If <em class="xref py py-obj">detailLevel == 1</em>, a dictionary containing all printed information is returned</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.getParam" title="itom.dataIO.getParam"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getParam</span></code></a>, <a class="reference internal" href="#itom.dataIO.setParam" title="itom.dataIO.setParam"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setParam</span></code></a>, <a class="reference internal" href="#itom.dataIO.getParamInfo" title="itom.dataIO.getParamInfo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getParamInfo</span></code></a>, <a class="reference internal" href="#itom.dataIO.getParamList" title="itom.dataIO.getParamList"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getParamList</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.getType">
<code class="sig-name descname">getType</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; returns dataIO type<a class="headerlink" href="#itom.dataIO.getType" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="itom.dataIO.getVal">
<code class="sig-name descname">getVal</code><span class="sig-paren">(</span><em class="sig-param">buffer=`dataObject`|`bytearray`|`bytes`</em>, <em class="sig-param">length = maxlength</em><span class="sig-paren">)</span> &#x2192; returns shallow copy of internal camera image if `dataObject`-buffer is provided. Else values from plugin are copied to given byte or byte-array buffer.<a class="headerlink" href="#itom.dataIO.getVal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference (shallow copy) of the recently acquired image (located in the internal memory if the plugin) if the plugin is a grabber or camera and the buffer is a <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dataObject</span></code></a>. 
Please consider that the values of the <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dataObject</span></code></a> might change if a new image is acquired since it is only a reference. Therefore consider copying the <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dataObject</span></code></a> or directly use 
<a class="reference internal" href="#itom.dataIO.copyVal" title="itom.dataIO.copyVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copyVal</span></code></a>.</p>
<p>If no acquisition has been triggered, this method raises a RuntimeError. If the acquisition is not finished yet, this method 
blocks and waits until the end of the acquisition.</p>
<p>If the plugin is another type than a grabber or camera (e.g. serialIO), this method requires any buffer-object that is preallocated with a reasonable size. Then, the currently available 
data is copied into this buffer object and the size of the copied data is returned. If the buffer is too small, only the data that fits into the buffer is copied. Another call to 
<a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getVal</span></code></a> will copy the rest.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>buffer</strong> : {<a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dataObject</span></code></a>, <em class="xref py py-obj">bytearray</em>, <em class="xref py py-obj">bytes</em> or <em class="xref py py-obj">str</em>}</p>
<blockquote>
<div><p>this parameter depends on the type of dataIO-instance:</p>
<ul class="simple">
<li><p>cameras, grabber: the buffer must be a <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dataObject</span></code></a> (no length parameter): A reference (shallow copy) to the internal memory of the camera plugin is set to the given data object.     Therefore its content may change if a new image is being acquired by the camera. Consider taking a deep copy if the image (<a class="reference internal" href="dataObject.html#itom.dataObject.copy" title="itom.dataObject.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dataObject.copy</span></code></a>) or use the method <a class="reference internal" href="#itom.dataIO.copyVal" title="itom.dataIO.copyVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copyVal</span></code></a>.</p></li>
<li><p>other IO-devices (AD-converters): The buffer must be an object of type <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dataObject</span></code></a>, bytearray, bytes or unicode string. The length parameter is then set to the size of the buffers. The effective     size of the used memory in buffer is returned.</p></li>
</ul>
</div></blockquote>
<p><strong>length</strong> : {int}, optional</p>
<blockquote>
<div><p>size of the given buffer. This value is usually automatically determined and must not be given.</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>out</strong> : {None or int}</p>
<blockquote>
<div><p>None or size of used buffer if buffer is no <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dataObject</span></code></a></p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.copyVal" title="itom.dataIO.copyVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copyVal</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.hideToolbox">
<code class="sig-name descname">hideToolbox</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; hides toolbox of the plugin<a class="headerlink" href="#itom.dataIO.hideToolbox" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError</strong> :</p>
<blockquote>
<div><p>if plugin does not provide a toolbox</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.showToolbox" title="itom.dataIO.showToolbox"><code class="xref py py-obj docutils literal notranslate"><span class="pre">showToolbox</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.info">
<code class="sig-name descname">info</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span> &#x2192; returns information about signal and slots.<a class="headerlink" href="#itom.dataIO.info" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>verbose</strong> : {int}</p>
<blockquote>
<div><p>0: only slots and signals from the plugin class are printed (default) 
1: all slots and signals from all inherited classes are printed</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.name">
<code class="sig-name descname">name</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; returns the plugin name<a class="headerlink" href="#itom.dataIO.name" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>name</strong> : {str}</p>
<blockquote>
<div><p>name of the plugin, which corresponds to <em class="xref py py-obj">getParam(‘name’)</em></p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.getParam" title="itom.dataIO.getParam"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getParam</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.setAutoGrabbing">
<code class="sig-name descname">setAutoGrabbing</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">on</span></em><span class="sig-paren">)</span> &#x2192; Set auto grabbing of the grabber device to on or off<a class="headerlink" href="#itom.dataIO.setAutoGrabbing" title="Permalink to this definition">¶</a></dt>
<dd><p>If the auto grabbing flag is set, the camera acquisition is automatically and continuously triggered if at least one live image is 
connected. This is an undesired behaviour if a measurement is started where the acquisition should be controlled by a specific 
script or something similar. Then disable the auto grabbing property. All connected live images will then get new images when 
<a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getVal</span></code></a> or <a class="reference internal" href="#itom.dataIO.copyVal" title="itom.dataIO.copyVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copyVal</span></code></a> is called by the script. The live image timer is disabled.</p>
<p>This method allows setting this flag.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>on</strong> : {bool}</p>
<blockquote>
<div><ul class="simple">
<li><p>TRUE = on</p></li>
<li><p>FALSE = off</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.enableAutoGrabbing" title="itom.dataIO.enableAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">enableAutoGrabbing</span></code></a>, <a class="reference internal" href="#itom.dataIO.disableAutoGrabbing" title="itom.dataIO.disableAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">disableAutoGrabbing</span></code></a>, <a class="reference internal" href="#itom.dataIO.getAutoGrabbing" title="itom.dataIO.getAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getAutoGrabbing</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.setAutoGrabbingInterval">
<code class="sig-name descname">setAutoGrabbingInterval</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Sets the current auto grabbing interval (in ms) without dis- or enabling the auto grabber<a class="headerlink" href="#itom.dataIO.setAutoGrabbingInterval" title="Permalink to this definition">¶</a></dt>
<dd><p>If auto grabbing is enabled for a grabber device, a timer is set that continuously acquires data or images from the devices and sends it 
to all connected windows or listeners. The timer event will occur with a certain interval (in ms). However, if the image acquisition 
requires more time than the interval, several events can be omitted, such that the next image is only acquired if the grabber device 
is in an idle state. Hence, the interval is considered to be a minimum value.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>interval</strong> : {int}</p>
<blockquote>
<div><p>Interval in ms.</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.enableAutoGrabbing" title="itom.dataIO.enableAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">enableAutoGrabbing</span></code></a>, <a class="reference internal" href="#itom.dataIO.disableAutoGrabbing" title="itom.dataIO.disableAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">disableAutoGrabbing</span></code></a>, <a class="reference internal" href="#itom.dataIO.getAutoGrabbing" title="itom.dataIO.getAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getAutoGrabbing</span></code></a>, <a class="reference internal" href="#itom.dataIO.setAutoGrabbing" title="itom.dataIO.setAutoGrabbing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setAutoGrabbing</span></code></a>, <a class="reference internal" href="#itom.dataIO.getAutoGrabbingInterval" title="itom.dataIO.getAutoGrabbingInterval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getAutoGrabbingInterval</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.setParam">
<code class="sig-name descname">setParam</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span> &#x2192; sets parameter ‘name’ to the given value.<a class="headerlink" href="#itom.dataIO.setParam" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the internal plugin parameter with ‘name’ to a new value. The plugin itsself can decide whether the given value is 
accepted as new value. This may depend on the type of the given value, but also on the allowed value range indicated by 
further meta information of the internal parameter. Parameters that have the read-only flag set can not be reset.</p>
<p>The name of the parameter must have the following form:</p>
<ul class="simple">
<li><p>name</p></li>
<li><p>name:additionalTag (additionalTag can be a special feature of some plugins)</p></li>
<li><p>name[index] (only possible if parameter is an array type and you only want to get one single value, specified by the integer index [0,nrOfArrayItems-1])</p></li>
<li><p>name[index]:additionalTag</p></li>
</ul>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> : {str}</p>
<blockquote>
<div><p>name of the parameter</p>
</div></blockquote>
<p><strong>value</strong> : {str, int, double, …}</p>
<blockquote>
<div><p>value that will be set. Only the name and existance of the parameter is checked before passing the request to the plugin. 
The plugin itsself is responsible for further validations (including read-only attribute).</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.getParam" title="itom.dataIO.getParam"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getParam</span></code></a>, <a class="reference internal" href="#itom.dataIO.getParamList" title="itom.dataIO.getParamList"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getParamList</span></code></a>, <a class="reference internal" href="#itom.dataIO.getParamListInfo" title="itom.dataIO.getParamListInfo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getParamListInfo</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.setVal">
<code class="sig-name descname">setVal</code><span class="sig-paren">(</span><em class="sig-param">dataObjectOrBuffer</em><span class="optional">[</span>, <em class="sig-param">length=1</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; transfer given `dataObject` to ADDA plugin or further buffer to other dataIO plugin.<a class="headerlink" href="#itom.dataIO.setVal" title="Permalink to this definition">¶</a></dt>
<dd><p>If the dataIO plugin has the subtype ADDA, this method is used to send data to one or more analog outputs of the device. 
In this case a <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dataObject</span></code></a> must be given as first argument and the second argument <em class="xref py py-obj">length</em> must be 1.</p>
<p>For other dataIO plugins, the first argument must be any buffer object, like <em class="xref py py-obj">bytearray</em>, <em class="xref py py-obj">bytes</em> or <em class="xref py py-obj">unicode string</em>. The length is then extracted 
from this value. However it is also possible to define a user-defined size using the ‘length’ argument.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dataObjectOrBuffer</strong> : {<a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dataObject</span></code></a>, <em class="xref py py-obj">bytearray</em>, <em class="xref py py-obj">bytes</em>, <em class="xref py py-obj">str</em>}</p>
<blockquote>
<div><p>value to send to plugin. For an ADDA plugin, a <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dataObject</span></code></a> is required whose content is sent to the analogous outputs of the device. For other dataIO 
plugins buffer values like <em class="xref py py-obj">bytearray</em>, <em class="xref py py-obj">bytes</em> or <em class="xref py py-obj">unicode string</em> are required.</p>
</div></blockquote>
<p><strong>length</strong> : {int}, optional</p>
<blockquote>
<div><p>usually this value is not required, since the length of the buffer is automatically extracted from the given objects and 1 for a <a class="reference internal" href="dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dataObject</span></code></a></p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.showConfiguration">
<code class="sig-name descname">showConfiguration</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; show configuration dialog of the plugin<a class="headerlink" href="#itom.dataIO.showConfiguration" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError</strong> :</p>
<blockquote>
<div><p>if plugin does not provide a configuration dialog</p>
</div></blockquote>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.showToolbox">
<code class="sig-name descname">showToolbox</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; open toolbox of the plugin<a class="headerlink" href="#itom.dataIO.showToolbox" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError</strong> :</p>
<blockquote>
<div><p>if plugin does not provide a toolbox</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.hideToolbox" title="itom.dataIO.hideToolbox"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hideToolbox</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.startDevice">
<code class="sig-name descname">startDevice</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">count</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span> &#x2192; starts the given dataIO-plugin.<a class="headerlink" href="#itom.dataIO.startDevice" title="Permalink to this definition">¶</a></dt>
<dd><p>This command starts the dataIO plugin such that it is ready for data acquisition. Call this method before you start 
using commands like acquire, <a class="reference internal" href="#itom.dataIO.getVal" title="itom.dataIO.getVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">getVal</span></code></a> or <a class="reference internal" href="#itom.dataIO.copyVal" title="itom.dataIO.copyVal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copyVal</span></code></a>. If the device already is started, an internal start-counter is incremented 
by the parameter ‘count’. The corresponding <a class="reference internal" href="#itom.dataIO.stopDevice" title="itom.dataIO.stopDevice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stopDevice</span></code></a> method then decrements this counter and finally stops the device once 
the counter drops to zero again.</p>
<p>The counter is necessary, since every connected live image needs to start the device without knownledge about any 
previous start. No acquisition is possible, if the device has not been started, hence the counter is 0.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>count</strong> : {int}, optional</p>
<blockquote>
<div><p>Number of increments to the internal start-counter [default:1]</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.stopDevice" title="itom.dataIO.stopDevice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stopDevice</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.stop">
<code class="sig-name descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; stops a started, continuous acquisition<a class="headerlink" href="#itom.dataIO.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>This method stops a previously started, continuous data acquisition. This method is not always 
implemented in plugins. A common example for its implementation is to stop an infinite, continuous 
acquisition job of a AD-converter plugin.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.acquire" title="itom.dataIO.acquire"><code class="xref py py-obj docutils literal notranslate"><span class="pre">acquire</span></code></a></p>
</div>
</dd></dl>

<dl class="py method">
<dt id="itom.dataIO.stopDevice">
<code class="sig-name descname">stopDevice</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">count</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span> &#x2192; stops the given dataIO-plugin.<a class="headerlink" href="#itom.dataIO.stopDevice" title="Permalink to this definition">¶</a></dt>
<dd><p>If this method is called as many times as the corresponding <a class="reference internal" href="#itom.dataIO.startDevice" title="itom.dataIO.startDevice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">startDevice</span></code></a> (or if the counts are equal), the 
dataIO device is stopped (not deleted) and it is not possible to acquire further data.</p>
<p>Once a live image is connected to a camera, <a class="reference internal" href="#itom.dataIO.startDevice" title="itom.dataIO.startDevice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">startDevice</span></code></a> is automatically called at start of the live acquisition 
and <a class="reference internal" href="#itom.dataIO.stopDevice" title="itom.dataIO.stopDevice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stopDevice</span></code></a> at shutdown.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>count</strong> : {int}, optional</p>
<blockquote>
<div><p>default = 1
if count &gt; 1, <a class="reference internal" href="#itom.dataIO.stopDevice" title="itom.dataIO.stopDevice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stopDevice</span></code></a> is executed ‘count’ times, in order to decrement the grabber internal start counter. 
You can also use -1 as count argument, then <a class="reference internal" href="#itom.dataIO.stopDevice" title="itom.dataIO.stopDevice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stopDevice</span></code></a> is repeated until the internal start counter is 0. The number of effective counts is then returned</p>
</div></blockquote>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>counts</strong> : {None or int}</p>
<blockquote>
<div><p>If <em class="xref py py-obj">count == -1</em> the number of required counts to finally stop the device is returned. Else: None</p>
</div></blockquote>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#itom.dataIO.startDevice" title="itom.dataIO.startDevice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">startDevice</span></code></a></p>
</div>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dataObject.html" class="btn btn-neutral float-right" title="10.6. dataObject" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="autoInterval.html" class="btn btn-neutral float-left" title="10.4. autoInterval" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2011-2020, Institut fuer Technische Optik (ITO), University Stuttgart. Bug report: https://bitbucket.org/itom/itom/issues
      <span class="lastupdated">
        Last updated on Oct 02, 2020.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>