<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>DataObject &mdash; itom Documentation</title>
    
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/breathe.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/breathe.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/breathe.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/breathe.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '5f9a611',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="itom Documentation" href="../../index.html" />
    <link rel="up" title="Development under C++" href="plugin-development.html" />
    <link rel="next" title="RetVal - Reference" href="plugin-RetVal-Ref.html" />
    <link rel="prev" title="ItomSharedSemaphore - Reference" href="plugin-sharedSemaphore-Ref.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="plugin-RetVal-Ref.html" title="RetVal - Reference"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="plugin-sharedSemaphore-Ref.html" title="ItomSharedSemaphore - Reference"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">itom</a> &raquo;</li>
          <li><a href="../../structure.html" >Structure of the manual</a> &raquo;</li>
          <li><a href="../plugins.html" >Plugins</a> &raquo;</li>
          <li><a href="plugin-development.html" accesskey="U">Development under C++</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="dataobject">
<span id="plugin-dataobject"></span><h1>DataObject<a class="headerlink" href="#dataobject" title="Permalink to this headline">¶</a></h1>
<p>The class <strong>DataObject</strong> (part of the library <strong>dataObject</strong>) provides a <em>n</em>-dimensional matrix that is used both in the core of <strong>itom</strong> as well as
in any plugins. The <em>n</em>-dimensional matrix can have different element types. These types and their often used enumeration value are defined
in the file <em>typeDefs.h</em> and are as follows.</p>
<table border="1" class="docutils">
<colgroup>
<col width="22%" />
<col width="22%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Typedef</th>
<th class="head">Enumeration</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>ito::int8</td>
<td>ito::tInt8</td>
<td>8bit, signed, fixed point</td>
</tr>
<tr class="row-odd"><td>ito::uint8</td>
<td>ito::tUint8</td>
<td>8bit, unsigned, fixed point</td>
</tr>
<tr class="row-even"><td>ito::int16</td>
<td>ito::tInt16</td>
<td>16bit, signed, fixed point</td>
</tr>
<tr class="row-odd"><td>ito::uint16</td>
<td>ito::tUint16</td>
<td>16bit, unsigned, fixed point</td>
</tr>
<tr class="row-even"><td>ito::int32</td>
<td>ito::tInt32</td>
<td>32bit, signed, fixed point</td>
</tr>
<tr class="row-odd"><td>ito::uint32</td>
<td>ito::tUint32</td>
<td>32bit, unsigned, fixed point</td>
</tr>
<tr class="row-even"><td>ito::float32</td>
<td>ito::tFloat32</td>
<td>32bit, single-precision floating point</td>
</tr>
<tr class="row-odd"><td>ito::float64</td>
<td>ito::tFloat64</td>
<td>64bit, double-precision floating point</td>
</tr>
<tr class="row-even"><td>ito::complex64</td>
<td>ito::tComplex64</td>
<td>real and imaginary part is float32 each</td>
</tr>
<tr class="row-odd"><td>ito::complex128</td>
<td>ito::tComplex128</td>
<td>real and imaginary part is float64 each</td>
</tr>
</tbody>
</table>
<p>The last two dimensions of each dataObject are denoted <em>plane</em> and physically correspond to images. In order to also handle huge matrices in memory,
The entire matrix is divided into planes, where each plane can be allocated at arbitrary positions and memory and is of type <strong>cv::Mat_&lt;type&gt;</strong>,
derived from <strong>cv::Mat</strong> of the <strong>OpenCV</strong> library. Therefore every plane can be used with every operator given by the <strong>OpenCV</strong>-framework (version 2.3.1
or higher). If available, the first <em>(n-2)</em> are allocated as one vector of pointers, each pointing to its corresponding plane. This kind of
dataObject and its way of allocating memory is called <em>unorganized</em>.</p>
<p>In order to make the <em>dataObject</em> compatible to matrices that are allocated in one huge memory block (like Numpy arrays), it is also possible to
make any <em>dataObject</em> continuous. Then, a huge data block is allocated, such that all planes lie consecutively in memory. Nevertheless, the pointer-tree
is still available, pointing to the starting points of all planes. This reallocation is implicitely done, when creating a Numpy-array from a dataObject.</p>
<p>DataObject can be declared in different possible ways with different dimensions and different data types.
Various possible implementations of declaring DataObject are listed below.</p>
<ol class="arabic simple">
<li>DataObject();</li>
<li>DataObject(const size_t size, const int type);</li>
<li>DataObject(const size_t sizeY, const size_t sizeX, const int type);</li>
<li>DataObject(const size_t sizeZ, const size_t sizeY, const size_t sizeX, const int type ,const unsigned char continuous = (unsigned char)&#8216;000&#8217;);</li>
<li>DataObject(const unsigned char diimesions, const size_t <a href="#id1"><span class="problematic" id="id2">*</span></a>sizes, const int type, const unsigned char continuous = (unsigned char)&#8216;000&#8217;);</li>
<li>DataObject(const unsigned char dimensions, const size_t <a href="#id3"><span class="problematic" id="id4">*</span></a>sizes, const int type, const uchar &#8220;continousouDataPtr, const size_t <a href="#id5"><span class="problematic" id="id6">*</span></a>steps = (const size_t <a href="#id7"><span class="problematic" id="id8">*</span></a>)0);</li>
<li>DataObject(const size_t sizeZ, const size_t sizeY, const size_t sizeX, const int type, const uchar*continuousDataPtr, const size_t <a href="#id9"><span class="problematic" id="id10">*</span></a>steps = (const size_t <a href="#id11"><span class="problematic" id="id12">*</span></a>)0);</li>
<li>DataObject(const ito::DataObject &amp;copyConstr);</li>
<li>DataObject(const unsigned char dimensions, const size_t <a href="#id13"><span class="problematic" id="id14">*</span></a>sizes, const int type, const cv::Mat <a href="#id15"><span class="problematic" id="id16">*</span></a>planes, const unsigned int nrOfPlanes);</li>
<li>DataObject(const ito::DataObject dObj);</li>
</ol>
<p>Let&#8217;s take an example of a data object with a dimensions 3x2x5. It can be imagined as shown in the figure below.</p>
<a class="reference internal image-reference" href="../../_images/DataObject.png"><img alt="../../_images/DataObject.png" src="../../_images/DataObject.png" style="width: 812.0px; height: 369.0px;" /></a>
<p>As we can see in this figure, each plane is of a type <strong>cv::Mat</strong> class from <strong>openCV</strong> library which we know.
<strong>m_data</strong> corresponds to the zero-based two-dimensional matrix-index for a perticular plane.
This matrix-index can be retrieved using <strong>seekMat()</strong> method and later on with the use of <strong>get_mdata()</strong> method, we can have the matrix pointer of the whole plane. The return type of <strong>get_mdata()</strong> method is <strong>int*</strong> which can be type-casted by <strong>cv:Mat*</strong> easily.
Please read the section <a class="reference internal" href="#direct-access-to-the-underlying-cv-mat">Direct Access to the underlying cv::Mat</a> to understand this concept in detail with a working example.</p>
<p>Following are some sample codes to get one quickly understand <em>basic programing structure of Data Objects</em>.</p>
<div class="section" id="example-codes">
<h2>Example Codes<a class="headerlink" href="#example-codes" title="Permalink to this headline">¶</a></h2>
<p><strong>itom</strong></p>
<p>The following code creates empty data object with no dimensions (0) and no type (0).</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="n">d0</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;empty data object: </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; dimensions: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d0</span><span class="p">.</span><span class="n">getDims</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; type: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d0</span><span class="p">.</span><span class="n">getType</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Here <strong>getDims()</strong> method returns the dimensions of data object d0, whereas <strong>getType()</strong> method returns the type of d0.</p>
</div>
<p>Now, lets take an example of creating a two dimensional data object.</p>
<p>The following code creates such 2 dimensional data object of dimensions Y=2, X=5 and of type float32.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="n">d1</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="n">ito</span><span class="o">::</span><span class="n">tFloat32</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;2x5 data object, float32: </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; dimensions: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d1</span><span class="p">.</span><span class="n">getDims</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; type: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d1</span><span class="p">.</span><span class="n">getType</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; size: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d1</span><span class="p">.</span><span class="n">getSize</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; x &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d1</span><span class="p">.</span><span class="n">getSize</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; total: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d1</span><span class="p">.</span><span class="n">getTotal</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Here, <strong>getSize()</strong> method returns the size of each dimension of a data object d1.
<strong>getDims()</strong> method returns the number of dimensions of d1.
<strong>getType()</strong> method returns the type of d1.
<strong>getTotal()</strong> method returns total number of elements in d1.</p>
</div>
</div>
</div>
<div class="section" id="addressing-the-elements-of-a-data-object">
<h1>Addressing the elements of a data object<a class="headerlink" href="#addressing-the-elements-of-a-data-object" title="Permalink to this headline">¶</a></h1>
<p>Now, we know how to create a data object, so lets have a look at how can one address the elements of a data object.
Sometimes it is necessary to read or set single values in one matrix, sometimes one want to access all elements
in the matrix or a certain subregion. Therefore, the addressing can be done in one of the following ways:</p>
<div class="section" id="direct-access-of-one-single-element-of-a-data-object-using-at-method">
<h2>Direct access of one single element of a Data Object using <strong>at()</strong> method<a class="headerlink" href="#direct-access-of-one-single-element-of-a-data-object-using-at-method" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="n">d1</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="n">ito</span><span class="o">::</span><span class="n">tFloat32</span><span class="p">);</span>
<span class="n">d1</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">ito</span><span class="o">::</span><span class="n">float32</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">5.2</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;d1(0,1) = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d1</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">ito</span><span class="o">::</span><span class="n">float32</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Here, the addressing is done by the method <strong>at()</strong> under the class ito::DataObject, which is pretty similar to the same method
under the <strong>OpenCV</strong> class <strong>cv::Mat</strong>. The <strong>at()</strong> method can either be used to get the value at a certain position or
to set value at that position in a data object. There are special implementations of <strong>at()</strong> for addressing values in a two- or three-dimensional
data object, where the first argument always is the <strong>z-index</strong> (3D), followed by the <strong>y-index</strong> and the <strong>x-index</strong>.
All indices are zero-based, hence the first element can be referred by addressing <strong>0th position</strong> in every dimension.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <strong>at()</strong> method is templated where the template parameter must correspond to the type of the corresponding
data object.</p>
</div>
<p>Let&#8217;s try to summerize some pros and cons of this method.</p>
<div class="section" id="advantages">
<h3>Advantages<a class="headerlink" href="#advantages" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>This method gives flexibility to a developer to access any element of a data object directly.</li>
<li>A developer can also access a part of a data object as well using <strong>at()</strong> method as described in <a class="reference internal" href="#direct-access-to-the-underlying-cv-mat">Direct Access to the underlying cv::Mat</a>.</li>
</ul>
</div>
<div class="section" id="drawbacks">
<h3>Drawbacks<a class="headerlink" href="#drawbacks" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Developer has to implement the code under the nest of <strong>if...else</strong> conditions if one needs to access the whole data object.</li>
<li>It is a slower method to execute performance wise if compared to the other methods of accessing the data object.</li>
</ul>
</div>
</div>
<div class="section" id="addressing-elements-of-a-data-object-using-row-pointer">
<h2>Addressing elements of a data object using row pointer<a class="headerlink" href="#addressing-elements-of-a-data-object-using-row-pointer" title="Permalink to this headline">¶</a></h2>
<p>When one needs to iterate through certain region of a data object, then the previous method of accessing a data object using <strong>at</strong> method seems quite insufficient.
In such case, one can define a row pointer for each row in matrix and work with row pointer to address elements of a data object in a following way.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="n">d1</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="n">ito</span><span class="o">::</span><span class="n">tInt16</span><span class="p">);</span>
<span class="n">size_t</span> <span class="n">planeID</span> <span class="o">=</span> <span class="n">d1</span><span class="p">.</span><span class="n">seekMat</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>   <span class="c1">//get internal plane number for the first plane</span>
<span class="n">ito</span><span class="o">::</span><span class="n">int16</span> <span class="o">*</span><span class="n">rowPtr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ito</span><span class="o">::</span><span class="n">int16</span><span class="o">*</span><span class="p">)</span><span class="n">d1</span><span class="p">.</span><span class="n">rowPtr</span><span class="p">(</span><span class="n">planeID</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
<span class="n">size_t</span> <span class="n">height</span> <span class="o">=</span> <span class="n">d1</span><span class="p">.</span><span class="n">getSize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">size_t</span> <span class="n">width</span> <span class="o">=</span> <span class="n">d1</span><span class="p">.</span><span class="n">getSize</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">m</span><span class="o">&lt;</span> <span class="n">height</span> <span class="p">;</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">rowPtr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ito</span><span class="o">::</span><span class="n">int16</span><span class="o">*</span><span class="p">)</span><span class="n">d1</span><span class="p">.</span><span class="n">rowPtr</span><span class="p">(</span><span class="n">planeID</span><span class="p">,</span><span class="n">m</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Row &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:&quot;</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">size_t</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span> <span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
                <span class="n">rowPtr</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>                          <span class="c1">//accessing each element of data object with row pointer</span>
        <span class="p">}</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Here, <strong>seekMat()</strong> method gets the internal plane number of the 1st plane in line #2.
In line #3, dynamic array rowPtr is defined as row pointer to the 0th plane of the data object d1.
Now accessing each element of row pointer will access each element of the data object in that row.</p>
<p>To use this row pointer method for data objects more than 2 dimensions, following code can be used.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ito</span><span class="o">::</span><span class="n">int16</span> <span class="o">*</span><span class="n">rowPtr1</span><span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">dim1</span> <span class="o">=</span> <span class="n">d1</span><span class="p">.</span><span class="n">getSize</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dim2</span> <span class="o">=</span> <span class="n">d1</span><span class="p">.</span><span class="n">getSize</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dim3</span> <span class="o">=</span> <span class="n">d1</span><span class="p">.</span><span class="n">getSize</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dim4</span> <span class="o">=</span> <span class="n">d1</span><span class="p">.</span><span class="n">getSize</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dim5</span> <span class="o">=</span> <span class="n">d1</span><span class="p">.</span><span class="n">getSize</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="n">size_t</span> <span class="n">dataIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">dim1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">dim2</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">dim3</span><span class="p">;</span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">dataIdx</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="n">dim2</span><span class="o">*</span><span class="n">dim3</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="n">dim3</span> <span class="o">+</span> <span class="n">k</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">dim4</span><span class="p">;</span><span class="n">l</span><span class="o">++</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">rowPtr1</span><span class="o">=</span> <span class="p">(</span><span class="n">TypeParam</span><span class="o">*</span><span class="p">)</span><span class="n">d1</span><span class="p">.</span><span class="n">rowPtr</span><span class="p">(</span><span class="n">dataIdx</span><span class="p">,</span><span class="n">l</span><span class="p">);</span>
                <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">m</span><span class="o">&lt;</span><span class="n">dim5</span><span class="p">;</span><span class="n">m</span><span class="o">++</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="c1">//Assigning unique value to each element of d1.</span>
                    <span class="n">rowPtr1</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">TypeParam</span><span class="o">&gt;</span><span class="p">(</span><span class="n">calcUniqueValue5D</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">));</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Here <strong>dataIdx</strong> represents the number of the plane in the matrix.
The formula in line #14 assigns a non repeating increasing value to dataIdx such that each plane of the data object can be pointed out without any overlapping.</p>
</div>
<p>Some advantages and disadvantages of using this method are given in the section below.</p>
<div class="section" id="id17">
<h3>Advantages<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>This method is the most efficient way to access the data object.</li>
<li>This method gives flexibility to access some rows or the full data object at once.</li>
</ul>
</div>
<div class="section" id="id18">
<h3>Drawbacks<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Complex implementation. One needs deep understanding of pointers to implement this method to access data object.</li>
<li>This is not an advisable method if one needs to access a few elements of the data object which are not in sequence.</li>
</ul>
</div>
</div>
<div class="section" id="assigning-a-single-value-to-all-elements-of-a-data-object">
<h2>Assigning a single value to all elements of a Data Object<a class="headerlink" href="#assigning-a-single-value-to-all-elements-of-a-data-object" title="Permalink to this headline">¶</a></h2>
<p>One can assign a single value to all elements of a data object using assignment operator &#8220;=&#8221; in the following way.
Here we will also have a look on how to declare a 5 dimensional data object and assign a single floating point value to each element of the data object.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">size_t</span> <span class="o">*</span><span class="n">temp_size</span> <span class="o">=</span> <span class="k">new</span> <span class="n">size_t</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">temp_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">temp_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
<span class="n">temp_size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
<span class="n">temp_size</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">18</span><span class="p">;</span>
<span class="n">temp_size</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="n">temp_size</span><span class="p">,</span><span class="n">ito</span><span class="o">::</span><span class="n">tFloat32</span><span class="p">);</span>
<span class="n">d1</span> <span class="o">=</span> <span class="mf">3.7</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="k">delete</span><span class="p">[]</span> <span class="n">temp_size</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Here line #7 uses implementation #4 for declaring 5 dimensional data object d1.</p>
</div>
<div class="section" id="direct-access-to-the-underlying-cv-mat">
<h2>Direct Access to the underlying cv::Mat<a class="headerlink" href="#direct-access-to-the-underlying-cv-mat" title="Permalink to this headline">¶</a></h2>
<p>In some cases, one needs to assign values of elements of a data objects based on some portion of another data object.
This can be done by using this method of accessing the underlying matrix (cv::Mat) of a data object directly.
Following example shows the method to access underlying planes in multidimensional matrices.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">// 4 x 5 x 3 DataObject, int16</span>
<span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="n">d4</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">ito</span><span class="o">::</span><span class="n">tInt16</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;DataObject (4x5x3), int16 </span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">d4</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>         <span class="c1">//assign value 3 to all elements</span>
<span class="c1">//access to the third plane (index 2)</span>
<span class="n">planeID</span> <span class="o">=</span> <span class="n">d4</span><span class="p">.</span><span class="n">seekMat</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="o">*</span><span class="n">plane3</span> <span class="o">=</span> <span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">*</span><span class="p">)</span><span class="n">d4</span><span class="p">.</span><span class="n">get_mdata</span><span class="p">()[</span><span class="n">planeID</span><span class="p">];</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;OpenCV plane&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">plane3</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="c1">//accessing second line in plane3</span>
<span class="n">ito</span><span class="o">::</span><span class="n">int16</span><span class="o">*</span> <span class="n">rowPtr2</span> <span class="o">=</span> <span class="p">(</span><span class="n">ito</span><span class="o">::</span><span class="n">int16</span><span class="o">*</span><span class="p">)</span><span class="n">plane3</span><span class="o">-&gt;</span><span class="n">ptr</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">//regions of interest</span>
<span class="c1">//d5 = d4[1:3,0:2,:]</span>
<span class="n">ito</span><span class="o">::</span><span class="n">Range</span> <span class="n">ranges</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">ito</span><span class="o">::</span><span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">ito</span><span class="o">::</span><span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">ito</span><span class="o">::</span><span class="n">Range</span><span class="o">::</span><span class="n">all</span><span class="p">()</span> <span class="p">};</span>
<span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span>  <span class="n">d5</span> <span class="o">=</span> <span class="n">d4</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">ranges</span><span class="p">);</span>
<span class="n">d5</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Let&#8217;s try to analyse the code above. As we can see in line #6, we used <strong>seekMat()</strong> method to retrieve the plane id of 3rd plane in 3 dimensional matrix d4.</p>
<p>line #7 declares a pointer variable plane3 of type cv::Mat to hold the contents of plane 3 of data object d4. Line #11 declares a row pointer to point a perticular row
in plane 3 of data object d4 as a revision to the previous method of accessing elements of a data object using row pointer.</p>
<p>line #14 defines the exemplary ranges to create a new data object d5 from a part of data object d4, which is done in line #15 with the use of <strong>at()</strong> method.</p>
<p>The other way to perform the same operation of line #14 is shown below.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ito</span><span class="o">::</span><span class="n">Range</span> <span class="o">*</span><span class="n">ranges</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ito</span><span class="o">::</span><span class="n">Range</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ito</span><span class="o">::</span><span class="n">Range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
<span class="n">ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ito</span><span class="o">::</span><span class="n">Range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
<span class="n">ranges</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ito</span><span class="o">::</span><span class="n">Range</span><span class="o">::</span><span class="n">all</span><span class="p">();</span>
</pre></div>
</td></tr></table></div>
<p>This code shows the way to modify ranges individually, which can be very useful if one needs to modify this range later in this code to work on other data objects perhaps.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>get_mdata()</strong> is a function declared under <em>DataObject</em> class. It returns pointer to vector of <em>cv::_Mat-matrices</em>.</p>
</div>
</div>
<div class="section" id="accessing-all-elements-of-a-data-object-using-iterators">
<h2>Accessing all elements of a Data Object using iterators<a class="headerlink" href="#accessing-all-elements-of-a-data-object-using-iterators" title="Permalink to this headline">¶</a></h2>
<p>There are two classes defined, called <strong>DObjIterator</strong> and <strong>DObjConstIterator</strong> respectively, under the namespace <strong>ITOM</strong>, which support the developer with an easy way to iterate through
the whole data object.
This method can be used only if one needs to iterate through all elements of a data object at once.
Following code snippet shows the example of this method.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>           <span class="c1">// Temporary variable for indexing some arrays used in this test.</span>
<span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="n">d6</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="n">ito</span><span class="o">::</span><span class="n">tInt16</span><span class="p">);</span>   <span class="c1">// Declaring a 21 x 13 data object with data type int16.</span>
<span class="n">ito</span><span class="o">::</span><span class="n">DObjIterator</span> <span class="n">it</span><span class="p">;</span>   <span class="c1">// Declaration of DObjIterator</span>
<span class="k">for</span><span class="p">(</span><span class="n">it</span><span class="o">=</span><span class="n">d6</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="n">it</span><span class="o">!=</span><span class="n">d6</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="o">++</span><span class="n">it</span><span class="p">)</span>
<span class="p">{</span>
        <span class="o">*</span><span class="p">((</span><span class="n">ito</span><span class="o">::</span><span class="n">int16</span><span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="n">it_2d</span><span class="p">))</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">TypeParam</span><span class="o">&gt;</span><span class="p">(</span><span class="n">temp</span><span class="o">++</span><span class="p">);</span>        <span class="c1">// Assigning a unique value to each element of a data object using iterator.</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>As can be seen in the code above, line #2 declares a 21x31 data object d6 of type int16. Line #3 declares an iterator object <strong>it</strong> of class <strong>DObjIterator</strong>.
DataObject class contains <strong>being()</strong> and <strong>end()</strong> methods to work with iterators. A brief description to this methods can be found under <a class="reference internal" href="plugin-DataObject-Ref.html#plugin-dataobject-ref"><em>DataObject - Reference</em></a> document.
These methods contains pointers to the first and last elements of any data objects respectively.
Line #4 makes a meaningful use of these methods in for loop to iterate through the data object <strong>d6</strong>. We first initiate the iterator <strong>it</strong> with the pointer returned by
<strong>d6.begin()</strong>, iterate through the whole data object increasing the iterator value by one in each iteration till the pointer value in iterator <strong>it</strong> reaches the pointer value of the
last element of the data object checking the condition <strong>it!=d6.end()</strong>.</p>
<div class="section" id="id19">
<h3>Advantages<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>This method is a compromise between its useability with ease and performance on execution level. Integration of this method in code is fast and easy.</li>
<li>Developer does not think about <strong>if...else</strong> conditions to decide the boundaries of Region of Interest to access any data object.</li>
</ul>
</div>
<div class="section" id="id20">
<h3>Drawbacks<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Performance degrades against the method <a class="reference internal" href="#addressing-elements-of-a-data-object-using-row-pointer">Addressing elements of a data object using row pointer</a>.</li>
<li>It is not advisable to use this method if one needs to access some part or a single element of a data object.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="working-with-data-objects">
<h1>Working with Data Objects<a class="headerlink" href="#working-with-data-objects" title="Permalink to this headline">¶</a></h1>
<p>Now, lets have a look on various methods to work with data objects.</p>
<div class="section" id="creating-eye-matrix">
<h2>Creating Eye Matrix<a class="headerlink" href="#creating-eye-matrix" title="Permalink to this headline">¶</a></h2>
<p>Any square Data Object might need to be converted in eye matrix during many operations in matrix calculations.
This can be quickly done using function <strong>eye()</strong> declared under <em>DataObject</em> class.
Syntax for the function <strong>eye()</strong> is shown below.</p>
<p><em>dataObjectName.eye(noOfDimensions, dataType);</em></p>
<p><em>Return Type: void</em></p>
<p>To understand the use of this function, following is an exemplary code given. Let&#8217;s have a look at it.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="o">*</span><span class="n">d2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span><span class="p">();</span>
<span class="n">d2</span><span class="o">-&gt;</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">ito</span><span class="o">::</span><span class="n">tInt8</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;3x3-eye matrix (int8)&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">d2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="k">delete</span> <span class="n">d2</span><span class="p">;</span>
<span class="n">d2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Here, the function eye() has been used with pointer variable d2 to convert the data object d2 into eye matrix.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">eye() function accepts only square matrices as inputs, otherwise it throws exception.</p>
</div>
</div>
<div class="section" id="creating-ones-matrix">
<h2>Creating Ones Matrix<a class="headerlink" href="#creating-ones-matrix" title="Permalink to this headline">¶</a></h2>
<p>Like Eye Matrix, Ones Matrix is equally important in matrix calculations.
So we have developed a function called <strong>ones()</strong> under <em>DataObject</em> class to quickly convert any <em>data object</em> into <em>ones matrix</em>.
Syntax for the function <strong>ones()</strong> is shown below.</p>
<p><em>dataObjectName.ones(dim 1,dim 2,...,dim n, dataType);</em></p>
<p><em>Return Type: void</em></p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="o">*</span><span class="n">d3</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span><span class="p">();</span>
<span class="n">d3</span><span class="o">-&gt;</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">ito</span><span class="o">::</span><span class="n">tFloat64</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;2x3x4-ones matrix (double)&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">d3</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="k">delete</span> <span class="n">d3</span><span class="p">;</span>
<span class="n">d3</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Here, the function ones() has been used in Line #2 with pointer variable d3 to convert the data object d3 into ones matrix of dimension 2x3x4.</p>
</div>
<div class="section" id="creating-zeros-matrix">
<h2>Creating Zeros Matrix<a class="headerlink" href="#creating-zeros-matrix" title="Permalink to this headline">¶</a></h2>
<p>We have developed a function called <strong>zeros()</strong> under <em>DataObject</em> class to quickly convert any <em>data object</em> into <em>zero matrix</em>.
Syntax for the function <strong>zeros()</strong> is shown below.</p>
<p><em>dataObjectName.zeros(dataType);</em></p>
<p><em>dataObjectName.zeros(const size_t size, dataType);</em></p>
<p><em>dataObjectName.zeros(const size_t sizeY, const size_t sizeX, dataType);</em></p>
<p><em>dataObjectName.zeros(const size_t sizeZ, const size_t sizeY, const size_t sizeX, dataType);</em></p>
<p><em>dataObjectName.zeros(const unsigned char dimensions, const size_t *sizes, dataType);</em></p>
<p><em>Return Type: RetVal</em></p>
<p>As zeros() function is overloaded, there are more than one syntax shown above.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <strong>RetVal</strong> class is used for handling error management and return relative codes. More description on this class can be seen in <a class="reference internal" href="plugin-RetVal-Ref.html#plugin-retval-ref"><em>RetVal - Reference</em></a>.</p>
</div>
<p>Following code explains the usage of <strong>zeros()</strong> function.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="o">*</span><span class="n">dObjZeros</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span><span class="p">();</span>
<span class="n">dObjZeros</span><span class="o">-&gt;</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">ito</span><span class="o">::</span><span class="n">tFloat64</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;3x4x5-zeros matrix (double)&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">dObjZeros</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="k">delete</span> <span class="n">dObjZeros</span><span class="p">;</span>
<span class="n">dObjZeros</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Here, line number 2 shows the way to use zeros() function to convert data object dObjZeros into a zero matrix.</p>
</div>
<div class="section" id="adjusting-roi-of-a-data-object">
<h2>Adjusting ROI of a Data Object<a class="headerlink" href="#adjusting-roi-of-a-data-object" title="Permalink to this headline">¶</a></h2>
<p>This section will teach you about how to adjust Region of Interest (ROI) in any data object.</p>
<p>The following example code shows the way to adjust ROI with adjustROI() method and to locate ROI with locateROI() method.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//adjusting ROI of 6x7 data object.</span>
<span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="n">d6</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="n">ito</span><span class="o">::</span><span class="n">tInt16</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">roiLocate</span><span class="p">[]</span><span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span> <span class="c1">//Empty Array to locate ROI of 2 dimensional data object d6.</span>
<span class="n">d6</span><span class="p">.</span><span class="n">adjustROI</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span>
<span class="n">d6</span><span class="p">.</span><span class="n">locateROI</span><span class="p">(</span><span class="n">roiLocate</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d6</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">roiLocate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Here, line #4 shows the use of adjustROI() function where negative parameters indicate that the ROI is shrinking in perticular dimension. More detailed description of adjustROI() and locateROI() methods can be seen under <a class="reference internal" href="plugin-DataObject-Ref.html#plugin-dataobject-ref"><em>DataObject - Reference</em></a> document.</p>
<p>One can also pass an array as a parameter to this adjustROI() function describing the offset details as shown in the following code.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">matLimits2d</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">};</span>
<span class="n">d6</span><span class="p">.</span><span class="n">adjustROI</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">matLimits2d</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d6</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Here, adjustROI() function is called with 2 parameters and as can be seen in line #1, the array matLimits2d[] contains the same offset values as passed in adjustROI() method in the previous example.</p>
<p>One can use this example to adjust ROI of data objects more than 2 dimensions as well as shown in later examples below.</p>
<p>The following code shows such an example to modify ROI of a 3 dimensional data object.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//adjusting ROI of 6x7x8 data object.</span>
<span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="n">d7</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="n">ito</span><span class="o">::</span><span class="n">tFloat32</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">matLimits3d</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">lims3d</span><span class="p">[]</span><span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">};</span> <span class="c1">//Empty Array to locate ROI of 3 dimensional data object d7.</span>
<span class="n">d7</span><span class="p">.</span><span class="n">adjustROI</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">matLimits3d</span><span class="p">);</span>
<span class="n">d7</span><span class="p">.</span><span class="n">locateROI</span><span class="p">(</span><span class="n">lims3d</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d7</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">lims3d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Here, a 3 dimensional data object d7 of dimensions 6x7x8 is declared in line #1 using the implementation #4 for data objects.</p>
<p>As can be seen in line #3, array matLimits3d[] of return type <strong>int</strong> contains required 6 offset values to adjust ROI of 3 dimensional data object d7. As shown in line #4, an empty array lims3d[] of <em>int</em> as return type is defined to locate the ROI of data object d7 using <strong>locateROI()</strong> function.
Line #7 will print the resultant data object after being adjusted by <strong>adjustROI()</strong> method in line #5 and the for loop in line #8-11 will print these located offset values of the resultant ROI of d7.</p>
</div>
<div class="section" id="setting-and-getting-axis-units">
<h2>Setting and Getting Axis Units<a class="headerlink" href="#setting-and-getting-axis-units" title="Permalink to this headline">¶</a></h2>
<p>In this section, you will study about assigning and retrieving the axis units at each dimension of a data object. <strong>setAxisUnit()</strong> method is used to assign a unit to a perticular axis (dimension) of a data object and is declared under <strong>DataObject</strong> class.
Syntax for this method is given below.</p>
<p><em>dataObjectName.setAxisUnit(const unsigned int axisNum, const std::string &amp;unit);</em></p>
<p><em>Return Type: int</em></p>
<p>This function returns 1 if the axis does not exists.</p>
<p><strong>getAxisUnit()</strong> method is used to retrieve a unit of a perticular axis and is also declared under <strong>DataObject</strong> class. The syntax for this method is shown below.</p>
<p><em>dataObjectName.getAxisUnit(const int axisNum, bool &amp;validOperation);</em></p>
<p><em>Return Type: std::string</em></p>
<p>This method returns Null if the axisNum is out of the range.</p>
<p>Following example code explains both of these methods.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="n">d8</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="n">ito</span><span class="o">::</span><span class="n">tFloat32</span><span class="p">);</span>
<span class="kt">bool</span> <span class="n">vop1</span><span class="p">,</span> <span class="n">vop2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">d8</span><span class="p">.</span><span class="n">setAxisUnit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s">&quot;µm&quot;</span><span class="p">);</span>
<span class="n">d8</span><span class="p">.</span><span class="n">setAxisUnit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;cm&quot;</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">AxisUnit1</span> <span class="o">=</span><span class="n">d8</span><span class="p">.</span><span class="n">getAxisUnit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">vop1</span><span class="p">);</span> <span class="c1">//Getting axis unit of 1st dimension of data object d8</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">AxisUnit2</span> <span class="o">=</span><span class="n">d8</span><span class="p">.</span><span class="n">getAxisUnit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">vop2</span><span class="p">);</span> <span class="c1">//Getting axis unit of 2nd dimension of data object d8</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Axis Unit of 1st Dimension:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">AxisUnit1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Axis Unit of 2nd Dimension:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">AxisUnit2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Here, a 2 dimensional data object <em>d8</em> of dimensions <em>6x7</em> is declared in line #1. Line #2 declares boolean variables vop1 and vop2 to pass as parameters in getAxisUnit() method later.
Line #3 and #4 sets the units for dimensions 1 and 2 of data object d8 respectively.</p>
<p>These assigned axis units can be retrieved by getAxisUnit() method as shown in line #5 and #6. Line #7 and #8 prints these retrieved axis units of data object d8.</p>
</div>
<div class="section" id="setting-and-getting-axis-scale">
<h2>Setting and Getting Axis Scale<a class="headerlink" href="#setting-and-getting-axis-scale" title="Permalink to this headline">¶</a></h2>
<p>In this section, we will learn about setting and getting the scale values of perticular Axis (dimension) of a data object.
This can be done using setAxisScale() and getAxisScale() functions as shown below. These both functions are declared under <em>DataObject</em> class.
Syntax for the setAxisScale() function is shown below:</p>
<p><em>DataObjectName.setAxisScale(const unsigned int axisNum, const double scale);</em></p>
<p><em>Return Type: int</em></p>
<p>In the same way, syntax for the <strong>getAxisScale()</strong> function is shown below.</p>
<p><em>DataObjecName.getAxisScale(const int axisNum)</em></p>
<p><em>Return Type: double</em></p>
<p>Following examplary code can explain the usage of these functions in a better way.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="n">d9</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">ito</span><span class="o">::</span><span class="n">tInt16</span><span class="p">);</span>
<span class="n">d9</span><span class="p">.</span><span class="n">setAxisScale</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
<span class="n">d9</span><span class="p">.</span><span class="n">setAxisScale</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">);</span>
<span class="n">d9</span><span class="p">.</span><span class="n">setAxisScale</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mf">3.24</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">AxisScale1</span> <span class="o">=</span><span class="n">d9</span><span class="p">.</span><span class="n">getAxisScale</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">AxisScale2</span> <span class="o">=</span><span class="n">d9</span><span class="p">.</span><span class="n">getAxisScale</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="kt">double</span> <span class="n">AxisScale3</span> <span class="o">=</span><span class="n">d9</span><span class="p">.</span><span class="n">getAxisScale</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Axis 1 Scale:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">AxisScale1</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Axis 2 Scale:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">AxisScale2</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Axis 3 Scale:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">AxisScale3</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>As shown in line #2-4, <strong>setAxisScale()</strong> function is used to assign scales of 5, -0.5 and 3.24 on Axis 0, 1 and 2 respectively of data object d9. Line #5-7 explains how the axis scales can be retrieved using the function <strong>getAxisScale()</strong>.
Line #8 prints down these retrieved axis values at the end of this code snippet.</p>
</div>
</div>
<div class="section" id="operations-on-data-objects">
<h1>Operations on Data Objects<a class="headerlink" href="#operations-on-data-objects" title="Permalink to this headline">¶</a></h1>
<p>In this section, we will learn some basic operations which can be performed using data objects.</p>
<div class="section" id="adjugate-the-data-object">
<h2>Adjugate the Data Object<a class="headerlink" href="#adjugate-the-data-object" title="Permalink to this headline">¶</a></h2>
<p>In many matrix calculations, there occurs a need to adjugate a matrix. Here, we also have a function <strong>adj()</strong> declared under <em>DataObject</em> class, which returns an adjugated matrix of the original data object.
Syntax for this method is shown below.</p>
<p><em>DataObjectName.adj();</em></p>
<p><em>Return Type:</em> ito::DataObject*</p>
<p>Following code snippet explains the use of <strong>adj()</strong> function.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="n">d10</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">ito</span><span class="o">::</span><span class="n">tComplex128</span><span class="p">);</span>
<span class="n">d10</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">ito</span><span class="o">::</span><span class="n">complex128</span> <span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">ito</span><span class="o">::</span><span class="n">complex128</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">ito</span><span class="o">::</span><span class="n">complex128</span> <span class="p">(</span><span class="mf">23.2</span><span class="p">,</span><span class="mi">0</span><span class="p">));</span>
<span class="n">d10</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">ito</span><span class="o">::</span><span class="n">complex128</span> <span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">ito</span><span class="o">::</span><span class="n">complex128</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">ito</span><span class="o">::</span><span class="n">complex128</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">));</span>
<span class="n">d10</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">ito</span><span class="o">::</span><span class="n">complex128</span> <span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">ito</span><span class="o">::</span><span class="n">complex128</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">ito</span><span class="o">::</span><span class="n">complex128</span> <span class="p">(</span><span class="mi">1234</span><span class="p">,</span><span class="o">-</span><span class="mf">23.34</span><span class="p">));</span>
<span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="n">adjugatedDataObj</span> <span class="o">=</span> <span class="n">d10</span><span class="p">.</span><span class="n">adj</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;The Adjugated data object:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>In the code above, a 6x5x3 data object d10 of data type <em>ito::tComplex128</em> is created. Later on, in line #2-4, some complex values are assigned at data object elements (0,1,2), (1,0,1) and (2,2,1).
In line #5, an adjugated matrix of data object d10 is created using <strong>adj()</strong> function and stored in new data object called <strong>adjugatedDataObj</strong>. Line #6 prints out this adjugated matrix.</p>
</div>
<div class="section" id="transpose-the-data-object">
<h2>Transpose the Data Object<a class="headerlink" href="#transpose-the-data-object" title="Permalink to this headline">¶</a></h2>
<p>Transposing a data object is also one of the very important techniques in matrix calculations. With the use of <em>trans()</em> function, we can achieve a transposed matrix of the original data object.
This function is also declared under <em>DataObject</em> class. Syntax for this function is shown below.</p>
<p><em>DataObjectName.trans()</em></p>
<p><em>Return Type: ito::DataObject</em></p>
<p>Following code snippet explains the usage of <strong>trans()</strong> function.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="n">d11</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">ito</span><span class="o">::</span><span class="n">tInt16</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
                <span class="n">temp</span><span class="o">++</span><span class="p">;</span>
                <span class="n">d11</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">ito</span><span class="o">::</span><span class="n">int16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span><span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">ito</span><span class="o">::</span><span class="n">int16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>
<span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="n">transDObj</span> <span class="o">=</span> <span class="n">d11</span><span class="p">.</span><span class="n">trans</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="s">&quot;The Transposed data object:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>In the code above, a 2x2 data object d11 of type <em>ito::tInt16</em> is created. This data object d11 is initiated by assigning different values to each element. In line #11, <em>trans()</em> function is used to transpose this data object d11 and resulted transposed data object is stored in new data objected transDobj, which gets printed out in line #12.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Transposing the data object also transposes the axis related informations.</p>
</div>
</div>
<div class="section" id="basic-operators-with-data-objects">
<h2>Basic Operators with Data Objects<a class="headerlink" href="#basic-operators-with-data-objects" title="Permalink to this headline">¶</a></h2>
<p>(Same syntax can be used for other operators like &#8216;+&#8217;,&#8217;-&#8216;,&#8217;=+&#8217;,&#8217;=-&#8216;, div, cross multiplication (!=), &lt;&lt;(shift left), &gt;&gt; ( shift right))
For the sake of simplicity, some arithmatic operators are overloaded to work upon data objects easily. In this section, such operators to work upon data objects are discussed in details with example codes and syntaxes.
Let us start with basic Add &#8220;+&#8221; operator. Following is one example shown to add two data objects with &#8220;+&#8221; operator.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="n">d12</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">ito</span><span class="o">::</span><span class="n">tInt16</span><span class="p">);</span>
<span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="n">d13</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">ito</span><span class="o">::</span><span class="n">tInt16</span><span class="p">);</span>
<span class="n">ito</span><span class="o">::</span><span class="n">DataObject</span> <span class="n">d14</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">ito</span><span class="o">::</span><span class="n">tInt16</span><span class="p">);</span>
<span class="n">d12</span><span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">ito</span><span class="o">::</span><span class="n">int16</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">d13</span><span class="o">=</span> <span class="n">cv</span><span class="o">::</span><span class="n">saturate_cast</span><span class="o">&lt;</span><span class="n">ito</span><span class="o">::</span><span class="n">int16</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">d14</span><span class="o">=</span> <span class="n">d12</span> <span class="o">+</span> <span class="n">d13</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Addition of two matrix is:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d14</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Here, two data objects d12 and d13 are added elementwise and the resulant data object is stored in d14. In the same way many other arithmatic, compare, bitwise oprators can work with data objects.
Follwing is the explanation of each possible operator to work with data object.</p>
<div class="section" id="add-operator">
<h3><strong>Add Operator &#8216;+&#8217;</strong><a class="headerlink" href="#add-operator" title="Permalink to this headline">¶</a></h3>
<p>If mat1, mat2 and mat3 are data objects of same size and same type, then &#8220;+&#8221; operator can be used to perform elementwise addition in the following way.</p>
<p><em>mat3 = mat1 + mat2;</em></p>
<p>&#8220;+&#8221; operator performs elementwise addition on mat1 and mat2 and returns a resultant data object. This operator returns the resultant data object of same size and type which needs to be stored in some other data object of same size and type (mat3) as shown in the statement above.</p>
</div>
<div class="section" id="add-and-assign-operator">
<h3><strong>Add and Assign Operator &#8216;+=&#8217;</strong><a class="headerlink" href="#add-and-assign-operator" title="Permalink to this headline">¶</a></h3>
<p>If mat1 and mat2 are data objects of same size and same type, then &#8220;+=&#8221; operator can be used to perform elementwise add and assign operation in the following way.</p>
<p><em>mat2 += mat1;</em></p>
<p>&#8220;+=&#8221; operator performs elementwise addition operation on mat1 and mat2 and stores the resultant data object leftside of this it.</p>
</div>
<div class="section" id="subtract-operator">
<h3><strong>Subtract Operator &#8216;-&#8216;</strong><a class="headerlink" href="#subtract-operator" title="Permalink to this headline">¶</a></h3>
<p>If mat1, mat2 and mat3 are data objects of same size and type, then &#8220;-&#8221; operator can be used to perform elementwise subtraction between these data objects in the following way.</p>
<p><em>mat3 = mat1 - mat2;</em></p>
<p>In the statement above, mat2 is subtracted from mat1 elementwise and the resultant data object is stored in mat3.</p>
</div>
<div class="section" id="subtract-and-assign-operator">
<h3><strong>Subtract and Assign Operator &#8216;-=&#8217;</strong><a class="headerlink" href="#subtract-and-assign-operator" title="Permalink to this headline">¶</a></h3>
<p>If mat1 and mat2 are data objects of same size and type, then &#8220;-=&#8221; operator can be used to perform elementwise subtraction between these data objects in the following way.</p>
<p><em>mat2 -= mat1;</em></p>
<p>In the statement above, mat1 is subtracted from mat2 elementwise and the resultant data object is stored back to mat2.</p>
</div>
<div class="section" id="multiplication-with-constant-factor">
<h3><strong>Multiplication with Constant Factor &#8216;*&#8217;</strong><a class="headerlink" href="#multiplication-with-constant-factor" title="Permalink to this headline">¶</a></h3>
<p>Operator &#8220;*&#8221; is overloaded to perform multiplication of a data object with constant factor in the following way.</p>
<p><em>mat2 = mat1 * x;</em></p>
<p>Here, the data type of mat2 must proper enough to store the correct resultant data object obtained from multiplication of each element of mat1 with constant factor <strong>&#8220;x&#8221;</strong>.</p>
</div>
<div class="section" id="multiplication-with-constant-factor-and-assign">
<h3><strong>Multiplication with Constant Factor and Assign &#8216;*=&#8217;</strong><a class="headerlink" href="#multiplication-with-constant-factor-and-assign" title="Permalink to this headline">¶</a></h3>
<p>One can multiply all elements of a data object with a constant factor and assign the result back to the same data object as shown in the following statement.</p>
<p><em>mat1 *= x;</em></p>
<p>Here each element of the data object <strong>mat1</strong> gets multiplied with a constant factor <strong>&#8220;x&#8221;</strong> and the result is stored back into data object mat1.</p>
</div>
<div class="section" id="cross-multiplication-operator">
<h3><strong>Cross Multiplication Operator &#8216;*&#8217;</strong><a class="headerlink" href="#cross-multiplication-operator" title="Permalink to this headline">¶</a></h3>
<p>One can use the operator &#8220;*&#8221; to perform a cross multiplication between two data objects with adequate dimensions in the following way.</p>
<p><em>crossMul_mat = mat1 * mat2;</em></p>
<p>In the statement above, operator <strong>&#8220;*&#8221;</strong> is used to perform cross multiplication between data objects mat1 and mat2. If sizes of mat1 and mat2 are axb and bxc respectively, then the size of crossMul_mat should be declared axc according to the principle of cross multiplication of matrices.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This operator is defined only for &#8220;float32&#8221; and &#8220;float64&#8221; datatypes.</p>
</div>
</div>
<div class="section" id="dot-multiplication-operator-mul">
<h3><strong>Dot Multiplication Operator &#8216;mul&#8217;</strong><a class="headerlink" href="#dot-multiplication-operator-mul" title="Permalink to this headline">¶</a></h3>
<p>With the use of &#8220;mul&#8221; operator, one can perform dot product (elementwise multiplication) between two data objects in the following way.</p>
<p><em>mul_mat=mat1.mul(mat2);</em></p>
<p>Here, &#8220;mul&#8221; operator takes two data objects mat1 and mat2 of same type and same size as arguments and perform dot product between them. The result of this dot product is saved in data object of same size mul_mat. Here, the size of mul_mat should be big enough to store correct result of dot product.</p>
</div>
<div class="section" id="division-operator-div">
<h3><strong>Division Operator &#8216;div&#8217;</strong><a class="headerlink" href="#division-operator-div" title="Permalink to this headline">¶</a></h3>
<p>This operator is used to perform elementwise division between two data objects in the following way.</p>
<p><em>div_mat = mat1.div(mat2);</em></p>
<p>Here, data object <strong>mat1</strong> is divided from data object <strong>mat2</strong> elementwise using <strong>&#8220;div&#8221;</strong> operator and the result is stored in data object <strong>div_mat</strong>. Sizes and data types of mat1, mat2 and mat2 should be same.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><strong>&#8220;div&#8221;</strong> operator can not be used to calculate inverse matrix.</p>
</div>
<div class="section" id="compare-operators">
<h4><strong>Compare Operators</strong><a class="headerlink" href="#compare-operators" title="Permalink to this headline">¶</a></h4>
<p>Compare operations are frequently needed while working with data objects. Keeping this in mind, we have developed some overloaded compare operators as well which we will discuss in this section.</p>
</div>
</div>
<div class="section" id="equal-to-elementwise-operator">
<h3><strong>== (Equal to)  (Elementwise operator)</strong><a class="headerlink" href="#equal-to-elementwise-operator" title="Permalink to this headline">¶</a></h3>
<p>This operator compares the element values of two different data objects on respective positions and retunrs a resultant data object with <strong>0s</strong> and <strong>1s</strong> according to the comparision result.
If two values on the respective positions match in two data objects, then a <strong>1</strong> is returned, otherwise a <strong>0</strong> is returned for that position in the resultant data object.
The way to use this <strong>== (Equal to)</strong> operator is shown as follows.</p>
<p><em>mat3 = mat1 == mat2;</em></p>
<p>Here, a comparision between data objects mat1 and mat2 is done with <strong>==</strong> operator and the result is stored in the data object mat3. As a result, mat3 contains &#8216;1&#8217; at the positions where the values in mat1 and mat2 are equal, otherwise &#8216;0&#8217; where the values are unequal.
Sizes of mat1, mat2 and mat3 should be equal.</p>
</div>
<div class="section" id="unequal-to-elementwise-operator">
<h3><strong>!= (unEqual to) (Elementwise operator)</strong><a class="headerlink" href="#unequal-to-elementwise-operator" title="Permalink to this headline">¶</a></h3>
<p>This operator compares the element values of two different data objects on respective positions and retunrs a resultant data object with <strong>0s</strong> and <strong>1s</strong> according to the comparision result.
If two values on the respective positions differ in two data objects, then a <strong>1</strong> is returned, otherwise a <strong>0</strong> is returned for that position in the resultant data object.
The way to use this <strong>!= (unEqual to)</strong> operator is shown as follows.</p>
<p><em>mat3 = mat1 != mat2;</em></p>
<p>Here, a comparision between data objects mat1 and mat2 is done with <strong>!=</strong> operator and the result is stored in the data object mat3. As a result, mat3 contains &#8216;1&#8217; at the positions where the values in mat1 and mat2 are unequal, otherwise &#8216;0&#8217; where the values are equal.
Sizes of mat1, mat2 and mat3 should be equal.</p>
</div>
<div class="section" id="lower-than-elementwise-operator">
<h3><strong>&lt; (lower than) (Elementwise operator)</strong><a class="headerlink" href="#lower-than-elementwise-operator" title="Permalink to this headline">¶</a></h3>
<p>This operator performs &#8220;lower than&#8221; comparision operation between the element values of two data objects. The way to perform this comparision is shown in the following statement.</p>
<p><em>mat3 = mat1 &lt; mat2;</em></p>
<p>In the statement above, elements of <strong>mat1 are</strong> compared with elements of mat2 for <strong>lower than</strong> operation with use of <strong>&lt;</strong> operator. The resultant data object <strong>mat3</strong> contains <strong>&#8216;1&#8217;</strong> at the postions where the element values in data object mat1 are lower than those of mat2 at respective positions, otherwise it containes <strong>&#8216;0&#8217;</strong> where this condition doesn&#8217;t satisfy.
Sizes of all three data objects mat1, mat2 and mat3 should be the same.</p>
</div>
<div class="section" id="lower-or-equal-to-elementwise-operator">
<h3><strong>&lt;= (lower or equal to) (Elementwise operator)</strong><a class="headerlink" href="#lower-or-equal-to-elementwise-operator" title="Permalink to this headline">¶</a></h3>
<p>This operator compares two data objects and helps us to find out which elements in one data object are <strong>&#8220;lower or equal to&#8221;</strong> the respective elements in the other data object in the following way.</p>
<p><em>mat3 = mat1 &lt;= mat2;</em></p>
<p>Here, <strong>&#8220;&lt;=&#8221;</strong> operator compares data object <strong>mat1</strong> with <strong>mat2</strong> and generates a resultant data object mat3 such as, mat3 contains <strong>1s</strong> at the positions where elements in <strong>mat1</strong> are lower or equal to the respective elements in <strong>mat2</strong>, otherwise contains <strong>0s</strong> where the condition doesn&#8217;t satisfy.
Sizes of mat1, mat2 and mat3 should be equal.</p>
</div>
<div class="section" id="bigger-than-elementwise-operator">
<h3><strong>&gt; (bigger than) (Elementwise operator)</strong><a class="headerlink" href="#bigger-than-elementwise-operator" title="Permalink to this headline">¶</a></h3>
<p>With the use of this over loaded operator, one can easily find out at which positions the values of elements in one data object are <strong>bigger than</strong> the values of the other data object in the following way.</p>
<p><em>mat3 = mat1 &gt; mat2;</em></p>
<p>Here in the above statement, comparision operation between <strong>mat1</strong> and <strong>mat2</strong> is done with <strong>&#8220;&gt;&#8221;</strong> operator and the final result is stored in data object <strong>mat3</strong>. As a result, <strong>mat3</strong> contains <strong>1s</strong> at the positions where the element values in <strong>mat1</strong> are bigger than the element values on the respective postions in <strong>mat2</strong>.
Data sizes of mat1, mat2 and mat3 should be the same for the successful comparision with this operator.</p>
</div>
<div class="section" id="bigger-or-equal-to-elementwise-operator">
<h3><strong>&gt;= (bigger or equal to) (Elementwise operator)</strong><a class="headerlink" href="#bigger-or-equal-to-elementwise-operator" title="Permalink to this headline">¶</a></h3>
<p>This operator is used to find out if the element values of one data objects are <strong>bigger or equal to</strong> the element values of the other data object.</p>
<p>Syntax to use this operator with data objects is shown below.</p>
<p><em>mat3 = mat1 &gt;= mat2;</em></p>
<p>As shown above, element values of <strong>mat1</strong> are compared with the element values of <strong>mat2</strong> and the result is stored in <strong>mat3</strong>. As a result, <strong>mat3</strong> contains <strong>1s</strong> at the positions where the element values in <strong>mat1</strong> are <strong>bigger or equal to</strong> the element values in <strong>mat2</strong>, otherwise contains <strong>0s</strong> at the positions where the condition doesn&#8217;t satisfy.
Sizes of mat1, mat2 and mat3 should be equal.</p>
<div class="section" id="shift-operators">
<h4><strong>Shift Operators</strong><a class="headerlink" href="#shift-operators" title="Permalink to this headline">¶</a></h4>
<p>Shift operators play a significant role during some arithmatic operations (i.e. division/multiplication by 2), bit level calculations, etc. With the over loading of some shift operators to let them be used for data objects, many matrix calculations can be made much easier.
We will go through such over loaded shift operators in this section.</p>
</div>
</div>
<div class="section" id="shift-left">
<h3><strong>&lt;&lt; (shift left)</strong><a class="headerlink" href="#shift-left" title="Permalink to this headline">¶</a></h3>
<p><strong>&lt;&lt;</strong> or in words <strong>&#8220;Shift Left&#8221;</strong> operator is overloaded to work with data objects. It shifts the element values of the data object at the bit level by a required amount on left.</p>
<p>Syntax to use this operator with data objects is shown below.</p>
<p><em>mat2 = mat1 &lt;&lt; &#8216;x&#8217;;</em></p>
<p>Here <strong>&#8216;x&#8217;</strong> is the Shiftbits number.
The values of the elements in mat1 are shifted left by &#8216;x&#8217; number of times and the resultant data object is stored in mat2d. Data type of the Shiftbits &#8216;x&#8217; is const unsigned int.</p>
</div>
<div class="section" id="shift-left-and-assign">
<h3><strong>&lt;&lt;= (shift left and assign)</strong><a class="headerlink" href="#shift-left-and-assign" title="Permalink to this headline">¶</a></h3>
<p>This operator is used to <strong>shift left</strong> the element values on a data object at a bit level and <strong>assign back</strong> these values to the same data object.</p>
<p>Syntax to use this operator with data objects is shown below.</p>
<p><em>mat1 &lt;&lt;= &#8216;x&#8217;;</em></p>
<p>Here &#8216;x&#8217; is the Shiftbits number.
The values of the elements in mat1 are shifted left by &#8216;x&#8217; number of times and assigned to the same data object. Data type of the Shiftbits &#8216;x&#8217; is const unsigned int.</p>
</div>
<div class="section" id="shift-right">
<h3><strong>&gt;&gt; (shift right)</strong><a class="headerlink" href="#shift-right" title="Permalink to this headline">¶</a></h3>
<p>This operator is used to <strong>shift right</strong> the elements of a data object at a bit level. As a result, this operation returns a data object with shifted element values which needs to be stored in some data object with same size and type.</p>
<p>Syntax to use this operator with data objects is shown below.</p>
<p><em>mat2 = mat1 &gt;&gt; &#8216;x&#8217;;</em></p>
<p>Here &#8216;x&#8217; is the Shiftbits number.
The values of the elements in mat1 are shifted right by &#8216;x&#8217; number of times and the resultant data object is stored in mat2. Data type of the Shiftbits &#8216;x&#8217; is const unsigned int.</p>
</div>
<div class="section" id="shift-right-and-assign">
<h3><strong>&gt;&gt;= (shift right and assign)</strong><a class="headerlink" href="#shift-right-and-assign" title="Permalink to this headline">¶</a></h3>
<p>This operator is used to <strong>shift right</strong> the elements of a data object at a bit level and <strong>assign back</strong> the shifted values to the same data object.</p>
<p>Syntax to use this operator with data objects is shown below.</p>
<p><em>mat1 &gt;&gt;= &#8216;x&#8217;;</em></p>
<p>Here &#8216;x&#8217; is the Shiftbits number.
The values of the elements in mat1are shifted right by &#8216;x&#8217; number of times and assigned to the same data object. Data type of the Shiftbits &#8216;x&#8217; is const unsigned int.</p>
<div class="section" id="bitwise-operations">
<h4><strong>Bitwise Operations</strong><a class="headerlink" href="#bitwise-operations" title="Permalink to this headline">¶</a></h4>
<p>Bitwise operators play important role in logical operations such as AND, OR and NOT. In this section, some of such over loaded logical operators for data objects are described.</p>
</div>
</div>
<div class="section" id="bitwise-and-operator">
<h3><strong>&#8216;&amp;&#8217; (Bitwise AND) Operator</strong><a class="headerlink" href="#bitwise-and-operator" title="Permalink to this headline">¶</a></h3>
<p>This operator performs a <strong>bitwise AND</strong> opearation between the elements of two data objects.</p>
<p>Syntax to use this operator with data objects is shown below.</p>
<p><em>d3 = d1 &amp; d2 ;</em></p>
<p>As shown in the statement above, with the use of <strong>&#8216;&amp;&#8217;</strong> operator, <strong>elementwise AND</strong> operation occurs at the bit level between the elements on the same locations of d1 and d2 and the resultant values are stored at the respective locations of d3.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Sizes and data types of data objects d1, d2 and d3 should be same, otherwise exception is thrown.</p>
</div>
</div>
<div class="section" id="bitwise-or-operator">
<h3><strong>&#8220;|&#8221; (Bitwise OR) Operator</strong><a class="headerlink" href="#bitwise-or-operator" title="Permalink to this headline">¶</a></h3>
<p>This operator performs a <strong>bitwise OR</strong> operation between the elements of two data objects.</p>
<p>Syntax to use this operator with data objects is shown below.</p>
<p><em>d3 = d1 | d2 ;</em></p>
<p>With the use of <strong>&#8216;|&#8217;</strong> operator, <strong>elementwise OR</strong> operation occurs at the bit level between the elements on the same locations of d1 and d2 and the resultant values are stored at the respective locations of d3.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Sizes and data types of data objects d1, d2 and d3 should be same, otherwise exception is thrown.</p>
</div>
</div>
<div class="section" id="bitwise-not-operator">
<h3><strong>&#8220;^&#8221; (Bitwise NOT) Operator</strong><a class="headerlink" href="#bitwise-not-operator" title="Permalink to this headline">¶</a></h3>
<p>This operator performs a <strong>bitwise NOT</strong> operation between the elements of two data objects.</p>
<p>Syntax to use this operator with data objects is shown below.</p>
<p><em>d3 = d1 ^ d2 ;</em></p>
<p>With the use of <strong>&#8216;^&#8217;</strong> operator, <strong>elementwise NOT</strong> operation at the bit level occurs between the elements on the same locations of d1 and d2 and the resultant values are stored at the respective locations of d3.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Sizes and data types of data objects d1, d2 and d3 should be same, otherwise exception is thrown.</p>
</div>
</div>
<div class="section" id="bitwise-and-and-assign-operator">
<h3><strong>&#8220;&amp;=&#8221; (Bitwise AND and Assign) Operator</strong><a class="headerlink" href="#bitwise-and-and-assign-operator" title="Permalink to this headline">¶</a></h3>
<p>This operator performs a <strong>bitwise AND</strong> operation between the elements of two data objects and <strong>assigns back</strong> the result into the first data object.</p>
<p>Syntax to use this operator with data objects is given below.</p>
<p><em>d2 &amp;= d1;</em></p>
<p>With the use of <strong>&#8216;&amp;=&#8217;</strong> operator, <strong>elementwise AND</strong> operation occurs at bit level between the elements on the same locations of d1 and d2 and the resultant values are assigned at the respective locations of d1 back.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Sizes and data types of data objects d1 and d2 should be same, otherwise exception is thrown.</p>
</div>
</div>
<div class="section" id="bitwise-or-and-assign-operator">
<h3><strong>&#8220;|=&#8221; (Bitwise OR and Assign) Operator</strong><a class="headerlink" href="#bitwise-or-and-assign-operator" title="Permalink to this headline">¶</a></h3>
<p>This operator performs a <strong>bitwise OR</strong> operation between the elements of two data objects and <strong>assigns back</strong> the result into the first data objects.</p>
<p>Syntax to use this operator with data objects is given below.</p>
<p><em>d2 |= d1;</em></p>
<p>With the use of <strong>&#8216;|=&#8217;</strong> operator, <strong>elementwise OR</strong> operation  at bit level occurs between the elements on the same locations of d1 and d2 and the resultant values are assigned at the respective locations of d1 again.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Sizes and data types of data objects d1 and d2 should be same, otherwise exception is thrown.</p>
</div>
</div>
<div class="section" id="bitwise-not-and-assign-operator">
<h3><strong>&#8220;^=&#8221; (Bitwise NOT and Assign) Operator</strong><a class="headerlink" href="#bitwise-not-and-assign-operator" title="Permalink to this headline">¶</a></h3>
<p>This operator performs a <strong>bitwise NOT</strong> operation between the elements of two data objects and <strong>assign back</strong> the result into the first data object.</p>
<p>Syntax to use this operator with data objects is given below.</p>
<p><em>d2 ^= d1;</em></p>
<p>With the use of <strong>&#8216;^=&#8217;</strong> operator, <strong>elementwise NOT</strong> operation at bit level occurs between the elements on the same locations of d1 and d2 and the resultant values are assigned at the respective locations of d1 again.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Sizes and data types of data objects d1 and d2 should be same, otherwise exception is thrown.</p>
</div>
<div class="section" id="combination-of-different-operators">
<h4><strong>Combination of Different Operators</strong><a class="headerlink" href="#combination-of-different-operators" title="Permalink to this headline">¶</a></h4>
<p>Different operators (explained above) can be used in different possible combinations with data objects for speedy calculations.</p>
<p>Some of the examples of such combinations are shown below.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre>    <span class="n">d4</span> <span class="o">=</span> <span class="n">d1</span> <span class="o">+</span> <span class="n">d2</span> <span class="o">-</span> <span class="n">d3</span><span class="p">;</span>
    <span class="n">d3</span> <span class="o">=</span> <span class="p">(</span><span class="n">d1</span> <span class="o">|</span> <span class="n">d2</span><span class="p">).</span><span class="n">div</span><span class="p">((</span><span class="n">d1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">d1</span><span class="p">);</span>
    <span class="n">d4</span><span class="o">=</span> <span class="p">(</span><span class="n">d1</span> <span class="o">&amp;</span> <span class="n">d2</span><span class="p">).</span><span class="n">mul</span><span class="p">(</span><span class="n">d3</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>With the close observation of the example statements above, one can get an idea on how to use these operators in different combinations to get the desired operation done.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For a full reference of the class <strong>DataObject</strong> see <a class="reference internal" href="plugin-DataObject-Ref.html#plugin-dataobject-ref"><em>DataObject - Reference</em></a>.</p>
</div>
<div class="toctree-wrapper compound">
</div>
<p>ito::DataObject <em class="xref std std-ref">ito::DataObject</em></p>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">DataObject</a><ul>
<li><a class="reference internal" href="#example-codes">Example Codes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#addressing-the-elements-of-a-data-object">Addressing the elements of a data object</a><ul>
<li><a class="reference internal" href="#direct-access-of-one-single-element-of-a-data-object-using-at-method">Direct access of one single element of a Data Object using <strong>at()</strong> method</a><ul>
<li><a class="reference internal" href="#advantages">Advantages</a></li>
<li><a class="reference internal" href="#drawbacks">Drawbacks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#addressing-elements-of-a-data-object-using-row-pointer">Addressing elements of a data object using row pointer</a><ul>
<li><a class="reference internal" href="#id17">Advantages</a></li>
<li><a class="reference internal" href="#id18">Drawbacks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#assigning-a-single-value-to-all-elements-of-a-data-object">Assigning a single value to all elements of a Data Object</a></li>
<li><a class="reference internal" href="#direct-access-to-the-underlying-cv-mat">Direct Access to the underlying cv::Mat</a></li>
<li><a class="reference internal" href="#accessing-all-elements-of-a-data-object-using-iterators">Accessing all elements of a Data Object using iterators</a><ul>
<li><a class="reference internal" href="#id19">Advantages</a></li>
<li><a class="reference internal" href="#id20">Drawbacks</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#working-with-data-objects">Working with Data Objects</a><ul>
<li><a class="reference internal" href="#creating-eye-matrix">Creating Eye Matrix</a></li>
<li><a class="reference internal" href="#creating-ones-matrix">Creating Ones Matrix</a></li>
<li><a class="reference internal" href="#creating-zeros-matrix">Creating Zeros Matrix</a></li>
<li><a class="reference internal" href="#adjusting-roi-of-a-data-object">Adjusting ROI of a Data Object</a></li>
<li><a class="reference internal" href="#setting-and-getting-axis-units">Setting and Getting Axis Units</a></li>
<li><a class="reference internal" href="#setting-and-getting-axis-scale">Setting and Getting Axis Scale</a></li>
</ul>
</li>
<li><a class="reference internal" href="#operations-on-data-objects">Operations on Data Objects</a><ul>
<li><a class="reference internal" href="#adjugate-the-data-object">Adjugate the Data Object</a></li>
<li><a class="reference internal" href="#transpose-the-data-object">Transpose the Data Object</a></li>
<li><a class="reference internal" href="#basic-operators-with-data-objects">Basic Operators with Data Objects</a><ul>
<li><a class="reference internal" href="#add-operator"><strong>Add Operator &#8216;+&#8217;</strong></a></li>
<li><a class="reference internal" href="#add-and-assign-operator"><strong>Add and Assign Operator &#8216;+=&#8217;</strong></a></li>
<li><a class="reference internal" href="#subtract-operator"><strong>Subtract Operator &#8216;-&#8216;</strong></a></li>
<li><a class="reference internal" href="#subtract-and-assign-operator"><strong>Subtract and Assign Operator &#8216;-=&#8217;</strong></a></li>
<li><a class="reference internal" href="#multiplication-with-constant-factor"><strong>Multiplication with Constant Factor &#8216;*&#8217;</strong></a></li>
<li><a class="reference internal" href="#multiplication-with-constant-factor-and-assign"><strong>Multiplication with Constant Factor and Assign &#8216;*=&#8217;</strong></a></li>
<li><a class="reference internal" href="#cross-multiplication-operator"><strong>Cross Multiplication Operator &#8216;*&#8217;</strong></a></li>
<li><a class="reference internal" href="#dot-multiplication-operator-mul"><strong>Dot Multiplication Operator &#8216;mul&#8217;</strong></a></li>
<li><a class="reference internal" href="#division-operator-div"><strong>Division Operator &#8216;div&#8217;</strong></a><ul>
<li><a class="reference internal" href="#compare-operators"><strong>Compare Operators</strong></a></li>
</ul>
</li>
<li><a class="reference internal" href="#equal-to-elementwise-operator"><strong>== (Equal to)  (Elementwise operator)</strong></a></li>
<li><a class="reference internal" href="#unequal-to-elementwise-operator"><strong>!= (unEqual to) (Elementwise operator)</strong></a></li>
<li><a class="reference internal" href="#lower-than-elementwise-operator"><strong>&lt; (lower than) (Elementwise operator)</strong></a></li>
<li><a class="reference internal" href="#lower-or-equal-to-elementwise-operator"><strong>&lt;= (lower or equal to) (Elementwise operator)</strong></a></li>
<li><a class="reference internal" href="#bigger-than-elementwise-operator"><strong>&gt; (bigger than) (Elementwise operator)</strong></a></li>
<li><a class="reference internal" href="#bigger-or-equal-to-elementwise-operator"><strong>&gt;= (bigger or equal to) (Elementwise operator)</strong></a><ul>
<li><a class="reference internal" href="#shift-operators"><strong>Shift Operators</strong></a></li>
</ul>
</li>
<li><a class="reference internal" href="#shift-left"><strong>&lt;&lt; (shift left)</strong></a></li>
<li><a class="reference internal" href="#shift-left-and-assign"><strong>&lt;&lt;= (shift left and assign)</strong></a></li>
<li><a class="reference internal" href="#shift-right"><strong>&gt;&gt; (shift right)</strong></a></li>
<li><a class="reference internal" href="#shift-right-and-assign"><strong>&gt;&gt;= (shift right and assign)</strong></a><ul>
<li><a class="reference internal" href="#bitwise-operations"><strong>Bitwise Operations</strong></a></li>
</ul>
</li>
<li><a class="reference internal" href="#bitwise-and-operator"><strong>&#8216;&amp;&#8217; (Bitwise AND) Operator</strong></a></li>
<li><a class="reference internal" href="#bitwise-or-operator"><strong>&#8220;|&#8221; (Bitwise OR) Operator</strong></a></li>
<li><a class="reference internal" href="#bitwise-not-operator"><strong>&#8220;^&#8221; (Bitwise NOT) Operator</strong></a></li>
<li><a class="reference internal" href="#bitwise-and-and-assign-operator"><strong>&#8220;&amp;=&#8221; (Bitwise AND and Assign) Operator</strong></a></li>
<li><a class="reference internal" href="#bitwise-or-and-assign-operator"><strong>&#8220;|=&#8221; (Bitwise OR and Assign) Operator</strong></a></li>
<li><a class="reference internal" href="#bitwise-not-and-assign-operator"><strong>&#8220;^=&#8221; (Bitwise NOT and Assign) Operator</strong></a><ul>
<li><a class="reference internal" href="#combination-of-different-operators"><strong>Combination of Different Operators</strong></a><ul>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="plugin-sharedSemaphore-Ref.html"
                        title="previous chapter">ItomSharedSemaphore - Reference</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="plugin-RetVal-Ref.html"
                        title="next chapter">RetVal - Reference</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../../_sources/07_plugins/development/plugin-dataObject.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="plugin-RetVal-Ref.html" title="RetVal - Reference"
             >next</a> |</li>
        <li class="right" >
          <a href="plugin-sharedSemaphore-Ref.html" title="ItomSharedSemaphore - Reference"
             >previous</a> |</li>
        <li><a href="../../index.html">itom</a> &raquo;</li>
          <li><a href="../../structure.html" >Structure of the manual</a> &raquo;</li>
          <li><a href="../plugins.html" >Plugins</a> &raquo;</li>
          <li><a href="plugin-development.html" >Development under C++</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2013, Institut fuer Technische Optik (ITO), University Stuttgart. Bug report: https://bitbucket.org/itom/itom/issues.
      Last updated on Aug 22, 2013.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b1.
    </div>
  </body>
</html>