<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>itom: ito Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="q_itoM48.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">itom&#160;<span id="projectnumber">1.3.0</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('namespaceito.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ito Namespace Reference</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_api_functions.html">ApiFunctions</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1api_functions_graph.html">apiFunctionsGraph</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_app_management.html">AppManagement</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; <a class="el" href="classito_1_1_app_management.html" title="&lt; AppManagement (in order to provide access to basic organizers, managers and other main components t...">AppManagement</a> (in order to provide access to basic organizers, managers and other main components to every instance  <a href="classito_1_1_app_management.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_i_o_helper.html">IOHelper</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_helper.html">ParamHelper</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_main_application.html">MainApplication</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classito_1_1_main_application.html" title="The MainApplication class is the basic management class for the entire application.">MainApplication</a> class is the basic management class for the entire application.  <a href="classito_1_1_main_application.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_break_point_item.html">BreakPointItem</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">item of <a class="el" href="class_break_point_model.html" title="model for management of all breakpoints. This model will be displayed by a viewer-widget in the main ...">BreakPointModel</a>  <a href="structito_1_1_break_point_item.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_class_navigator_item.html">ClassNavigatorItem</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_leaf_filter_proxy_model.html">LeafFilterProxyModel</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a special search function to the help model. The normal filtermodel hides nodes if they don´t contain the searched term, even though the children contain it.  <a href="classito_1_1_leaf_filter_proxy_model.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_plugin_load_status.html">PluginLoadStatus</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct provides a structure for saving the load status of any plugins or designerWidgets.  <a href="structito_1_1_plugin_load_status.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_plug_in_model.html">PlugInModel</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for visualizing the available (loaded) plugins  <a href="classito_1_1_plug_in_model.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_designer_plugin.html">DesignerPlugin</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_user_info_struct.html">UserInfoStruct</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_user_model.html">UserModel</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for for visualizing the available users  <a href="classito_1_1_user_model.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_manager.html">AddInManager</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for AddIn management  <a href="classito_1_1_add_in_manager.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_algo_interface_validator.html">AlgoInterfaceValidator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The class <a class="el" href="classito_1_1_algo_interface_validator.html" title="The class AlgoInterfaceValidator provides validators and checks in order to verify that a certain fil...">AlgoInterfaceValidator</a> provides validators and checks in order to verify that a certain filter or algoWidget that pretends to implement a certain interface really fits to the requirements and conditions of this interface.  <a href="classito_1_1_algo_interface_validator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dummy_itom_designer_plugin.html">DummyItomDesignerPlugin</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_figure_plugin.html">FigurePlugin</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_figure_category.html">FigureCategory</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_designer_widget_organizer.html">DesignerWidgetOrganizer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_help_system.html">HelpSystem</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_itom_palette_base.html">ItomPaletteBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_palette_organizer.html">PaletteOrganizer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_process_organizer.html">ProcessOrganizer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_qsci_api_manager.html">QsciApiManager</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_script_editor_organizer.html">ScriptEditorOrganizer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">organizes script editors, independent on their appearance (docked or window-style)  <a href="classito_1_1_script_editor_organizer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_ui_container.html">UiContainer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Every instance of this class contains information about one user interface (main window, dialog, dock widget...) which is organized by <a class="el" href="classito_1_1_ui_organizer.html" title="The UiOrganizer is started as singleton instance within itom and organizes all main windows...">UiOrganizer</a>.  <a href="structito_1_1_ui_container.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_ui_container_item.html">UiContainerItem</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_ui_data_container.html">UiDataContainer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_ui_organizer.html">UiOrganizer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classito_1_1_ui_organizer.html" title="The UiOrganizer is started as singleton instance within itom and organizes all main windows...">UiOrganizer</a> is started as singleton instance within itom and organizes all main windows, dialogs, widgets,... which are currently loaded at runtime from any ui-file or from a widget, provided by any algorithm plugin.  <a href="classito_1_1_ui_organizer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_user_interaction_watcher.html">UserInteractionWatcher</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_user_organizer.html">UserOrganizer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_wrapper.html">WidgetWrapper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">One instance of this class acts as wrapper for several import public methods of classes, derived from QObject, which should be made available by the call-method in python.  <a href="classito_1_1_widget_wrapper.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_auto_interval.html">PythonAutoInterval</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_common.html">PythonCommon</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_data_object.html">PythonDataObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_engine.html">PythonEngine</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_figure.html">PythonFigure</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_itom.html">PythonItom</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_python_q_object_marshal.html">PythonQObjectMarshal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_method_description.html">MethodDescription</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Small wrapper class with all necessary information for any method, signal or slot of class which should be inherited from QObject*.  <a href="classito_1_1_method_description.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_fct_call_param_container.html">FctCallParamContainer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">each instance of this class contains the parameters (including return parameter) for any function call, which is parsed by the Qt-signal-slot system. This class is especially used for wrapping function calls between C++ and any python method. The convention for the main member variables corresponds to the usual Qt-way to wrap such function calls.  <a href="classito_1_1_fct_call_param_container.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_np_data_object.html">PythonNpDataObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_numeric.html">PythonNumeric</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_plot_item.html">PythonPlotItem</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_plugins.html">PythonPlugins</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class summing up the functionality of itom - hardware python plugins  <a href="classito_1_1_python_plugins.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_proxy.html">PythonProxy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_qt_conversion.html">PythonQtConversion</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion class with mainly static methods, which convert values between Qt and standard C++ data types and PyObject* values.  <a href="classito_1_1_python_qt_conversion.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_qt_signal_target.html">PythonQtSignalTarget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_qt_signal_mapper_base.html">PythonQtSignalMapperBase</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for <a class="el" href="classito_1_1_python_qt_signal_mapper.html" title="This class provides the possibility to redirect any signal emitted in an user-defined GUI to differen...">PythonQtSignalMapper</a>  <a href="classito_1_1_python_qt_signal_mapper_base.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_qt_signal_mapper.html">PythonQtSignalMapper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the possibility to redirect any signal emitted in an user-defined GUI to different python methods.  <a href="classito_1_1_python_qt_signal_mapper.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_region.html">PythonRegion</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_rgba.html">PythonRgba</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_shared_pointer_guard.html">PythonSharedPointerGuard</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_param_conversion.html">PythonParamConversion</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_ui.html">PythonUi</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_timer_callback.html">TimerCallback</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_timer.html">PythonTimer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_py_workspace_item.html">PyWorkspaceItem</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_py_workspace_container.html">PyWorkspaceContainer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_q_debug_stream.html">QDebugStream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_filter_dialog.html">AbstractFilterDialog</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_property_page_widget.html">AbstractPropertyPageWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_about_q_itom.html">DialogAboutQItom</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_edit_breakpoint.html">DialogEditBreakpoint</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_goto.html">DialogGoto</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_icon_browser.html">DialogIconBrowser</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_loaded_plugins.html">DialogLoadedPlugins</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_new_plugin_instance.html">DialogNewPluginInstance</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_open_file_with_filter.html">DialogOpenFileWithFilter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_picker_sort_filter_proxy_model.html">PickerSortFilterProxyModel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_plugin_picker.html">DialogPluginPicker</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_properties.html">DialogProperties</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_reload_module.html">DialogReloadModule</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_replace.html">DialogReplace</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_save_file_with_filter.html">DialogSaveFileWithFilter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_select_user.html">DialogSelectUser</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_variable_detail.html">DialogVariableDetail</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_help_tree_dock_widget.html">HelpTreeDockWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_itom_spin_box.html">ItomSpinBox</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_input_parser.html">ParamInputParser</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_find_word.html">WidgetFindWord</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_info_box.html">WidgetInfoBox</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_console_last_command.html">WidgetPropConsoleLastCommand</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_console_wrap.html">WidgetPropConsoleWrap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_editor_a_p_i.html">WidgetPropEditorAPI</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_editor_auto_completion.html">WidgetPropEditorAutoCompletion</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_editor_calltips.html">WidgetPropEditorCalltips</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_editor_general.html">WidgetPropEditorGeneral</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_editor_styles.html">WidgetPropEditorStyles</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_figure_plugins.html">WidgetPropFigurePlugins</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_figure_plugin_delegate.html">FigurePluginDelegate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_general_application.html">WidgetPropGeneralApplication</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_general_language.html">WidgetPropGeneralLanguage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_help_dock.html">WidgetPropHelpDock</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_python_startup.html">WidgetPropPythonStartup</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_dock_widget.html">AbstractDockWidget</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract dock widget class which inherits QDockWidget. The content of QDockWidget consists of an instance of QMainWindow. The real widget is then placed as central widget of this QMainWindow. QMainWindow has the ability to show a menubar as well as a toolbar, which is used in different versions depending on docked state. Inherit <a class="el" href="classito_1_1_abstract_dock_widget.html" title="abstract dock widget class which inherits QDockWidget. The content of QDockWidget consists of an inst...">AbstractDockWidget</a> in order to realize content of QMainWindow.  <a href="classito_1_1_abstract_dock_widget.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_py_scintilla_widget.html">AbstractPyScintillaWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_a_i_manager_widget.html">AIManagerWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_break_point_dock_widget.html">BreakPointDockWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_call_stack_dock_widget.html">CallStackDockWidget</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">docking  <a href="classito_1_1_call_stack_dock_widget.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_console_widget.html">ConsoleWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_deque_command_list.html">DequeCommandList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_figure_widget.html">FigureWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_file_system_dock_widget.html">FileSystemDockWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_help_dock_widget.html">HelpDockWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_q_tab_widget_itom.html">QTabWidgetItom</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_q_tree_view_itom.html">QTreeViewItom</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_last_command_tree_widget.html">LastCommandTreeWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_last_command_dock_widget.html">LastCommandDockWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_main_window.html">MainWindow</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_script_dock_widget.html">ScriptDockWidget</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">widget containing one or multiple script editors (tabbed). This widget can either be a docking widget, docked in a docking area in the main window or it can be a floatable window which has a standard window behaviour.  <a href="classito_1_1_script_dock_widget.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_script_editor_storage.html">ScriptEditorStorage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_user_management.html">DialogUserManagement</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_workspace_dock_widget.html">WorkspaceDockWidget</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">docking widget for contents of type workspace widget  <a href="classito_1_1_workspace_dock_widget.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_workspace_widget.html">WorkspaceWidget</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">the workspaceWidget displays either a global or a local workspace given by a python dictionary. This widget is inherited from QTreeWidget.  <a href="classito_1_1_workspace_widget.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object_tags_private.html">DataObjectTagsPrivate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_range.html">Range</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">each range value has a start and end point. Optionally range can be marked as <a class="el" href="classito_1_1_range.html#a9019bdda86a9b42d3e804a26f6c46602">Range::all()</a>, which indicates a full range  <a href="classito_1_1_range.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object_tag_type.html">DataObjectTagType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_d_obj_const_iterator.html">DObjConstIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_d_obj_iterator.html">DObjIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html">DataObject</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">dataObject contains a n-dimensional matrix  <a href="classito_1_1_data_object.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_read_write_lock.html">ReadWriteLock</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_add_in_config_dialog_private.html">AbstractAddInConfigDialogPrivate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_add_in_config_dialog.html">AbstractAddInConfigDialog</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract base class for configuration dialogs of plugins  <a href="classito_1_1_abstract_add_in_config_dialog.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_add_in_dock_widget_private.html">AbstractAddInDockWidgetPrivate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_add_in_dock_widget.html">AbstractAddInDockWidget</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract base class for dock widgets (toolboxes) of plugins  <a href="classito_1_1_abstract_add_in_dock_widget.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_grabber.html">AddInGrabber</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherit from <a class="el" href="classito_1_1_add_in_grabber.html" title="Inherit from AddInGrabber if you write a camera/grabber plugin. Please call the constructor of AddInG...">AddInGrabber</a> if you write a camera/grabber plugin. Please call the constructor of <a class="el" href="classito_1_1_add_in_grabber.html" title="Inherit from AddInGrabber if you write a camera/grabber plugin. Please call the constructor of AddInG...">AddInGrabber</a> within your plugin constructor.  <a href="classito_1_1_add_in_grabber.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_exec_func_params.html">ExecFuncParams</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_filter_params.html">FilterParams</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_interface_base.html">AddInInterfaceBase</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class of the AddIn - Library (DLL) - Interface  <a href="classito_1_1_add_in_interface_base.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_base.html">AddInBase</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all plugins.  <a href="classito_1_1_add_in_base.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_data_i_o.html">AddInDataIO</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for all dataIO plugin classes  <a href="classito_1_1_add_in_data_i_o.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_actuator.html">AddInActuator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for all actuator plugin classes  <a href="classito_1_1_add_in_actuator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_algo.html">AddInAlgo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for all "algorithm" plugin classes  <a href="classito_1_1_add_in_algo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_byte_array.html">ByteArray</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_rgba32.html">Rgba32</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_r_g_b_channel.html">RGBChannel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1thread_actuator.html">threadActuator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to give plugin-Developer an easy access to actuators in other threads.  <a href="classito_1_1thread_actuator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1thread_camera.html">threadCamera</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to give plugin-Developer an easy access to cameras in other threads.  <a href="classito_1_1thread_camera.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_auto_interval.html">AutoInterval</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for a interval type containing a min-max-range and an auto-flag.  <a href="classito_1_1_auto_interval.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_base.html">ParamBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param.html">Param</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for parameter handling e.g. to pass paramters to plugins  <a href="classito_1_1_param.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_param_helper.html">ItomParamHelper</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_param_helper_3_01double_01_4.html">ItomParamHelper&lt; double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_param_helper_3_01int_01_4.html">ItomParamHelper&lt; int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_param_helper_3_01char_01_4.html">ItomParamHelper&lt; char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_param_helper_3_01unsigned_01char_01_4.html">ItomParamHelper&lt; unsigned char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_meta.html">ParamMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all meta-information classes.  <a href="classito_1_1_param_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_char_meta.html">CharMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins">Param</a> of type Char.  <a href="classito_1_1_char_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_int_meta.html">IntMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins">Param</a> of type Int.  <a href="classito_1_1_int_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_double_meta.html">DoubleMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins">ito::Param</a> of type Double.  <a href="classito_1_1_double_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_h_w_meta.html">HWMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins">Param</a> of type HWPtr.  <a href="classito_1_1_h_w_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_string_meta.html">StringMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins">Param</a> of type String.  <a href="classito_1_1_string_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_d_obj_meta.html">DObjMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins">Param</a> of type DObjPtr.  <a href="classito_1_1_d_obj_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_char_array_meta.html">CharArrayMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins">Param</a> of type <a class="el" href="classito_1_1_char_array_meta.html" title="Meta-information for Param of type CharArrayMeta.">CharArrayMeta</a>.  <a href="classito_1_1_char_array_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_int_array_meta.html">IntArrayMeta</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_double_array_meta.html">DoubleArrayMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins">Param</a> of type <a class="el" href="classito_1_1_double_array_meta.html" title="Meta-information for Param of type DoubleArrayMeta.">DoubleArrayMeta</a>.  <a href="classito_1_1_double_array_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_double_interval_meta.html">DoubleIntervalMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins">Param</a> of type <a class="el" href="classito_1_1_double_interval_meta.html" title="Meta-information for Param of type DoubleIntervalMeta.">DoubleIntervalMeta</a>.  <a href="classito_1_1_double_interval_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_interval_meta.html">IntervalMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins">Param</a> of type <a class="el" href="classito_1_1_int_array_meta.html">IntArrayMeta</a> that represent an interval (minimum, maximum).  <a href="classito_1_1_interval_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_range_meta.html">RangeMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins">Param</a> of type <a class="el" href="classito_1_1_int_array_meta.html">IntArrayMeta</a> that represent a range (left, right).  <a href="classito_1_1_range_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_rect_meta.html">RectMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins">Param</a> of type <a class="el" href="classito_1_1_int_array_meta.html">IntArrayMeta</a> that represent a rectangle (left, top, width, height).  <a href="classito_1_1_rect_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_ret_val.html">RetVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for error value management.  <a href="classito_1_1_ret_val.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_plugin_info.html">PluginInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_palette.html">ItomPalette</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_primitive_container.html">PrimitiveContainer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_rgba_base32.html">RgbaBase32</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d184b85b3805334e65f8cb73dfd2616"></a><!-- doxytag: member="ito::MethodDescriptionList" ref="a1d184b85b3805334e65f8cb73dfd2616" args="" -->
typedef QList&lt; <a class="el" href="classito_1_1_method_description.html">MethodDescription</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MethodDescriptionList</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1a36722155ba4cbcc3cb410858db7ef"></a><!-- doxytag: member="ito::tCreateFunc" ref="ad1a36722155ba4cbcc3cb410858db7ef" args=")(DataObject *dObj, const unsigned char dimensions, const int *sizes, const unsigned char continuous, const uchar *continuousDataPtr, const int *steps)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCreateFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned char dimensions, const int *sizes, const unsigned char continuous, const uchar *continuousDataPtr, const int *steps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b398f2a6e5931ab1fad8323905224c5"></a><!-- doxytag: member="ito::tCreateFuncWithCVPlanes" ref="a0b398f2a6e5931ab1fad8323905224c5" args=")(DataObject *dObj, const unsigned char dimensions, const int *sizes, const cv::Mat *planes, const unsigned int nrOfPlanes)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCreateFuncWithCVPlanes</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned char dimensions, const int *sizes, const cv::Mat *planes, const unsigned int nrOfPlanes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a579607698d3a482cb1e9488b028a1490"></a><!-- doxytag: member="ito::tFreeFunc" ref="a579607698d3a482cb1e9488b028a1490" args=")(DataObject *dObj)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tFreeFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05d2661eb508cabfe3ed9bfd8475adf1"></a><!-- doxytag: member="ito::tSecureFreeFunc" ref="a05d2661eb508cabfe3ed9bfd8475adf1" args=")(DataObject *dObj)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tSecureFreeFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e225dc89c9782086d9bfcf6c61192aa"></a><!-- doxytag: member="ito::tCopyToFunc" ref="a9e225dc89c9782086d9bfcf6c61192aa" args=")(const DataObject &amp;lhs, DataObject &amp;rhs, unsigned char regionOnly)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCopyToFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, unsigned char regionOnly)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56f51a787377536fbbb35cf54edcdc72"></a><!-- doxytag: member="ito::tDeepCopyPartialFunc" ref="a56f51a787377536fbbb35cf54edcdc72" args=")(DataObject &amp;lhs, DataObject &amp;rhs)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tDeepCopyPartialFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a218ed5a3f3d9439c7ceb3920210f1306"></a><!-- doxytag: member="ito::tConvertToFunc" ref="a218ed5a3f3d9439c7ceb3920210f1306" args=")(const DataObject &amp;lhs, DataObject &amp;rhs, const int type, const double alpha, const double beta)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tConvertToFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, const int type, const double alpha, const double beta)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a776d4f1ec80ef4974bbc13776b0c4514"></a><!-- doxytag: member="ito::tZerosFunc" ref="a776d4f1ec80ef4974bbc13776b0c4514" args=")(const int sizeY, const int sizeX, uchar **dstMat)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tZerosFunc</b> )(const int sizeY, const int sizeX, uchar **dstMat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d7b4c2dbf583cf20e8e2ccfdc097a1a"></a><!-- doxytag: member="ito::tOnesFunc" ref="a8d7b4c2dbf583cf20e8e2ccfdc097a1a" args=")(const int sizeY, const int sizeX, uchar **dstMat)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tOnesFunc</b> )(const int sizeY, const int sizeX, uchar **dstMat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a719f76b90761f6fabf6c627935615830"></a><!-- doxytag: member="ito::tRandFunc" ref="a719f76b90761f6fabf6c627935615830" args=")(const int sizeY, const int sizeX, const double value1, const double value2, const bool randMode, uchar **dstMat)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tRandFunc</b> )(const int sizeY, const int sizeX, const double value1, const double value2, const bool randMode, uchar **dstMat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab789b3747f2d4e8bd06bc3db4424afe2"></a><!-- doxytag: member="ito::tCopyMatFunc" ref="ab789b3747f2d4e8bd06bc3db4424afe2" args=")(uchar **src, uchar **&amp;dst, bool transposed, const int sizeofs)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCopyMatFunc</b> )(uchar **src, uchar **&amp;dst, bool transposed, const int sizeofs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca6e3dd9430a6b79e04f46ec987b7c9b"></a><!-- doxytag: member="ito::tAssignScalarFunc" ref="aca6e3dd9430a6b79e04f46ec987b7c9b" args=")(const DataObject *src, const ito::tDataType type, const void *scalar)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tAssignScalarFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> type, const void *scalar)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f18c87103be0d305e4c941bc7716002"></a><!-- doxytag: member="ito::tAddFunc" ref="a3f18c87103be0d305e4c941bc7716002" args=")(const DataObject *src1, const DataObject *src2, DataObject *dst)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tAddFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47d2abf030ce88e0dc393d5239766e59"></a><!-- doxytag: member="ito::tAddScalarFunc" ref="a47d2abf030ce88e0dc393d5239766e59" args=")(const DataObject *dObjIn, ito::float64 scalar, DataObject *dObjOut)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tAddScalarFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjIn, ito::float64 scalar, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a181299e491f51cebccffe55e7ab9e48c"></a><!-- doxytag: member="ito::tSubFunc" ref="a181299e491f51cebccffe55e7ab9e48c" args=")(const DataObject *src1, const DataObject *src2, DataObject *dst)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tSubFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abceb8e48e57030a10d4f7331ef1d38fc"></a><!-- doxytag: member="ito::tOpMulFunc" ref="abceb8e48e57030a10d4f7331ef1d38fc" args=")(const DataObject *src1, const DataObject *src2, DataObject *dst)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tOpMulFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a674ab2ade49e62b34c388ef96b9b9abd"></a><!-- doxytag: member="ito::tOpScalarMulFunc" ref="a674ab2ade49e62b34c388ef96b9b9abd" args=")(const DataObject *src, const double &amp;factor)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tOpScalarMulFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const double &amp;factor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa35e5b801b599ca73dfc85e25bf5076c"></a><!-- doxytag: member="ito::tCmpFunc" ref="aa35e5b801b599ca73dfc85e25bf5076c" args=")(const DataObject *src1, const DataObject *src2, DataObject *dst, int cmpOp)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCmpFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst, int cmpOp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8843ed96e703e61ff5f47da85a508dc"></a><!-- doxytag: member="ito::tShiftLFunc" ref="ab8843ed96e703e61ff5f47da85a508dc" args=")(DataObject *src, const unsigned char shiftbit)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tShiftLFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const unsigned char shiftbit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e185821ebaeb2090928c53b806786f4"></a><!-- doxytag: member="ito::tShiftRFunc" ref="a9e185821ebaeb2090928c53b806786f4" args=")(DataObject *src, const unsigned char shiftbit)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tShiftRFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const unsigned char shiftbit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac46799d32f26674c9214c4ce3707370e"></a><!-- doxytag: member="ito::tBitAndFunc" ref="ac46799d32f26674c9214c4ce3707370e" args=")(const DataObject *src1, const DataObject *src2, DataObject *dst)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tBitAndFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa30e6492db24fb4b187d300c4e19190"></a><!-- doxytag: member="ito::tBitOrFunc" ref="aaa30e6492db24fb4b187d300c4e19190" args=")(const DataObject *src1, const DataObject *src2, DataObject *dst)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tBitOrFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea25eb675491904693c2e37bdb5801ee"></a><!-- doxytag: member="ito::tBitXorFunc" ref="aea25eb675491904693c2e37bdb5801ee" args=")(const DataObject *src1, const DataObject *src2, DataObject *dst)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tBitXorFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af74c540c806191b37b2aa846d2ed1f5b"></a><!-- doxytag: member="ito::tGetRangeFunc" ref="af74c540c806191b37b2aa846d2ed1f5b" args=")(DataObject *dObj, const int dtop, const int dbottom, const int dleft, const int dright)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tGetRangeFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const int dtop, const int dbottom, const int dleft, const int dright)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fce076240bb1af1ff9dde93ea87c914"></a><!-- doxytag: member="ito::tAdjustROIFunc" ref="a8fce076240bb1af1ff9dde93ea87c914" args=")(DataObject *dObj, int dtop, int dbottom, int dleft, int dright)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tAdjustROIFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, int dtop, int dbottom, int dleft, int dright)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54bad3d95d8fc81cc819f0ff3097b551"></a><!-- doxytag: member="ito::tEyeFunc" ref="a54bad3d95d8fc81cc819f0ff3097b551" args=")(const int size, uchar **dstMat)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tEyeFunc</b> )(const int size, uchar **dstMat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1939d9a44426c4c6fa500836032a5500"></a><!-- doxytag: member="ito::tConjFunc" ref="a1939d9a44426c4c6fa500836032a5500" args=")(DataObject *dObj)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tConjFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2912a735b82241ff7939136deecb8ca"></a><!-- doxytag: member="ito::tRowFunc" ref="ad2912a735b82241ff7939136deecb8ca" args=")(DataObject *dObj, const unsigned int selRow)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tRowFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned int selRow)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51d4e7953b9556acdce6d2ff68bb7fa8"></a><!-- doxytag: member="ito::tColFunc" ref="a51d4e7953b9556acdce6d2ff68bb7fa8" args=")(DataObject *dObj, const unsigned int selCol)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tColFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned int selCol)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a201a8fc0b1eac2edad8e8aa131d7c79e"></a><!-- doxytag: member="ito::tMulFunc" ref="a201a8fc0b1eac2edad8e8aa131d7c79e" args=")(const DataObject *src1, const DataObject *src2, DataObject *res, const double scale)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tMulFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *res, const double scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbcda67c8239ce15691839180fb6adc9"></a><!-- doxytag: member="ito::tDivFunc" ref="adbcda67c8239ce15691839180fb6adc9" args=")(const DataObject *src1, const DataObject *src2, DataObject *res, const double scale)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tDivFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *res, const double scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a674b0080f512e406c6d2d719a5d040ba"></a><!-- doxytag: member="ito::tAbsFunc" ref="a674b0080f512e406c6d2d719a5d040ba" args=")(const DataObject *dObj, DataObject *resObj)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tAbsFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf2f6ec8dc42e5c9a47697c93242b35f"></a><!-- doxytag: member="ito::tArgFunc" ref="acf2f6ec8dc42e5c9a47697c93242b35f" args=")(const DataObject *dObj, DataObject *resObj)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tArgFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dfc73f3786787fbd2f36bbb83b1b74c"></a><!-- doxytag: member="ito::tRealFunc" ref="a3dfc73f3786787fbd2f36bbb83b1b74c" args=")(const DataObject *dObj, DataObject *resObj)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tRealFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a264cf4c255ff6dfbbf4c7a613653f0e9"></a><!-- doxytag: member="ito::tImagFunc" ref="a264cf4c255ff6dfbbf4c7a613653f0e9" args=")(const DataObject *dObj, DataObject *resObj)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tImagFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a859f5e5658f1c4a388b86c2b94d9f46a"></a><!-- doxytag: member="ito::tMakeContinuousFunc" ref="a859f5e5658f1c4a388b86c2b94d9f46a" args=")(const DataObject &amp;dObj, DataObject &amp;resDObj)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tMakeContinuousFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;resDObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdb47b5b70eea8dac2f49e41e6048be8"></a><!-- doxytag: member="ito::tCoutFunc" ref="acdb47b5b70eea8dac2f49e41e6048be8" args=")(std::ostream &amp;out, const DataObject &amp;dObj)" -->
typedef std::ostream &amp;(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCoutFunc</b> )(std::ostream &amp;out, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9a6e9ace75645d3010dbb885fe05f66"></a><!-- doxytag: member="ito::AlphaChannel" ref="ae9a6e9ace75645d3010dbb885fe05f66" args="" -->
typedef <a class="el" href="classito_1_1_r_g_b_channel.html">RGBChannel</a><br class="typebreak"/>
&lt; Rgba32::RGBA_A &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AlphaChannel</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf216996d3046c629bf9889cd4a0bc90"></a><!-- doxytag: member="ito::RedChannel" ref="adf216996d3046c629bf9889cd4a0bc90" args="" -->
typedef <a class="el" href="classito_1_1_r_g_b_channel.html">RGBChannel</a><br class="typebreak"/>
&lt; Rgba32::RGBA_R &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RedChannel</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac02405a0ec6cb97dffe9a46b2aa6d1ae"></a><!-- doxytag: member="ito::GreenChannel" ref="ac02405a0ec6cb97dffe9a46b2aa6d1ae" args="" -->
typedef <a class="el" href="classito_1_1_r_g_b_channel.html">RGBChannel</a><br class="typebreak"/>
&lt; Rgba32::RGBA_G &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GreenChannel</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a2c6e352aaa11b4d818c1e15edade65"></a><!-- doxytag: member="ito::BlueChannel" ref="a5a2c6e352aaa11b4d818c1e15edade65" args="" -->
typedef <a class="el" href="classito_1_1_r_g_b_channel.html">RGBChannel</a><br class="typebreak"/>
&lt; Rgba32::RGBA_B &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BlueChannel</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfb68169378e1801c903a3c11472ed1b"></a><!-- doxytag: member="ito::int8" ref="adfb68169378e1801c903a3c11472ed1b" args="" -->
typedef int8_t&#160;</td><td class="memItemRight" valign="bottom"><b>int8</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af28e9c7a6873a87cb6a6d4c9e8293380"></a><!-- doxytag: member="ito::int16" ref="af28e9c7a6873a87cb6a6d4c9e8293380" args="" -->
typedef int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>int16</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7d30f17fdb55cf4b8832bf284045732"></a><!-- doxytag: member="ito::int32" ref="af7d30f17fdb55cf4b8832bf284045732" args="" -->
typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>int32</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a109f9ea5c8d2dbe9dc1647c0d20bfc"></a><!-- doxytag: member="ito::uint8" ref="a8a109f9ea5c8d2dbe9dc1647c0d20bfc" args="" -->
typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>uint8</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ed4f11b7fc17f66fb746c9ec331a1f9"></a><!-- doxytag: member="ito::uint16" ref="a0ed4f11b7fc17f66fb746c9ec331a1f9" args="" -->
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>uint16</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c56952b10680ef46b594cfeaf56f898"></a><!-- doxytag: member="ito::uint32" ref="a8c56952b10680ef46b594cfeaf56f898" args="" -->
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>uint32</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afca36c5597ed39e5ef07b688d29e16a4"></a><!-- doxytag: member="ito::float32" ref="afca36c5597ed39e5ef07b688d29e16a4" args="" -->
typedef float&#160;</td><td class="memItemRight" valign="bottom"><b>float32</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1dc6b3b1081db881220b71b74e70319"></a><!-- doxytag: member="ito::float64" ref="ab1dc6b3b1081db881220b71b74e70319" args="" -->
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>float64</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46b874ecd64788e7d33c8d2b1f76febe"></a><!-- doxytag: member="ito::complex64" ref="a46b874ecd64788e7d33c8d2b1f76febe" args="" -->
typedef std::complex<br class="typebreak"/>
&lt; ito::float32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>complex64</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63b9394bb5bcc3baf7409f0e5f8ebfe2"></a><!-- doxytag: member="ito::complex128" ref="a63b9394bb5bcc3baf7409f0e5f8ebfe2" args="" -->
typedef std::complex<br class="typebreak"/>
&lt; ito::float64 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>complex128</b></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcf">tPluginLoadStatusFlag</a> { <br/>
&#160;&#160;<a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcfa0c084ed64a1e58022675c2855494b904">plsfOk</a> =  0x001, 
<a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcfae886791877d339615c79aed5c21d35f0">plsfWarning</a> =  0x002, 
<a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcfa89928bf15c88b96936c0f981580994ba">plsfError</a> =  0x004, 
<a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcfa8e51ce1381d3ccf924b2b6152b554f88">plsfIgnored</a> =  0x008, 
<br/>
&#160;&#160;<a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcfa83b35bae2ed80b743503263abc05ddf8">plsfRelDbg</a> =  0x100
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>userTypes</b> { <b>userTypeBasic</b> =  0, 
<b>userTypeAdministrator</b> =  1, 
<b>userTypeDeveloper</b> =  2
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>userFeatures</b> { <br/>
&#160;&#160;<b>featDeveloper</b> =  1, 
<b>featFileSystem</b> =  2, 
<b>featUserManag</b> =  4, 
<b>featPlugins</b> =  8, 
<br/>
&#160;&#160;<b>featConsole</b> =  16, 
<b>featConsoleRW</b> =  32
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30">tPluginType</a> { <br/>
&#160;&#160;<a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30a4cab6a4edc95b2ef6846c79aedd818cb">typeDataIO</a> =  0x1, 
<a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30a67b1093d817ca4c45de9b4b1075045b1">typeActuator</a> =  0x2, 
<a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30a8c028979c4b81e7eaa0a7f51e1e62d26">typeAlgo</a> =  0x4, 
<a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30af4dfe66a7744cc365947716d5bdb9f6d">typeGrabber</a> =  0x80, 
<br/>
&#160;&#160;<a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30a95ac93a74aac433a17c998c1810e3e51">typeADDA</a> =  0x100, 
<a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30ad2e2fbe4821bac18934a307bd89428c2">typeRawIO</a> =  0x200
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tPluginType enumeration  <a href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383">tActuatorStatus</a> { <br/>
&#160;&#160;<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a599af524525e8c64bddf91298784e767">actuatorUnknown</a> =  0x0001, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a8b74ac01caf78e23c95f58b02eaab2a0">actuatorInterrupted</a> =  0x0002, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a159167245176483f6062495f2baadd00">actuatorMoving</a> =  0x0004, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383af8836b7f26106593b4d36a5c857ec048">actuatorAtTarget</a> =  0x0008, 
<br/>
&#160;&#160;<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a84db4f5b5d047c90ca78d93b46656874">actuatorTimeout</a> =  0x0010, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383ae70cba1af756a2c62c1fc2957643b424">actuatorEndSwitch</a> =  0x0100, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a6edddb993c8b1438045128e4f8a7788f">actuatorLeftEndSwitch</a> =  0x0200, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a3d4d3a51e6e7e7fee69ae59d359f8be7">actuatorRightEndSwitch</a> =  0x0400, 
<br/>
&#160;&#160;<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383af55796f42d5efcd1ea80324402d4d72f">actuatorRefSwitch</a> =  0x0800, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a993a882ad6ec2c8f7657483b637a9f87">actuatorLeftRefSwitch</a> =  0x1000, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a85d7cfb84b5000f7ac16726433589e39">actuatorRightRefSwitch</a> =  0x2000, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a5a1d7a7c2ab70910db005617b3a8571a">actuatorAvailable</a> =  0x4000, 
<br/>
&#160;&#160;<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a83f4cf9f8319fbbeec0b7f75f4d07682">actuatorEnabled</a> =  0x8000, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a067270bd694afa11b542e1768d50b06b">actMovingMask</a> =  actuatorUnknown | actuatorInterrupted | actuatorMoving | actuatorAtTarget | actuatorTimeout, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a088d0d001f7e269d045e17084e31a343">actEndSwitchMask</a> =  actuatorEndSwitch | actuatorLeftEndSwitch | actuatorRightEndSwitch, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383afe023404e59f14ea85192ecf4a205d3e">actRefSwitchMask</a> =  actuatorRefSwitch | actuatorLeftRefSwitch | actuatorRightRefSwitch, 
<br/>
&#160;&#160;<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383ab8727b678dd0975d5259d4ef6e0c2c71">actSwitchesMask</a> =  actEndSwitchMask | actRefSwitchMask, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a13165fe6a2fd39d5092982cf35388dfc">actStatusMask</a> =  actuatorAvailable | actuatorEnabled
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tActuatorStatus enumeration  <a href="namespaceito.html#ab4779b960376c89061f1b12ae3738383">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a20bda469be01178ac6cf406bcba2ee73">tAutoLoadPolicy</a> { <a class="el" href="namespaceito.html#a20bda469be01178ac6cf406bcba2ee73a8ec2058becac1ccaae65864d6f961cdf">autoLoadAlways</a> =  0x1, 
<a class="el" href="namespaceito.html#a20bda469be01178ac6cf406bcba2ee73ad39587830e30b302adc4421224049c28">autoLoadNever</a> =  0x2, 
<a class="el" href="namespaceito.html#a20bda469be01178ac6cf406bcba2ee73a4c932e4379045955c6194e202c0b6b2d">autoLoadKeywordDefined</a> =  0x4
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8d769b26bbab936560f4c95674ff5477">tAutoSavePolicy</a> { <a class="el" href="namespaceito.html#a8d769b26bbab936560f4c95674ff5477a9ca1d2e8fbcc5c11e86bd24fcdec9e50">autoSaveAlways</a> =  0x1, 
<a class="el" href="namespaceito.html#a8d769b26bbab936560f4c95674ff5477a977bb0b86cfdfa0e8486241790087703">autoSaveNever</a> =  0x2
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>PlotDataType</b> { <br/>
&#160;&#160;<b>DataObjLine</b> =  0x0001, 
<b>DataObjPlane</b> =  0x0002, 
<b>DataObjPlaneStack</b> =  0x0004, 
<b>PointCloud</b> =  0x0008, 
<br/>
&#160;&#160;<b>PolygonMesh</b> =  0x0010
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>PlotDataFormat</b> { <br/>
&#160;&#160;<b>Format_Gray8</b> =  0x0001, 
<b>Format_Gray16</b> =  0x0002, 
<b>Format_Gray32</b> =  0x0004, 
<b>Format_RGB32</b> =  0x0008, 
<br/>
&#160;&#160;<b>Format_ARGB32</b> =  0x0010, 
<b>Format_CMYK32</b> =  0x0020, 
<b>Format_Float32</b> =  0x0040, 
<b>Format_Float64</b> =  0x0080, 
<br/>
&#160;&#160;<b>Format_Complex</b> =  0x0100
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>PlotFeature</b> { <br/>
&#160;&#160;<b>Static</b> =  0x0001, 
<b>Live</b> =  0x0002, 
<b>Cartesian</b> =  0x0004, 
<b>Polar</b> =  0x0008, 
<br/>
&#160;&#160;<b>Cylindrical</b> =  0x0010, 
<b>OpenGl</b> =  0x0020, 
<b>Cuda</b> =  0x0040, 
<b>X3D</b> =  0x0080, 
<br/>
&#160;&#160;<b>PlotLine</b> =  0x0100, 
<b>PlotImage</b> =  0x0200, 
<b>PlotISO</b> =  0x0400, 
<b>Plot3D</b> =  0x0800
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>tPalette</b> { <br/>
&#160;&#160;<b>tPaletteNoType</b> =  0x00, 
<b>tPaletteGray</b> =  0x01, 
<b>tPaletteRGB</b> =  0x02, 
<b>tPaletteFC</b> =  0x04, 
<br/>
&#160;&#160;<b>tPaletteIndexed</b> =  0x08, 
<b>tPaletteLinear</b> =  0x10, 
<b>tPaletteReadOnly</b> =  0x20
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a43f8ec3cdde4591a8ea77f4faf569773">tLogLevel</a> { <br/>
&#160;&#160;<b>logNone</b> =  0x0, 
<b>logError</b> =  0x1, 
<b>logWarning</b> =  0x2, 
<b>logInfo</b> =  0x4, 
<br/>
&#160;&#160;<b>logAll</b> =  logInfo | logWarning | logError
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202">tRetValue</a> { <a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a2ced39cc25866a04f2fb1c9f1d6a542e">retOk</a> =  0x0, 
<a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a59b8253725a061086f085758a117002b">retWarning</a> =  0x1, 
<a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a199f41b7779e742e0a3cc281c42c97c0">retError</a> =  0x2
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8811ca8b85b70b969122b25a7c84e0ee">tMsgType</a> { <br/>
&#160;&#160;<b>msgReturnInfo</b>, 
<b>msgReturnWarning</b>, 
<b>msgReturnError</b>, 
<b>msgTextInfo</b>, 
<br/>
&#160;&#160;<b>msgTextWarning</b>, 
<b>msgTextError</b>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>tPythonDbgCmd</b> { <br/>
&#160;&#160;<b>pyDbgNone</b> = 0, 
<b>pyDbgContinue</b> = 1, 
<b>pyDbgStep</b> = 2, 
<b>pyDbgStepOut</b> = 4, 
<br/>
&#160;&#160;<b>pyDbgStepOver</b> = 8, 
<b>pyDbgQuit</b> = 16
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>tPythonTransitions</b> { <br/>
&#160;&#160;<b>pyTransBeginRun</b> =  1, 
<b>pyTransEndRun</b> =  2, 
<b>pyTransBeginDebug</b> =  4, 
<b>pyTransEndDebug</b> =  8, 
<br/>
&#160;&#160;<b>pyTransDebugWaiting</b> =  16, 
<b>pyTransDebugContinue</b> =  32, 
<b>pyTransDebugExecCmdBegin</b> =  64, 
<b>pyTransDebugExecCmdEnd</b> =  128
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>tCompareResult</b> { <b>tCmpEqual</b>, 
<b>tCmpCompatible</b>, 
<b>tCmpFailed</b>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>tPythonState</b> { <br/>
&#160;&#160;<b>pyStateIdle</b> =  1, 
<b>pyStateRunning</b> =  2, 
<b>pyStateDebugging</b> =  4, 
<b>pyStateDebuggingWaiting</b> =  8, 
<br/>
&#160;&#160;<b>pyStateDebuggingWaitingButBusy</b> =  16
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">tDataType</a> { <br/>
&#160;&#160;<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa35aa1b8e08158b49ebbf6bdfb4b6a508">tInt8</a> =  0, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaad21eb4541e782dc23501912f788a38bd">tUInt8</a> =  1, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa142219f864f22d3b2e6f116f5f5cd936">tInt16</a> =  2, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa68d7e991164d07a036f40379a101112b">tUInt16</a> =  3, 
<br/>
&#160;&#160;<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa47b295973c6b4b7de62599401c16df62">tInt32</a> =  4, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaaf08334798ddd5082595350b296a7a868">tUInt32</a> =  5, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa17ad621a0158b30fc85eb1e89b93ce3b">tFloat32</a> =  6, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa6b9559a5cfa765160ae209ecdc258ed6">tFloat64</a> =  7, 
<br/>
&#160;&#160;<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa722b93c77819223b8d630ab0fca5a0ec">tComplex64</a> =  8, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa39fef9b8e46915c6ba232020e2fe2e7a">tComplex128</a> =  9, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa8473d2c11cdf726247c29c5ecf7dfbaa">tRGBA32</a> =  10
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360e">tPCLPointType</a> { <br/>
&#160;&#160;<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360eaa2585c0961b5f357d98ed732c17b9359">pclInvalid</a> =  0x0000, 
<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360ea6273432d3a0ca503e1a77d27ad8ab994">pclXYZ</a> =  0x0001, 
<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360ea6385e470bdc9a9e3aead145eb0ded4d8">pclXYZI</a> =  0x0002, 
<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360eaefd9ce8422846a24673536424375f223">pclXYZRGBA</a> =  0x0004, 
<br/>
&#160;&#160;<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360ea5f6680f5c10ff985f0be8ce06780e16a">pclXYZNormal</a> =  0x0008, 
<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360ea9c19394acf64356ecfc0ed60bc6c8b52">pclXYZINormal</a> =  0x0010, 
<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360ea6dd64651a1b85540ac80b6efa5eeb738">pclXYZRGBNormal</a> =  0x0020
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a87c024c43b3d17174e8f0b14fdc09cd6">apiFCheckAndSetParamVal</a> (QVariant *tempParam, <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> *param, int *set)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aba757c479378ddaa7db70850c6590f3c">apiFParseInitParams</a> (QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *initParamListMand, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *initParamListOpt, QVector&lt; QVariant &gt; *params)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QMap&lt; QString, QString &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a2a69198fb9449e1750a65dabb3911cd3">getItomVersionMap</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called to get all version numbers that itom contains.  <a href="#a2a69198fb9449e1750a65dabb3911cd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25e9de463e6bb8a123be7e0435b5a8fe"></a><!-- doxytag: member="ito::operator&lt;&lt;" ref="a25e9de463e6bb8a123be7e0435b5a8fe" args="(QDataStream &amp;out, const BreakPointItem &amp;obj)" -->
QDataStream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (QDataStream &amp;out, const <a class="el" href="structito_1_1_break_point_item.html">BreakPointItem</a> &amp;obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e76ddc8f9036d1de55f03ea8d8f00b6"></a><!-- doxytag: member="ito::operator&gt;&gt;" ref="a0e76ddc8f9036d1de55f03ea8d8f00b6" args="(QDataStream &amp;in, BreakPointItem &amp;obj)" -->
QDataStream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (QDataStream &amp;in, <a class="el" href="structito_1_1_break_point_item.html">BreakPointItem</a> &amp;obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a2ee6d1fc3b644438e7e45011be71540e">decRefParamPlugins</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *ai)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a9f86dfd2e4d25372a4b35066e423f4b2">incRefParamPlugins</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *ai, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *paramsMand, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *paramsOpt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01244bd1f2f2bc62040ed24856e00ff1"></a><!-- doxytag: member="ito::operator&lt;&lt;" ref="a01244bd1f2f2bc62040ed24856e00ff1" args="(QDataStream &amp;out, const ito::ScriptEditorStorage &amp;obj)" -->
QDataStream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (QDataStream &amp;out, const <a class="el" href="structito_1_1_script_editor_storage.html">ito::ScriptEditorStorage</a> &amp;obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8ca7cb1f82cb947bbda0d495db69237"></a><!-- doxytag: member="ito::operator&gt;&gt;" ref="ad8ca7cb1f82cb947bbda0d495db69237" args="(QDataStream &amp;in, ito::ScriptEditorStorage &amp;obj)" -->
QDataStream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (QDataStream &amp;in, <a class="el" href="structito_1_1_script_editor_storage.html">ito::ScriptEditorStorage</a> &amp;obj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e0952e9e0b0a818cdcdd5400923e814"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a3e0952e9e0b0a818cdcdd5400923e814" args="(autoIntervalInit_doc,&quot;autoInterval([min=&#45;inf, max=inf, auto=false]) &#45;&gt; creates a new auto interval object.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
min : {float} \n\
    minimum value of interval (default: &#45;infinity) \n\
max : {float}, \n\
    maximum value of interval (default: +infinity) \n\
auto : {uint8} \n\
    0 if interval is fixed (default), 1 if the interval can be scaled automatically&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (autoIntervalInit_doc,&quot;autoInterval([min=-inf, max=inf, auto=false]) -&gt; creates a new auto interval object.\n\
\n\
Parameters \n\
----------- \n\
min : {float} \n\
    minimum value of interval (default: -infinity) \n\
max : {float}, \n\
    maximum value of interval (default: +infinity) \n\
auto : {uint8} \n\
    0 if interval is fixed (default), 1 if the interval can be scaled automatically&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#acaadeb5a84e7fa9f44207f4f6ea80a85">checkAndSetParamVal</a> (PyObject *tempObj, <a class="el" href="classito_1_1_param.html">ito::Param</a> *param, int *set)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0733e868f1be90670675e6984876ba2f"></a><!-- doxytag: member="ito::checkAndSetParamVal" ref="a0733e868f1be90670675e6984876ba2f" args="(PyObject *pyObj, const ito::Param *defaultParam, ito::ParamBase &amp;outParam, int *set)" -->
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a0733e868f1be90670675e6984876ba2f">checkAndSetParamVal</a> (PyObject *pyObj, const <a class="el" href="classito_1_1_param.html">ito::Param</a> *defaultParam, <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &amp;outParam, int *set)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to print out parameters to a dictionary and the itom-console. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6437a093317b540f12e592fcf9470f6"></a><!-- doxytag: member="ito::PrntOutParams" ref="ac6437a093317b540f12e592fcf9470f6" args="(const QVector&lt; ito::Param &gt; *params, bool asErr, bool addInfos, const int num, bool printToStdStream)" -->
PyObject *&#160;</td><td class="memItemRight" valign="bottom"><b>PrntOutParams</b> (const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *params, bool asErr, bool addInfos, const int num, bool printToStdStream)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8b32235878d1e9594569d92771bfcfcd">errOutInitParams</a> (const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *params, const int num, const QString reason)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8e672322a951881453fcd73de2c771ff">parseInitParams</a> (QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *initParamListMand, QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *initParamListOpt, PyObject *args, PyObject *kwds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a141b897a464e5d831cf05c76f19f24b4"></a><!-- doxytag: member="ito::parseInitParams" ref="a141b897a464e5d831cf05c76f19f24b4" args="(const QVector&lt; ito::Param &gt; *defaultParamListMand, const QVector&lt; ito::Param &gt; *defaultParamListOpt, PyObject *args, PyObject *kwds, QVector&lt; ito::ParamBase &gt; &amp;paramListMandOut, QVector&lt; ito::ParamBase &gt; &amp;paramListOptOut)" -->
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseInitParams</b> (const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *defaultParamListMand, const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *defaultParamListOpt, PyObject *args, PyObject *kwds, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;paramListMandOut, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;paramListOptOut)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#af336f965d8dcb64d35de938c63e18e53">copyParamVector</a> (const QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *paramVecIn, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;paramVecOut)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad9596d29ad4cb556064117c73031bd0d">copyParamVector</a> (const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramVecIn, QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; &amp;paramVecOut)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1c6bd4bcdbd9f72e50bbbe132b204db"></a><!-- doxytag: member="ito::copyParamVector" ref="ac1c6bd4bcdbd9f72e50bbbe132b204db" args="(const QVector&lt; ito::Param &gt; *paramVecIn, QVector&lt; ito::ParamBase &gt; &amp;paramVecOut)" -->
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>copyParamVector</b> (const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramVecIn, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;paramVecOut)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecf6fce61a26436009f63cd0e37da946"></a><!-- doxytag: member="ito::createEmptyParamBaseFromParamVector" ref="aecf6fce61a26436009f63cd0e37da946" args="(const QVector&lt; ito::Param &gt; *paramVecIn, QVector&lt; ito::ParamBase &gt; &amp;paramVecOut)" -->
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aecf6fce61a26436009f63cd0e37da946">createEmptyParamBaseFromParamVector</a> (const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramVecIn, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;paramVecOut)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function searches for reserves Keywords (e.g. autoLoadParams) sets the corresponding bool parameter to the right value and than deletes the keyword. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a01723110515894b52457c2e3ffbb3d6f">findAndDeleteReservedInitKeyWords</a> (PyObject *kwds, bool *enableAutoLoadParams)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeddc375b0c7a21152f858961b7914412"></a><!-- doxytag: member="ito::buildFilterOutputValues" ref="aeddc375b0c7a21152f858961b7914412" args="(QVector&lt; QVariant &gt; *outVals, ito::RetVal &amp;retValue)" -->
PyObject *&#160;</td><td class="memItemRight" valign="bottom"><b>buildFilterOutputValues</b> (QVector&lt; QVariant &gt; *outVals, <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> &amp;retValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a616eeca3c7b5773bfffeba9839402297">PyDoc_STRVAR</a> (dataObjectInit_doc,&quot;dataObject([dims [, dtype='uint8'[, continuous = 0][, data = valueOrSequence]]]) -&gt; constructor to get a new dataObject.\n\
\n\
The itom.dataObject represents a multidimensional array of fixed-size items with corresponding meta information (units, axes descriptions, scalings, tags, protocol...). \n\
Recently the following data types (dtype) are supported: \n\
\n\
* Integer-type (int8, uint8, int16, uint16, int32, uint32),\n\
* Floating-type (float32, float64 (=&gt; double)),\n\
* Complex-type  (complex64 (2x float32), complex128 (2x float64)).\n\
* Color-type  (rgba32 (uint32 or uint[4] containing the four 8bit values [R, G, B, Alpha])).\n\
\n\
Arrays can also be constructed using some of the static pre-initialization methods 'zeros', 'ones', 'rand' or 'randN' (refer to the See Also section below). \n\
\n\
Parameters \n\
----------- \n\
dims : {sequence of integers}, optional \n\
    'dims' is a list or tuple indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns. If not given, an empty data object is created.\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','uint32','float32','float64','complex64','complex128', 'rgba32'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
data : {str}, optional \n\
    'data' is a single value or a sequence with the same amount of values than the data object. The values from data will be assigned to the new data object (filled row by row).\n\
\n\
Notes \n\
------ \n\
\n\
The itom.dataObject is a direct wrapper for the underlying C++ class *dataObject*. This array class mainly is based on the class *Mat* of the computer vision library (OpenCV). \n\
\n\
In order to handle huge matrices, the data object can divide one array into chunks in memory.\n\
Each subpart (called matrix-plane) is two-dimensional and covers data of the last two dimensions.\n\
In c++-context each of these matrix-planes is of type cv::Mat_&lt;type&gt; and can be used with every operator given by the openCV-framework (version 2.3.1 or higher).\n\
\n\
The dimensions of the matrix are structured descending. So if we assume to have a n-dimensional matrix A,\n\
where each dimension has its size s_i, the dimensions order is n, .., z, y, x and the corresponding sizes of A are [s_n, s_(n-1),  s_(n-2), ..., s_y, s_x].\n\
\n\
In order to make the data object compatible to continuously organized data structures, like numpy-arrays, \n\
it is also possible to have all matrix-planes in one data-block in memory (not recommended for huge matrices).\n\
Nevertheless, the indicated data structure with the two-dimensional sub-matrix-planes is still existing. \n\
The data organization is equal to the one of openCV, hence, two-dimensional matrices are stored row-by-row (C-style)...\n\
\n\
In addition to OpenCV, itom.dataObject supports complex valued data types for all operators and methods. \n\
\n\
Warning 'uint32' is not fully openCV-compatible and hence causes instability!\n\
\n\
**Deep Copy, Shallow Copy and ROI** \n\
\n\
It is possible to set a n-dimensional region of interest (ROI) to each matrix, the virtual dimensions,\n\
which will be delivered if the user asks for the matrix size.\n\
To avoid copy operations where possible a simple =_Operator will also make a shallow copy of the object.\n\
Shallow copies share the same data (elements and meta data) with the original object, hence manipulations of one object will affect the\n\
original object and all shallow copies.\n\
\n\
The opposite a deep copy of a dataObject (by sourceObject.copy()) creates a complete mew matrix with own meta data object.\n\
\n\
Example:\n\
::\n\
    #Create an object \n\
    dObj = dataObject([5, 10, 10], 'int8')\n\
    \n\
    # Make a shallow copy \n\
    dObjShallow = dObj \n\
    \n\
    # Make a shallow copy on ROI\n\
    dObjROI = dObj[1, :, :] \n\
    \n\
    # Set the value of element [1, 0, 0] to 0\n\
    dObj[1, 0, 0] = 0\n\
    \n\
    # Make a deep copy of the dObjROI\n\
    dObjROICopy = dObjROI.copy()\n\
    \n\
    # Set the value of dObjROICopy element [0, 0, 0] to 127 without effecting other objects\n\
    dObjROICopy[0, 0, 0] = 127\n\
\n\
**Constructor** \n\
\n\
The function dataObject([dims [, dtype='uint8'[, continuous = 0][, data = valueOrSequence]]])\n\
creates a new itom-dataObject filled with undefined data.\n\
If no parameters are given, an uninitilized DataObject (dims = 0, no sizes) is created.\n\
\n\
As second possibility you can also use the copy-constructor 'dataObject(AnyArray)', \n\
where AnyArray must be any array-like structure which is parsable by the numpy-interface.\n\
\n\
See Also \n\
---------- \n\
ones() : Static method to construct a data object filled with ones. \n\
zeros() : Static method to construct a data object filled with zeros. \n\
rand() : Static method to construct a randomly filled data object (uniform distribution). \n\
randN() : Static method to construct a randomly filled data object (gaussian distribution).&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">brief description  <a href="#a616eeca3c7b5773bfffeba9839402297"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0c62bc80cb8d0427449789db03f3662"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ac0c62bc80cb8d0427449789db03f3662" args="(dataObjectAttrDims_doc,&quot;number of dimensions of this data object\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
read&#45;only property, this property is readable both by the attributes ndim and dims. \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrDims_doc,&quot;number of dimensions of this data object\n\
\n\
Notes \n\
----- \n\
read-only property, this property is readable both by the attributes ndim and dims. \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac380b15ac71a2c01f5d7252cd535d69f"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ac380b15ac71a2c01f5d7252cd535d69f" args="(dataObjectAttrType_doc,&quot;get type string of data in this data object \n\
\n\
This type string has one of these values: 'uint8', 'int8', 'uint16', 'int16', 'uint32', 'int32', \n\
'float32', 'float64', 'complex64', 'complex128', 'rgba32'\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
This attribute is read&#45;only&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrType_doc,&quot;get type string of data in this data object \n\
\n\
This type string has one of these values: 'uint8', 'int8', 'uint16', 'int16', 'uint32', 'int32', \n\
'float32', 'float64', 'complex64', 'complex128', 'rgba32'\n\
\n\
Notes \n\
----- \n\
This attribute is read-only&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9478f1c2086738162712e65940da8216"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a9478f1c2086738162712e65940da8216" args="(dataObjectAttrContinuous_doc,&quot;true if matrix is continuously organized, else false. \n\
\n\
If true, the whole matrix is allocated in one huge block in memory, hence, \n\
this data object can be transformed into a numpy representation (npDataObject) \n\
without reallocating memory.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
read&#45;only\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrContinuous_doc,&quot;true if matrix is continuously organized, else false. \n\
\n\
If true, the whole matrix is allocated in one huge block in memory, hence, \n\
this data object can be transformed into a numpy representation (npDataObject) \n\
without reallocating memory.\n\
\n\
Notes \n\
----- \n\
read-only\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5a233eb208de7ff1e36c22e8026c92e"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ae5a233eb208de7ff1e36c22e8026c92e" args="(dataObjectAttrShape_doc,&quot;tuple with the sizes of each dimension / axis of this data object. \n\
\n\
Notes\n\
&#45;&#45;&#45;&#45;&#45;&#45;\n\
In difference to the shape attribute of numpy arrays, no new shape tuple can be assigned to \
this value (used to 'reshape' the array). Read&#45;only.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
size() : Alternative method to return the size of all or any specific axis&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrShape_doc,&quot;tuple with the sizes of each dimension / axis of this data object. \n\
\n\
Notes\n\
------\n\
In difference to the shape attribute of numpy arrays, no new shape tuple can be assigned to \
this value (used to 'reshape' the array). Read-only.\n\
\n\
See Also \n\
--------- \n\
size() : Alternative method to return the size of all or any specific axis&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d4efbfd262d144e00bb856e1cdcb001"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a0d4efbfd262d144e00bb856e1cdcb001" args="(dataObjectAttrTags_doc,&quot;tag dictionary of this data object. \n\
\n\
This attribute returns a dict_proxy object of the tag dictionary of this data object. This object is read&#45;only. \n\
However you can assign an entire new dictionary to this attribute that fully replaces the old tag dictionary. \n\
The tag dictionary can contain arbitrary pairs of key &#45;&gt; value where value is either a string or a double value. \n\
\n\
Special tags are the key 'protocol' that contains the newline&#45;separated protocol string of the data object (see: addToProtocol()) \n\
or the key 'title' that can for instance be used as title in any plots. \n\
\n\
You can add single elements using the method setTag(key,value) or you can delete tags using deleteTag(key).\n\
\n\
Do NOT use 'special character' within the tag key because they are not XML&#45;save.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
read&#45;only / write only for fully new dictionary&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrTags_doc,&quot;tag dictionary of this data object. \n\
\n\
This attribute returns a dict_proxy object of the tag dictionary of this data object. This object is read-only. \n\
However you can assign an entire new dictionary to this attribute that fully replaces the old tag dictionary. \n\
The tag dictionary can contain arbitrary pairs of key -&gt; value where value is either a string or a double value. \n\
\n\
Special tags are the key 'protocol' that contains the newline-separated protocol string of the data object (see: addToProtocol()) \n\
or the key 'title' that can for instance be used as title in any plots. \n\
\n\
You can add single elements using the method setTag(key,value) or you can delete tags using deleteTag(key).\n\
\n\
Do NOT use 'special character' within the tag key because they are not XML-save.\n\
\n\
Notes \n\
----- \n\
read-only / write only for fully new dictionary&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9f062fc64e10e9e49d797cf975a1617"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ac9f062fc64e10e9e49d797cf975a1617" args="(dataObjectAttrAxisScales_doc,&quot;tuple containing the axis scales [unit/px]. \n\
\n\
This attribute gives access to the internal axis scales [unit/px] expressed as \n\
a tuple of double values. The i&#45;th value in the tuple corresponds to the scaling factor of the i&#45;th \n\
axis. Either assign a new tuple with the same length than the number of dimensions or change single values \n\
using tuple indexing. \n\
\n\
Definition: Physical unit = (px&#45;Coordinate &#45; offset)* scale\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
read / write\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
setAxisScale() : Alternative method to set the scale value of one single axis&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrAxisScales_doc,&quot;tuple containing the axis scales [unit/px]. \n\
\n\
This attribute gives access to the internal axis scales [unit/px] expressed as \n\
a tuple of double values. The i-th value in the tuple corresponds to the scaling factor of the i-th \n\
axis. Either assign a new tuple with the same length than the number of dimensions or change single values \n\
using tuple indexing. \n\
\n\
Definition: Physical unit = (px-Coordinate - offset)* scale\n\
\n\
Notes \n\
----- \n\
read / write\n\
\n\
See Also \n\
--------- \n\
setAxisScale() : Alternative method to set the scale value of one single axis&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b90b6621242db404fdd64797c72297f"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a8b90b6621242db404fdd64797c72297f" args="(dataObjectAttrAxisOffsets_doc,&quot;tuple containing the axis offsets [px]. \n\
\n\
This attribute gives access to the internal axis offsets [px] expressed as \n\
a tuple of double values. The i&#45;th value in the tuple corresponds to the pixel&#45;offset of the i&#45;th \n\
axis. Either assign a new tuple with the same length than the number of dimensions or change single values \n\
using tuple indexing. \n\
\n\
Definition: Physical unit = (px&#45;Coordinate &#45; offset)* scale\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
read / write\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
setAxisOffset() : Alternative method to set the offset value of one single axis&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrAxisOffsets_doc,&quot;tuple containing the axis offsets [px]. \n\
\n\
This attribute gives access to the internal axis offsets [px] expressed as \n\
a tuple of double values. The i-th value in the tuple corresponds to the pixel-offset of the i-th \n\
axis. Either assign a new tuple with the same length than the number of dimensions or change single values \n\
using tuple indexing. \n\
\n\
Definition: Physical unit = (px-Coordinate - offset)* scale\n\
\n\
Notes \n\
----- \n\
read / write\n\
\n\
See Also \n\
--------- \n\
setAxisOffset() : Alternative method to set the offset value of one single axis&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa97cd00795260ab442f34402fdaffdae"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aa97cd00795260ab442f34402fdaffdae" args="(dataObjectAttrAxisDescriptions_doc,&quot;tuple containing the axis descriptions {str}. \n\
\n\
This attribute gives access to the internal axis descriptions expressed as \n\
a tuple of strings. The tuple has the same length than the number of dimensions of this data object. \n\
\n\
You can either assign a new tuple with the same length or change single values using tuple indexing. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
setAxisDescriptions : alternative method to change the description string of one single axis \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
read / write&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrAxisDescriptions_doc,&quot;tuple containing the axis descriptions {str}. \n\
\n\
This attribute gives access to the internal axis descriptions expressed as \n\
a tuple of strings. The tuple has the same length than the number of dimensions of this data object. \n\
\n\
You can either assign a new tuple with the same length or change single values using tuple indexing. \n\
\n\
See Also \n\
--------- \n\
setAxisDescriptions : alternative method to change the description string of one single axis \n\
\n\
Notes \n\
------- \n\
read / write&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f9960f95d6268149cfd59377f6634aa"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a6f9960f95d6268149cfd59377f6634aa" args="(dataObjectAttrAxisUnits_doc,&quot;tuple containing the axis units {str}. \n\
\n\
This attribute gives access to the internal axis units expressed as \n\
a tuple of strings. The tuple has the same length than the number of dimensions of this data object. \n\
\n\
You can either assign a new tuple with the same length or change single values using tuple indexing. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
setAxisUnits : alternative method to change the unit string of one single axis \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
read / write&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrAxisUnits_doc,&quot;tuple containing the axis units {str}. \n\
\n\
This attribute gives access to the internal axis units expressed as \n\
a tuple of strings. The tuple has the same length than the number of dimensions of this data object. \n\
\n\
You can either assign a new tuple with the same length or change single values using tuple indexing. \n\
\n\
See Also \n\
--------- \n\
setAxisUnits : alternative method to change the unit string of one single axis \n\
\n\
Notes \n\
------- \n\
read / write&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa740f49b5904ccaf09c7bb30a5477c20"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aa740f49b5904ccaf09c7bb30a5477c20" args="(dataObjectAttrValueUnit_doc,&quot;value unit. \n\
\n\
Attribute to read or write the unit string of the values in this data object. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
read / write&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrValueUnit_doc,&quot;value unit. \n\
\n\
Attribute to read or write the unit string of the values in this data object. \n\
\n\
Notes \n\
----- \n\
read / write&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe73f08c5ec8d8a4e40720da1699ae4a"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="abe73f08c5ec8d8a4e40720da1699ae4a" args="(dataObjectAttrValueDescription_doc,&quot;value unit description. \n\
\n\
Attribute to read or write the unit description string of the values in this data object. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
read / write&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrValueDescription_doc,&quot;value unit description. \n\
\n\
Attribute to read or write the unit description string of the values in this data object. \n\
\n\
Notes \n\
----- \n\
read / write&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49e99d7583919b71fd91dd6287e67d42"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a49e99d7583919b71fd91dd6287e67d42" args="(dataObjectAttrValueScale_doc,&quot;value scale [default: 0.0].\n\
\n\
This attribute gives the scaling factor of each value in the data object. This value is always 1.0. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
This attribute is read only&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrValueScale_doc,&quot;value scale [default: 0.0].\n\
\n\
This attribute gives the scaling factor of each value in the data object. This value is always 1.0. \n\
\n\
Notes \n\
----- \n\
This attribute is read only&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a982a1614c96901d9d0d47e76893b64af"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a982a1614c96901d9d0d47e76893b64af" args="(dataObjectAttrValueOffset_doc,&quot;value offset [default: 0.0].\n\
\n\
This attribute gives the offset of each value in the data object. This value is always 0.0. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
This attribute is read only&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrValueOffset_doc,&quot;value offset [default: 0.0].\n\
\n\
This attribute gives the offset of each value in the data object. This value is always 0.0. \n\
\n\
Notes \n\
----- \n\
This attribute is read only&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ad9e2aa04e38aa9a8c4cca347498822"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a7ad9e2aa04e38aa9a8c4cca347498822" args="(dataObjectAttrValue_doc,&quot;get/set the values within the ROI as a one&#45;dimensional tuple.\n\
\n\
This method gets or sets the values within the ROI. If this attribute is called by means of a getter, \n\
a tuple is returned which is created by iterating through the values of the data object (row&#45;wise). \n\
In the same way of iterating, the values are set to the data object if you provide a tuple of the size of the data object \n\
or its ROI, respectively. \n\
\n\
Example: ::\n\
\n\
    b = dataObject[1,1:10,1,1].value\n\
    # or for the first value \n\
    b = dataObject[1,1:10,1,1].value[0]\n\
    # The elements of the tuple are adressed with b[idx].&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrValue_doc,&quot;get/set the values within the ROI as a one-dimensional tuple.\n\
\n\
This method gets or sets the values within the ROI. If this attribute is called by means of a getter, \n\
a tuple is returned which is created by iterating through the values of the data object (row-wise). \n\
In the same way of iterating, the values are set to the data object if you provide a tuple of the size of the data object \n\
or its ROI, respectively. \n\
\n\
Example: ::\n\
\n\
    b = dataObject[1,1:10,1,1].value\n\
    # or for the first value \n\
    b = dataObject[1,1:10,1,1].value[0]\n\
    # The elements of the tuple are adressed with b[idx].&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af437e17e67ed88fb8126120f186a2379"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="af437e17e67ed88fb8126120f186a2379" args="(dataObjectAttrRotationalMatrix_doc,&quot;Access the 3x3 rotational matrix in the dataObject tagspace \n\
\n\
This attribute gives access to the xyRotationalMatrix in the metaData&#45;Tagspace.\n\
The getter method retuns a 3x3&#45;Array deep copied from the internal matrix,\n\
Implemented to offer compability to x3p format.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
{3x3 array of doubles} : ReadWrite\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrRotationalMatrix_doc,&quot;Access the 3x3 rotational matrix in the dataObject tagspace \n\
\n\
This attribute gives access to the xyRotationalMatrix in the metaData-Tagspace.\n\
The getter method retuns a 3x3-Array deep copied from the internal matrix,\n\
Implemented to offer compability to x3p format.\n\
\n\
Notes \n\
----- \n\
{3x3 array of doubles} : ReadWrite\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6634b2861937a34c4e2031313244cc5a"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a6634b2861937a34c4e2031313244cc5a" args="(pyDataObjectSetAxisOffset_doc,&quot;setAxisOffset(axisNum, axisOffset) &#45;&gt; Set the offset of the specified axis. \n\
\n\
Each axis in the data object can get a specific scale value, described in axisUnits per pixel. Use this method to set the scale of one specific axis. \n\
The value of each pixel in its physical unit is the (px&#45;Coordinate &#45; axisOffset) * axisScale \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
axisNum : {int}\n\
    The addressed axis index\n\
axisOffset : {double}\n\
    New axis offset in [px]\n\
\n\
Raises \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Runtime error : \n\
    if the given axisNum is invalid (out of range) \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
axisOffsets : this attribute can directly be used to read/write the axis offset(s) of single or all axes&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSetAxisOffset_doc,&quot;setAxisOffset(axisNum, axisOffset) -&gt; Set the offset of the specified axis. \n\
\n\
Each axis in the data object can get a specific scale value, described in axisUnits per pixel. Use this method to set the scale of one specific axis. \n\
The value of each pixel in its physical unit is the (px-Coordinate - axisOffset) * axisScale \n\
\n\
Parameters  \n\
------------\n\
axisNum : {int}\n\
    The addressed axis index\n\
axisOffset : {double}\n\
    New axis offset in [px]\n\
\n\
Raises \n\
------- \n\
Runtime error : \n\
    if the given axisNum is invalid (out of range) \n\
\n\
See Also \n\
--------- \n\
axisOffsets : this attribute can directly be used to read/write the axis offset(s) of single or all axes&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e2aa660c49f924de7e43d8e0b25a688"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a4e2aa660c49f924de7e43d8e0b25a688" args="(pyDataObjectSetAxisScale_doc,&quot;setAxisScale(axisNum, axisScale) &#45;&gt; Set the scale value of the specified axis. \n\
\n\
Each axis in the data object can get a specific scale value, described in axisUnits per pixel. Use this method to set the scale of one specific axis. \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
axisNum : {int}\n\
    The addressed axis index\n\
axisScale : {double}\n\
    New axis scale in axisUnit/px\n\
\n\
Raises \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Runtime error : \n\
    if the given axisNum is invalid (out of range) \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
axisScales : this attribute can directly be used to read/write the axis scale(s) of single or all axes&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSetAxisScale_doc,&quot;setAxisScale(axisNum, axisScale) -&gt; Set the scale value of the specified axis. \n\
\n\
Each axis in the data object can get a specific scale value, described in axisUnits per pixel. Use this method to set the scale of one specific axis. \n\
\n\
Parameters  \n\
------------\n\
axisNum : {int}\n\
    The addressed axis index\n\
axisScale : {double}\n\
    New axis scale in axisUnit/px\n\
\n\
Raises \n\
------- \n\
Runtime error : \n\
    if the given axisNum is invalid (out of range) \n\
\n\
See Also \n\
--------- \n\
axisScales : this attribute can directly be used to read/write the axis scale(s) of single or all axes&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c40507093d784ad4fb4acd683e168d7"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a9c40507093d784ad4fb4acd683e168d7" args="(pyDataObjectSetAxisDescription_doc,&quot;setAxisDescription(axisNum, axisDescription) &#45;&gt; Set the description of the specified axis. \n\
\n\
Each axis in the data object can get a specific axisDescription string (e.g. mm). Use this method to set the axisDescription of one specific axis. \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
axisNum : {int}\n\
    The addressed axis index\n\
axisDescription : {str}\n\
    New axis description\n\
\n\
Raises \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Runtime error : \n\
    if the given axisNum is invalid (out of range) \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
axisDescriptions : this attribute can directly be used to read/write the axis description(s) of single or all axes&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSetAxisDescription_doc,&quot;setAxisDescription(axisNum, axisDescription) -&gt; Set the description of the specified axis. \n\
\n\
Each axis in the data object can get a specific axisDescription string (e.g. mm). Use this method to set the axisDescription of one specific axis. \n\
\n\
Parameters  \n\
------------\n\
axisNum : {int}\n\
    The addressed axis index\n\
axisDescription : {str}\n\
    New axis description\n\
\n\
Raises \n\
------- \n\
Runtime error : \n\
    if the given axisNum is invalid (out of range) \n\
\n\
See Also \n\
--------- \n\
axisDescriptions : this attribute can directly be used to read/write the axis description(s) of single or all axes&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80afe8224d99fa3a3350f6f1a7c27278"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a80afe8224d99fa3a3350f6f1a7c27278" args="(pyDataObjectSetAxisUnit_doc,&quot;setAxisUnit(axisNum, axisUnit) &#45;&gt; Set the unit of the specified axis. \n\
\n\
Each axis in the data object can get a specific unit string (e.g. mm). Use this method to set the unit of one specific axis. \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
axisNum : {int}\n\
    The addressed axis index\n\
axisUnit : {str}\n\
    New axis unit\n\
\n\
Raises \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Runtime error : \n\
    if the given axisNum is invalid (out of range) \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
axisUnits : this attribute can directly be used to read/write the axis unit(s) of single or all axes&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSetAxisUnit_doc,&quot;setAxisUnit(axisNum, axisUnit) -&gt; Set the unit of the specified axis. \n\
\n\
Each axis in the data object can get a specific unit string (e.g. mm). Use this method to set the unit of one specific axis. \n\
\n\
Parameters  \n\
------------\n\
axisNum : {int}\n\
    The addressed axis index\n\
axisUnit : {str}\n\
    New axis unit\n\
\n\
Raises \n\
------- \n\
Runtime error : \n\
    if the given axisNum is invalid (out of range) \n\
\n\
See Also \n\
--------- \n\
axisUnits : this attribute can directly be used to read/write the axis unit(s) of single or all axes&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab04dff8838990fba76d38daf4f6c5191"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ab04dff8838990fba76d38daf4f6c5191" args="(pyDataObjectSetTag_doc,&quot;setTag(key, tagvalue) &#45;&gt; Set the value of tag specified by key. \n\
\n\
Sets the value of an existing tag (defined by key) in the tag dictionary to the string or double tagvalue or \
adds a new item with key. \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
key : {str}\n\
    the name of the tag to set\n\
tagvalue : {str or double}\n\
    the new value of the tag, either string or double value\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
Do NOT use 'special character' within the tag key because they are not XML&#45;save.\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSetTag_doc,&quot;setTag(key, tagvalue) -&gt; Set the value of tag specified by key. \n\
\n\
Sets the value of an existing tag (defined by key) in the tag dictionary to the string or double tagvalue or \
adds a new item with key. \n\
\n\
Parameters  \n\
------------\n\
key : {str}\n\
    the name of the tag to set\n\
tagvalue : {str or double}\n\
    the new value of the tag, either string or double value\n\
\n\
Notes \n\
----- \n\
Do NOT use 'special character' within the tag key because they are not XML-save.\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ac1ddc12927ad3f36caf853e5408e40"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a1ac1ddc12927ad3f36caf853e5408e40" args="(pyDataObjectDeleteTag_doc,&quot;deleteTag(key) &#45;&gt; Delete a tag specified by key from the tag dictionary. \n\
\n\
Checks whether a tag with the given key exists in the tag dictionary and if so deletes it. \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
key : {str}\n\
    the name of the tag to be deleted\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
success : {bool}: \n\
    True if tag with given key existed and could be deleted, else False&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectDeleteTag_doc,&quot;deleteTag(key) -&gt; Delete a tag specified by key from the tag dictionary. \n\
\n\
Checks whether a tag with the given key exists in the tag dictionary and if so deletes it. \n\
\n\
Parameters  \n\
------------\n\
key : {str}\n\
    the name of the tag to be deleted\n\
\n\
Returns \n\
-------- \n\
success : {bool}: \n\
    True if tag with given key existed and could be deleted, else False&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc46e4c0d6c093a0565c5ad228fc9b6e"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="afc46e4c0d6c093a0565c5ad228fc9b6e" args="(pyDataObjectTagExists_doc,&quot;existTag(key) &#45;&gt; return True if tag with given key exists, else False \n\
\n\
Checks whether a tag with the given key exists in tag dictionary of this data object and returns True if such a tag exists, else False. \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
key : {str}\n\
    the key of the tag\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
result : {bool}\n\
    True if tag exists, else False&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectTagExists_doc,&quot;existTag(key) -&gt; return True if tag with given key exists, else False \n\
\n\
Checks whether a tag with the given key exists in tag dictionary of this data object and returns True if such a tag exists, else False. \n\
\n\
Parameters  \n\
------------\n\
key : {str}\n\
    the key of the tag\n\
\n\
Returns \n\
-------- \n\
result : {bool}\n\
    True if tag exists, else False&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ca1c119c377c8b5a000c3973b8f7218"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a2ca1c119c377c8b5a000c3973b8f7218" args="(pyDataObjectGetTagListSize_doc,&quot;getTagListSize() &#45;&gt; returns the number of tags in the tag dictionary\n\
\n\
Every data object can have an arbitrary number of tags stored in the tag dictionary. This method returns the number of different tags, \
where the protocol is also one tag with the key 'protocol'. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
length : {int}: \n\
    size of the tag dictionary. The optional protocol also counts as one item.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectGetTagListSize_doc,&quot;getTagListSize() -&gt; returns the number of tags in the tag dictionary\n\
\n\
Every data object can have an arbitrary number of tags stored in the tag dictionary. This method returns the number of different tags, \
where the protocol is also one tag with the key 'protocol'. \n\
\n\
Returns \n\
------- \n\
length : {int}: \n\
    size of the tag dictionary. The optional protocol also counts as one item.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a190968ba6bcb880283ee88b11824f067"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a190968ba6bcb880283ee88b11824f067" args="(pyDataObjectAddToProtocol_doc,&quot;addToProtocol(newLine) &#45;&gt; Appends a protocol line to the protocol. \n\
\n\
Appends a line of text to the protocol string of this data object. If this data object has got a region of interest defined, \
the rectangle of the ROI is automatically appended to newLine. The protocol string ends with a newline character. \n\
\n\
Address the content of the protocol by obj.tags[\&quot;protocol\&quot;]. The protocol is contained in the ordinary tag dictionary of this data object under the key 'protocol'. \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
newLine : {str}\n\
    The text to be added to the protocol.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectAddToProtocol_doc,&quot;addToProtocol(newLine) -&gt; Appends a protocol line to the protocol. \n\
\n\
Appends a line of text to the protocol string of this data object. If this data object has got a region of interest defined, \
the rectangle of the ROI is automatically appended to newLine. The protocol string ends with a newline character. \n\
\n\
Address the content of the protocol by obj.tags[\&quot;protocol\&quot;]. The protocol is contained in the ordinary tag dictionary of this data object under the key 'protocol'. \n\
\n\
Parameters  \n\
------------\n\
newLine : {str}\n\
    The text to be added to the protocol.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8652b96653673ca33fbc774bbf8316c5"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a8652b96653673ca33fbc774bbf8316c5" args="(pyDataObjectName_doc,&quot;name() &#45;&gt; returns the name of this object (dataObject)&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectName_doc,&quot;name() -&gt; returns the name of this object (dataObject)&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8b3020cf0ea38798f331a8ace707a9a"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ac8b3020cf0ea38798f331a8ace707a9a" args="(pyDataObjectData_doc,&quot;data() &#45;&gt; prints the content of the dataObject in a readable form. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
When calling this method, the complete content of the dataObject is printed to the standard output stream.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectData_doc,&quot;data() -&gt; prints the content of the dataObject in a readable form. \n\
\n\
Notes \n\
----- \n\
When calling this method, the complete content of the dataObject is printed to the standard output stream.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4f8aa4712bd611f8aa736df8a898429"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ad4f8aa4712bd611f8aa736df8a898429" args="(pyDataObjectConj_doc,&quot;conj() &#45;&gt; complex&#45;conjugates all elements of this dataObject (inline). \n\
\n\
Every value of this dataObject is replaced by its complex&#45;conjugate value. \n\
\n\
Raises \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
TypeError : \n\
    if data type of this data object is not complex.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
conjugate() : does the same operation but returns a complex&#45;conjugated copy of this data object&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectConj_doc,&quot;conj() -&gt; complex-conjugates all elements of this dataObject (inline). \n\
\n\
Every value of this dataObject is replaced by its complex-conjugate value. \n\
\n\
Raises \n\
------- \n\
TypeError : \n\
    if data type of this data object is not complex.\n\
\n\
See Also \n\
--------- \n\
conjugate() : does the same operation but returns a complex-conjugated copy of this data object&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2894e946d5dfc28735fbe3bedbf5350b"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a2894e946d5dfc28735fbe3bedbf5350b" args="(pyDataObjectConjugate_doc,&quot;conjugate() &#45;&gt; return a copy of this dataObject where every element is complex&#45;conjugated. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {dataObject} \n\
    element&#45;wise complex conjugate of this data object \n\
\n\
Raises \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
TypeError : \n\
    if data type of this data object is not complex.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
conj() : does the same operation but manipulates this object inline.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectConjugate_doc,&quot;conjugate() -&gt; return a copy of this dataObject where every element is complex-conjugated. \n\
\n\
Returns \n\
------- \n\
out : {dataObject} \n\
    element-wise complex conjugate of this data object \n\
\n\
Raises \n\
------- \n\
TypeError : \n\
    if data type of this data object is not complex.\n\
\n\
See Also \n\
--------- \n\
conj() : does the same operation but manipulates this object inline.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d4bb3ea7fbd30feecff6dc2afb354fb"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a8d4bb3ea7fbd30feecff6dc2afb354fb" args="(pyDataObjectAdj_doc,&quot;adj() &#45;&gt; Adjugate all elements (inline)\n\
\n\
Every plane (spanned by the last two axes) is transposed and every element is replaced by its complex conjugate value. \n\
\n\
Raises \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
TypeError : \n\
    if data type of this data object is not complex.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
adjugate() : does the same operation but returns the resulting data object&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectAdj_doc,&quot;adj() -&gt; Adjugate all elements (inline)\n\
\n\
Every plane (spanned by the last two axes) is transposed and every element is replaced by its complex conjugate value. \n\
\n\
Raises \n\
------- \n\
TypeError : \n\
    if data type of this data object is not complex.\n\
\n\
See Also \n\
--------- \n\
adjugate() : does the same operation but returns the resulting data object&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc0c2b131fdc0435da2718ae636081bc"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="afc0c2b131fdc0435da2718ae636081bc" args="(pyDataObjectAdjugate_doc,&quot;adjugate() &#45;&gt; returns the plane&#45;wise adjugated array of this dataObject. \n\
\n\
If this data object has a complex type, the tranposed data object is returned where every element is complex conjugated. \
For data objects with more than two dimensions the tranposition is done plane&#45;wise, hence, only the last two dimensions are permutated. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {dataObject} \n\
    adjugate of this dataObject \n\
\n\
Raises \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
TypeError : \n\
    if data type of this data object is not complex.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
adj() : does the same operation but manipulates this object inline.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectAdjugate_doc,&quot;adjugate() -&gt; returns the plane-wise adjugated array of this dataObject. \n\
\n\
If this data object has a complex type, the tranposed data object is returned where every element is complex conjugated. \
For data objects with more than two dimensions the tranposition is done plane-wise, hence, only the last two dimensions are permutated. \n\
\n\
Returns \n\
------- \n\
out : {dataObject} \n\
    adjugate of this dataObject \n\
\n\
Raises \n\
------- \n\
TypeError : \n\
    if data type of this data object is not complex.\n\
\n\
See Also \n\
--------- \n\
adj() : does the same operation but manipulates this object inline.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af03dfef2f22b477b18ef2a338d40c82c"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="af03dfef2f22b477b18ef2a338d40c82c" args="(pyDataObjectTrans_doc,&quot;trans() &#45;&gt; return a plane&#45;wise transposed dataObject\n\
\n\
Return a new data object with the same data type than this object and where every plane (data spanned by the last two dimensions) \
is transposed respectively such that the last two axes are permuted. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {dataObject} \n\
    A copy of this dataObject is returned where every plane is its transposed plane.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectTrans_doc,&quot;trans() -&gt; return a plane-wise transposed dataObject\n\
\n\
Return a new data object with the same data type than this object and where every plane (data spanned by the last two dimensions) \
is transposed respectively such that the last two axes are permuted. \n\
\n\
Returns \n\
-------- \n\
out : {dataObject} \n\
    A copy of this dataObject is returned where every plane is its transposed plane.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2886e92246f5b1ebf1e0cab1d05eb539"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a2886e92246f5b1ebf1e0cab1d05eb539" args="(pyDataObjectMakeContinuous_doc,&quot;makeContinuous() &#45;&gt; return continuous representation of dataObject\n\
\n\
Per default a dataObject with more than two dimensions allocates separated chunks of memory for every plane, where \
a plane is always the matrix given by the last two dimensions. This separated storage usually allows allocating more \
memory for huge for instance three dimensional matrices. However, in order to generate a dataObject that is directly \
compatible to Numpy or other C&#45;style matrix structures, the entire allocated memory must be in one block, that is called \
continuous. If you create a Numpy array from a dataObject that is not continuous, this function is implicitely called \
in order to firstly make the dataObject continuous before passing to Numpy. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
obj : {dataObject} \n\
    continuous dataObject\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
if this dataObject already is continuous, a simple shallow copy is returned&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectMakeContinuous_doc,&quot;makeContinuous() -&gt; return continuous representation of dataObject\n\
\n\
Per default a dataObject with more than two dimensions allocates separated chunks of memory for every plane, where \
a plane is always the matrix given by the last two dimensions. This separated storage usually allows allocating more \
memory for huge for instance three dimensional matrices. However, in order to generate a dataObject that is directly \
compatible to Numpy or other C-style matrix structures, the entire allocated memory must be in one block, that is called \
continuous. If you create a Numpy array from a dataObject that is not continuous, this function is implicitely called \
in order to firstly make the dataObject continuous before passing to Numpy. \n\
\n\
Returns \n\
-------- \n\
obj : {dataObject} \n\
    continuous dataObject\n\
\n\
Notes \n\
----- \n\
if this dataObject already is continuous, a simple shallow copy is returned&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16e5bc1aad9e16dda5edc8a251d03e07"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a16e5bc1aad9e16dda5edc8a251d03e07" args="(pyDataObjectSize_doc,&quot;size([index]) &#45;&gt; returns the size of this dataObject (tuple of the sizes in all dimensions or size in dimension indicated by optional axis index). \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
index : {int}, optional\n\
    If index is given, only the size of the indicated dimension is returned as single number (0 &lt;= index &lt; number of dimensions) \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
A tuple containing the sizes of all dimensions or one single size value if 'index' is indicated. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
For a more consistent syntax with respect to numpy arrays, the same result is obtained by the attribute shape. Please use the attribute shape for future implementations \
since this method is marked as deprecated.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
shape : the read&#45;only attribute shape is equal to size()&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSize_doc,&quot;size([index]) -&gt; returns the size of this dataObject (tuple of the sizes in all dimensions or size in dimension indicated by optional axis index). \n\
\n\
Parameters  \n\
------------\n\
index : {int}, optional\n\
    If index is given, only the size of the indicated dimension is returned as single number (0 &lt;= index &lt; number of dimensions) \n\
\n\
Returns \n\
-------- \n\
A tuple containing the sizes of all dimensions or one single size value if 'index' is indicated. \n\
\n\
Notes \n\
--------- \n\
For a more consistent syntax with respect to numpy arrays, the same result is obtained by the attribute shape. Please use the attribute shape for future implementations \
since this method is marked as deprecated.\n\
\n\
See Also \n\
--------- \n\
shape : the read-only attribute shape is equal to size()&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed671a0f9ee90a668d552c14e1ff2cae"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aed671a0f9ee90a668d552c14e1ff2cae" args="(pyDataObjectCopy_doc,&quot;copy(regionOnly=0) &#45;&gt; return a deep copy of this dataObject\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
regionOnly : {bool}, optional \n\
    If regionOnly is 1, only the current region of interest of this dataObject is copied, else the entire dataObject \
    including the current settings concerning the region of interest are deeply copied [default].\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
cpy : {dataObject} \n\
    Deep copy of this dataObject&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectCopy_doc,&quot;copy(regionOnly=0) -&gt; return a deep copy of this dataObject\n\
\n\
Parameters \n\
----------- \n\
regionOnly : {bool}, optional \n\
    If regionOnly is 1, only the current region of interest of this dataObject is copied, else the entire dataObject \
    including the current settings concerning the region of interest are deeply copied [default].\n\
\n\
Returns \n\
------- \n\
cpy : {dataObject} \n\
    Deep copy of this dataObject&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42083d9c65656e36d6482687208c7acd"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a42083d9c65656e36d6482687208c7acd" args="(pyDataObjectMul_doc,&quot;mul(obj) &#45;&gt; a.mul(b) returns element wise multiplication of a*b\n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
obj : {dataObject} \n\
    dataObject whose values are element&#45;wisely multiplied with the values in this dataObject. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
c : {dataObject} \n\
    Resulting multiplied data object.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectMul_doc,&quot;mul(obj) -&gt; a.mul(b) returns element wise multiplication of a*b\n\
\n\
Parameters  \n\
------------\n\
obj : {dataObject} \n\
    dataObject whose values are element-wisely multiplied with the values in this dataObject. \n\
\n\
Returns \n\
-------- \n\
c : {dataObject} \n\
    Resulting multiplied data object.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f8291a095254442723494d2b4858200"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a5f8291a095254442723494d2b4858200" args="(pyDataObjectDiv_doc,&quot;div(obj) &#45;&gt; a.div(b) return result of element wise division of a./b \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
obj : {dataObject} \n\
    Every value in this data object is divided by the corresponding value in obj. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
c : {dataObject} \n\
    Resulting divided data object.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectDiv_doc,&quot;div(obj) -&gt; a.div(b) return result of element wise division of a./b \n\
\n\
Parameters  \n\
------------\n\
obj : {dataObject} \n\
    Every value in this data object is divided by the corresponding value in obj. \n\
\n\
Returns \n\
-------- \n\
c : {dataObject} \n\
    Resulting divided data object.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4669f1fbcd0cb62f4f07965332fbf263"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a4669f1fbcd0cb62f4f07965332fbf263" args="(pyDataObjectReshape_doc,&quot;reshape(newSizes) &#45;&gt; Returns reshaped shallow copy of data object  \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
Not implemented yet.\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectReshape_doc,&quot;reshape(newSizes) -&gt; Returns reshaped shallow copy of data object  \n\
\n\
Notes \n\
----- \n\
Not implemented yet.\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa7db53ab3360b3d767f4e277a56ccc4"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aaa7db53ab3360b3d767f4e277a56ccc4" args="(pyDataObjectAstype_doc,&quot;astype(typestring) &#45;&gt; converts this data object to another type\n\
\n\
Converts this data object to a new data object with another type, given by the string newTypestring (e.g. 'uint8'). The converted data object \
is a deep copy of this object if the new type does not correspond to the current type, else a shallow copy of this object is returned. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
typestring : {str} \n\
    Type string indicating the new type ('uint8',...'float32',..,'complex64') \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
c : {dataObject} \n\
    type&#45;converted data object \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
This method mainly uses the method convertTo of OpenCV. \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectAstype_doc,&quot;astype(typestring) -&gt; converts this data object to another type\n\
\n\
Converts this data object to a new data object with another type, given by the string newTypestring (e.g. 'uint8'). The converted data object \
is a deep copy of this object if the new type does not correspond to the current type, else a shallow copy of this object is returned. \n\
\n\
Parameters \n\
----------- \n\
typestring : {str} \n\
    Type string indicating the new type ('uint8',...'float32',..,'complex64') \n\
\n\
Returns \n\
-------- \n\
c : {dataObject} \n\
    type-converted data object \n\
\n\
Notes \n\
----- \n\
This method mainly uses the method convertTo of OpenCV. \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9844158bbf70b42a2a36532587fd9d61"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a9844158bbf70b42a2a36532587fd9d61" args="(pyDataObjectNormalize_doc,&quot;normalize([minValue=0.0, maxValue=1.0, typestring='']) &#45;&gt; returns the normalization of this dataObject\n\
\n\
Returns the normalized version of this data object, where the values lie in the range [minValue,maxValue]. Additionally it is also \n\
possible to convert the resulting data object to another type (given by the parameter typestring). As default no type conversion is executed.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
minValue : {double} \n\
    minimum value of the normalized range \n\
maxValue : {double} \n\
    maximum value of the normalized range \n\
typestring : {String} \n\
    Type string indicating the new type ('uint8',...'float32',..,'complex64'), default: '' (no type conversion) \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
normalized : {dataObject} \n\
    normalized data object&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectNormalize_doc,&quot;normalize([minValue=0.0, maxValue=1.0, typestring='']) -&gt; returns the normalization of this dataObject\n\
\n\
Returns the normalized version of this data object, where the values lie in the range [minValue,maxValue]. Additionally it is also \n\
possible to convert the resulting data object to another type (given by the parameter typestring). As default no type conversion is executed.\n\
\n\
Parameters \n\
----------- \n\
minValue : {double} \n\
    minimum value of the normalized range \n\
maxValue : {double} \n\
    maximum value of the normalized range \n\
typestring : {String} \n\
    Type string indicating the new type ('uint8',...'float32',..,'complex64'), default: '' (no type conversion) \n\
\n\
Returns \n\
-------- \n\
normalized : {dataObject} \n\
    normalized data object&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a685cd7ae8ddeea1f2943e37608e78e94"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a685cd7ae8ddeea1f2943e37608e78e94" args="(pyDataObjectLocateROI_doc,&quot;locateROI() &#45;&gt; returns information about the current region of interest of this data object\n\
\n\
A region of interest (ROI) of a data object is defined by the two values per axis. The first element always indicates the size between the \n\
real border of the data object and the region of interest on the left / top ... side and the second value the margin of the right / bottom ... side. \n\
\n\
This method returns a tuple with two elements: The first is a list with the original sizes of this data object, \
the second is a list with the offsets from the original data object to the first value in the current region of interest \n\
\n\
If no region of interest is set (hence: full region of interest), the first list corresponds to the one returned by size(), \
the second list is a zero&#45;vector. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
adjustROI(offsetList) : method to change the current region of interest&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectLocateROI_doc,&quot;locateROI() -&gt; returns information about the current region of interest of this data object\n\
\n\
A region of interest (ROI) of a data object is defined by the two values per axis. The first element always indicates the size between the \n\
real border of the data object and the region of interest on the left / top ... side and the second value the margin of the right / bottom ... side. \n\
\n\
This method returns a tuple with two elements: The first is a list with the original sizes of this data object, \
the second is a list with the offsets from the original data object to the first value in the current region of interest \n\
\n\
If no region of interest is set (hence: full region of interest), the first list corresponds to the one returned by size(), \
the second list is a zero-vector. \n\
\n\
See Also \n\
-------- \n\
adjustROI(offsetList) : method to change the current region of interest&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0452010557cfc72d6c16a57d0e7df31c"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a0452010557cfc72d6c16a57d0e7df31c" args="(pyDataObjectAdjustROI_doc,&quot;adjustROI(offsetList) &#45;&gt; adjust the size and position of the region of interest of this data object\n\
\n\
For every data object, it is possible to define a region of interest such that subsequent commands only refer to this subpart. However, if values within \n\
the region of interest (ROI) are changed, this also affects the original data object due to the shallow copy principal of python. \n\
Use this command to adjust the current size and position of this region of interest by passing an offset list, that contains \
integer numbers with twice the size than the number of dimensions. \n\
\n\
Example: :: \n\
\n\
    d = dataObject([5,4]) \n\
    droi = d \n\
    droi.adjustROI([&#45;2,0,&#45;1,&#45;1]) \n\
    \n\
Now *droi* is a region of interest of the original data object whose first value is equal to d[2,1] and its size is (3,2) \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
offsetList : {list of integers} \n\
    This list must have twice as many values than the number of dimensions of this data object. A pair of numbers indicates the shift of the \
    current boundaries of the region of interest in every dimension. The first value of each pair is the offset of the 'left' boundary, the \
    second the shift of the right boundary. A positive value means a growth of the region of interest, a negative one let the region of interest \
    shrink towards the center. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
locateROI() : method to get the borders of the current ROI&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectAdjustROI_doc,&quot;adjustROI(offsetList) -&gt; adjust the size and position of the region of interest of this data object\n\
\n\
For every data object, it is possible to define a region of interest such that subsequent commands only refer to this subpart. However, if values within \n\
the region of interest (ROI) are changed, this also affects the original data object due to the shallow copy principal of python. \n\
Use this command to adjust the current size and position of this region of interest by passing an offset list, that contains \
integer numbers with twice the size than the number of dimensions. \n\
\n\
Example: :: \n\
\n\
    d = dataObject([5,4]) \n\
    droi = d \n\
    droi.adjustROI([-2,0,-1,-1]) \n\
    \n\
Now *droi* is a region of interest of the original data object whose first value is equal to d[2,1] and its size is (3,2) \n\
\n\
Parameters \n\
----------- \n\
offsetList : {list of integers} \n\
    This list must have twice as many values than the number of dimensions of this data object. A pair of numbers indicates the shift of the \
    current boundaries of the region of interest in every dimension. The first value of each pair is the offset of the 'left' boundary, the \
    second the shift of the right boundary. A positive value means a growth of the region of interest, a negative one let the region of interest \
    shrink towards the center. \n\
\n\
See Also \n\
--------- \n\
locateROI() : method to get the borders of the current ROI&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c4350d0f9807fee342e4982edeb30cb"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a9c4350d0f9807fee342e4982edeb30cb" args="(pyDataObjectSqueeze_doc,&quot;squeeze() &#45;&gt; return a squeezed shallow copy (if possible) of this dataObject. \n\
\n\
This method removes every dimension with size equal to 1. Take care, that \n\
none of the last two dimensions is considered by this squeeze&#45;command. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
squeezed : {dataObject} \n\
    The squeezed data object where all kept planes are shallow copies of the original plane. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
The returned squeezed data object is a shallow copy of the original data object and hence changes in its values\n\
will also change the original data set.\n\
This method is equal to numpy.squeeze&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSqueeze_doc,&quot;squeeze() -&gt; return a squeezed shallow copy (if possible) of this dataObject. \n\
\n\
This method removes every dimension with size equal to 1. Take care, that \n\
none of the last two dimensions is considered by this squeeze-command. \n\
\n\
Returns \n\
-------- \n\
squeezed : {dataObject} \n\
    The squeezed data object where all kept planes are shallow copies of the original plane. \n\
\n\
Notes \n\
----- \n\
The returned squeezed data object is a shallow copy of the original data object and hence changes in its values\n\
will also change the original data set.\n\
This method is equal to numpy.squeeze&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02795f884e8187a6687cee047e40feff"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a02795f884e8187a6687cee047e40feff" args="(dataObjectAttrTagDict_doc,&quot;return dictionary with all meta information of this dataObject \n\
\n\
Returns a new dictionary with the following meta information: \n\
\n\
* axisOffsets : List with offsets of each axis \n\
* axisScales : List with the scales of each axis \n\
* axisUnits : List with the unit strings of each axis \n\
* axisDescriptions : List with the description strings of each axis \n\
* tags : Dictionary with all tags including the tag 'protocol' if at least one protocol entry has been added using addToProtocol \n\
* valueOffset : Offset of each value (0.0) \n\
* valueScale : Scale of each value (1.0) \n\
* valueDescription : Description of the values \n\
* valueUnit : The unit string of the values \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
Adding or changing values to / in the dictionary does not change the meta information of the dataObject. \
Use the corresponding setters like setTag... instead.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrTagDict_doc,&quot;return dictionary with all meta information of this dataObject \n\
\n\
Returns a new dictionary with the following meta information: \n\
\n\
* axisOffsets : List with offsets of each axis \n\
* axisScales : List with the scales of each axis \n\
* axisUnits : List with the unit strings of each axis \n\
* axisDescriptions : List with the description strings of each axis \n\
* tags : Dictionary with all tags including the tag 'protocol' if at least one protocol entry has been added using addToProtocol \n\
* valueOffset : Offset of each value (0.0) \n\
* valueScale : Scale of each value (1.0) \n\
* valueDescription : Description of the values \n\
* valueUnit : The unit string of the values \n\
\n\
Notes \n\
----- \n\
Adding or changing values to / in the dictionary does not change the meta information of the dataObject. \
Use the corresponding setters like setTag... instead.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a860b17c3941d7c8f8834c6fcad000f80"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a860b17c3941d7c8f8834c6fcad000f80" args="(dataObjectArray_StructGet_doc,&quot;__array_struct__ &#45;&gt; general python&#45;array interface (do not call this directly) \n\
                                           This interface makes the data object compatible to every array structure in python \n\
                                           which does equally implement the array interface (e.g. NumPy). This method is \n\
                                           therefore a helper method for the array interface.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectArray_StructGet_doc,&quot;__array_struct__ -&gt; general python-array interface (do not call this directly) \n\
                                           This interface makes the data object compatible to every array structure in python \n\
                                           which does equally implement the array interface (e.g. NumPy). This method is \n\
                                           therefore a helper method for the array interface.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add87ed3c2c37aa8feaea80bb34d2952b"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="add87ed3c2c37aa8feaea80bb34d2952b" args="(dataObjectArray_Interface_doc,&quot;__array_interface__ &#45;&gt; general python&#45;array interface (do not call this directly) \n\
                                           This interface makes the data object compatible to every array structure in python \n\
                                           which does equally implement the array interface (e.g. NumPy).&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectArray_Interface_doc,&quot;__array_interface__ -&gt; general python-array interface (do not call this directly) \n\
                                           This interface makes the data object compatible to every array structure in python \n\
                                           which does equally implement the array interface (e.g. NumPy).&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c17e574703375081c707e3eae3f952e"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a8c17e574703375081c707e3eae3f952e" args="(dataObject_Array__doc,&quot;__array__([dtype]) &#45;&gt; returns a numpy.ndarray from this dataObject. If possible a shallow copy is returned. \n\
                                   If no desired dtype is given and if the this dataObject is continuous, a ndarray sharing its memory with this dataObject is returned. \n\
                                   If the desired dtype does not fit to the type of this dataObject, a casted deep copy is returned. This is also the case if \n\
                                   this dataObject is not continuous. Then a continuous dataObject is created that is the base object of the returned ndarray.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObject_Array__doc,&quot;__array__([dtype]) -&gt; returns a numpy.ndarray from this dataObject. If possible a shallow copy is returned. \n\
                                   If no desired dtype is given and if the this dataObject is continuous, a ndarray sharing its memory with this dataObject is returned. \n\
                                   If the desired dtype does not fit to the type of this dataObject, a casted deep copy is returned. This is also the case if \n\
                                   this dataObject is not continuous. Then a continuous dataObject is created that is the base object of the returned ndarray.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10dd2557e4974a12baf8aab93256bd70"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a10dd2557e4974a12baf8aab93256bd70" args="(pyDataObjectAbs_doc,&quot;abs() &#45;&gt; return a new data object with the absolute values of the source\n\
\n\
This method calculates the abs value of each element in source and writes the result to the output object.\
In case of floating point or real object, the type of the output will not change. For complex values\
the type is changes to the corresponding floating type value.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
res : {dataObject} \n\
    output dataObject of same shape but the type may be changed.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectAbs_doc,&quot;abs() -&gt; return a new data object with the absolute values of the source\n\
\n\
This method calculates the abs value of each element in source and writes the result to the output object.\
In case of floating point or real object, the type of the output will not change. For complex values\
the type is changes to the corresponding floating type value.\n\
\n\
Returns \n\
------- \n\
res : {dataObject} \n\
    output dataObject of same shape but the type may be changed.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6c8a11df6253d6a759daf76c532c2e2"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ae6c8a11df6253d6a759daf76c532c2e2" args="(pyDataObjectArg_doc,&quot;arg() &#45;&gt; return a new data object with the argument values of the source\n\
\n\
This method calculates the argument value of each element in source and writes the result to the output object.\
This object must be of complex type (complex128 or complex64). The output value will be float type (float64 or float32).\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
res : {dataObject} \n\
    output dataObject of same shape but the type is changed.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectArg_doc,&quot;arg() -&gt; return a new data object with the argument values of the source\n\
\n\
This method calculates the argument value of each element in source and writes the result to the output object.\
This object must be of complex type (complex128 or complex64). The output value will be float type (float64 or float32).\n\
\n\
Returns \n\
------- \n\
res : {dataObject} \n\
    output dataObject of same shape but the type is changed.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbf0d065978761aac7eecc1068f13ac7"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="acbf0d065978761aac7eecc1068f13ac7" args="(pyDataObjectReal_doc,&quot;real() &#45;&gt; return a new data object with the real part of the source\n\
\n\
This method extracts the real part of each element in source and writes the result to the output object.\
This object must be of complex type (complex128 or complex64). The output value will be float type (float64 or float32).\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
res : {dataObject} \n\
    output dataObject of same shape but the type is changed.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectReal_doc,&quot;real() -&gt; return a new data object with the real part of the source\n\
\n\
This method extracts the real part of each element in source and writes the result to the output object.\
This object must be of complex type (complex128 or complex64). The output value will be float type (float64 or float32).\n\
\n\
Returns \n\
------- \n\
res : {dataObject} \n\
    output dataObject of same shape but the type is changed.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe7b5d69c3768b71b7332a2635d99729"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="abe7b5d69c3768b71b7332a2635d99729" args="(pyDataObjectImag_doc,&quot;imag() &#45;&gt; return a new data object with the imaginary part of the source\n\
\n\
This method extracts the imaginary part of each element in source and writes the result to the output object.\
This object must be of complex type (complex128 or complex64). The output value will be float type (float64 or float32).\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
res : {dataObject} \n\
    output dataObject of same shape but the type is changed.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectImag_doc,&quot;imag() -&gt; return a new data object with the imaginary part of the source\n\
\n\
This method extracts the imaginary part of each element in source and writes the result to the output object.\
This object must be of complex type (complex128 or complex64). The output value will be float type (float64 or float32).\n\
\n\
Returns \n\
------- \n\
res : {dataObject} \n\
    output dataObject of same shape but the type is changed.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09145f1dc2101fde53027e5f1f6e9a52"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a09145f1dc2101fde53027e5f1f6e9a52" args="(pyDataObj_ToGray_doc,&quot;toGray([destinationType='uint8']) &#45;&gt; returns the rgba32 color data object as a gray&#45;scale object\n\
\n\
The destination data object has the same size than this data object and the real type given by destinationType. The pixel&#45;wise \
conversion is done using the formula: gray = 0.299 * red + 0.587 * green + 0.114 * blue.\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
destinationType : {str} \n\
    Type string indicating the new real type ('uint8',...'float32','float64' &#45; no complex) \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
dataObj : {dataObject} \n\
    converted gray&#45;scale data object of desired type&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObj_ToGray_doc,&quot;toGray([destinationType='uint8']) -&gt; returns the rgba32 color data object as a gray-scale object\n\
\n\
The destination data object has the same size than this data object and the real type given by destinationType. The pixel-wise \
conversion is done using the formula: gray = 0.299 * red + 0.587 * green + 0.114 * blue.\
\n\
Parameters \n\
----------- \n\
destinationType : {str} \n\
    Type string indicating the new real type ('uint8',...'float32','float64' - no complex) \n\
\n\
Returns \n\
------- \n\
dataObj : {dataObject} \n\
    converted gray-scale data object of desired type&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab41f40ae095ff0b6784ac8c4e55f849f"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ab41f40ae095ff0b6784ac8c4e55f849f" args="(pyDataObjectToList_doc,&quot;tolist() &#45;&gt; return the data object as a (possibly nested) list\n\
\n\
This method returns a nested list with all values of this data object. The recursion level of this nested list \
corresponds to the number of dimensions. The outer list corresponds to the first dimension. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
y : {list} \n\
    Nested list with values of data object (int, float or complex depending on type of data object)&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectToList_doc,&quot;tolist() -&gt; return the data object as a (possibly nested) list\n\
\n\
This method returns a nested list with all values of this data object. The recursion level of this nested list \
corresponds to the number of dimensions. The outer list corresponds to the first dimension. \n\
\n\
Returns \n\
------- \n\
y : {list} \n\
    Nested list with values of data object (int, float or complex depending on type of data object)&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a205f443b8f5ce1499fb5a907594a7fa3"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a205f443b8f5ce1499fb5a907594a7fa3" args="(pyDataObjectStaticZeros_doc,&quot;zeros(dims [, dtype='uint8'[, continuous = 0]]) &#45;&gt; creates new dataObject filled with zeros.  \n\
\n\
Static method for creating a new n&#45;dimensional itom.dataObject with given number of dimensions and dtype, filled with zeros. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
dims : {integer list} \n\
    'dims' is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','float32','float64','complex64','complex128', 'rgba32'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
I : {dataObject} of shape (size,size)\n\
    An array where all elements are equal to zero. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
eye: method for creating an eye matrix \n\
ones: method for creating a matrix filled with ones \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45;&#45; \n\
For color&#45;types (rgba32) every item / cell will be black and transparent: [r=0 g=0 b=0 a=0].&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectStaticZeros_doc,&quot;zeros(dims [, dtype='uint8'[, continuous = 0]]) -&gt; creates new dataObject filled with zeros.  \n\
\n\
Static method for creating a new n-dimensional itom.dataObject with given number of dimensions and dtype, filled with zeros. \n\
\n\
Parameters \n\
----------- \n\
dims : {integer list} \n\
    'dims' is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','float32','float64','complex64','complex128', 'rgba32'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
\n\
Returns \n\
------- \n\
I : {dataObject} of shape (size,size)\n\
    An array where all elements are equal to zero. \n\
\n\
See Also \n\
--------- \n\
eye: method for creating an eye matrix \n\
ones: method for creating a matrix filled with ones \n\
\n\
Notes \n\
------ \n\
For color-types (rgba32) every item / cell will be black and transparent: [r=0 g=0 b=0 a=0].&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a327bfda7ae3e05a3d65e5f0dfc6d6f90"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a327bfda7ae3e05a3d65e5f0dfc6d6f90" args="(pyDataObjectStaticOnes_doc,&quot;ones(dims [, dtype='uint8'[, continuous = 0]]) &#45;&gt; creates new dataObject filled with ones.  \n\
\n\
Static method for creating a new n&#45;dimensional itom.dataObject with given number of dimensions and dtype, filled with ones. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
dims : {integer list} \n\
    'dims' is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','float32','float64','complex64','complex128', 'rgba32'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
I : {dataObject} of shape (size,size)\n\
    An array where all elements are equal to one. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
eye: method for creating an eye matrix \n\
zeros: method for creating a matrix filled with zeros \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45;&#45; \n\
For color&#45;types (rgba32) every item / cell will be white: [r=255 g=255 b=255 a=255].&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectStaticOnes_doc,&quot;ones(dims [, dtype='uint8'[, continuous = 0]]) -&gt; creates new dataObject filled with ones.  \n\
\n\
Static method for creating a new n-dimensional itom.dataObject with given number of dimensions and dtype, filled with ones. \n\
\n\
Parameters \n\
----------- \n\
dims : {integer list} \n\
    'dims' is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','float32','float64','complex64','complex128', 'rgba32'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
\n\
Returns \n\
------- \n\
I : {dataObject} of shape (size,size)\n\
    An array where all elements are equal to one. \n\
\n\
See Also \n\
--------- \n\
eye: method for creating an eye matrix \n\
zeros: method for creating a matrix filled with zeros \n\
\n\
Notes \n\
------ \n\
For color-types (rgba32) every item / cell will be white: [r=255 g=255 b=255 a=255].&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d360c363991ae3d0141ea6da00c7074"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a2d360c363991ae3d0141ea6da00c7074" args="(pyDataObjectStaticRand_doc,&quot;rand([dims [, dtype='uint8'[, continuous = 0]]]) &#45;&gt; creates new dataObject filled with uniform distributed random values.  \n\
\n\
Static method to create a new itom.dataObject filled with uniform distributed random numbers.\n\
In case of an integer type, the uniform noise is from min&lt;ObjectType&gt;(inclusiv) to max&lt;ObjectType&gt;(inclusiv).\n\
For floating point types, the noise is between 0(inclusiv) and 1(exclusiv). \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
dims : {integer list} \n\
    'dims' is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns.\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','float32','float64','complex64','complex128'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {dataObject} \n\
    Array of random numbers with the given dimensions, dtype. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
randN: method for creating a matrix filled with gaussianly distributed values&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectStaticRand_doc,&quot;rand([dims [, dtype='uint8'[, continuous = 0]]]) -&gt; creates new dataObject filled with uniform distributed random values.  \n\
\n\
Static method to create a new itom.dataObject filled with uniform distributed random numbers.\n\
In case of an integer type, the uniform noise is from min&lt;ObjectType&gt;(inclusiv) to max&lt;ObjectType&gt;(inclusiv).\n\
For floating point types, the noise is between 0(inclusiv) and 1(exclusiv). \n\
\n\
Parameters \n\
----------- \n\
dims : {integer list} \n\
    'dims' is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns.\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','float32','float64','complex64','complex128'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
\n\
Returns \n\
------- \n\
out : {dataObject} \n\
    Array of random numbers with the given dimensions, dtype. \n\
\n\
See Also \n\
--------- \n\
randN: method for creating a matrix filled with gaussianly distributed values&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa55a663c1eab9392827db017f7db08b1"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aa55a663c1eab9392827db017f7db08b1" args="(pyDataObjectStaticRandN_doc,&quot;randN(dims [, dtype='uint8'[, continuous = 0]]) &#45;&gt; creates dataObject filled with gaussian distributed random values.  \n\
\n\
Static method to create a new itom.dataObject filled with gaussian distributed random numbers. \n\
In case of an integer type, the gausian noise mean value is (max+min)/2.0 and the standard deviation is (max&#45;min/)6.0 to max. \n\
For floating point types, the noise mean value is 0 and the standard deviation is 1.0/3.0. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
dims : {integer list} \n\
    'dims' is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns.\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32', 'float32','float64','complex64','complex128'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {dataObject} \n\
    Array of random numbers with the given dimensions, dtype. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
rand: method for creating a matrix filled with unformly distributed values&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectStaticRandN_doc,&quot;randN(dims [, dtype='uint8'[, continuous = 0]]) -&gt; creates dataObject filled with gaussian distributed random values.  \n\
\n\
Static method to create a new itom.dataObject filled with gaussian distributed random numbers. \n\
In case of an integer type, the gausian noise mean value is (max+min)/2.0 and the standard deviation is (max-min/)6.0 to max. \n\
For floating point types, the noise mean value is 0 and the standard deviation is 1.0/3.0. \n\
\n\
Parameters \n\
----------- \n\
dims : {integer list} \n\
    'dims' is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns.\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32', 'float32','float64','complex64','complex128'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
\n\
Returns \n\
------- \n\
out : {dataObject} \n\
    Array of random numbers with the given dimensions, dtype. \n\
\n\
See Also \n\
--------- \n\
rand: method for creating a matrix filled with unformly distributed values&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9633df5bdbdc78556bd09b82658abcd6"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a9633df5bdbdc78556bd09b82658abcd6" args="(pyDataObjectStaticEye_doc,&quot;eye(size [, dtype='uint8']) &#45;&gt; creates a 2D, square, eye&#45;matrix.\n\
\n\
Static method for creating a two&#45;dimensional, square, eye&#45;matrix of type itom.dataObject. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
size : {int}, \n\
    the size of the square matrix (single value)\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','uint32','float32','float64','complex64','complex128'\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
I : {dataObject} of shape (size,size)\n\
    An array where all elements are equal to zero, except for the 'k&#45;th diagonal, whose values are equal to one. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
ones: method for creating a matrix filled with ones \n\
zeros: method for creating a matrix filled with zeros&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectStaticEye_doc,&quot;eye(size [, dtype='uint8']) -&gt; creates a 2D, square, eye-matrix.\n\
\n\
Static method for creating a two-dimensional, square, eye-matrix of type itom.dataObject. \n\
\n\
Parameters \n\
----------- \n\
size : {int}, \n\
    the size of the square matrix (single value)\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','uint32','float32','float64','complex64','complex128'\n\
\n\
Returns \n\
------- \n\
I : {dataObject} of shape (size,size)\n\
    An array where all elements are equal to zero, except for the 'k-th diagonal, whose values are equal to one. \n\
\n\
See Also \n\
--------- \n\
ones: method for creating a matrix filled with ones \n\
zeros: method for creating a matrix filled with zeros&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7466be0eb8d68831a0dc9cfeb16b792"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="af7466be0eb8d68831a0dc9cfeb16b792" args="(pyDataObjectIterLen_doc,&quot;Private method returning an estimate of len(list(it)).&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectIterLen_doc,&quot;Private method returning an estimate of len(list(it)).&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95729a740cf724488c527c103f1440a9"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a95729a740cf724488c527c103f1440a9" args="(pyFigureInit_doc,&quot;figure([handle, [rows = 1, cols = 1]]) &#45;&gt; creates figure window.\n\
\n\
The class itom.figure represents a standalone figure window, that can have various subplots. If an instance of this class \n\
is created without further parameters a new figure is created and opened having one subplot area (currently empty) and the numeric \n\
handle to this figure is returned:: \n\
    \n\
    h = figure() \n\
\n\
Subplots are arranged in a regular grid whose size is defined by the optional parameters 'rows' and 'cols'. If you create a figure \n\
instance with a given handle, the instance is either a reference to an existing figure that has got this handle or if it does not exist, \n\
a new figure with the desired handle is opened and the handle is returned, too. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
handle : {int} \n\
    numeric handle of the desired figure. \n\
rows : {int, default: 1} \n\
    number of rows this figure should have (defines the size of the subplot&#45;grid) \n\
cols : {int, default: 1} \n\
    number of columns this figure should have (defines the size of the subplot&#45;grid)&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigureInit_doc,&quot;figure([handle, [rows = 1, cols = 1]]) -&gt; creates figure window.\n\
\n\
The class itom.figure represents a standalone figure window, that can have various subplots. If an instance of this class \n\
is created without further parameters a new figure is created and opened having one subplot area (currently empty) and the numeric \n\
handle to this figure is returned:: \n\
    \n\
    h = figure() \n\
\n\
Subplots are arranged in a regular grid whose size is defined by the optional parameters 'rows' and 'cols'. If you create a figure \n\
instance with a given handle, the instance is either a reference to an existing figure that has got this handle or if it does not exist, \n\
a new figure with the desired handle is opened and the handle is returned, too. \n\
\n\
Parameters \n\
------------- \n\
handle : {int} \n\
    numeric handle of the desired figure. \n\
rows : {int, default: 1} \n\
    number of rows this figure should have (defines the size of the subplot-grid) \n\
cols : {int, default: 1} \n\
    number of columns this figure should have (defines the size of the subplot-grid)&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcbae707809fa46b642b6cc097ce2d9e"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="afcbae707809fa46b642b6cc097ce2d9e" args="(pyFigurePlot_doc,&quot;plot(data, [areaIndex, className]) &#45;&gt; plots a dataObject in the current or given area of this figure\n\
Plot an existing dataObject in not dockable, not blocking window. \n\
The style of the plot will depend on the object dimensions.\n\
If x&#45;dim or y&#45;dim are equal to 1, plot will be a lineplot else a 2D&#45;plot.\n\
\n\
Parameters\n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
data : {DataObject} \n\
    Is the data object whose region of interest will be plotted.\n\
areaIndex: {int}, optional \n\
    \n\
className : {str}, optional \n\
    class name of desired plot (if not indicated default plot will be used (see application settings) \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigurePlot_doc,&quot;plot(data, [areaIndex, className]) -&gt; plots a dataObject in the current or given area of this figure\n\
Plot an existing dataObject in not dockable, not blocking window. \n\
The style of the plot will depend on the object dimensions.\n\
If x-dim or y-dim are equal to 1, plot will be a lineplot else a 2D-plot.\n\
\n\
Parameters\n\
-----------\n\
data : {DataObject} \n\
    Is the data object whose region of interest will be plotted.\n\
areaIndex: {int}, optional \n\
    \n\
className : {str}, optional \n\
    class name of desired plot (if not indicated default plot will be used (see application settings) \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a907ae5d64d2813a786897e9d1c3901cc"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a907ae5d64d2813a786897e9d1c3901cc" args="(pyFigureLiveImage_doc,&quot;liveImage(cam, [areaIndex, className]) &#45;&gt; shows a camera live image in the current or given area of this figure\n\
Creates a plot&#45;image (2D) and automatically grabs images into this window.\n\
This function is not blocking.\n\
\n\
Parameters\n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
cam : {dataIO&#45;Instance} \n\
    Camera grabber device from which images are acquired.\n\
areaIndex: {int}, optional \n\
    \n\
className : {str}, optional \n\
    class name of desired plot (if not indicated default plot will be used (see application settings) \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigureLiveImage_doc,&quot;liveImage(cam, [areaIndex, className]) -&gt; shows a camera live image in the current or given area of this figure\n\
Creates a plot-image (2D) and automatically grabs images into this window.\n\
This function is not blocking.\n\
\n\
Parameters\n\
-----------\n\
cam : {dataIO-Instance} \n\
    Camera grabber device from which images are acquired.\n\
areaIndex: {int}, optional \n\
    \n\
className : {str}, optional \n\
    class name of desired plot (if not indicated default plot will be used (see application settings) \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a499d493462db6b3dfd286ce562c54f0c"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a499d493462db6b3dfd286ce562c54f0c" args="(pyFigureShow_doc,&quot;show() &#45;&gt; shows figure \n\
\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigureShow_doc,&quot;show() -&gt; shows figure \n\
\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3263e380c929b4cc91e36e09f148d354"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a3263e380c929b4cc91e36e09f148d354" args="(pyFigureHide_doc,&quot;hide() &#45;&gt; hides figure without deleting it\n\
\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigureHide_doc,&quot;hide() -&gt; hides figure without deleting it\n\
\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77a5665b381dccef36470f8c51837455"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a77a5665b381dccef36470f8c51837455" args="(pyFigureSubplot_doc,&quot;subplot(index) &#45;&gt; returns plotItem of desired subplot\n\
\n\
This method closes and deletes any specific figure (given by handle) or all opened figures. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
index : {unsigned int} \n\
    index to desired subplot. The subplot at the top, left position has the index 0 whereas the index is incremented row&#45;wise.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigureSubplot_doc,&quot;subplot(index) -&gt; returns plotItem of desired subplot\n\
\n\
This method closes and deletes any specific figure (given by handle) or all opened figures. \n\
\n\
Parameters \n\
----------- \n\
index : {unsigned int} \n\
    index to desired subplot. The subplot at the top, left position has the index 0 whereas the index is incremented row-wise.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af557696cdd8e91c0f817143135038480"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="af557696cdd8e91c0f817143135038480" args="(pyFigure_docked_doc,&quot;dock status of figure (True|False) \n\
\n\
this attribute controls the dock appearance of this figure. If it is docked, the figure is integrated into the main window \n\
of itom, else it is a independent window. \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigure_docked_doc,&quot;dock status of figure (True|False) \n\
\n\
this attribute controls the dock appearance of this figure. If it is docked, the figure is integrated into the main window \n\
of itom, else it is a independent window. \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a121751eff3d9fc6345a1eb964eedb906"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a121751eff3d9fc6345a1eb964eedb906" args="(pyFigure_Close_doc,&quot;close(handle|'all') &#45;&gt; static method to close any specific or all open figures (unless any figure&#45;instance still keeps track of them)\n\
\n\
This method closes and deletes any specific figure (given by handle) or all opened figures. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
handle : {dataIO&#45;Instance} \n\
    any figure handle (&gt;0) or 'all' in order to close all opened figures \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
If any instance of class 'figure' still keeps a reference to any figure, it is only closed and deleted if the last instance is deleted, too.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigure_Close_doc,&quot;close(handle|'all') -&gt; static method to close any specific or all open figures (unless any figure-instance still keeps track of them)\n\
\n\
This method closes and deletes any specific figure (given by handle) or all opened figures. \n\
\n\
Parameters \n\
----------- \n\
handle : {dataIO-Instance} \n\
    any figure handle (&gt;0) or 'all' in order to close all opened figures \n\
\n\
Notes \n\
------- \n\
If any instance of class 'figure' still keeps a reference to any figure, it is only closed and deleted if the last instance is deleted, too.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9719212e423bba722226f9663da31153"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a9719212e423bba722226f9663da31153" args="(pyOpenEmptyScriptEditor_doc,&quot;scriptEditor() &#45;&gt; opens new, empty script editor window (undocked)&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyOpenEmptyScriptEditor_doc,&quot;scriptEditor() -&gt; opens new, empty script editor window (undocked)&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a6bf8481954d39f880c4a71d9324d98"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a7a6bf8481954d39f880c4a71d9324d98" args="(pyNewScript_doc,&quot;newScript() &#45;&gt; opens an empty, new script in the current script window.\n\
\n\
Creates a new itom script in the latest opened editor window.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyNewScript_doc,&quot;newScript() -&gt; opens an empty, new script in the current script window.\n\
\n\
Creates a new itom script in the latest opened editor window.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29d9f14738279258ce2deae63d211549"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a29d9f14738279258ce2deae63d211549" args="(pyOpenScript_doc,&quot;openScript(filename) &#45;&gt; open the given script in current script window.\n\
\n\
Open the python script indicated by *filename* in a new tab in the current, latest opened editor window. \n\
Filename can be either a string with a relative or absolute filename to the script to open or any object \n\
with a `__file__` attribute. This attribute is then read and used as path. \n\
\n\
The relative filename is relative with respect to the current directory. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filename : {str} or {obj} \n\
    Relative or absolute filename to a python script that is then opened (in the current editor window). Alternatively an object with a `__file__` attribute is allowed.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyOpenScript_doc,&quot;openScript(filename) -&gt; open the given script in current script window.\n\
\n\
Open the python script indicated by *filename* in a new tab in the current, latest opened editor window. \n\
Filename can be either a string with a relative or absolute filename to the script to open or any object \n\
with a `__file__` attribute. This attribute is then read and used as path. \n\
\n\
The relative filename is relative with respect to the current directory. \n\
\n\
Parameters \n\
----------- \n\
filename : {str} or {obj} \n\
    Relative or absolute filename to a python script that is then opened (in the current editor window). Alternatively an object with a `__file__` attribute is allowed.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a600ebf664dbc889ee7097b52ef10f203"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a600ebf664dbc889ee7097b52ef10f203" args="(pyPlotImage_doc,&quot;plot(data, [className, properties]) &#45;&gt; plots a dataObject in a newly created figure \n\
\n\
Plot an existing dataObject in dockable, not blocking window. \n\
The style of the plot depends on the object dimensions.\n\
If x&#45;dim or y&#45;dim are equal to 1, plot will be a line&#45;plot, else a 2D&#45;plot.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
data : {DataObject} \n\
    Is the data object whose region of interest will be plotted.\n\
className : {str}, optional \n\
    class name of desired plot (if not indicated or if the className can not be found, the default plot will be used (see application settings) \n\
properties : {dict}, optional \n\
    optional dictionary of properties that will be directly applied to the plot widget.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlotImage_doc,&quot;plot(data, [className, properties]) -&gt; plots a dataObject in a newly created figure \n\
\n\
Plot an existing dataObject in dockable, not blocking window. \n\
The style of the plot depends on the object dimensions.\n\
If x-dim or y-dim are equal to 1, plot will be a line-plot, else a 2D-plot.\n\
\n\
Parameters \n\
----------- \n\
data : {DataObject} \n\
    Is the data object whose region of interest will be plotted.\n\
className : {str}, optional \n\
    class name of desired plot (if not indicated or if the className can not be found, the default plot will be used (see application settings) \n\
properties : {dict}, optional \n\
    optional dictionary of properties that will be directly applied to the plot widget.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80356e6b79063c9b10c2e3aa83444316"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a80356e6b79063c9b10c2e3aa83444316" args="(pyLiveImage_doc,&quot;liveImage(cam, [className, properties]) &#45;&gt; show a camera live image in a newly created figure\n\
\n\
Creates a plot&#45;image (2D) and automatically grabs images into this window.\n\
This function is not blocking.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
cam : {dataIO&#45;Instance} \n\
    Camera grabber device from which images are acquired.\n\
className : {str}, optional \n\
    class name of desired plot (if not indicated or if the className can not be found, the default plot will be used (see application settings) \n\
properties : {dict}, optional \n\
    optional dictionary of properties that will be directly applied to the plot widget.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyLiveImage_doc,&quot;liveImage(cam, [className, properties]) -&gt; show a camera live image in a newly created figure\n\
\n\
Creates a plot-image (2D) and automatically grabs images into this window.\n\
This function is not blocking.\n\
\n\
Parameters \n\
----------- \n\
cam : {dataIO-Instance} \n\
    Camera grabber device from which images are acquired.\n\
className : {str}, optional \n\
    class name of desired plot (if not indicated or if the className can not be found, the default plot will be used (see application settings) \n\
properties : {dict}, optional \n\
    optional dictionary of properties that will be directly applied to the plot widget.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a9d28eae15e9624a9b374e03abe6d8f83">PyWidgetOrFilterHelp</a> (bool getWidgetHelp, PyObject *pArgs, PyObject *pKwds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3461543b07884b94016ba2ad6d54dc81"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a3461543b07884b94016ba2ad6d54dc81" args="(pyFilterHelp_doc,&quot;filterHelp([filterName, dictionary = 0, furtherInfos = 0]) &#45;&gt; generates an online help for the given filter(s). \n\
\n\
This method prints information about one specific filter (algorithm) or a list of filters to the console output. If one specific filter, defined \
in an algorithm plugin can be found that case&#45;sensitively fits the given filterName its full documentation is printed. Else, a list of filters \
is printed whose name contains the given filterName.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filterName : {str}, optional \n\
    is the fullname or a part of any filter&#45;name which should be displayed. \n\
    If filterName is empty or no filter matches filterName (case sensitive) a list with all suitable filters is given. \n\
dictionary : {dict}, optional \n\
    if dictionary == 1, a dictionary with all relevant components of the filter's documentation is returned and nothing is printed to the command line [default: 0] \n\
furtherInfos : {int}, optional \n\
    Usually, filters or algorithms whose name only contains the given filterName are only listed at the end of the information text. \n\
    If this parameter is set to 1 [default: 0], the full information for all these filters is printed as well. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {None or dict} \n\
    In its default parameterization this method returns None. Depending on the parameter dictionary it is also possible that this method \
    returns a dictionary with the single components of the information text.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFilterHelp_doc,&quot;filterHelp([filterName, dictionary = 0, furtherInfos = 0]) -&gt; generates an online help for the given filter(s). \n\
\n\
This method prints information about one specific filter (algorithm) or a list of filters to the console output. If one specific filter, defined \
in an algorithm plugin can be found that case-sensitively fits the given filterName its full documentation is printed. Else, a list of filters \
is printed whose name contains the given filterName.\n\
\n\
Parameters \n\
----------- \n\
filterName : {str}, optional \n\
    is the fullname or a part of any filter-name which should be displayed. \n\
    If filterName is empty or no filter matches filterName (case sensitive) a list with all suitable filters is given. \n\
dictionary : {dict}, optional \n\
    if dictionary == 1, a dictionary with all relevant components of the filter's documentation is returned and nothing is printed to the command line [default: 0] \n\
furtherInfos : {int}, optional \n\
    Usually, filters or algorithms whose name only contains the given filterName are only listed at the end of the information text. \n\
    If this parameter is set to 1 [default: 0], the full information for all these filters is printed as well. \n\
\n\
Returns \n\
------- \n\
out : {None or dict} \n\
    In its default parameterization this method returns None. Depending on the parameter dictionary it is also possible that this method \
    returns a dictionary with the single components of the information text.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4f21b08d44a339e9a0dfbd9419ce637"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ac4f21b08d44a339e9a0dfbd9419ce637" args="(pyWidgetHelp_doc,&quot;widgetHelp([widgetName, dictionary = 0, furtherInfos = 0]) &#45;&gt; generates an online help for the given widget(s). \n\
\n\
This method prints information about one specific widget or a list of widgets to the console output. If one specific widget, defined \
in an algorithm plugin can be found that case&#45;sensitively fits the given widgetName its full documentation is printed. Else, a list of widgets \
is printed whose name contains the given widgetName.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
widgetName : {str}, optional \n\
    is the fullname or a part of any widget&#45;name which should be displayed. \n\
    If widgetName is empty or no widget matches widgetName (case sensitive) a list with all suitable widgets is given. \n\
dictionary : {dict}, optional \n\
    if dictionary == 1, a dictionary with all relevant components of the widget's documentation is returned and nothing is printed to the command line [default: 0] \n\
furtherInfos : {int}, optional \n\
    Usually, widgets whose name only contains the given widgetName are only listed at the end of the information text. \n\
    If this parameter is set to 1 [default: 0], the full information for all these widgets is printed as well. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {None or dict} \n\
    In its default parameterization this method returns None. Depending on the parameter dictionary it is also possible that this method \
    returns a dictionary with the single components of the information text.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyWidgetHelp_doc,&quot;widgetHelp([widgetName, dictionary = 0, furtherInfos = 0]) -&gt; generates an online help for the given widget(s). \n\
\n\
This method prints information about one specific widget or a list of widgets to the console output. If one specific widget, defined \
in an algorithm plugin can be found that case-sensitively fits the given widgetName its full documentation is printed. Else, a list of widgets \
is printed whose name contains the given widgetName.\n\
\n\
Parameters \n\
----------- \n\
widgetName : {str}, optional \n\
    is the fullname or a part of any widget-name which should be displayed. \n\
    If widgetName is empty or no widget matches widgetName (case sensitive) a list with all suitable widgets is given. \n\
dictionary : {dict}, optional \n\
    if dictionary == 1, a dictionary with all relevant components of the widget's documentation is returned and nothing is printed to the command line [default: 0] \n\
furtherInfos : {int}, optional \n\
    Usually, widgets whose name only contains the given widgetName are only listed at the end of the information text. \n\
    If this parameter is set to 1 [default: 0], the full information for all these widgets is printed as well. \n\
\n\
Returns \n\
------- \n\
out : {None or dict} \n\
    In its default parameterization this method returns None. Depending on the parameter dictionary it is also possible that this method \
    returns a dictionary with the single components of the information text.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c059740f2347f115f382fc05b6e526e"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a9c059740f2347f115f382fc05b6e526e" args="(pyPluginLoaded_doc,&quot;pluginLoaded(pluginName) &#45;&gt; check if a certain plugin could be successfully loaded.\n\
\n\
Checks if a specified plugin is loaded and returns the result as a boolean expression. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
pluginName :  {str} \n\
    The name of a specified plugin as usually displayed in the plugin window.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
result : {bool} \n\
    True, if the plugin has been loaded and can be used, else False.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginLoaded_doc,&quot;pluginLoaded(pluginName) -&gt; check if a certain plugin could be successfully loaded.\n\
\n\
Checks if a specified plugin is loaded and returns the result as a boolean expression. \n\
\n\
Parameters \n\
----------- \n\
pluginName :  {str} \n\
    The name of a specified plugin as usually displayed in the plugin window.\n\
\n\
Returns \n\
------- \n\
result : {bool} \n\
    True, if the plugin has been loaded and can be used, else False.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaddddd7752d641809207e627f0e698e7"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aaddddd7752d641809207e627f0e698e7" args="(pyPlotLoaded_doc,&quot;plotLoaded(plotName) &#45;&gt; check if a certain plot widget is loaded.\n\
\n\
Checks if a specified plot widget is loaded and returns the result as a boolean expression. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
pluginName :  {str} \n\
    The name of a specified plot widget as displayed in the preferences window.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
result : {bool} \n\
    True, if the plot has been loaded and can be used, else False.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlotLoaded_doc,&quot;plotLoaded(plotName) -&gt; check if a certain plot widget is loaded.\n\
\n\
Checks if a specified plot widget is loaded and returns the result as a boolean expression. \n\
\n\
Parameters \n\
----------- \n\
pluginName :  {str} \n\
    The name of a specified plot widget as displayed in the preferences window.\n\
\n\
Returns \n\
------- \n\
result : {bool} \n\
    True, if the plot has been loaded and can be used, else False.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade5bcd4efb4d391ef24a196a2e27827e"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ade5bcd4efb4d391ef24a196a2e27827e" args="(pyPlotHelp_doc,&quot;plotHelp(plotName [, dictionary = False]) &#45;&gt; generates an online help for the specified plot.\n\
                              Gets (also print to console) the available slots / properties of the plot specified by plotName (str, as specified in the properties window).\n\
If `dictionary == True`, a dict with all plot slots / properties is returned and nothing is printed to the console.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
plotName : {str} \n\
    is the fullname of a plot as specified in the properties window (case insensitive).\n\
dictionary : {bool}, optional \n\
    if `dictionary == True`, function returns a dict with plot slots and properties and does not print anything to the console (default: False)\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {None or dict} \n\
    Returns None or a dict depending on the value of parameter `dictionary`.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlotHelp_doc,&quot;plotHelp(plotName [, dictionary = False]) -&gt; generates an online help for the specified plot.\n\
                              Gets (also print to console) the available slots / properties of the plot specified by plotName (str, as specified in the properties window).\n\
If `dictionary == True`, a dict with all plot slots / properties is returned and nothing is printed to the console.\n\
\n\
Parameters \n\
----------- \n\
plotName : {str} \n\
    is the fullname of a plot as specified in the properties window (case insensitive).\n\
dictionary : {bool}, optional \n\
    if `dictionary == True`, function returns a dict with plot slots and properties and does not print anything to the console (default: False)\n\
\n\
Returns \n\
------- \n\
out : {None or dict} \n\
    Returns None or a dict depending on the value of parameter `dictionary`.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a042445ae6e840ba240bb685cf6995520"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a042445ae6e840ba240bb685cf6995520" args="(pyPluginHelp_doc,&quot;pluginHelp(pluginName [, dictionary = False]) &#45;&gt; generates an online help for the specified plugin.\n\
                              Gets (also print to console) the initialisation parameters of the plugin specified pluginName (str, as specified in the plugin window).\n\
If `dictionary == True`, a dict with all plugin parameters is returned and nothing is printed to the console.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
pluginName : {str} \n\
    is the fullname of a plugin as specified in the plugin window.\n\
dictionary : {bool}, optional \n\
    if `dictionary == True`, function returns a dict with plugin parameters and does not print anything to the console (default: False)\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {None or dict} \n\
    Returns None or a dict depending on the value of parameter `dictionary`.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginHelp_doc,&quot;pluginHelp(pluginName [, dictionary = False]) -&gt; generates an online help for the specified plugin.\n\
                              Gets (also print to console) the initialisation parameters of the plugin specified pluginName (str, as specified in the plugin window).\n\
If `dictionary == True`, a dict with all plugin parameters is returned and nothing is printed to the console.\n\
\n\
Parameters \n\
----------- \n\
pluginName : {str} \n\
    is the fullname of a plugin as specified in the plugin window.\n\
dictionary : {bool}, optional \n\
    if `dictionary == True`, function returns a dict with plugin parameters and does not print anything to the console (default: False)\n\
\n\
Returns \n\
------- \n\
out : {None or dict} \n\
    Returns None or a dict depending on the value of parameter `dictionary`.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a052adc06067d3deef7753d81a483e878"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a052adc06067d3deef7753d81a483e878" args="(pyITOMVersion_doc,&quot;version([toggle&#45;output [, include&#45;plugins]])) &#45;&gt; retrieve complete information about itom version numbers\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
toggle&#45;output : {bool}, optional\n\
    default = false\n\
    if true, output will be written to a dictionary else to console.\n\
dictionary : {bool}, optional \n\
    default = false\n\
    if true, add informations about plugIn versions.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
None (display outPut) or PyDictionary with version information.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
Retrieve complete version information of itom and if specified version information of loaded plugins\n\
and print it either to the console or to a PyDictionary.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyITOMVersion_doc,&quot;version([toggle-output [, include-plugins]])) -&gt; retrieve complete information about itom version numbers\n\
\n\
Parameters \n\
----------- \n\
toggle-output : {bool}, optional\n\
    default = false\n\
    if true, output will be written to a dictionary else to console.\n\
dictionary : {bool}, optional \n\
    default = false\n\
    if true, add informations about plugIn versions.\n\
\n\
Returns \n\
------- \n\
None (display outPut) or PyDictionary with version information.\n\
\n\
Notes \n\
----- \n\
\n\
Retrieve complete version information of itom and if specified version information of loaded plugins\n\
and print it either to the console or to a PyDictionary.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addee72cd2cde1dcf0264a5cab82392c9"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="addee72cd2cde1dcf0264a5cab82392c9" args="(pyAddButton_doc,&quot;addButton(toolbarName, buttonName, code [, icon, argtuple]) &#45;&gt; adds a button to a toolbar in the main window \n\
\n\
This function adds a button to a toolbar in the main window. If the button is pressed the given code, function or method is executed. \n\
If the toolbar specified by 'toolbarName' does not exist, it is created. The button will show the optional icon, or if not given or not \n\
loadable, 'buttonName' is displayed as text. \n\
\n\
itom comes with basic icons addressable by ':/../iconname.png', e.g. ':/gui/icons/close.png'. These natively available icons are listed \n\
in the icon&#45;browser in the menu 'edit &gt;&gt; iconbrowser' of any script window. Furthermore you can give a relative or absolute path to \n\
any allowed icon file (the preferred file format is png). \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
toolbarName : {str} \n\
    The name of the toolbar.\n\
buttonName : {str} \n\
    The name and identifier of the button to create.\n\
code : {str, method, function}\n\
    The code to be executed if the button is pressed.\n\
icon : {str}, optional \n\
    The filename of an icon&#45;file. This can also be relative to the application directory of 'itom'.\n\
argtuple : {tuple}, optional \n\
    Arguments, which will be passed to the method (in order to avoid cyclic references try to only use basic element types). \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
removeButton()&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyAddButton_doc,&quot;addButton(toolbarName, buttonName, code [, icon, argtuple]) -&gt; adds a button to a toolbar in the main window \n\
\n\
This function adds a button to a toolbar in the main window. If the button is pressed the given code, function or method is executed. \n\
If the toolbar specified by 'toolbarName' does not exist, it is created. The button will show the optional icon, or if not given or not \n\
loadable, 'buttonName' is displayed as text. \n\
\n\
itom comes with basic icons addressable by ':/../iconname.png', e.g. ':/gui/icons/close.png'. These natively available icons are listed \n\
in the icon-browser in the menu 'edit &gt;&gt; iconbrowser' of any script window. Furthermore you can give a relative or absolute path to \n\
any allowed icon file (the preferred file format is png). \n\
\n\
Parameters \n\
----------- \n\
toolbarName : {str} \n\
    The name of the toolbar.\n\
buttonName : {str} \n\
    The name and identifier of the button to create.\n\
code : {str, method, function}\n\
    The code to be executed if the button is pressed.\n\
icon : {str}, optional \n\
    The filename of an icon-file. This can also be relative to the application directory of 'itom'.\n\
argtuple : {tuple}, optional \n\
    Arguments, which will be passed to the method (in order to avoid cyclic references try to only use basic element types). \n\
\n\
See Also \n\
--------- \n\
removeButton()&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5241bf3b82ab1b1044b766f822b5b52e"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a5241bf3b82ab1b1044b766f822b5b52e" args="(pyRemoveButton_doc,&quot;removeButton(toolbarName, buttonName) &#45;&gt; removes a button from a given toolbar. \n\
\n\
This method removes an existing button from a toolbar in the main window of 'itom'. This button must have been \n\
created using `addButton`. If the toolbar is empty after the removal, it is finally deleted. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
toolbarName : {str} \n\
    The name of the toolbar.\n\
buttonName : {str} \n\
    The name (str, identifier) of the button to remove.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
addButton()&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRemoveButton_doc,&quot;removeButton(toolbarName, buttonName) -&gt; removes a button from a given toolbar. \n\
\n\
This method removes an existing button from a toolbar in the main window of 'itom'. This button must have been \n\
created using `addButton`. If the toolbar is empty after the removal, it is finally deleted. \n\
\n\
Parameters \n\
----------- \n\
toolbarName : {str} \n\
    The name of the toolbar.\n\
buttonName : {str} \n\
    The name (str, identifier) of the button to remove.\n\
\n\
See Also \n\
--------- \n\
addButton()&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02da90d99d7f463b24b50e2c023e5118"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a02da90d99d7f463b24b50e2c023e5118" args="(pyAddMenu_doc,&quot;addMenu(type, key [, name, code, icon, argtuple]) &#45;&gt; adds an element to the menu bar of itom. \n\
\n\
This function adds an element to the main window menu bar. \n\
The root element of every menu&#45;list must be a MENU&#45;element. Such a MENU&#45;element can contain sub&#45;elements. \n\
The following sub&#45;elements can be either another MENU, a SEPARATOR or a BUTTON. Only the BUTTON itself \n\
triggers a signal, which then executes the code, given by a string or a reference to a callable python method \n\
or function. Remember, that this reference is only stored as a weak pointer. \n\
If you want to directly add a sub&#45;element, you can give a slash&#45;separated string in the key&#45;parameter. \n\
Every sub&#45;component of this string then represents the menu&#45;element in its specific level. Only the element in the last \n\
can be something else than MENU.\n\
\n\
itom comes with basic icons addressable by ':/../iconname.png', e.g. ':/gui/icons/close.png'. These natively available icons are listed \n\
in the icon&#45;browser in the menu 'edit &gt;&gt; iconbrowser' of any script window. Furthermore you can give a relative or absolute path to \n\
any allowed icon file (the preferred file format is png). \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
type : {Int}\n\
    The type of the menu&#45;element (BUTTON:0 [default], SEPARATOR:1, MENU:2). Use the corresponding constans in module 'itom'.\n\
key : {str} \n\
    A slash&#45;separated string where every sub&#45;element is the key&#45;name for the menu&#45;element in the specific level.\n\
name : {str}, optional \n\
    The text of the menu&#45;element. If not indicated, the last sub&#45;element of key is taken.\n\
code : {str, Method, Function}, optional \n\
    The code to be executed if menu element is pressed.\n\
icon : {str}, optional \n\
    The filename of an icon&#45;file. This can also be relative to the application directory of 'itom'.\n\
argtuple : {tuple}, optional \n\
    Arguments, which will be passed to method (in order to avoid cyclic references try to only use basic element types).\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
removeMenu&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyAddMenu_doc,&quot;addMenu(type, key [, name, code, icon, argtuple]) -&gt; adds an element to the menu bar of itom. \n\
\n\
This function adds an element to the main window menu bar. \n\
The root element of every menu-list must be a MENU-element. Such a MENU-element can contain sub-elements. \n\
The following sub-elements can be either another MENU, a SEPARATOR or a BUTTON. Only the BUTTON itself \n\
triggers a signal, which then executes the code, given by a string or a reference to a callable python method \n\
or function. Remember, that this reference is only stored as a weak pointer. \n\
If you want to directly add a sub-element, you can give a slash-separated string in the key-parameter. \n\
Every sub-component of this string then represents the menu-element in its specific level. Only the element in the last \n\
can be something else than MENU.\n\
\n\
itom comes with basic icons addressable by ':/../iconname.png', e.g. ':/gui/icons/close.png'. These natively available icons are listed \n\
in the icon-browser in the menu 'edit &gt;&gt; iconbrowser' of any script window. Furthermore you can give a relative or absolute path to \n\
any allowed icon file (the preferred file format is png). \n\
\n\
Parameters \n\
----------- \n\
type : {Int}\n\
    The type of the menu-element (BUTTON:0 [default], SEPARATOR:1, MENU:2). Use the corresponding constans in module 'itom'.\n\
key : {str} \n\
    A slash-separated string where every sub-element is the key-name for the menu-element in the specific level.\n\
name : {str}, optional \n\
    The text of the menu-element. If not indicated, the last sub-element of key is taken.\n\
code : {str, Method, Function}, optional \n\
    The code to be executed if menu element is pressed.\n\
icon : {str}, optional \n\
    The filename of an icon-file. This can also be relative to the application directory of 'itom'.\n\
argtuple : {tuple}, optional \n\
    Arguments, which will be passed to method (in order to avoid cyclic references try to only use basic element types).\n\
\n\
See Also \n\
--------- \n\
removeMenu&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab44372e0b4afba5b2ce1462bf5722ab3"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ab44372e0b4afba5b2ce1462bf5722ab3" args="(pyRemoveMenu_doc,&quot;removeMenu(key) &#45;&gt; remove a menu element with the given key. \n\
\n\
This function remove a menu element with the given key. \n\
key is a slash separated list. The sub&#45;components then \n\
lead the way to the final element, which should be removed. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
key : {str} \n\
    The name (str, identifier) of the menu entry to remove.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
addMenu&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRemoveMenu_doc,&quot;removeMenu(key) -&gt; remove a menu element with the given key. \n\
\n\
This function remove a menu element with the given key. \n\
key is a slash separated list. The sub-components then \n\
lead the way to the final element, which should be removed. \n\
\n\
Parameters \n\
----------- \n\
key : {str} \n\
    The name (str, identifier) of the menu entry to remove.\n\
\n\
See Also \n\
--------- \n\
addMenu&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2af857ed7b57ff98ece9628c404876de"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a2af857ed7b57ff98ece9628c404876de" args="(autoReloader_doc,&quot;autoReloader(enabled [,checkFileExec = True, checkCmdExec = True, checkFctExec = False]) &#45;&gt; dis&#45;/enables the module to automatically reload changed modules \n\
\n\
Use this method to enable or disable (and configure) a tool that automatically tries to reload imported modules and their submodules if they have changed \n\
since the last run. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
enable : {bool} \n\
    The auto&#45;reload tool is loaded if it is enabled for the first time. If it is disabled, \n\
    it does not check changes of any imported modules. \n\
checkFileExec : {bool} \n\
    If True (default) and auto&#45;reload enabled, a check for modifications is executed whenever a script is executed \n\
checkCmdExec : {bool} \n\
    If True (default) and auto&#45;reload enabled, a check for modifications is executed whenever a command in the command line is executed \n\
checkFctExec : {bool} \n\
    If True and auto&#45;reload enabled, a check for modifications is executed whenever a function or method is run (e.g. by an event or button click) (default: False)\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
This tool is inspired by and based on the IPython extension 'autoreload'. \n\
\n\
Reloading Python modules in a reliable way is in general difficult, \n\
and unexpected things may occur. ``autoReloader`` tries to work around \n\
common pitfalls by replacing function code objects and parts of \n\
classes previously in the module with new versions. This makes the \n\
following things to work: \n\
 \n\
&#45; Functions and classes imported via 'from xxx import foo' are upgraded \n\
  to new versions when 'xxx' is reloaded. \n\
\n\
&#45; Methods and properties of classes are upgraded on reload, so that \n\
  calling 'c.foo()' on an object 'c' created before the reload causes \n\
  the new code for 'foo' to be executed. \n\
 \n\
Some of the known remaining caveats are: \n\
 \n\
&#45; Replacing code objects does not always succeed: changing a @property \n\
  in a class to an ordinary method or a method to a member variable \n\
  can cause problems (but in old objects only). \n\
 \n\
&#45; Functions that are removed (eg. via monkey&#45;patching) from a module \n\
  before it is reloaded are not upgraded. \n\
 \n\
&#45; C extension modules cannot be reloaded, and so cannot be autoreloaded.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (autoReloader_doc,&quot;autoReloader(enabled [,checkFileExec = True, checkCmdExec = True, checkFctExec = False]) -&gt; dis-/enables the module to automatically reload changed modules \n\
\n\
Use this method to enable or disable (and configure) a tool that automatically tries to reload imported modules and their submodules if they have changed \n\
since the last run. \n\
\n\
Returns \n\
------- \n\
enable : {bool} \n\
    The auto-reload tool is loaded if it is enabled for the first time. If it is disabled, \n\
    it does not check changes of any imported modules. \n\
checkFileExec : {bool} \n\
    If True (default) and auto-reload enabled, a check for modifications is executed whenever a script is executed \n\
checkCmdExec : {bool} \n\
    If True (default) and auto-reload enabled, a check for modifications is executed whenever a command in the command line is executed \n\
checkFctExec : {bool} \n\
    If True and auto-reload enabled, a check for modifications is executed whenever a function or method is run (e.g. by an event or button click) (default: False)\n\
\n\
Notes \n\
------- \n\
This tool is inspired by and based on the IPython extension 'autoreload'. \n\
\n\
Reloading Python modules in a reliable way is in general difficult, \n\
and unexpected things may occur. ``autoReloader`` tries to work around \n\
common pitfalls by replacing function code objects and parts of \n\
classes previously in the module with new versions. This makes the \n\
following things to work: \n\
 \n\
- Functions and classes imported via 'from xxx import foo' are upgraded \n\
  to new versions when 'xxx' is reloaded. \n\
\n\
- Methods and properties of classes are upgraded on reload, so that \n\
  calling 'c.foo()' on an object 'c' created before the reload causes \n\
  the new code for 'foo' to be executed. \n\
 \n\
Some of the known remaining caveats are: \n\
 \n\
- Replacing code objects does not always succeed: changing a @property \n\
  in a class to an ordinary method or a method to a member variable \n\
  can cause problems (but in old objects only). \n\
 \n\
- Functions that are removed (eg. via monkey-patching) from a module \n\
  before it is reloaded are not upgraded. \n\
 \n\
- C extension modules cannot be reloaded, and so cannot be autoreloaded.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed1492e9aa28ffef71f54c2377172bb8"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aed1492e9aa28ffef71f54c2377172bb8" args="(getScreenInfo_doc,&quot;getScreenInfo() &#45;&gt; returns dictionary with information about all available screens. \n\
\n\
This method returns a dictionary with information about the current screen configuration of this computer. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
screenInfo : {dict} \n\
    dictionary with the following content is returned: \n\
    \n\
    * screenCount (int): number of available screens \n\
    * primaryScreen (int): index (0&#45;based) of primary screen \n\
    * geometry (tuple): tuple with dictionaries for each screen containing data for width (w), height (h) and its top&#45;left&#45;position (x, y)&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (getScreenInfo_doc,&quot;getScreenInfo() -&gt; returns dictionary with information about all available screens. \n\
\n\
This method returns a dictionary with information about the current screen configuration of this computer. \n\
\n\
Returns \n\
------- \n\
screenInfo : {dict} \n\
    dictionary with the following content is returned: \n\
    \n\
    * screenCount (int): number of available screens \n\
    * primaryScreen (int): index (0-based) of primary screen \n\
    * geometry (tuple): tuple with dictionaries for each screen containing data for width (w), height (h) and its top-left-position (x, y)&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a285ed2cc002465abae5d77fd686348be"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a285ed2cc002465abae5d77fd686348be" args="(pySaveMatlabMat_doc,&quot;saveMatlabMat(filename, values[, matrixName = 'matrix']) &#45;&gt; save strings, numbers, arrays or combinations into a Matlab mat file. \n\
\n\
Save one or multiple objects (strings, numbers, arrays, `dataObject`, `numpy.ndarray`, `npDataObject`...) to a Matlab *mat* file. \n\
There are the following possibilites for saving: \n\
\n\
* One given value is saved under one given 'matrixName' or 'matrix' if 'matrixName' is not given. \n\
* A list or tuple of objects is given. If no 'matrixName' is given, the items get the names 'matrix1', 'matrix2'... Else, 'matrixName' must be a sequence of value names with the same length than 'values'. \n\
* A dictionary is given, such that each value is stored under its corresponding key. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filename : {str} \n\
    Filename under which the file should be saved (.mat will be appended if not available)\n\
values : {dictionary, list, tuple, variant} \n\
    single value, dictionary, list or tuple with elements of type number, string, array (dataObject, numpy.ndarray, npDataObject...)\n\
matrix&#45;name : {str, list, tuple}, optional \n\
    if 'values' is a single value, this parameter must be one single str, if 'values' is a sequence it must be a sequence of strings with the same length, if 'values' is a dictionary this argument is ignored. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
loadMatlabMat&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pySaveMatlabMat_doc,&quot;saveMatlabMat(filename, values[, matrixName = 'matrix']) -&gt; save strings, numbers, arrays or combinations into a Matlab mat file. \n\
\n\
Save one or multiple objects (strings, numbers, arrays, `dataObject`, `numpy.ndarray`, `npDataObject`...) to a Matlab *mat* file. \n\
There are the following possibilites for saving: \n\
\n\
* One given value is saved under one given 'matrixName' or 'matrix' if 'matrixName' is not given. \n\
* A list or tuple of objects is given. If no 'matrixName' is given, the items get the names 'matrix1', 'matrix2'... Else, 'matrixName' must be a sequence of value names with the same length than 'values'. \n\
* A dictionary is given, such that each value is stored under its corresponding key. \n\
\n\
Parameters \n\
----------- \n\
filename : {str} \n\
    Filename under which the file should be saved (.mat will be appended if not available)\n\
values : {dictionary, list, tuple, variant} \n\
    single value, dictionary, list or tuple with elements of type number, string, array (dataObject, numpy.ndarray, npDataObject...)\n\
matrix-name : {str, list, tuple}, optional \n\
    if 'values' is a single value, this parameter must be one single str, if 'values' is a sequence it must be a sequence of strings with the same length, if 'values' is a dictionary this argument is ignored. \n\
\n\
See Also \n\
---------- \n\
loadMatlabMat&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02ce77191cac6ddbb84bf7c1825751e6"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a02ce77191cac6ddbb84bf7c1825751e6" args="(pyLoadMatlabMat_doc,&quot;loadMatlabMat(filename) &#45;&gt; loads Matlab mat&#45;file by using scipy methods and returns the loaded dictionary. \n\
\n\
This function loads matlab mat&#45;file by using scipy methods and returns the loaded dictionary. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filename : {str} \n\
    Filename from which the data will be imported (.mat will be added if not available)\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
mat : {dict} \n\
    dictionary with content of file \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
saveMatlabMat&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyLoadMatlabMat_doc,&quot;loadMatlabMat(filename) -&gt; loads Matlab mat-file by using scipy methods and returns the loaded dictionary. \n\
\n\
This function loads matlab mat-file by using scipy methods and returns the loaded dictionary. \n\
\n\
Parameters \n\
----------- \n\
filename : {str} \n\
    Filename from which the data will be imported (.mat will be added if not available)\n\
\n\
Returns \n\
------- \n\
mat : {dict} \n\
    dictionary with content of file \n\
\n\
See Also \n\
--------- \n\
saveMatlabMat&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80fbe24b389f306ad424224f9218a314"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a80fbe24b389f306ad424224f9218a314" args="(pyFilter_doc,&quot;filter(name [, furtherParameters, ...]) &#45;&gt; invoke a filter (or algorithm) function from an algorithm&#45;plugin. \n\
\n\
This function is used to invoke itom filter&#45;functions or algorithms, declared within itom&#45;algorithm plugins.\n\
The parameters (arguments) depends on the specific filter function (see filterHelp(name)),\n\
By filterHelp() a list of available filter functions is retrieved. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
name : {str} \n\
    The name of the filter\n\
furtherParameters : {variant} \n\
    Further parameters depend on the filter&#45;methods itself (give the mandatory and then optional parameters in their defined order).\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {variant} \n\
    The returned values depend on the definition of each filter. In general it is a tuple of all output parameters that are defined by the filter function.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filterHelp&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFilter_doc,&quot;filter(name [, furtherParameters, ...]) -&gt; invoke a filter (or algorithm) function from an algorithm-plugin. \n\
\n\
This function is used to invoke itom filter-functions or algorithms, declared within itom-algorithm plugins.\n\
The parameters (arguments) depends on the specific filter function (see filterHelp(name)),\n\
By filterHelp() a list of available filter functions is retrieved. \n\
\n\
Parameters \n\
----------- \n\
name : {str} \n\
    The name of the filter\n\
furtherParameters : {variant} \n\
    Further parameters depend on the filter-methods itself (give the mandatory and then optional parameters in their defined order).\n\
\n\
Returns \n\
------- \n\
out : {variant} \n\
    The returned values depend on the definition of each filter. In general it is a tuple of all output parameters that are defined by the filter function.\n\
\n\
See Also \n\
--------- \n\
filterHelp&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10010647854eadddbfbe8306569e2018"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a10010647854eadddbfbe8306569e2018" args="(pySaveDataObject_doc,&quot;saveDataObject(filename, dataObject [, tagsAsBinary = False]) &#45;&gt; save a dataObject to harddrive in a xml&#45;based file format. \n\
\n\
This method writes a `dataObject` into the file specified by 'filename'. The data is stored in a binary format within a xml&#45;based structure. \n\
All string&#45;tags of the dataObject are encoded in order to avoid xml&#45;errors, the value of numerical tags are converted to string with \n\
15 significant digits (&gt;32bit, tagsAsBinary = False [default]) or in a binary format (tagsAsBinary = True). \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filename : {str} \n\
    Filename and Path of the destination (.ido will be added if no .*&#45;ending is available)\n\
dataObject : {DataObject} \n\
    An allocated dataObject of n&#45;Dimensions.\n\
tagsAsBinary : {bool}, optional \n\
    Optional tag to toggle if numeric&#45;tags should be saved (metaData) as binary or by default as string.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
Tagnames which contains special characters leads to XML&#45;conflics. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
loadDataObject&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pySaveDataObject_doc,&quot;saveDataObject(filename, dataObject [, tagsAsBinary = False]) -&gt; save a dataObject to harddrive in a xml-based file format. \n\
\n\
This method writes a `dataObject` into the file specified by 'filename'. The data is stored in a binary format within a xml-based structure. \n\
All string-tags of the dataObject are encoded in order to avoid xml-errors, the value of numerical tags are converted to string with \n\
15 significant digits (&gt;32bit, tagsAsBinary = False [default]) or in a binary format (tagsAsBinary = True). \n\
\n\
Parameters \n\
----------- \n\
filename : {str} \n\
    Filename and Path of the destination (.ido will be added if no .*-ending is available)\n\
dataObject : {DataObject} \n\
    An allocated dataObject of n-Dimensions.\n\
tagsAsBinary : {bool}, optional \n\
    Optional tag to toggle if numeric-tags should be saved (metaData) as binary or by default as string.\n\
\n\
Notes \n\
----- \n\
Tagnames which contains special characters leads to XML-conflics. \n\
\n\
See Also \n\
--------- \n\
loadDataObject&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a399e68ef1f095b0ef8137fc98fd7c130"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a399e68ef1f095b0ef8137fc98fd7c130" args="(pyLoadDataObject_doc,&quot;loadDataObject(filename, dataObject [, doNotAppendIDO]) &#45;&gt; load a dataObject from the harddrive. \n\
\n\
This function reads a `dataObject` from the file specified by filename. \n\
MetaData saveType (string, binary) are extracted from the file and restored within the object.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filename : {str} \n\
    Filename and Path of the destination (.ido will be added if not available)\n\
dataObject : {`dataObject`} \n\
    A pre&#45;allocated `dataObject` (empty dataObject is allowed).\n\
doNotAppendIDO : {bool}, optional \n\
    False[default]: file suffix *.ido* will not be appended to filename, True: it will be added.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
The value of string&#45;Tags must be encoded to avoid XML&#45;conflics.\n\
Tagnames which contains special characters leads to XML&#45;conflics.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyLoadDataObject_doc,&quot;loadDataObject(filename, dataObject [, doNotAppendIDO]) -&gt; load a dataObject from the harddrive. \n\
\n\
This function reads a `dataObject` from the file specified by filename. \n\
MetaData saveType (string, binary) are extracted from the file and restored within the object.\n\
\n\
Parameters \n\
----------- \n\
filename : {str} \n\
    Filename and Path of the destination (.ido will be added if not available)\n\
dataObject : {`dataObject`} \n\
    A pre-allocated `dataObject` (empty dataObject is allowed).\n\
doNotAppendIDO : {bool}, optional \n\
    False[default]: file suffix *.ido* will not be appended to filename, True: it will be added.\n\
\n\
Notes \n\
----- \n\
\n\
The value of string-Tags must be encoded to avoid XML-conflics.\n\
Tagnames which contains special characters leads to XML-conflics.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a286610c80e7aff0d51c7c3661e33baa7"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a286610c80e7aff0d51c7c3661e33baa7" args="(getDefaultScaleableUnits_doc,&quot;getDefaultScaleableUnits() &#45;&gt; Get a list with the strings of the standard scalable units. \n\
\n\
The unit strings returned as a list by this method can be transformed into each other using `scaleValueAndUnit`. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
units : {list} \n\
    List with strings containing all scaleable units \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
scaleValueAndUnit&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (getDefaultScaleableUnits_doc,&quot;getDefaultScaleableUnits() -&gt; Get a list with the strings of the standard scalable units. \n\
\n\
The unit strings returned as a list by this method can be transformed into each other using `scaleValueAndUnit`. \n\
\n\
Returns \n\
------- \n\
units : {list} \n\
    List with strings containing all scaleable units \n\
\n\
See Also \n\
-------- \n\
scaleValueAndUnit&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a678fe2fcadf85876517ef969264a7533"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a678fe2fcadf85876517ef969264a7533" args="(scaleValueAndUnit_doc,&quot;ScaleValueAndUnit(scaleableUnits, value, valueUnit) &#45;&gt; Scale a value and its unit and returns [value, 'Unit'] \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
scaleableUnits : {PyList of Strings} \n\
    A string list with all scaleable units\n\
value : {double} \n\
    The value to be scaled\n\
valueUnit : {str} \n\
    The value unit to be scaled\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
PyTuple with scaled value and scaled unit\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
Rescale a value with SI&#45;unit (e.g. 0.01 mm to 10 micrometer). Used together with itom.getDefaultScaleableUnits()&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (scaleValueAndUnit_doc,&quot;ScaleValueAndUnit(scaleableUnits, value, valueUnit) -&gt; Scale a value and its unit and returns [value, 'Unit'] \n\
\n\
Parameters \n\
----------- \n\
scaleableUnits : {PyList of Strings} \n\
    A string list with all scaleable units\n\
value : {double} \n\
    The value to be scaled\n\
valueUnit : {str} \n\
    The value unit to be scaled\n\
\n\
Returns \n\
------- \n\
PyTuple with scaled value and scaled unit\n\
\n\
Notes \n\
----- \n\
\n\
Rescale a value with SI-unit (e.g. 0.01 mm to 10 micrometer). Used together with itom.getDefaultScaleableUnits()&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4053c7a1b5683690dd484645da54a185"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a4053c7a1b5683690dd484645da54a185" args="(getAppPath_doc,&quot;getAppPath() &#45;&gt; returns absolute path of application base directory.\n\
\n\
This function returns the absolute path of application base directory.\n\
The return value is independent of the current working directory. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
path : {str}\n\
    absolute path of this application's base directory&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (getAppPath_doc,&quot;getAppPath() -&gt; returns absolute path of application base directory.\n\
\n\
This function returns the absolute path of application base directory.\n\
The return value is independent of the current working directory. \n\
\n\
Returns \n\
------- \n\
path : {str}\n\
    absolute path of this application's base directory&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec1c066407c0a2fcbd55612ac9a09cfa"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aec1c066407c0a2fcbd55612ac9a09cfa" args="(getCurrentPath_doc,&quot;getCurrentPath() &#45;&gt; returns absolute path of current working directory.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Path : {str}\n\
    absolute path of current working directory \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
setCurrentPath&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (getCurrentPath_doc,&quot;getCurrentPath() -&gt; returns absolute path of current working directory.\n\
\n\
Returns \n\
------- \n\
Path : {str}\n\
    absolute path of current working directory \n\
\n\
See Also \n\
---------- \n\
setCurrentPath&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84aeb8fe25bfc7c4f6d3734588addf09"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a84aeb8fe25bfc7c4f6d3734588addf09" args="(setCurrentPath_doc,&quot;setCurrentPath(newPath) &#45;&gt; set current working directory to given absolute newPath \n\
\n\
sets the absolute path of the current working directory to 'newPath'. The current working directory is the base \n\
directory for all subsequent relative pathes of icon&#45;files, script&#45;files, ui&#45;files, relative import statements... \n\
\n\
The current directory is always indicated in the right corner of the status bar of the main window. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
newPath : {str} \n\
    The new working path of this application\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
success : {bool} \n\
    True in case of success else False \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getCurrentPath()&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (setCurrentPath_doc,&quot;setCurrentPath(newPath) -&gt; set current working directory to given absolute newPath \n\
\n\
sets the absolute path of the current working directory to 'newPath'. The current working directory is the base \n\
directory for all subsequent relative pathes of icon-files, script-files, ui-files, relative import statements... \n\
\n\
The current directory is always indicated in the right corner of the status bar of the main window. \n\
\n\
Parameters \n\
----------- \n\
newPath : {str} \n\
    The new working path of this application\n\
\n\
Returns \n\
------- \n\
success : {bool} \n\
    True in case of success else False \n\
\n\
See Also \n\
--------- \n\
getCurrentPath()&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a250c5bf23f76711e0417152bc07062c3"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a250c5bf23f76711e0417152bc07062c3" args="(pyLoadIDC_doc,&quot;loadIDC(filename) &#45;&gt; load a pickled idc&#45;file and return the content as dictionary\n\
\n\
This methods loads the given idc&#45;file using the method `pickle.load` from the python&#45;buildin module `pickle` and returns the loaded dictionary.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filename : {String} \n\
    absolute filename or filename relative to the current directory. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
content : {dict} \n\
    dictionary with loaded content \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
pickle.load, saveIDC&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a250c5bf23f76711e0417152bc07062c3">PyDoc_STRVAR</a> (pyLoadIDC_doc,&quot;loadIDC(filename) -&gt; load a pickled idc-file and return the content as dictionary\n\
\n\
This methods loads the given idc-file using the method `pickle.load` from the python-buildin module `pickle` and returns the loaded dictionary.\n\
\n\
Parameters \n\
----------- \n\
filename : {String} \n\
    absolute filename or filename relative to the current directory. \n\
\n\
Returns \n\
-------- \n\
content : {dict} \n\
    dictionary with loaded content \n\
\n\
See Also \n\
--------- \n\
pickle.load, saveIDC&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">*static*/ PyObject* PythonItom::PyGetGlobalDict(PyObject* /*pSelf*/) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac789b5ee6663437ee17aaa3d4f5c78ca"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ac789b5ee6663437ee17aaa3d4f5c78ca" args="(pySaveIDC_doc,&quot;saveIDC(filename, dict [,overwriteIfExists = True]) &#45;&gt; saves the given dictionary as pickled idc&#45;file.\n\
\n\
This method saves the given dictionary as pickled idc&#45;file using the method dump from the builtin module pickle.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filename : {string} \n\
    absolute filename or filename relative to the current directory. \n\
dict : {dict} \n\
    dictionary which should be pickled. \n\
overwriteIfExists : {bool}, default: True \n\
    if True, an existing file will be overwritten. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
pickle.dump, loadIDC&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pySaveIDC_doc,&quot;saveIDC(filename, dict [,overwriteIfExists = True]) -&gt; saves the given dictionary as pickled idc-file.\n\
\n\
This method saves the given dictionary as pickled idc-file using the method dump from the builtin module pickle.\n\
\n\
Parameters \n\
----------- \n\
filename : {string} \n\
    absolute filename or filename relative to the current directory. \n\
dict : {dict} \n\
    dictionary which should be pickled. \n\
overwriteIfExists : {bool}, default: True \n\
    if True, an existing file will be overwritten. \n\
\n\
See Also \n\
--------- \n\
pickle.dump, loadIDC&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a509b4804efd0d494c39df1af38278cde"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a509b4804efd0d494c39df1af38278cde" args="(pyCheckIsAdmin_doc,&quot;userIsAdmin() &#45;&gt; return True if USER has administrator status.\n\
\n\
This method returns a boolean expression. If the USER defined by the user managment has administrator status it is true, in other cases it is False. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
isRequestedType : {boolean} \n\
    Boolean return value \n\
    \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyCheckIsAdmin_doc,&quot;userIsAdmin() -&gt; return True if USER has administrator status.\n\
\n\
This method returns a boolean expression. If the USER defined by the user managment has administrator status it is true, in other cases it is False. \n\
\n\
Returns \n\
------- \n\
isRequestedType : {boolean} \n\
    Boolean return value \n\
    \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73f737c19cb53e11e832e82987b247c2"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a73f737c19cb53e11e832e82987b247c2" args="(pyCheckIsDeveloper_doc,&quot;userIsDeveloper() &#45;&gt; return True if USER has developer status.\n\
\n\
This method returns a boolean expression. If the USER defined by the user managment has developer status it is true, in other cases it is False. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
isRequestedType : {boolean} \n\
    Boolean return value \n\
    \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyCheckIsDeveloper_doc,&quot;userIsDeveloper() -&gt; return True if USER has developer status.\n\
\n\
This method returns a boolean expression. If the USER defined by the user managment has developer status it is true, in other cases it is False. \n\
\n\
Returns \n\
------- \n\
isRequestedType : {boolean} \n\
    Boolean return value \n\
    \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f6ad5908ae286859c50d627fde255fe"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a1f6ad5908ae286859c50d627fde255fe" args="(pyCheckIsUser_doc,&quot;userIsUser() &#45;&gt; return True if USER has only user status.\n\
\n\
This method returns a boolean expression. If the USER defined by the user managment has only user status it is true, in other cases it is False. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
isRequestedType : {boolean} \n\
    Boolean return value \n\
    \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyCheckIsUser_doc,&quot;userIsUser() -&gt; return True if USER has only user status.\n\
\n\
This method returns a boolean expression. If the USER defined by the user managment has only user status it is true, in other cases it is False. \n\
\n\
Returns \n\
------- \n\
isRequestedType : {boolean} \n\
    Boolean return value \n\
    \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a307b491ae4792ff807d83d06679bc0d2"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a307b491ae4792ff807d83d06679bc0d2" args="(pyGetUserInfo_doc,&quot;userGetInfo() &#45;&gt; return a dictionary with the current user management information.\n\
\n\
This method returns a dictionary which contains the current user concerning system configuration. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
isUser : {dict} \n\
    dictionary with the following content is returned: \n\
    \n\
    * Name (string): The name of the current user \n\
    * Type (string): The user type as string [user, administrator, developer] \n\
    * ID (string): The user ID as a string \n\
    * File (string): The location and name of the corresponding initialization file.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyGetUserInfo_doc,&quot;userGetInfo() -&gt; return a dictionary with the current user management information.\n\
\n\
This method returns a dictionary which contains the current user concerning system configuration. \n\
\n\
Returns \n\
------- \n\
isUser : {dict} \n\
    dictionary with the following content is returned: \n\
    \n\
    * Name (string): The name of the current user \n\
    * Type (string): The user type as string [user, administrator, developer] \n\
    * ID (string): The user ID as a string \n\
    * File (string): The location and name of the corresponding initialization file.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea4233dafa4f1a42ed8c748815f83e80"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aea4233dafa4f1a42ed8c748815f83e80" args="(pyItom_FigureClose_doc,&quot;close(handle|'all') &#45;&gt; method to close any specific or all open figures (unless any figure&#45;instance still keeps track of them)\n\
\n\
This method closes and deletes any specific figure (given by handle) or all opened figures. This method always calls the static method \n\
`figure.close`.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
handle : {`dataIO`, str} \n\
    any figure handle (&gt;0) or 'all' in order to close all opened figures \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
If any instance of class 'figure' still keeps a reference to any figure, it is only closed and will be deleted after that the last referencing instance has been deleted. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
figure.close&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyItom_FigureClose_doc,&quot;close(handle|'all') -&gt; method to close any specific or all open figures (unless any figure-instance still keeps track of them)\n\
\n\
This method closes and deletes any specific figure (given by handle) or all opened figures. This method always calls the static method \n\
`figure.close`.\n\
\n\
Parameters \n\
----------- \n\
handle : {`dataIO`, str} \n\
    any figure handle (&gt;0) or 'all' in order to close all opened figures \n\
\n\
Notes \n\
------- \n\
If any instance of class 'figure' still keeps a reference to any figure, it is only closed and will be deleted after that the last referencing instance has been deleted. \n\
\n\
See Also \n\
--------- \n\
figure.close&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a233d059c94b86c423ba60a0b63c8b2aa"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a233d059c94b86c423ba60a0b63c8b2aa" args="(pyAMax_doc,&quot;amax(dataObject) &#45;&gt; returns the maximum value of the data object.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyAMax_doc,&quot;amax(dataObject) -&gt; returns the maximum value of the data object.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06ecd4663183af8b067b36d909b0cc38"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a06ecd4663183af8b067b36d909b0cc38" args="(pyPlotItemInit_doc,&quot;plotItem(figure[, subplotIdx]) &#45;&gt; instance of the plot or subplot of a figure.\n\
\n\
Use can use this constructor to access any plot or subplot (if more than one plot) of a figure. The subplotIndex \n\
row&#45;wisely addresses the subplots, beginning with 0. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
figure : {???} \n\
\n\
subplotIdx: {???}\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlotItemInit_doc,&quot;plotItem(figure[, subplotIdx]) -&gt; instance of the plot or subplot of a figure.\n\
\n\
Use can use this constructor to access any plot or subplot (if more than one plot) of a figure. The subplotIndex \n\
row-wisely addresses the subplots, beginning with 0. \n\
\n\
Parameters \n\
------------ \n\
figure : {???} \n\
\n\
subplotIdx: {???}\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8736310f3371417c066220d55e7ff9b"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ad8736310f3371417c066220d55e7ff9b" args="(pyPlotItem_pickPoints_doc,&quot;pickPoints(points [,maxNrPoints]) &#45;&gt; method to let the user pick points on a plot (only if plot supports this) \n\
\n\
This method lets the user select one or multiple points (up to maxNrPoints) at the current plot (if the plot supports this).\n\
\n\
Parameters\n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
points : {DataObject} \n\
    resulting data object containing the 2D positions of the selected points [2 x nrOfSelectedPoints].\n\
maxNrPoints: {int}, optional \n\
    let the user select up to this number of points [default: infinity]. Selection can be stopped pressing Space or Esc.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlotItem_pickPoints_doc,&quot;pickPoints(points [,maxNrPoints]) -&gt; method to let the user pick points on a plot (only if plot supports this) \n\
\n\
This method lets the user select one or multiple points (up to maxNrPoints) at the current plot (if the plot supports this).\n\
\n\
Parameters\n\
-----------\n\
points : {<a class="el" href="classito_1_1_data_object.html">DataObject</a>} \n\
    resulting data object containing the 2D positions of the selected points [2 x nrOfSelectedPoints].\n\
maxNrPoints: {int}, optional \n\
    let the user select up to this number of points [default: infinity]. Selection can be stopped pressing Space or Esc.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6fedd20ed5522be54ac020304772b76"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ae6fedd20ed5522be54ac020304772b76" args="(pyPlotItem_drawAndPickElement_doc,&quot;drawAndPickElement(elementType, elementData, [,maxNrElements]) &#45;&gt; method to let the user draw geometric elements on a plot (only if plot supports this) \n\
\n\
This method lets the user select one or multiple elements of type (up to maxNrElements) at the current plot (if the plot supports this).\n\
\n\
Parameters\n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
elementType : {int} \n\
    The element type to plot according to ito::PrimitiveContainer::tPrimitive.\n\
points : {DataObject} \n\
    resulting data object containing the 2D positions of the selected points [2 x nrOfSelectedPoints].\n\
maxNrElements: {int}, optional \n\
    let the user select up to this number of points [default: infinity]. Selection can be stopped pressing Space or Esc.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlotItem_drawAndPickElement_doc,&quot;drawAndPickElement(elementType, elementData, [,maxNrElements]) -&gt; method to let the user draw geometric elements on a plot (only if plot supports this) \n\
\n\
This method lets the user select one or multiple elements of type (up to maxNrElements) at the current plot (if the plot supports this).\n\
\n\
Parameters\n\
-----------\n\
elementType : {int} \n\
    The element type to plot according to ito::PrimitiveContainer::tPrimitive.\n\
points : {<a class="el" href="classito_1_1_data_object.html">DataObject</a>} \n\
    resulting data object containing the 2D positions of the selected points [2 x nrOfSelectedPoints].\n\
maxNrElements: {int}, optional \n\
    let the user select up to this number of points [default: infinity]. Selection can be stopped pressing Space or Esc.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8fe6cab8c18f8e06ec5b141d57ab1389">parseParams</a> (PyObject *args, int length, char **&amp;cargs, char *&amp;cargt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa872946454ba282dd90912cb19cce19b">freeParams</a> (int length, char *&amp;cargt, char **&amp;cargs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a9116ec57a2f79c788a4991e28b4617e8">getParamList</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a1abfad65cf3b738c5d98938d20b9e7fe">getParamListInfo</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib, PyObject *args)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2afcf614200505b3662be3fff4db315d"></a><!-- doxytag: member="ito::plugin_showConfiguration" ref="a2afcf614200505b3662be3fff4db315d" args="(ito::AddInBase *aib)" -->
PyObject *&#160;</td><td class="memItemRight" valign="bottom"><b>plugin_showConfiguration</b> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ac145e823451a24a203e1a201da54bbdc">plugin_showToolbox</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a870a619f4f3ef4e483e8bf469d89ce97">plugin_hideToolbox</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab89b2aaf2edbb230bb22d996d713f02d">getExecFuncsInfo</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib, PyObject *args, PyObject *kwds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a9f9082c16ab511f4da066735faff3262">getName</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *addInObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0039bf5249d18fd0d228cad6137002e"></a><!-- doxytag: member="ito::execFunc" ref="ac0039bf5249d18fd0d228cad6137002e" args="(ito::AddInBase *aib, PyObject *args, PyObject *kwds)" -->
PyObject *&#160;</td><td class="memItemRight" valign="bottom"><b>execFunc</b> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib, PyObject *args, PyObject *kwds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a2ef056717cc8a683562a568e7caa02cc">getParam</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *addInObj, PyObject *args)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1cd72f5424a487691ecd3cffe9d5834"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ad1cd72f5424a487691ecd3cffe9d5834" args="(pyPluginName_doc,&quot;name() &#45;&gt; returns the plugin name\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
name : {str} \n\
    name of the plugin, which corresponds to `getParam('name')` \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getParam&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginName_doc,&quot;name() -&gt; returns the plugin name\n\
\n\
Returns \n\
-------- \n\
name : {str} \n\
    name of the plugin, which corresponds to `getParam('name')` \n\
\n\
See Also \n\
--------- \n\
getParam&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4187251afaa835d532a9188167825730"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a4187251afaa835d532a9188167825730" args="(pyPluginGetParamList_doc,&quot;getParamList() &#45;&gt; returns a list of the names of the internal parameters of the plugin\n\
\n\
Each plugin defines a set of parameters, where each parameter has got a name and maps to any value. The value is represented by \n\
the C++ class ito::ParamBase and can have one of the following types: \n\
\n\
* String \n\
* Char \n\
* Integer \n\
* Double \n\
* CharArray \n\
* IntegerArray \n\
* DoubleArray \n\
* DataObject \n\
* PolygonMesh \n\
* PointCloud \n\
* Another plugin instance \n\
\n\
Using one of the parameter names, its current value can be obtained by `getParam('name')` and \n\
is writable by `setParam('name', newValue)` (if not read&#45;only) \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {list} \n\
    list of parameter names \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getParam, setParam, getParamListInfo&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginGetParamList_doc,&quot;getParamList() -&gt; returns a list of the names of the internal parameters of the plugin\n\
\n\
Each plugin defines a set of parameters, where each parameter has got a name and maps to any value. The value is represented by \n\
the C++ class <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> and can have one of the following types: \n\
\n\
* String \n\
* Char \n\
* Integer \n\
* Double \n\
* CharArray \n\
* IntegerArray \n\
* DoubleArray \n\
* <a class="el" href="classito_1_1_data_object.html">DataObject</a> \n\
* PolygonMesh \n\
* PointCloud \n\
* Another plugin instance \n\
\n\
Using one of the parameter names, its current value can be obtained by `getParam('name')` and \n\
is writable by `setParam('name', newValue)` (if not read-only) \n\
\n\
Returns \n\
------- \n\
out : {list} \n\
    list of parameter names \n\
\n\
See Also \n\
--------- \n\
getParam, setParam, getParamListInfo&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca3d870ea391a3ff5c06d4cbef93551e"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aca3d870ea391a3ff5c06d4cbef93551e" args="(pyPluginGetParamListInfo_doc,&quot;getParamListInfo([detailLevel]) &#45;&gt; prints detailed information about all plugin parameters. \n\
\n\
Each plugin defines a set of parameters, where each parameter has got a name and maps to any value. The value is represented by \n\
the C++ class ito::ParamBase and can have one of the following types: \n\
\n\
* String \n\
* Char \n\
* Integer \n\
* Double \n\
* CharArray \n\
* IntegerArray \n\
* DoubleArray \n\
* DataObject \n\
* PolygonMesh \n\
* PointCloud \n\
* Another plugin instance \n\
\n\
Using one of the parameter names, its current value can be obtained by `getParam('name')` and \n\
is writable by `setParam('name', newValue)` (if not read&#45;only) \n\
\n\
This method prints a detailed table with the name, current value, description string and further meta information of every plugin parameter. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
detailLevel : {dict}, optional \n\
    if `detailLevel == 1`, function returns a dictionary with parameters, else None is returned [default]\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {None, dict} \n\
    If `detailLevel == 1`, a dictionary containing all printed information is returned \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getParam, setParam, getParamList&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginGetParamListInfo_doc,&quot;getParamListInfo([detailLevel]) -&gt; prints detailed information about all plugin parameters. \n\
\n\
Each plugin defines a set of parameters, where each parameter has got a name and maps to any value. The value is represented by \n\
the C++ class <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> and can have one of the following types: \n\
\n\
* String \n\
* Char \n\
* Integer \n\
* Double \n\
* CharArray \n\
* IntegerArray \n\
* DoubleArray \n\
* <a class="el" href="classito_1_1_data_object.html">DataObject</a> \n\
* PolygonMesh \n\
* PointCloud \n\
* Another plugin instance \n\
\n\
Using one of the parameter names, its current value can be obtained by `getParam('name')` and \n\
is writable by `setParam('name', newValue)` (if not read-only) \n\
\n\
This method prints a detailed table with the name, current value, description string and further meta information of every plugin parameter. \n\
\n\
Parameters \n\
----------- \n\
detailLevel : {dict}, optional \n\
    if `detailLevel == 1`, function returns a dictionary with parameters, else None is returned [default]\n\
\n\
Returns \n\
------- \n\
out : {None, dict} \n\
    If `detailLevel == 1`, a dictionary containing all printed information is returned \n\
\n\
See Also \n\
---------- \n\
getParam, setParam, getParamList&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2fb97dcb6a4c5ccf3627adf60a2846bd"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a2fb97dcb6a4c5ccf3627adf60a2846bd" args="(pyPluginGetParam_doc,&quot;getParam(name) &#45;&gt; current value of the plugin parameter 'name'.\n\
\n\
Returns the current value of the internal plugin parameter with 'name'. The type of the returned value depends on the \n\
real type of the internal plugin, which may be: \n\
\n\
* String &#45;&gt; str \n\
* Char, Integer &#45;&gt; int \n\
* Double &#45;&gt; float \n\
* CharArray, IntegerArray &#45;&gt; tuple of int \n\
* DoubleArray &#45;&gt; tuple of float \n\
* DataObject &#45;&gt; dataObject \n\
* PolygonMesh &#45;&gt; polygonMesh \n\
* PointCloud &#45;&gt; pointCloud \n\
* Another plugin instance &#45;&gt; dataIO or actuator \n\
\n\
The name of the parameter must have the following form: \n\
\n\
* name \n\
* name:additionalTag (additionalTag can be a special feature of some plugins) \n\
* name[index] (only possible if parameter is an array type and you only want to get one single value, specified by the integer index [0,nrOfArrayItems&#45;1]) \n\
* name[index]:additionalTag \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
name : {str}\n\
    name of the requested parameter\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {variant}\n\
    value of the parameter \n\
\n\
Raises \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
ValueError \n\
    if parameter does not exist \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
setParam, getParamList, getParamListInfo&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginGetParam_doc,&quot;getParam(name) -&gt; current value of the plugin parameter 'name'.\n\
\n\
Returns the current value of the internal plugin parameter with 'name'. The type of the returned value depends on the \n\
real type of the internal plugin, which may be: \n\
\n\
* String -&gt; str \n\
* Char, Integer -&gt; int \n\
* Double -&gt; float \n\
* CharArray, IntegerArray -&gt; tuple of int \n\
* DoubleArray -&gt; tuple of float \n\
* <a class="el" href="classito_1_1_data_object.html">DataObject</a> -&gt; dataObject \n\
* PolygonMesh -&gt; polygonMesh \n\
* PointCloud -&gt; pointCloud \n\
* Another plugin instance -&gt; dataIO or actuator \n\
\n\
The name of the parameter must have the following form: \n\
\n\
* name \n\
* name:additionalTag (additionalTag can be a special feature of some plugins) \n\
* name[index] (only possible if parameter is an array type and you only want to get one single value, specified by the integer index [0,nrOfArrayItems-1]) \n\
* name[index]:additionalTag \n\
\n\
Parameters \n\
----------- \n\
name : {str}\n\
    name of the requested parameter\n\
\n\
Returns \n\
------- \n\
out : {variant}\n\
    value of the parameter \n\
\n\
Raises \n\
------- \n\
ValueError \n\
    if parameter does not exist \n\
\n\
See Also \n\
--------- \n\
setParam, getParamList, getParamListInfo&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd9c8519d717f213396f5c030897475a"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="abd9c8519d717f213396f5c030897475a" args="(pyPluginSetParam_doc,&quot;setParam(name, value) &#45;&gt; sets parameter 'name' to the given value.\n\
\n\
Sets the internal plugin parameter with 'name' to a new value. The plugin itsself can decide whether the given value is \n\
accepted as new value. This may depend on the type of the given value, but also on the allowed value range indicated by \n\
further meta information of the internal parameter. Parameters that have the read&#45;only flag set can not be reset. \n\
\n\
The name of the parameter must have the following form: \n\
\n\
* name \n\
* name:additionalTag (additionalTag can be a special feature of some plugins) \n\
* name[index] (only possible if parameter is an array type and you only want to get one single value, specified by the integer index [0,nrOfArrayItems&#45;1]) \n\
* name[index]:additionalTag \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
name : {str}\n\
    name of the parameter\n\
value : {str, int, double, ...}\n\
    value that will be set. Only the name and existance of the parameter is checked before passing the request to the plugin. \n\
    The plugin itsself is responsible for further validations (including read&#45;only attribute). \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getParam, getParamList, getParamListInfo&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginSetParam_doc,&quot;setParam(name, value) -&gt; sets parameter 'name' to the given value.\n\
\n\
Sets the internal plugin parameter with 'name' to a new value. The plugin itsself can decide whether the given value is \n\
accepted as new value. This may depend on the type of the given value, but also on the allowed value range indicated by \n\
further meta information of the internal parameter. Parameters that have the read-only flag set can not be reset. \n\
\n\
The name of the parameter must have the following form: \n\
\n\
* name \n\
* name:additionalTag (additionalTag can be a special feature of some plugins) \n\
* name[index] (only possible if parameter is an array type and you only want to get one single value, specified by the integer index [0,nrOfArrayItems-1]) \n\
* name[index]:additionalTag \n\
\n\
Parameters \n\
----------- \n\
name : {str}\n\
    name of the parameter\n\
value : {str, int, double, ...}\n\
    value that will be set. Only the name and existance of the parameter is checked before passing the request to the plugin. \n\
    The plugin itsself is responsible for further validations (including read-only attribute). \n\
\n\
See Also \n\
--------- \n\
getParam, getParamList, getParamListInfo&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53153c070f6a2e309c8a1e9bb372e388"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a53153c070f6a2e309c8a1e9bb372e388" args="(pyPluginShowToolbox_doc,&quot;showToolbox() &#45;&gt; open toolbox of the plugin \n\
\n\
Raises \n\
&#45;&#45;&#45;&#45;&#45;&#45; \n\
RuntimeError \n\
    if plugin does not provide a toolbox \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
hideToolbox&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginShowToolbox_doc,&quot;showToolbox() -&gt; open toolbox of the plugin \n\
\n\
Raises \n\
------ \n\
RuntimeError \n\
    if plugin does not provide a toolbox \n\
\n\
See Also \n\
--------- \n\
hideToolbox&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7933f934fa2ceb1fddac62035516f5d9"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a7933f934fa2ceb1fddac62035516f5d9" args="(pyPluginHideToolbox_doc,&quot;hideToolbox() &#45;&gt; hides toolbox of the plugin \n\
\n\
Raises \n\
&#45;&#45;&#45;&#45;&#45;&#45; \n\
RuntimeError \n\
    if plugin does not provide a toolbox \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
showToolbox&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginHideToolbox_doc,&quot;hideToolbox() -&gt; hides toolbox of the plugin \n\
\n\
Raises \n\
------ \n\
RuntimeError \n\
    if plugin does not provide a toolbox \n\
\n\
See Also \n\
--------- \n\
showToolbox&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fd557793c3ec7888aa06800e7b0da92"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a5fd557793c3ec7888aa06800e7b0da92" args="(pyPluginShowConfiguration_doc,&quot;showConfiguration() &#45;&gt; show configuration dialog of the plugin\n\
\n\
Raises \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
RuntimeError \n\
    if plugin does not provide a configuration dialog&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginShowConfiguration_doc,&quot;showConfiguration() -&gt; show configuration dialog of the plugin\n\
\n\
Raises \n\
------- \n\
RuntimeError \n\
    if plugin does not provide a configuration dialog&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72f62dea52db56b36cd46f2f25522604"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a72f62dea52db56b36cd46f2f25522604" args="(pyPlugInGetExecFuncsInfo_doc,&quot;getExecFuncsInfo([funcName [, detailLevel]]) &#45;&gt; plots a list of available execFuncs or a detailed description of the specified execFunc. \n\
\n\
Every plugin can define further functions, that are called by plugin.exec('funcName' [,param1, param2...]). This can for  \n\
instance be used in order to call specific calibration routines of cameras or actuators. This method allows printing \n\
information about available functions of this type. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
funcName : {str}, optional \n\
    is the fullname or a part of any execFunc&#45;name which should be displayed. \n\
    If funcName is none or no execFunc matches funcName casesensitiv a list with all suitable execFuncs is given. \n\
detailLevel : {dict}, optional \n\
    if `detailLevel == 1`, function returns a dictionary with parameters [default: 0]. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {None or dict}\n\
    depending on the value of *detailLevel*. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
exec&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlugInGetExecFuncsInfo_doc,&quot;getExecFuncsInfo([funcName [, detailLevel]]) -&gt; plots a list of available execFuncs or a detailed description of the specified execFunc. \n\
\n\
Every plugin can define further functions, that are called by plugin.exec('funcName' [,param1, param2...]). This can for  \n\
instance be used in order to call specific calibration routines of cameras or actuators. This method allows printing \n\
information about available functions of this type. \n\
\n\
Parameters \n\
----------- \n\
funcName : {str}, optional \n\
    is the fullname or a part of any execFunc-name which should be displayed. \n\
    If funcName is none or no execFunc matches funcName casesensitiv a list with all suitable execFuncs is given. \n\
detailLevel : {dict}, optional \n\
    if `detailLevel == 1`, function returns a dictionary with parameters [default: 0]. \n\
\n\
Returns \n\
------- \n\
out : {None or dict}\n\
    depending on the value of *detailLevel*. \n\
\n\
See Also \n\
-------- \n\
exec&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8938ba6f8d55d33f2ced0732107710df"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a8938ba6f8d55d33f2ced0732107710df" args="(PyPlugin_execFunc_doc,&quot;exec(funcName [, param1, ...]) &#45;&gt; invoke the function 'funcName' registered as execFunc within the plugin.\n\
\n\
Every plugin can define further functions that can for instance be used in order to call specific calibration routines \n\
of cameras or actuators. This general method is used to call one of these specific functions registered under `funcName`. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
funcName : {str} \n\
    The name of the function\n\
param1 : {variant}, optional \n\
    Further parameters depending on the requirements of the specific function.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {variant, list of variants}.\n\
    The return values depend on the function itself.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
execFuncsInfo&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyPlugin_execFunc_doc,&quot;exec(funcName [, param1, ...]) -&gt; invoke the function 'funcName' registered as execFunc within the plugin.\n\
\n\
Every plugin can define further functions that can for instance be used in order to call specific calibration routines \n\
of cameras or actuators. This general method is used to call one of these specific functions registered under `funcName`. \n\
\n\
Parameters \n\
----------- \n\
funcName : {str} \n\
    The name of the function\n\
param1 : {variant}, optional \n\
    Further parameters depending on the requirements of the specific function.\n\
\n\
Returns \n\
------- \n\
out : {variant, list of variants}.\n\
    The return values depend on the function itself.\n\
\n\
See Also \n\
-------- \n\
execFuncsInfo&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8d52a7127228d59e411619e569fbee41">setParam</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *addInObj, PyObject *args)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a05c33735a26bb8f9d8aab303006f1a"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a0a05c33735a26bb8f9d8aab303006f1a" args="(pyActuatorInit_doc,&quot;actuator(name[, mandparams, optparams]) &#45;&gt; creates new instance of actuator plugin 'name' \n\
\n\
This is the constructor for an `actuator` plugin. It initializes an new instance of the plugin specified by 'name'. \n\
The initialisation parameters are parsed and unnamed parameters are used in their incoming order to fill first \n\
mandatory parameters and afterwards optional parameters. Parameters may be passed with name as well but after \n\
the first named parameter no more unnamed parameters are allowed.\n\
\n\
See pluginHelp(name) for detail information about the specific initialisation parameters.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
name : {str} \n\
    is the fullname (case sensitive) of an 'actuator'&#45;plugin as specified in the plugin&#45;window. \n\
mandparams : {variant(s)} \n\
    arguments corresponding the mandatory initialization parameters. The number of arguments and their order must fit the the required mandatory parameters \n\
optparams : {variant(s)}, optional \n\
    argument corresponding to the optional initialization parameters. If unnamed arguments are used, their order must correspond to the order of the optional parameters, keyword&#45;based parameters are allowed as well. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
inst : {actuator} \n\
    new instance of the actuator&#45;plugin&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorInit_doc,&quot;actuator(name[, mandparams, optparams]) -&gt; creates new instance of actuator plugin 'name' \n\
\n\
This is the constructor for an `actuator` plugin. It initializes an new instance of the plugin specified by 'name'. \n\
The initialisation parameters are parsed and unnamed parameters are used in their incoming order to fill first \n\
mandatory parameters and afterwards optional parameters. Parameters may be passed with name as well but after \n\
the first named parameter no more unnamed parameters are allowed.\n\
\n\
See pluginHelp(name) for detail information about the specific initialisation parameters.\n\
\n\
Parameters \n\
----------- \n\
name : {str} \n\
    is the fullname (case sensitive) of an 'actuator'-plugin as specified in the plugin-window. \n\
mandparams : {variant(s)} \n\
    arguments corresponding the mandatory initialization parameters. The number of arguments and their order must fit the the required mandatory parameters \n\
optparams : {variant(s)}, optional \n\
    argument corresponding to the optional initialization parameters. If unnamed arguments are used, their order must correspond to the order of the optional parameters, keyword-based parameters are allowed as well. \n\
\n\
Returns \n\
-------- \n\
inst : {actuator} \n\
    new instance of the actuator-plugin&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fe8de4b3baef4451b8be10aae3210e6"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a8fe8de4b3baef4451b8be10aae3210e6" args="(pyActuatorCalib_doc,&quot;calib(axis[, axis1, ...]) &#45;&gt; starts calibration or homing of given axes (0&#45;based).\n\
\n\
Most actuators have the possibility to calibrate or home certain axes. Use this command to start the calibration. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
axis : {int}\n\
    index of the first axis to calibrate (e.g. 0 for first axis) \n\
axis1 : {int}\n\
    add the indices of further axes as optional arguments if they should be calibrated as well\n\
\n\
Raises \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
NotImplemented \n\
    if calibration not available&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorCalib_doc,&quot;calib(axis[, axis1, ...]) -&gt; starts calibration or homing of given axes (0-based).\n\
\n\
Most actuators have the possibility to calibrate or home certain axes. Use this command to start the calibration. \n\
\n\
Parameters \n\
----------- \n\
axis : {int}\n\
    index of the first axis to calibrate (e.g. 0 for first axis) \n\
axis1 : {int}\n\
    add the indices of further axes as optional arguments if they should be calibrated as well\n\
\n\
Raises \n\
---------- \n\
NotImplemented \n\
    if calibration not available&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ba508255c6487e00f46445c1ef9c1fe"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a1ba508255c6487e00f46445c1ef9c1fe" args="(pyActuatorSetOrigin_doc,&quot;setOrigin(axis[, axis1, ...]) &#45;&gt; defines the actual position of the given axes to value 0. \n\
\n\
The current positions of all indicated axes (axis, axis1,...) are considered to be 0 such that following positioning commands \n\
are relative with respect to the current position. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
axis : {int}\n\
    index of the first axis (e.g. 0 for first axis) \n\
axis1 : {int}\n\
    add the indices of further axes as optional arguments\n\
\n\
Raises \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
NotImplemented \n\
    if actuator does not support this feature&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorSetOrigin_doc,&quot;setOrigin(axis[, axis1, ...]) -&gt; defines the actual position of the given axes to value 0. \n\
\n\
The current positions of all indicated axes (axis, axis1,...) are considered to be 0 such that following positioning commands \n\
are relative with respect to the current position. \n\
\n\
Parameters \n\
----------- \n\
axis : {int}\n\
    index of the first axis (e.g. 0 for first axis) \n\
axis1 : {int}\n\
    add the indices of further axes as optional arguments\n\
\n\
Raises \n\
---------- \n\
NotImplemented \n\
    if actuator does not support this feature&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4cc9bc28832cbad40a8ee733e364dbd8"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a4cc9bc28832cbad40a8ee733e364dbd8" args="(pyActuatorGetStatus_doc,&quot;getStatus() &#45;&gt; returns a list of status values for each axis\n\
\n\
Each axis of an actuator plugin has got a status value that is used for informing about the current status of the axis. \n\
\n\
The status value is an or&#45;combination of the following possible values: \n\
\n\
Moving flags: \n\
\n\
* actuatorUnknown     = 0x0001 : unknown current moving status \n\
* actuatorInterrupted = 0x0002 : movement has been interrupted by the user or another error during the movement occurred \n\
* actuatorMoving      = 0x0004 : axis is currently moving \n\
* actuatorAtTarget    = 0x0008 : axis reached the target position \n\
* actuatorTimeout     = 0x0010 : timout during movement. Unknown status of the movement \n\
\n\
Switches flags: \n\
\n\
* actuatorEndSwitch      = 0x0100 : axis reached any end switch (e.g. if only one end switch is available) \n\
* actuatorLeftEndSwitch  = 0x0200 : axis reached the left end switch \n\
* actuatorRightEndSwitch = 0x0400 : axis reached the right end switch \n\
* actuatorRefSwitch      = 0x0800 : axis reached any reference switch (e.g. for calibration...) \n\
* actuatorLeftRefSwitch  = 0x1000 : axis reached left reference switch \n\
* actuatorRightRefSwitch = 0x2000 : axis reached right reference switch \n\
\n\
Status flags: \n\
\n\
* actuatorAvailable = 0x4000 : the axis is available \n\
* actuatorEnabled   = 0x8000 : the axis is currently enabled and can be moved \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
status : {list of integers} \n\
    list of integers (size corresponds to number of axes) with the current status of each axis&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorGetStatus_doc,&quot;getStatus() -&gt; returns a list of status values for each axis\n\
\n\
Each axis of an actuator plugin has got a status value that is used for informing about the current status of the axis. \n\
\n\
The status value is an or-combination of the following possible values: \n\
\n\
Moving flags: \n\
\n\
* actuatorUnknown     = 0x0001 : unknown current moving status \n\
* actuatorInterrupted = 0x0002 : movement has been interrupted by the user or another error during the movement occurred \n\
* actuatorMoving      = 0x0004 : axis is currently moving \n\
* actuatorAtTarget    = 0x0008 : axis reached the target position \n\
* actuatorTimeout     = 0x0010 : timout during movement. Unknown status of the movement \n\
\n\
Switches flags: \n\
\n\
* actuatorEndSwitch      = 0x0100 : axis reached any end switch (e.g. if only one end switch is available) \n\
* actuatorLeftEndSwitch  = 0x0200 : axis reached the left end switch \n\
* actuatorRightEndSwitch = 0x0400 : axis reached the right end switch \n\
* actuatorRefSwitch      = 0x0800 : axis reached any reference switch (e.g. for calibration...) \n\
* actuatorLeftRefSwitch  = 0x1000 : axis reached left reference switch \n\
* actuatorRightRefSwitch = 0x2000 : axis reached right reference switch \n\
\n\
Status flags: \n\
\n\
* actuatorAvailable = 0x4000 : the axis is available \n\
* actuatorEnabled   = 0x8000 : the axis is currently enabled and can be moved \n\
\n\
Returns \n\
------- \n\
status : {list of integers} \n\
    list of integers (size corresponds to number of axes) with the current status of each axis&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8395eb558447d339dd7308fc2d8f120a"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a8395eb558447d339dd7308fc2d8f120a" args="(pyActuatorGetPos_doc,&quot;getPos(axis[, axis1, ...]) &#45;&gt; returns the actual positions of the given axes (in mm or degree).\n\
\n\
This method requests the current position(s) of the given axes and returns it. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
axis : {int}\n\
    index of the first axis (e.g. 0 for first axis) \n\
axis1 : {int}\n\
    add the indices of further axes as optional arguments\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
positions : {float or tuple of float} \n\
    Current position as float value if only one axis is given or tuple of floats for multiple axes. The unit is mm or degree. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
setPosRel, setPosAbs&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorGetPos_doc,&quot;getPos(axis[, axis1, ...]) -&gt; returns the actual positions of the given axes (in mm or degree).\n\
\n\
This method requests the current position(s) of the given axes and returns it. \n\
\n\
Parameters \n\
----------- \n\
axis : {int}\n\
    index of the first axis (e.g. 0 for first axis) \n\
axis1 : {int}\n\
    add the indices of further axes as optional arguments\n\
\n\
Returns \n\
------- \n\
positions : {float or tuple of float} \n\
    Current position as float value if only one axis is given or tuple of floats for multiple axes. The unit is mm or degree. \n\
\n\
See Also \n\
--------- \n\
setPosRel, setPosAbs&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3987a528009a40e5fb285c48997fb0ae"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a3987a528009a40e5fb285c48997fb0ae" args="(PyActuatorPlugin_getType_doc,&quot;getType() &#45;&gt; returns actuator type&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyActuatorPlugin_getType_doc,&quot;getType() -&gt; returns actuator type&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b2abbb8348f02d92a39c2f751b818d7"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a2b2abbb8348f02d92a39c2f751b818d7" args="(pyActuatorSetInterrupt_doc,&quot;setInterrupt() &#45;&gt; interrupts a movement of an actuator \n\
\n\
Sets the interrupt flag of an actuator. The actuator interrupts the movement of all running axes \
as soon as this flag is checked again.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorSetInterrupt_doc,&quot;setInterrupt() -&gt; interrupts a movement of an actuator \n\
\n\
Sets the interrupt flag of an actuator. The actuator interrupts the movement of all running axes \
as soon as this flag is checked again.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#afb4b7505de2474537f0ff7a5e678cf94">parsePosParams</a> (PyObject *args, char **&amp;cargs, char *&amp;cargt, QVector&lt; int &gt; &amp;axisVec, QVector&lt; double &gt; &amp;posVec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae83ee11dcbe0a4c61d358e226a8ca4f6"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ae83ee11dcbe0a4c61d358e226a8ca4f6" args="(pyActuatorSetPosAbs_doc,&quot;setPosAbs(axis0, pos0 [, axis1, pos1, ...]) &#45;&gt; moves given axes to given absolute values (in mm or degree).\n\
\n\
All arguments are a pair of axis index and the new target position of this axis. This method starts the absolute positioning of all given axes. \n\
If the 'async' parameter of the plugin is 0 (usually default), a synchronous positioning is started, hence, this method returns after that all \n\
axes reached their target position or a timeout occurred. Else this method immediately returns and the actuator goes on moving. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
axisM : {int} \n\
    index of the axis to position \n\
posM : {float} \n\
    absolute target position of the `axisM` (in mm or degree) \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getPos, setPosRel&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorSetPosAbs_doc,&quot;setPosAbs(axis0, pos0 [, axis1, pos1, ...]) -&gt; moves given axes to given absolute values (in mm or degree).\n\
\n\
All arguments are a pair of axis index and the new target position of this axis. This method starts the absolute positioning of all given axes. \n\
If the 'async' parameter of the plugin is 0 (usually default), a synchronous positioning is started, hence, this method returns after that all \n\
axes reached their target position or a timeout occurred. Else this method immediately returns and the actuator goes on moving. \n\
\n\
Parameters \n\
----------- \n\
axisM : {int} \n\
    index of the axis to position \n\
posM : {float} \n\
    absolute target position of the `axisM` (in mm or degree) \n\
\n\
See Also \n\
--------- \n\
getPos, setPosRel&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6befe5b18c2bcb05eaa8de07ef9ab044"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a6befe5b18c2bcb05eaa8de07ef9ab044" args="(pyActuatorSetPosRel_doc,&quot;setPosRel(axis0, pos0[, axis1, pos1, ...]) &#45;&gt; relatively moves given axes by the given distances [in mm or degree].\n\
\n\
All arguments are a pair of axis index and the relative moving&#45;distance of this axis. This method starts the relative positioning of all given axes. \n\
If the 'async' parameter of the plugin is 0 (usually default), a synchronous positioning is started, hence, this method returns after that all \n\
axes reached their target position or a timeout occurred. Else this method immediately returns and the actuator goes on moving. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
axisM : {int} \n\
    index of the axis to position \n\
posM : {float} \n\
    relative target position of the `axisM` (in mm or degree) \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getPos, setPosAbs&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorSetPosRel_doc,&quot;setPosRel(axis0, pos0[, axis1, pos1, ...]) -&gt; relatively moves given axes by the given distances [in mm or degree].\n\
\n\
All arguments are a pair of axis index and the relative moving-distance of this axis. This method starts the relative positioning of all given axes. \n\
If the 'async' parameter of the plugin is 0 (usually default), a synchronous positioning is started, hence, this method returns after that all \n\
axes reached their target position or a timeout occurred. Else this method immediately returns and the actuator goes on moving. \n\
\n\
Parameters \n\
----------- \n\
axisM : {int} \n\
    index of the axis to position \n\
posM : {float} \n\
    relative target position of the `axisM` (in mm or degree) \n\
\n\
See Also \n\
--------- \n\
getPos, setPosAbs&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08c00b7a20b0b6ddc1f769e0d52b9515"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a08c00b7a20b0b6ddc1f769e0d52b9515" args="(pyDataIOInit_doc,&quot;dataIO(name[, mandparams, optparams]) &#45;&gt; creates new instance of dataIO plugin 'name' \n\
\n\
This is the constructor for a `dataIO` plugin. It initializes an new instance of the plugin specified by 'name'. \n\
The initialisation parameters are parsed and unnamed parameters are used in their incoming order to fill first \n\
mandatory parameters and afterwards optional parameters. Parameters may be passed with name as well but after \n\
the first named parameter no more unnamed parameters are allowed.\n\
\n\
See pluginHelp(name) for detail information about the specific initialisation parameters.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
name : {str} \n\
    is the fullname (case sensitive) of an 'actuator'&#45;plugin as specified in the plugin&#45;window. \n\
mandparams : {variant(s)} \n\
    arguments corresponding the mandatory initialization parameters. The number of arguments and their order must fit the the required mandatory parameters \n\
optparams : {variant(s)}, optional \n\
    argument corresponding to the optional initialization parameters. If unnamed arguments are used, their order must correspond to the order of the optional parameters, keyword&#45;based parameters are allowed as well. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
inst : {dataIO} \n\
    new instance of the dataIO&#45;plugin&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataIOInit_doc,&quot;dataIO(name[, mandparams, optparams]) -&gt; creates new instance of dataIO plugin 'name' \n\
\n\
This is the constructor for a `dataIO` plugin. It initializes an new instance of the plugin specified by 'name'. \n\
The initialisation parameters are parsed and unnamed parameters are used in their incoming order to fill first \n\
mandatory parameters and afterwards optional parameters. Parameters may be passed with name as well but after \n\
the first named parameter no more unnamed parameters are allowed.\n\
\n\
See pluginHelp(name) for detail information about the specific initialisation parameters.\n\
\n\
Parameters \n\
----------- \n\
name : {str} \n\
    is the fullname (case sensitive) of an 'actuator'-plugin as specified in the plugin-window. \n\
mandparams : {variant(s)} \n\
    arguments corresponding the mandatory initialization parameters. The number of arguments and their order must fit the the required mandatory parameters \n\
optparams : {variant(s)}, optional \n\
    argument corresponding to the optional initialization parameters. If unnamed arguments are used, their order must correspond to the order of the optional parameters, keyword-based parameters are allowed as well. \n\
\n\
Returns \n\
-------- \n\
inst : {dataIO} \n\
    new instance of the dataIO-plugin&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf5cec984031163727e96c83e1189bcd"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="abf5cec984031163727e96c83e1189bcd" args="(PyDataIOPlugin_startDevice_doc,&quot;startDevice([count=1]) &#45;&gt; starts the given dataIO&#45;plugin. \n\
\n\
This command starts the dataIO plugin such that it is ready for data acquisition. Call this method before you start \n\
using commands like acquire, `getVal` or `copyVal`. If the device already is started, an internal start&#45;counter is incremented \n\
by the parameter 'count'. The corresponding `stopDevice` method then decrements this counter and finally stops the device once \n\
the counter drops to zero again. \n\
\n\
The counter is necessary, since every connected live image needs to start the device without knownledge about any \n\
previous start. No acquisition is possible, if the device has not been started, hence the counter is 0. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
count : {int}, optional \n\
    Number of increments to the internal start&#45;counter [default:1] \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
stopDevice()&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_startDevice_doc,&quot;startDevice([count=1]) -&gt; starts the given dataIO-plugin. \n\
\n\
This command starts the dataIO plugin such that it is ready for data acquisition. Call this method before you start \n\
using commands like acquire, `getVal` or `copyVal`. If the device already is started, an internal start-counter is incremented \n\
by the parameter 'count'. The corresponding `stopDevice` method then decrements this counter and finally stops the device once \n\
the counter drops to zero again. \n\
\n\
The counter is necessary, since every connected live image needs to start the device without knownledge about any \n\
previous start. No acquisition is possible, if the device has not been started, hence the counter is 0. \n\
\n\
Parameters \n\
----------- \n\
count : {int}, optional \n\
    Number of increments to the internal start-counter [default:1] \n\
\n\
See Also \n\
--------- \n\
stopDevice()&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af36dd56a0ffb56fa2896e3ffae6ab101"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="af36dd56a0ffb56fa2896e3ffae6ab101" args="(PyDataIOPlugin_stopDevice_doc,&quot;stopDevice([count=1]) &#45;&gt; stops the given dataIO&#45;plugin. \n\
\n\
If this method is called as many times as the corresponding `startDevice` (or if the counts are equal), the \n\
dataIO device is stopped (not deleted) and it is not possible to acquire further data. \n\
\n\
Once a live image is connected to a camera, `startDevice` is automatically called at start of the live acquisition \n\
and `stopDevice` at shutdown. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
count : {int}, optional\n\
    default = 1\n\
    if count &gt; 1, `stopDevice` is executed 'count' times, in order to decrement the grabber internal start counter. \n\
    You can also use &#45;1 as count argument, then `stopDevice` is repeated until the internal start counter is 0. The number of effective counts is then returned \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
counts : {None or int} \n\
    If `count == &#45;1` the number of required counts to finally stop the device is returned. Else: None \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
startDevice()&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_stopDevice_doc,&quot;stopDevice([count=1]) -&gt; stops the given dataIO-plugin. \n\
\n\
If this method is called as many times as the corresponding `startDevice` (or if the counts are equal), the \n\
dataIO device is stopped (not deleted) and it is not possible to acquire further data. \n\
\n\
Once a live image is connected to a camera, `startDevice` is automatically called at start of the live acquisition \n\
and `stopDevice` at shutdown. \n\
\n\
Parameters \n\
----------- \n\
count : {int}, optional\n\
    default = 1\n\
    if count &gt; 1, `stopDevice` is executed 'count' times, in order to decrement the grabber internal start counter. \n\
    You can also use -1 as count argument, then `stopDevice` is repeated until the internal start counter is 0. The number of effective counts is then returned \n\
\n\
Returns \n\
-------- \n\
counts : {None or int} \n\
    If `count == -1` the number of required counts to finally stop the device is returned. Else: None \n\
\n\
See Also \n\
--------- \n\
startDevice()&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73536a5aebb46c7e05516e0847bee1c1"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a73536a5aebb46c7e05516e0847bee1c1" args="(PyDataIOPlugin_acquire_doc,&quot;acquire(trigger=dataIO.TRIGGER_SOFTWARE) &#45;&gt; triggers a new the camera acquisition \n\
\n\
This method triggers a new data acquisition. This method immediately returns even if the acquisition is not finished yet. \n\
Use `getVal` or `copyVal` to get the acquired data. Both methods block until the data is available. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
trigger : {int}, optional\n\
    Type of the trigger: \n\
    \n\
    * `dataIO.TRIGGER_SOFTWARE = 0` : a software trigger is started, hence, the acquisition is immediately started when calling this method\n\
    * others : depending on your camera, this parameter can be used to set other triggers, like hardware trigger with raising or falling edges...&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_acquire_doc,&quot;acquire(trigger=dataIO.TRIGGER_SOFTWARE) -&gt; triggers a new the camera acquisition \n\
\n\
This method triggers a new data acquisition. This method immediately returns even if the acquisition is not finished yet. \n\
Use `getVal` or `copyVal` to get the acquired data. Both methods block until the data is available. \n\
\n\
Parameters \n\
----------- \n\
trigger : {int}, optional\n\
    Type of the trigger: \n\
    \n\
    * `dataIO.TRIGGER_SOFTWARE = 0` : a software trigger is started, hence, the acquisition is immediately started when calling this method\n\
    * others : depending on your camera, this parameter can be used to set other triggers, like hardware trigger with raising or falling edges...&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a61c25efb136a98be34f6e25dab92fc"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a5a61c25efb136a98be34f6e25dab92fc" args="(PyDataIOPlugin_getVal_doc,&quot;getVal(buffer=`dataObject`|`bytearray`|`bytes` [,length=maxlength]) &#45;&gt; returns shallow copy of internal camera image if `dataObject`&#45;buffer is provided. Else values from plugin are copied to given byte or byte&#45;array buffer. \n\
\n\
Returns a reference (shallow copy) of the recently acquired image (located in the internal memory if the plugin) if the plugin is a grabber or camera and the buffer is a `dataObject`. \n\
Please consider that the values of the `dataObject` might change if a new image is acquired since it is only a reference. Therefore consider copying the `dataObject` or directly use \n\
`copyVal`. \n\
\n\
If no acquisition has been triggered, this method raises a RuntimeError. If the acquisition is not finished yet, this method \n\
blocks and waits until the end of the acquisition. \n\
\n\
If the plugin is another type than a grabber or camera (e.g. serialIO), this method requires any buffer&#45;object that is preallocated with a reasonable size. Then, the currently available \n\
data is copied into this buffer object and the size of the copied data is returned. If the buffer is too small, only the data that fits into the buffer is copied. Another call to \n\
`getVal` will copy the rest. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
buffer : {`dataObject`, `bytearray`, `bytes` or `str`} \n\
    this parameter depends on the type of dataIO&#45;instance: \n\
    \n\
    * cameras, grabber: the buffer must be a `dataObject` (no length parameter): A reference (shallow copy) to the internal memory of the camera plugin is set to the given data object. \
    Therefore its content may change if a new image is being acquired by the camera. Consider taking a deep copy if the image (`dataObject.copy`) or use the method `copyVal`. \n\
    * other IO&#45;devices (AD&#45;converters): The buffer must be an object of type `dataObject`, bytearray, bytes or unicode string. The length parameter is then set to the size of the buffers. The effective \
    size of the used memory in buffer is returned. \n\
length : {int}, optional \n\
    size of the given buffer. This value is usually automatically determined and must not be given. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {None or int} \n\
    None or size of used buffer if buffer is no `dataObject` \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
copyVal()&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_getVal_doc,&quot;getVal(buffer=`dataObject`|`bytearray`|`bytes` [,length=maxlength]) -&gt; returns shallow copy of internal camera image if `dataObject`-buffer is provided. Else values from plugin are copied to given byte or byte-array buffer. \n\
\n\
Returns a reference (shallow copy) of the recently acquired image (located in the internal memory if the plugin) if the plugin is a grabber or camera and the buffer is a `dataObject`. \n\
Please consider that the values of the `dataObject` might change if a new image is acquired since it is only a reference. Therefore consider copying the `dataObject` or directly use \n\
`copyVal`. \n\
\n\
If no acquisition has been triggered, this method raises a RuntimeError. If the acquisition is not finished yet, this method \n\
blocks and waits until the end of the acquisition. \n\
\n\
If the plugin is another type than a grabber or camera (e.g. serialIO), this method requires any buffer-object that is preallocated with a reasonable size. Then, the currently available \n\
data is copied into this buffer object and the size of the copied data is returned. If the buffer is too small, only the data that fits into the buffer is copied. Another call to \n\
`getVal` will copy the rest. \n\
\n\
Parameters \n\
----------- \n\
buffer : {`dataObject`, `bytearray`, `bytes` or `str`} \n\
    this parameter depends on the type of dataIO-instance: \n\
    \n\
    * cameras, grabber: the buffer must be a `dataObject` (no length parameter): A reference (shallow copy) to the internal memory of the camera plugin is set to the given data object. \
    Therefore its content may change if a new image is being acquired by the camera. Consider taking a deep copy if the image (`dataObject.copy`) or use the method `copyVal`. \n\
    * other IO-devices (AD-converters): The buffer must be an object of type `dataObject`, bytearray, bytes or unicode string. The length parameter is then set to the size of the buffers. The effective \
    size of the used memory in buffer is returned. \n\
length : {int}, optional \n\
    size of the given buffer. This value is usually automatically determined and must not be given. \n\
\n\
Returns \n\
-------- \n\
out : {None or int} \n\
    None or size of used buffer if buffer is no `dataObject` \n\
\n\
See Also \n\
--------- \n\
copyVal()&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cfbf185776c7a0bc5cf8ce153994389"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a6cfbf185776c7a0bc5cf8ce153994389" args="(PyDataIOPlugin_copyVal_doc,&quot;copyVal(dataObject) &#45;&gt; gets deep copy of data of this plugin, stored in the given data object. \n\
\n\
Returns a deep copy of the recently acquired data (for grabber and ADDA only) of the camera or AD&#45;converter device. \n\
The deep copy sometimes requires one copy operation more than the similar command `getVal`. However, `getVal` only returns \n\
a reference to the plugin internal data structure whose values might be changed if another data acquisition is started. \n\
\n\
If no acquisition has been triggered, this method raises a RuntimeError. If the acquisition is not finished yet, this method \n\
blocks and waits until the end of the acquisition. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
dataObject : {`dataObject`}\n\
    `dataObject` where the plugin data is copied to. Either provide an empty `dataObject` or a `dataObject` whose size (or region of interest) \n\
    exactly has the same size than the available data of the plugin. Therefore you can allocate a 3D data object, set a region of interest \n\
    to one plane such that the data from the plugin is copied into this plane. \n\
\n\
Raises \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
RuntimeError \n\
    if the dataIO plugin is anything else than ADDA or grabber\n\
    or if no acquisition has been triggered \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getVal()&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_copyVal_doc,&quot;copyVal(dataObject) -&gt; gets deep copy of data of this plugin, stored in the given data object. \n\
\n\
Returns a deep copy of the recently acquired data (for grabber and ADDA only) of the camera or AD-converter device. \n\
The deep copy sometimes requires one copy operation more than the similar command `getVal`. However, `getVal` only returns \n\
a reference to the plugin internal data structure whose values might be changed if another data acquisition is started. \n\
\n\
If no acquisition has been triggered, this method raises a RuntimeError. If the acquisition is not finished yet, this method \n\
blocks and waits until the end of the acquisition. \n\
\n\
Parameters \n\
----------- \n\
dataObject : {`dataObject`}\n\
    `dataObject` where the plugin data is copied to. Either provide an empty `dataObject` or a `dataObject` whose size (or region of interest) \n\
    exactly has the same size than the available data of the plugin. Therefore you can allocate a 3D data object, set a region of interest \n\
    to one plane such that the data from the plugin is copied into this plane. \n\
\n\
Raises \n\
------- \n\
RuntimeError \n\
    if the dataIO plugin is anything else than ADDA or grabber\n\
    or if no acquisition has been triggered \n\
\n\
See Also \n\
--------- \n\
getVal()&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabcaf66854a63583dbabca56637ed003"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aabcaf66854a63583dbabca56637ed003" args="(PyDataIOPlugin_setVal_doc,&quot;setVal(dataObjectOrBuffer [, length=1]) &#45;&gt; transfer given `dataObject` to ADDA plugin or further buffer to other dataIO plugin.\n\
\n\
If the dataIO plugin has the subtype ADDA, this method is used to send data to one or more analog outputs of the device. \n\
In this case a `dataObject` must be given as first argument and the second argument `length` must be 1. \n\
\n\
For other dataIO plugins, the first argument must be any buffer object, like `bytearray`, `bytes` or `unicode string`. The length is then extracted \n\
from this value. However it is also possible to define a user&#45;defined size using the 'length' argument. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
dataObjectOrBuffer : {`dataObject`, `bytearray`, `bytes`, `str`}\n\
    value to send to plugin. For an ADDA plugin, a `dataObject` is required whose content is sent to the analogous outputs of the device. For other dataIO \n\
    plugins buffer values like `bytearray`, `bytes` or `unicode string` are required. \n\
length : {int}, optional \n\
    usually this value is not required, since the length of the buffer is automatically extracted from the given objects and 1 for a `dataObject`&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_setVal_doc,&quot;setVal(dataObjectOrBuffer [, length=1]) -&gt; transfer given `dataObject` to ADDA plugin or further buffer to other dataIO plugin.\n\
\n\
If the dataIO plugin has the subtype ADDA, this method is used to send data to one or more analog outputs of the device. \n\
In this case a `dataObject` must be given as first argument and the second argument `length` must be 1. \n\
\n\
For other dataIO plugins, the first argument must be any buffer object, like `bytearray`, `bytes` or `unicode string`. The length is then extracted \n\
from this value. However it is also possible to define a user-defined size using the 'length' argument. \n\
\n\
Parameters \n\
----------- \n\
dataObjectOrBuffer : {`dataObject`, `bytearray`, `bytes`, `str`}\n\
    value to send to plugin. For an ADDA plugin, a `dataObject` is required whose content is sent to the analogous outputs of the device. For other dataIO \n\
    plugins buffer values like `bytearray`, `bytes` or `unicode string` are required. \n\
length : {int}, optional \n\
    usually this value is not required, since the length of the buffer is automatically extracted from the given objects and 1 for a `dataObject`&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e54699e1e05a2282fd136d2b834b3ca"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a9e54699e1e05a2282fd136d2b834b3ca" args="(PyDataIOPlugin_enableAutoGrabbing_doc,&quot;enableAutoGrabbing() &#45;&gt; enable auto grabbing for the grabber (camera...), \n\
\n\
If the auto grabbing flag is set, the camera acquisition is automatically and continuously triggered if at least one live image is \n\
connected. This is an undesired behaviour if a measurement is started where the acquisition should be controlled by a specific \n\
script or something similar. Then disable the auto grabbing property. All connected live images will then get new images when \n\
`getVal` or `copyVal` is called by the script. The live image timer is disabled. \n\
\n\
This method enables the auto grabbing flag. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
setAutoGrabbing(on), disableAutoGrabbing(), getAutoGrabbing()&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_enableAutoGrabbing_doc,&quot;enableAutoGrabbing() -&gt; enable auto grabbing for the grabber (camera...), \n\
\n\
If the auto grabbing flag is set, the camera acquisition is automatically and continuously triggered if at least one live image is \n\
connected. This is an undesired behaviour if a measurement is started where the acquisition should be controlled by a specific \n\
script or something similar. Then disable the auto grabbing property. All connected live images will then get new images when \n\
`getVal` or `copyVal` is called by the script. The live image timer is disabled. \n\
\n\
This method enables the auto grabbing flag. \n\
\n\
See Also \n\
--------- \n\
setAutoGrabbing(on), disableAutoGrabbing(), getAutoGrabbing()&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3084653989ceadc4c196095b5b9d52b2"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a3084653989ceadc4c196095b5b9d52b2" args="(PyDataIOPlugin_disableAutoGrabbing_doc,&quot;disableAutoGrabbing() &#45;&gt; Disable auto grabbing for the grabber (camera...), \n\
\n\
If the auto grabbing flag is set, the camera acquisition is automatically and continuously triggered if at least one live image is \n\
connected. This is an undesired behaviour if a measurement is started where the acquisition should be controlled by a specific \n\
script or something similar. Then disable the auto grabbing property. All connected live images will then get new images when \n\
`getVal` or `copyVal` is called by the script. The live image timer is disabled. \n\
\n\
This method disables the auto grabbing flag. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
setAutoGrabbing(on), disableAutoGrabbing(), getAutoGrabbing()&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_disableAutoGrabbing_doc,&quot;disableAutoGrabbing() -&gt; Disable auto grabbing for the grabber (camera...), \n\
\n\
If the auto grabbing flag is set, the camera acquisition is automatically and continuously triggered if at least one live image is \n\
connected. This is an undesired behaviour if a measurement is started where the acquisition should be controlled by a specific \n\
script or something similar. Then disable the auto grabbing property. All connected live images will then get new images when \n\
`getVal` or `copyVal` is called by the script. The live image timer is disabled. \n\
\n\
This method disables the auto grabbing flag. \n\
\n\
See Also \n\
--------- \n\
setAutoGrabbing(on), disableAutoGrabbing(), getAutoGrabbing()&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7b77ff1dbee72125596fa4856a46f1f"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ab7b77ff1dbee72125596fa4856a46f1f" args="(PyDataIOPlugin_setAutoGrabbing_doc,&quot;setAutoGrabbing(on) &#45;&gt; Set auto grabbing of the grabber device to on or off\n\
\n\
If the auto grabbing flag is set, the camera acquisition is automatically and continuously triggered if at least one live image is \n\
connected. This is an undesired behaviour if a measurement is started where the acquisition should be controlled by a specific \n\
script or something similar. Then disable the auto grabbing property. All connected live images will then get new images when \n\
`getVal` or `copyVal` is called by the script. The live image timer is disabled. \n\
\n\
This method allows setting this flag. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
on : {bool}\n\
    * TRUE = on\n\
    * FALSE = off\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
enableAutoGrabbing(), disableAutoGrabbing(), getAutoGrabbing()&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_setAutoGrabbing_doc,&quot;setAutoGrabbing(on) -&gt; Set auto grabbing of the grabber device to on or off\n\
\n\
If the auto grabbing flag is set, the camera acquisition is automatically and continuously triggered if at least one live image is \n\
connected. This is an undesired behaviour if a measurement is started where the acquisition should be controlled by a specific \n\
script or something similar. Then disable the auto grabbing property. All connected live images will then get new images when \n\
`getVal` or `copyVal` is called by the script. The live image timer is disabled. \n\
\n\
This method allows setting this flag. \n\
\n\
Parameters \n\
----------- \n\
on : {bool}\n\
    * TRUE = on\n\
    * FALSE = off\n\
\n\
See Also \n\
--------- \n\
enableAutoGrabbing(), disableAutoGrabbing(), getAutoGrabbing()&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae60ae304accef9e9950fd74015626b00"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ae60ae304accef9e9950fd74015626b00" args="(PyDataIOPlugin_getAutoGrabbing_doc,&quot;getAutoGrabbing() &#45;&gt; return the status of the auto grabbing flag. \n\
\n\
If the auto grabbing flag is set, the camera acquisition is automatically and continuously triggered if at least one live image is \n\
connected. This is an undesired behaviour if a measurement is started where the acquisition should be controlled by a specific \n\
script or something similar. Then disable the auto grabbing property. All connected live images will then get new images when \n\
`getVal` or `copyVal` is called by the script. The live image timer is disabled. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
auto grabbing flag : {bool}\n\
    * False = auto grabbing off \n\
    * True = auto grabbing on. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
enableAutoGrabbing(), disableAutoGrabbing(), setAutoGrabbing(bool)&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_getAutoGrabbing_doc,&quot;getAutoGrabbing() -&gt; return the status of the auto grabbing flag. \n\
\n\
If the auto grabbing flag is set, the camera acquisition is automatically and continuously triggered if at least one live image is \n\
connected. This is an undesired behaviour if a measurement is started where the acquisition should be controlled by a specific \n\
script or something similar. Then disable the auto grabbing property. All connected live images will then get new images when \n\
`getVal` or `copyVal` is called by the script. The live image timer is disabled. \n\
\n\
Returns \n\
------- \n\
auto grabbing flag : {bool}\n\
    * False = auto grabbing off \n\
    * True = auto grabbing on. \n\
\n\
See Also \n\
--------- \n\
enableAutoGrabbing(), disableAutoGrabbing(), setAutoGrabbing(bool)&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a628bd5960ee89cedd376d064b4f872a2"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a628bd5960ee89cedd376d064b4f872a2" args="(PyDataIOPlugin_getType_doc,&quot;getType() &#45;&gt; returns dataIO type&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_getType_doc,&quot;getType() -&gt; returns dataIO type&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87012b03942d7c1576593908602b50f4"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a87012b03942d7c1576593908602b50f4" args="(pyRegion_doc,&quot;region([x, y, w, h [,type=region.RECTANGLE]]) &#45;&gt; creates a rectangular or elliptical region. \n\
\n\
This class is a wrapper for the class QRegion of Qt. It provides possibilities for creating pixel&#45;based regions. Furtherone you can \n\
calculate new regions based on the intersection, union or subtraction of other regions. Based on the region it is possible to get \n\
a uint8 masked dataObject, where every point within the entire region has the value 255 and all other values 0 \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
x : {int} \n\
    x&#45;coordinate of the reference corner of the region \n\
y : {int} \n\
    y&#45;coordinate of the reference corner of the region \n\
w : {int} \n\
    width of the region \n\
h : {int} \n\
    height of the region \n\
type : {int}, optional \n\
    region.RECTANGLE creates a rectangular region (default). region.ELLIPSE creates an elliptical region, which is placed inside of the \n\
    given boundaries. \n\
\n\
Notes\n\
&#45;&#45;&#45;&#45;&#45; \n\
It is also possible to create an empty instance of the region.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegion_doc,&quot;region([x, y, w, h [,type=region.RECTANGLE]]) -&gt; creates a rectangular or elliptical region. \n\
\n\
This class is a wrapper for the class QRegion of Qt. It provides possibilities for creating pixel-based regions. Furtherone you can \n\
calculate new regions based on the intersection, union or subtraction of other regions. Based on the region it is possible to get \n\
a uint8 masked dataObject, where every point within the entire region has the value 255 and all other values 0 \n\
\n\
Parameters \n\
----------- \n\
x : {int} \n\
    x-coordinate of the reference corner of the region \n\
y : {int} \n\
    y-coordinate of the reference corner of the region \n\
w : {int} \n\
    width of the region \n\
h : {int} \n\
    height of the region \n\
type : {int}, optional \n\
    region.RECTANGLE creates a rectangular region (default). region.ELLIPSE creates an elliptical region, which is placed inside of the \n\
    given boundaries. \n\
\n\
Notes\n\
----- \n\
It is also possible to create an empty instance of the region.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96dfea3db9a15ff33434a8f27c115dd2"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a96dfea3db9a15ff33434a8f27c115dd2" args="(pyRegionContains_doc,&quot;contains(x,y[,w,h]) &#45;&gt; returns True if the given point or rectangle is fully contained in this region, otherwise returns False. \n\
\n\
This method returns True, if the given point (x,y) or region (x,y,w,h) is fully contained in this region. Otherwise returns False.\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
x : {int} \n\
    x&#45;coordinate of one corner of the new rectangular region \n\
y : {int} \n\
    y&#45;coordinate of one corner of the new rectangular region \n\
w : {int}, optional \n\
    width of the new rectangular region. If not given, point is assumed. \n\
h : {int}, optional \n\
    height of the new rectangular region. If not given, point is assumed. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
True or False&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionContains_doc,&quot;contains(x,y[,w,h]) -&gt; returns True if the given point or rectangle is fully contained in this region, otherwise returns False. \n\
\n\
This method returns True, if the given point (x,y) or region (x,y,w,h) is fully contained in this region. Otherwise returns False.\n\
Parameters \n\
----------- \n\
x : {int} \n\
    x-coordinate of one corner of the new rectangular region \n\
y : {int} \n\
    y-coordinate of one corner of the new rectangular region \n\
w : {int}, optional \n\
    width of the new rectangular region. If not given, point is assumed. \n\
h : {int}, optional \n\
    height of the new rectangular region. If not given, point is assumed. \n\
\n\
Returns \n\
------- \n\
True or False&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45e7d18be28e5021c13e7f3b5f7476c4"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a45e7d18be28e5021c13e7f3b5f7476c4" args="(pyRegionIntersected_doc,&quot;intersected(x,y,w,h | region) &#45;&gt; returns a region which is the intersection of a new region and this region. \n\
\n\
This method returns a new region, which is the intersection of this region and the given, new region. The intersection only contains points that are \n\
part of both given regions. \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
x : {int} \n\
    x&#45;coordinate of one corner of the new rectangular region \n\
y : {int} \n\
    y&#45;coordinate of one corner of the new rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region&#45;object} \n\
    another instance of region \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
new intersected region. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionIntersected_doc,&quot;intersected(x,y,w,h | region) -&gt; returns a region which is the intersection of a new region and this region. \n\
\n\
This method returns a new region, which is the intersection of this region and the given, new region. The intersection only contains points that are \n\
part of both given regions. \n\
Parameters \n\
----------- \n\
x : {int} \n\
    x-coordinate of one corner of the new rectangular region \n\
y : {int} \n\
    y-coordinate of one corner of the new rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region-object} \n\
    another instance of region \n\
\n\
Returns \n\
------- \n\
new intersected region. \n\
\n\
Notes \n\
----- \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70e48f62938499cc5967aaa832aaa640"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a70e48f62938499cc5967aaa832aaa640" args="(pyRegionIntersects_doc,&quot;intersects(x,y,w,h | region) &#45;&gt; returns True if this region intersects with the given region, else False. \n\
\n\
This method returns True, if this region intersects with the new region, otherwise returns False. \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
x : {int} \n\
    x&#45;coordinate of one corner of the new rectangular region \n\
y : {int} \n\
    y&#45;coordinate of one corner of the new rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region&#45;object} \n\
    another instance of region \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
True or False \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionIntersects_doc,&quot;intersects(x,y,w,h | region) -&gt; returns True if this region intersects with the given region, else False. \n\
\n\
This method returns True, if this region intersects with the new region, otherwise returns False. \n\
Parameters \n\
----------- \n\
x : {int} \n\
    x-coordinate of one corner of the new rectangular region \n\
y : {int} \n\
    y-coordinate of one corner of the new rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region-object} \n\
    another instance of region \n\
\n\
Returns \n\
------- \n\
True or False \n\
\n\
Notes \n\
----- \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85f6a07cf252a06adc4402d2bc33759f"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a85f6a07cf252a06adc4402d2bc33759f" args="(pyRegionSubtracted_doc,&quot;subtracted(x,y,w,h | region) &#45;&gt; returns a region which is the new region subtracted from this region. \n\
\n\
This method returns a new region, which is the given, new region subtracted from this region. \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
x : {int} \n\
    x&#45;coordinate of one corner of the new rectangular region \n\
y : {int} \n\
    y&#45;coordinate of one corner of the new rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region&#45;object} \n\
    another instance of region \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
new subtracted region. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionSubtracted_doc,&quot;subtracted(x,y,w,h | region) -&gt; returns a region which is the new region subtracted from this region. \n\
\n\
This method returns a new region, which is the given, new region subtracted from this region. \n\
Parameters \n\
----------- \n\
x : {int} \n\
    x-coordinate of one corner of the new rectangular region \n\
y : {int} \n\
    y-coordinate of one corner of the new rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region-object} \n\
    another instance of region \n\
\n\
Returns \n\
------- \n\
new subtracted region. \n\
\n\
Notes \n\
----- \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4cfa1de885c6814a2f629554c196875"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ad4cfa1de885c6814a2f629554c196875" args="(pyRegionTranslate_doc,&quot;translate(x,y) &#45;&gt; translateds this region by the given coordinates. \n\
\n\
This method translates this region by the given coordinates. \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
x : {int} \n\
    translation in x&#45;direction \n\
y : {int} \n\
    translation in y&#45;direction \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
translated&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionTranslate_doc,&quot;translate(x,y) -&gt; translateds this region by the given coordinates. \n\
\n\
This method translates this region by the given coordinates. \n\
Parameters \n\
----------- \n\
x : {int} \n\
    translation in x-direction \n\
y : {int} \n\
    translation in y-direction \n\
\n\
See Also \n\
--------- \n\
translated&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2598f46c67cedf95b82f75c2ddbe1fbf"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a2598f46c67cedf95b82f75c2ddbe1fbf" args="(pyRegionTranslated_doc,&quot;translated(x,y) &#45;&gt; returns a region, translated by the given coordinates. \n\
\n\
This method returns a new region, which is translated by the given coordinates in x and y direction. \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
x : {int} \n\
    translation in x&#45;direction \n\
y : {int} \n\
    translation in y&#45;direction \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
new translated region.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
translate&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionTranslated_doc,&quot;translated(x,y) -&gt; returns a region, translated by the given coordinates. \n\
\n\
This method returns a new region, which is translated by the given coordinates in x and y direction. \n\
Parameters \n\
----------- \n\
x : {int} \n\
    translation in x-direction \n\
y : {int} \n\
    translation in y-direction \n\
\n\
Returns \n\
------- \n\
new translated region.\n\
\n\
See Also \n\
--------- \n\
translate&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ef00615e5fb483ba0eb43ec8984d697"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a9ef00615e5fb483ba0eb43ec8984d697" args="(pyRegionUnited_doc,&quot;united(x,y,w,h | region) &#45;&gt; returns a region which is the union of the given region with this region. \n\
\n\
This method returns a new region, which is the union of this region with the region given as parameters. Union means that all values, that\n\
are contained in any of both regions is part of the overall region, too. \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
x : {int} \n\
    x&#45;coordinate of one corner of a rectangular region \n\
y : {int} \n\
    y&#45;coordinate of one corner of a rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region&#45;object} \n\
    another instance of region \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
new united region. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionUnited_doc,&quot;united(x,y,w,h | region) -&gt; returns a region which is the union of the given region with this region. \n\
\n\
This method returns a new region, which is the union of this region with the region given as parameters. Union means that all values, that\n\
are contained in any of both regions is part of the overall region, too. \n\
Parameters \n\
----------- \n\
x : {int} \n\
    x-coordinate of one corner of a rectangular region \n\
y : {int} \n\
    y-coordinate of one corner of a rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region-object} \n\
    another instance of region \n\
\n\
Returns \n\
------- \n\
new united region. \n\
\n\
Notes \n\
----- \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c9509489c3f894f6f979c1e9a6bdbfb"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a4c9509489c3f894f6f979c1e9a6bdbfb" args="(pyRegionXored_doc,&quot;xored(x,y,w,h | region) &#45;&gt; returns a region which is an xor combination of the given region with this region. \n\
\n\
This method returns a new region, which is defined by an xor&#45;combination of this region with the region given as parameters. \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
x : {int} \n\
    x&#45;coordinate of one corner of a rectangular region \n\
y : {int} \n\
    y&#45;coordinate of one corner of a rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region&#45;object} \n\
    another instance of region \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
new xored region. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionXored_doc,&quot;xored(x,y,w,h | region) -&gt; returns a region which is an xor combination of the given region with this region. \n\
\n\
This method returns a new region, which is defined by an xor-combination of this region with the region given as parameters. \n\
Parameters \n\
----------- \n\
x : {int} \n\
    x-coordinate of one corner of a rectangular region \n\
y : {int} \n\
    y-coordinate of one corner of a rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region-object} \n\
    another instance of region \n\
\n\
Returns \n\
------- \n\
new xored region. \n\
\n\
Notes \n\
----- \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84b450ebde4123fda504dfc6b16769ca"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a84b450ebde4123fda504dfc6b16769ca" args="(pyRegionCreateMask_doc,&quot;createMask() &#45;&gt; creates mask data object based on this region. \n\
\n\
Returns a uint8&#45;dataObject whose size corresponds to the width and height of the bounding rectangle. \n\
All pixels contained in the region have a value of 255 while the rest is set to 0. The offset value of \n\
the dataObject is set such that it fits to the real position of the region, since the first element \n\
in the dataObject corresponds to the left upper corner of the bounding rectangle.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionCreateMask_doc,&quot;createMask() -&gt; creates mask data object based on this region. \n\
\n\
Returns a uint8-dataObject whose size corresponds to the width and height of the bounding rectangle. \n\
All pixels contained in the region have a value of 255 while the rest is set to 0. The offset value of \n\
the dataObject is set such that it fits to the real position of the region, since the first element \n\
in the dataObject corresponds to the left upper corner of the bounding rectangle.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69e1d88b583647cc6b0c99b01b9d4fd4"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a69e1d88b583647cc6b0c99b01b9d4fd4" args="(rgbaInit_doc,&quot;rgba(r, g, b [, alpha=255]) &#45;&gt; creates a new color value from red, green, blue and optional alpha\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
r : {uint8} \n\
    red component [0,255] \n\
g : {uint8}, \n\
    green component [0,255] \n\
b : {uint8} \n\
    blue component [0,255] \n\
alpha : {uint8}, optional \n\
    alpha component [0,255], default: 255 (no transparancy) \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
For a gray value set all colors to the same value.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (rgbaInit_doc,&quot;rgba(r, g, b [, alpha=255]) -&gt; creates a new color value from red, green, blue and optional alpha\n\
\n\
Parameters \n\
----------- \n\
r : {uint8} \n\
    red component [0,255] \n\
g : {uint8}, \n\
    green component [0,255] \n\
b : {uint8} \n\
    blue component [0,255] \n\
alpha : {uint8}, optional \n\
    alpha component [0,255], default: 255 (no transparancy) \n\
\n\
Notes \n\
------ \n\
\n\
For a gray value set all colors to the same value.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42d49894453a994c7f96a1c4da7d0fd1"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a42d49894453a994c7f96a1c4da7d0fd1" args="(PyUiItemInit_doc,&quot;uiItem(...) &#45;&gt; base class representing any widget of a graphical user interface \n\
\n\
This class represents any widget (graphical, interactive element like a button or checkbox) on a graphical user interface. \n\
An instance of this class provides many functionalities given by the underlying Qt system. For instance, it is posible to \n\
call a public slot of the corresponding widget, connect signals to specific python methods or functions or change properties \n\
of the widget represeted by the instance. \n\
\n\
The overall dialog or window as main element of a graphical user interface itself are instances of the class *ui*. However, \n\
they are derived from *uiItem*, since dialogs or windows internally are widgets as well. \n\
\n\
Widgets placed at a user interface using the Qt Designer can be referenced by an *uiItem* instance by their specific objectName, \n\
assigned in the Qt Designer as well. As an example, a simple dialog with one button is created and the text of the button (objectName: btn) \n\
is set to OK: :: \n\
    \n\
    dialog = ui('filename.ui', type=ui.TYPEDIALOG) \n\
    button = dialog.btn #here the reference to the button is obtained \n\
    button[\&quot;text\&quot;] = \&quot;OK\&quot; #set the property text of the button \n\
    \n\
Information about available properties, signals and slots can be obtained using the method **info()** of *uiItem*. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45;&#45; \n\
It is not intended to directly instantiate this class. Either create a user interface using the class *ui* or obtain \n\
a reference to an existing widget (this is then an instance of *uiItem*) using the dot&#45;operator of a \n\
parent widget or the entire user interface.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemInit_doc,&quot;uiItem(...) -&gt; base class representing any widget of a graphical user interface \n\
\n\
This class represents any widget (graphical, interactive element like a button or checkbox) on a graphical user interface. \n\
An instance of this class provides many functionalities given by the underlying Qt system. For instance, it is posible to \n\
call a public slot of the corresponding widget, connect signals to specific python methods or functions or change properties \n\
of the widget represeted by the instance. \n\
\n\
The overall dialog or window as main element of a graphical user interface itself are instances of the class *ui*. However, \n\
they are derived from *uiItem*, since dialogs or windows internally are widgets as well. \n\
\n\
Widgets placed at a user interface using the Qt Designer can be referenced by an *uiItem* instance by their specific objectName, \n\
assigned in the Qt Designer as well. As an example, a simple dialog with one button is created and the text of the button (objectName: btn) \n\
is set to OK: :: \n\
    \n\
    dialog = ui('filename.ui', type=ui.TYPEDIALOG) \n\
    button = dialog.btn #here the reference to the button is obtained \n\
    button[\&quot;text\&quot;] = \&quot;OK\&quot; #set the property text of the button \n\
    \n\
Information about available properties, signals and slots can be obtained using the method **info()** of *uiItem*. \n\
\n\
Notes \n\
------ \n\
It is not intended to directly instantiate this class. Either create a user interface using the class *ui* or obtain \n\
a reference to an existing widget (this is then an instance of *uiItem*) using the dot-operator of a \n\
parent widget or the entire user interface.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9db8c6e85fba8129ab87f624cb59df1c"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a9db8c6e85fba8129ab87f624cb59df1c" args="(PyUiItemCall_doc,&quot;call(slotOrPublicMethod [,argument1, argument2, ...]) &#45;&gt; calls any public slot of this widget or any accessible public method.  \n\
\n\
This method invokes (calls) a method of the underlying widget that is marked as public slot. Besides slots there are some public methods of specific \n\
widget classes that are wrapped by itom and therefore are callable by this method, too. \n\
\n\
If only method is available, all arguments are tried to be cast to the requested types and the slot is called on conversion success. If the method has \n\
multiple overloaded possibilities in the underlying C++ classes, at first, it is intended to find the variant where all arguments can be strictly casted \n\
from Python types to the necessary C&#45;types. If this fails, the next variant with a non&#45;strict conversion is chosen. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
slotOrPublicMethod : {str} \n\
    name of the slot or method \n\
arguments : {various types}, optional\n\
    Here you must indicate every argument, that the definition of the slot indicates. The type must be convertable into the \n\
    requested C++ based argument type.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
If you want to know all possible slots of a specific widget, see the Qt help or call the member *info()* of the widget. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
info()&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemCall_doc,&quot;call(slotOrPublicMethod [,argument1, argument2, ...]) -&gt; calls any public slot of this widget or any accessible public method.  \n\
\n\
This method invokes (calls) a method of the underlying widget that is marked as public slot. Besides slots there are some public methods of specific \n\
widget classes that are wrapped by itom and therefore are callable by this method, too. \n\
\n\
If only method is available, all arguments are tried to be cast to the requested types and the slot is called on conversion success. If the method has \n\
multiple overloaded possibilities in the underlying C++ classes, at first, it is intended to find the variant where all arguments can be strictly casted \n\
from Python types to the necessary C-types. If this fails, the next variant with a non-strict conversion is chosen. \n\
\n\
Parameters \n\
----------- \n\
slotOrPublicMethod : {str} \n\
    name of the slot or method \n\
arguments : {various types}, optional\n\
    Here you must indicate every argument, that the definition of the slot indicates. The type must be convertable into the \n\
    requested C++ based argument type.\n\
\n\
Notes \n\
----- \n\
If you want to know all possible slots of a specific widget, see the Qt help or call the member *info()* of the widget. \n\
\n\
See Also \n\
--------- \n\
info()&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a766343b0a5f59c222213d5ca0ca82a61"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a766343b0a5f59c222213d5ca0ca82a61" args="(PyUiItemConnect_doc,&quot;connect(signalSignature, callableMethod) &#45;&gt; connects the signal of the widget with the given callable python method \n\
\n\
This instance of *uiItem* wraps a widget, that is defined by a C++&#45;class, that is finally derived from *QWidget*. See Qt&#45;help for more information \n\
about the capabilities of every specific widget. Every widget can send various signals. Use this method to connect any signal to any \n\
callable python method (bounded or unbounded). This method must have the same number of arguments than the signal and the types of the \n\
signal definition must be convertable into a python object. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
signalSignature : {str} \n\
    This must be the valid signature, known from the Qt&#45;method *connect* (e.g. 'clicked(bool)') \n\
callableMethod : {python method or function} \n\
    valid method or function that is called if the signal is emitted. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
disconnect, invokeKeyboardInterrupt&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemConnect_doc,&quot;connect(signalSignature, callableMethod) -&gt; connects the signal of the widget with the given callable python method \n\
\n\
This instance of *uiItem* wraps a widget, that is defined by a C++-class, that is finally derived from *QWidget*. See Qt-help for more information \n\
about the capabilities of every specific widget. Every widget can send various signals. Use this method to connect any signal to any \n\
callable python method (bounded or unbounded). This method must have the same number of arguments than the signal and the types of the \n\
signal definition must be convertable into a python object. \n\
\n\
Parameters \n\
----------- \n\
signalSignature : {str} \n\
    This must be the valid signature, known from the Qt-method *connect* (e.g. 'clicked(bool)') \n\
callableMethod : {python method or function} \n\
    valid method or function that is called if the signal is emitted. \n\
\n\
See Also \n\
--------- \n\
disconnect, invokeKeyboardInterrupt&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1af247b5969057307cb95c570dbd4b08"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a1af247b5969057307cb95c570dbd4b08" args="(PyUiItemConnectKeyboardInterrupt_doc,&quot;invokeKeyboardInterrupt(signalSignature) &#45;&gt; connects the given signal with a slot immediately invoking a python interrupt signal. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
signalSignature : {str} \n\
    This must be the valid signature, known from the Qt&#45;method *connect* (e.g. 'clicked(bool)') \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
If you use the connect method to link a signal with a python method or function, this method can only be executed if python is in an idle status. \n\
However, if you want raise the python interrupt signal if a specific signal is emitted, this interruption should be immediately invoked. Therefore \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
connect&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemConnectKeyboardInterrupt_doc,&quot;invokeKeyboardInterrupt(signalSignature) -&gt; connects the given signal with a slot immediately invoking a python interrupt signal. \n\
\n\
Parameters \n\
----------- \n\
signalSignature : {str} \n\
    This must be the valid signature, known from the Qt-method *connect* (e.g. 'clicked(bool)') \n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
If you use the connect method to link a signal with a python method or function, this method can only be executed if python is in an idle status. \n\
However, if you want raise the python interrupt signal if a specific signal is emitted, this interruption should be immediately invoked. Therefore \n\
\n\
See Also \n\
--------- \n\
connect&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f6748c0b54e31d99852fe3075ab0e2f"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a6f6748c0b54e31d99852fe3075ab0e2f" args="(PyUiItemDisconnect_doc,&quot;disconnect(signalSignature, callableMethod) &#45;&gt; disconnects a connection which must have been established with exactly the same parameters.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
signalSignature : {str} \n\
callableMethod : {python method or function} \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemDisconnect_doc,&quot;disconnect(signalSignature, callableMethod) -&gt; disconnects a connection which must have been established with exactly the same parameters.\n\
\n\
Parameters \n\
----------- \n\
signalSignature : {str} \n\
callableMethod : {python method or function} \n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8cc364148a86eb56dd6b8435a83f6da"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ae8cc364148a86eb56dd6b8435a83f6da" args="(PyUiItemGetProperty_doc,&quot;getProperty(propertyName | listOfPropertyNames) &#45;&gt; returns tuple of requested properties (single property or tuple of properties)\n\
Use this method or the operator [] in order to get the value of one specific property of this widget or of multiple properties. \n\
Multiple properties are given by a tuple or list of property names. For one single property, its value is returned as it is. \n\
If the property names are passed as sequence, a sequence of same size is returned with the corresponding values. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
property : {string, string&#45;list} \n\
    Name of one property or sequence (tuple,list...) of property names \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {variant, sequence of variants} \n\
    the value of one single property of a list of values, if a sequence of names is given as parameter. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
setProperty \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemGetProperty_doc,&quot;getProperty(propertyName | listOfPropertyNames) -&gt; returns tuple of requested properties (single property or tuple of properties)\n\
Use this method or the operator [] in order to get the value of one specific property of this widget or of multiple properties. \n\
Multiple properties are given by a tuple or list of property names. For one single property, its value is returned as it is. \n\
If the property names are passed as sequence, a sequence of same size is returned with the corresponding values. \n\
\n\
Parameters \n\
----------- \n\
property : {string, string-list} \n\
    Name of one property or sequence (tuple,list...) of property names \n\
\n\
Returns \n\
------- \n\
out : {variant, sequence of variants} \n\
    the value of one single property of a list of values, if a sequence of names is given as parameter. \n\
\n\
See Also \n\
--------- \n\
setProperty \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa633827cc9748b0e2f27cec069047a10"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aa633827cc9748b0e2f27cec069047a10" args="(PyUiItemSetProperty_doc,&quot;setProperty(propertyDict) &#45;&gt; each property in the parameter dictionary is set to the dictionaries value.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
propertyDict : {dict}\n\
    Dictionary with properties (keyword) and the values that should be set.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getProperty \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemSetProperty_doc,&quot;setProperty(propertyDict) -&gt; each property in the parameter dictionary is set to the dictionaries value.\n\
\n\
Parameters \n\
----------- \n\
propertyDict : {dict}\n\
    Dictionary with properties (keyword) and the values that should be set.\n\
\n\
See Also \n\
--------- \n\
getProperty \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa23fba3e2d8ab1249171e25b1da0eb4a"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aa23fba3e2d8ab1249171e25b1da0eb4a" args="(PyUiItemGetPropertyInfo_doc,&quot;getPropertyInfo([propertyName]) &#45;&gt; returns information about the property 'propertyName' of this widget or all properties, if no name indicated.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
propertyName : {tuple}, optional \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemGetPropertyInfo_doc,&quot;getPropertyInfo([propertyName]) -&gt; returns information about the property 'propertyName' of this widget or all properties, if no name indicated.\n\
\n\
Parameters \n\
----------- \n\
propertyName : {tuple}, optional \n\
\n\
Returns \n\
------- \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a617a9916056d88f2b179cd6cf0c76d19"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a617a9916056d88f2b179cd6cf0c76d19" args="(PyUiItemGetAttribute_doc,&quot;getAttribute(attributeNumber) &#45;&gt; returns specified attribute of corresponding widget.\n\
\n\
Widgets have specific attributes that influence their behaviour. These attributes are contained in the Qt&#45;enumeration \n\
Qt::WidgetAttribute. Use this method to query the current status of one specific attributes. \n\
\n\
Important attributes are: \n\
\n\
* Qt::WA_DeleteOnClose (55) &#45;&gt; deletes the widget when it is closed, else it is only hidden [default] \n\
* Qt::WA_MouseTracking (2) &#45;&gt; indicates that the widget has mouse tracking enabled \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
attributeNumber : {int} \n\
    Number of the attribute of the widget to query (enum Qt::WidgetAttribute) \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {bool} \n\
    True if attribute is set, else False \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
setAttribute()\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemGetAttribute_doc,&quot;getAttribute(attributeNumber) -&gt; returns specified attribute of corresponding widget.\n\
\n\
Widgets have specific attributes that influence their behaviour. These attributes are contained in the Qt-enumeration \n\
Qt::WidgetAttribute. Use this method to query the current status of one specific attributes. \n\
\n\
Important attributes are: \n\
\n\
* Qt::WA_DeleteOnClose (55) -&gt; deletes the widget when it is closed, else it is only hidden [default] \n\
* Qt::WA_MouseTracking (2) -&gt; indicates that the widget has mouse tracking enabled \n\
\n\
Parameters \n\
----------- \n\
attributeNumber : {int} \n\
    Number of the attribute of the widget to query (enum Qt::WidgetAttribute) \n\
\n\
Returns \n\
------- \n\
out : {bool} \n\
    True if attribute is set, else False \n\
\n\
See Also \n\
--------- \n\
setAttribute()\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a330f62c1cbc7b96b35238e8f47e899e4"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a330f62c1cbc7b96b35238e8f47e899e4" args="(PyUiItemSetAttribute_doc,&quot;setAttribute(attributeNumber, value) &#45;&gt; sets attribute of corresponding widget.\n\
\n\
Widgets have specific attributes that influence their behaviour. These attributes are contained in the Qt&#45;enumeration \n\
Qt::WidgetAttribute. Use this method to enable/disable one specific attribute.\n\
\n\
Important attributes are: \n\
\n\
* Qt::WA_DeleteOnClose (55) &#45;&gt; deletes the widget when it is closed, else it is only hidden [default] \n\
* Qt::WA_MouseTracking (2) &#45;&gt; indicates that the widget has mouse tracking enabled \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
attributeNumber : {int} \n\
    Number of the attribute of the widget to set (enum Qt::WidgetAttribute) \n\
value : {bool} \n\
    True if attribute should be enabled, else False \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getAttribute&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemSetAttribute_doc,&quot;setAttribute(attributeNumber, value) -&gt; sets attribute of corresponding widget.\n\
\n\
Widgets have specific attributes that influence their behaviour. These attributes are contained in the Qt-enumeration \n\
Qt::WidgetAttribute. Use this method to enable/disable one specific attribute.\n\
\n\
Important attributes are: \n\
\n\
* Qt::WA_DeleteOnClose (55) -&gt; deletes the widget when it is closed, else it is only hidden [default] \n\
* Qt::WA_MouseTracking (2) -&gt; indicates that the widget has mouse tracking enabled \n\
\n\
Parameters \n\
----------- \n\
attributeNumber : {int} \n\
    Number of the attribute of the widget to set (enum Qt::WidgetAttribute) \n\
value : {bool} \n\
    True if attribute should be enabled, else False \n\
\n\
See Also \n\
--------- \n\
getAttribute&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7df6d3afc581c027a9fde17dad1214ae"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a7df6d3afc581c027a9fde17dad1214ae" args="(PyUiItemSetWindowFlags_doc,&quot;setWindowFlags(flags) &#45;&gt; set window flags of corresponding widget.\n\
\n\
The window flags are used to set the type of a widget, dialog or window including further hints to the window system. \n\
This method is used to set the entire or&#45;combination of all flags, contained in the Qt&#45;enumeration Qt::WindowType. \n\
\n\
The most important types are: \n\
\n\
* Qt::Widget (0) &#45;&gt; default type for widgets \n\
* Qt::Window (1) &#45;&gt; the widget looks and behaves like a windows (title bar, window frame...) \n\
* Qt::Dialog (3) &#45;&gt; window decorated as dialog (no minimize or maximize button...) \n\
\n\
Further hints can be (among others): \n\
\n\
* Qt::FramelessWindowHint (0x00000800) &#45;&gt; borderless window (user cannot move or resize the window) \n\
* Qt::WindowTitleBar (0x00001000) &#45;&gt; gives the window a title bar \n\
* Qt::WindowMinimizeButtonHint (0x00004000) &#45;&gt; adds a minimize button to the title bar \n\
* Qt::WindowMaximizeButtonHint (0x00008000) &#45;&gt; adds a maximize button to the title bar \n\
* Qt::WindowCloseButtonHint (0x00010000) &#45;&gt; adds a close button. \n\
\n\
If you simply want to change one hint, get the current set of flags using **getWindowFlags**, change the necessary bitmask and \n\
set it again using this method. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
flags : {int} \n\
    window flags to set (or&#45;combination, see Qt::WindowFlags) \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getWindowFlags()&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemSetWindowFlags_doc,&quot;setWindowFlags(flags) -&gt; set window flags of corresponding widget.\n\
\n\
The window flags are used to set the type of a widget, dialog or window including further hints to the window system. \n\
This method is used to set the entire or-combination of all flags, contained in the Qt-enumeration Qt::WindowType. \n\
\n\
The most important types are: \n\
\n\
* Qt::Widget (0) -&gt; default type for widgets \n\
* Qt::Window (1) -&gt; the widget looks and behaves like a windows (title bar, window frame...) \n\
* Qt::Dialog (3) -&gt; window decorated as dialog (no minimize or maximize button...) \n\
\n\
Further hints can be (among others): \n\
\n\
* Qt::FramelessWindowHint (0x00000800) -&gt; borderless window (user cannot move or resize the window) \n\
* Qt::WindowTitleBar (0x00001000) -&gt; gives the window a title bar \n\
* Qt::WindowMinimizeButtonHint (0x00004000) -&gt; adds a minimize button to the title bar \n\
* Qt::WindowMaximizeButtonHint (0x00008000) -&gt; adds a maximize button to the title bar \n\
* Qt::WindowCloseButtonHint (0x00010000) -&gt; adds a close button. \n\
\n\
If you simply want to change one hint, get the current set of flags using **getWindowFlags**, change the necessary bitmask and \n\
set it again using this method. \n\
\n\
Parameters \n\
----------- \n\
flags : {int} \n\
    window flags to set (or-combination, see Qt::WindowFlags) \n\
\n\
See Also \n\
---------- \n\
getWindowFlags()&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a564b54e4ddf61d87a0e37db87327fa57"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a564b54e4ddf61d87a0e37db87327fa57" args="(PyUiItemGetWindowFlags_doc,&quot;getWindowFlags(flags) &#45;&gt; gets window flags of corresponding widget. \n\
\n\
The flags&#45;value is an or&#45;combination of the enumeration Qt::WindowType. See Qt documentation for more information. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
flags {int}: \n\
    or&#45;combination of Qt::WindowType describing the type and further hints of the user interface \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
setWindowFlags()&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemGetWindowFlags_doc,&quot;getWindowFlags(flags) -&gt; gets window flags of corresponding widget. \n\
\n\
The flags-value is an or-combination of the enumeration Qt::WindowType. See Qt documentation for more information. \n\
\n\
Returns \n\
-------- \n\
flags {int}: \n\
    or-combination of Qt::WindowType describing the type and further hints of the user interface \n\
\n\
See Also \n\
--------- \n\
setWindowFlags()&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a699373f56fe528900cabe07028907a63"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a699373f56fe528900cabe07028907a63" args="(PyUiItemExists_doc,&quot;exists() &#45;&gt; returns true if widget still exists, else false.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemExists_doc,&quot;exists() -&gt; returns true if widget still exists, else false.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a555f8f1cc8e1a5c299023c4ea7103873"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a555f8f1cc8e1a5c299023c4ea7103873" args="(pyUiInit_doc,&quot;ui(filename, [type, dialogButtonBar, dialogButtons, childOfMainWindow, deleteOnClose]) &#45;&gt; instance of user interface \n\
\n\
The class **ui** wraps a user interface, externally designed and given by a ui&#45;file. If your user interface is a dialog or window, \n\
chose *ui.TYPEWINDOW* as type, if the user interface is a widget (simplest case), chose *ui.TYPEDIALOG* and your widget \n\
will be embedded in a dialog, provided by *itom*. This dialog can be equiped with a button bar, whose buttons are already \n\
connected to *itom* internal methods. If you then show your dialog in a modal mode, *itom* knows which button has been \n\
clicked in order to accept or reject the dialog. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filename : {str} \n\
    path to user interface file (*.ui), absolute or relative to current directory \n\
type : {int}, optional \n\
    display type: \n\
    \n\
        * 0 (ui.TYPEDIALOG): ui&#45;file is embedded in auto&#45;created dialog (default), \n\
        * 1 (ui.TYPEWINDOW): ui&#45;file is handled as main window, \n\
        * 2 (ui.TYPEDOCKWIDGET): ui&#45;file is handled as dock&#45;widget and appended to the main&#45;window dock area \n\
dialogButtonBar :  {int}, optional \n\
    Only for type ui.TYPEDIALOG (0). Indicates whether buttons should automatically be added to the dialog: \n\
    \n\
        * 0 (ui.BUTTONBAR_NO): do not add any buttons (default) \n\
        * 1 (ui.BUTTONBAR_HORIZONTAL): add horizontal button bar \n\
        * 2 (ui.BUTTONBAR_VERTICAL): add vertical button bar \n\
dialogButtons : {dict}, optional \n\
    every dictionary&#45;entry is one button. key is the role, value is the button text \n\
childOfMainWindow :  {bool}, optional \n\
    for type TYPEDIALOG and TYPEWINDOW only. Indicates whether window should be a child of itom main window (default: True) \n\
deleteOnClose : {bool}, optional \n\
    Indicates whether window should be deleted if user closes it or if it is hidden (default: Hidden, False)&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiInit_doc,&quot;ui(filename, [type, dialogButtonBar, dialogButtons, childOfMainWindow, deleteOnClose]) -&gt; instance of user interface \n\
\n\
The class **ui** wraps a user interface, externally designed and given by a ui-file. If your user interface is a dialog or window, \n\
chose *ui.TYPEWINDOW* as type, if the user interface is a widget (simplest case), chose *ui.TYPEDIALOG* and your widget \n\
will be embedded in a dialog, provided by *itom*. This dialog can be equiped with a button bar, whose buttons are already \n\
connected to *itom* internal methods. If you then show your dialog in a modal mode, *itom* knows which button has been \n\
clicked in order to accept or reject the dialog. \n\
\n\
Parameters \n\
----------- \n\
filename : {str} \n\
    path to user interface file (*.ui), absolute or relative to current directory \n\
type : {int}, optional \n\
    display type: \n\
    \n\
        * 0 (ui.TYPEDIALOG): ui-file is embedded in auto-created dialog (default), \n\
        * 1 (ui.TYPEWINDOW): ui-file is handled as main window, \n\
        * 2 (ui.TYPEDOCKWIDGET): ui-file is handled as dock-widget and appended to the main-window dock area \n\
dialogButtonBar :  {int}, optional \n\
    Only for type ui.TYPEDIALOG (0). Indicates whether buttons should automatically be added to the dialog: \n\
    \n\
        * 0 (ui.BUTTONBAR_NO): do not add any buttons (default) \n\
        * 1 (ui.BUTTONBAR_HORIZONTAL): add horizontal button bar \n\
        * 2 (ui.BUTTONBAR_VERTICAL): add vertical button bar \n\
dialogButtons : {dict}, optional \n\
    every dictionary-entry is one button. key is the role, value is the button text \n\
childOfMainWindow :  {bool}, optional \n\
    for type TYPEDIALOG and TYPEWINDOW only. Indicates whether window should be a child of itom main window (default: True) \n\
deleteOnClose : {bool}, optional \n\
    Indicates whether window should be deleted if user closes it or if it is hidden (default: Hidden, False)&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa13a84ff63b8195f7c98d508cde1f0b6"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aa13a84ff63b8195f7c98d508cde1f0b6" args="(pyUiShow_doc,&quot;show([modal=0]) &#45;&gt; shows initialized UI&#45;Dialog \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
modal : {int}, optional \n\
    * 0: non&#45;modal (default)\n\
    * 1: modal (python waits until dialog is hidden)\n\
    * 2: modal (python returns immediately)\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
hide()&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiShow_doc,&quot;show([modal=0]) -&gt; shows initialized UI-Dialog \n\
\n\
Parameters \n\
----------- \n\
modal : {int}, optional \n\
    * 0: non-modal (default)\n\
    * 1: modal (python waits until dialog is hidden)\n\
    * 2: modal (python returns immediately)\n\
\n\
See Also \n\
--------- \n\
hide()&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf0f21d6d637a1ca5d4c7e2a1df33761"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="acf0f21d6d637a1ca5d4c7e2a1df33761" args="(pyUiHide_doc,&quot;hide() &#45;&gt; hides initialized user interface \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
show(modal)&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiHide_doc,&quot;hide() -&gt; hides initialized user interface \n\
\n\
See Also \n\
--------- \n\
show(modal)&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8eeda85acc354e590ac20be8cf8c90fa"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a8eeda85acc354e590ac20be8cf8c90fa" args="(pyUiIsVisible_doc,&quot;isVisible() &#45;&gt; returns true if dialog is still visible\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
visibility : {bool} \n\
    True if user interface is visible, False if it is hidden&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiIsVisible_doc,&quot;isVisible() -&gt; returns true if dialog is still visible\n\
\n\
Returns \n\
------- \n\
visibility : {bool} \n\
    True if user interface is visible, False if it is hidden&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae82eaef18c18910d114050fe7545119d"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ae82eaef18c18910d114050fe7545119d" args="(pyUiGetDouble_doc,&quot;getDouble(title, label, defaultValue [, min, max, decimals=3]) &#45;&gt; shows a dialog to get a double value from the user\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
title : {str}\n\
    is the dialog title \n\
label : {str}\n\
    is the label above the spin box \n\
defaultValue : {double}, optional\n\
    is the default value in the spin box \n\
min : {double}, optional\n\
    default = &#45;2147483647.0\n\
    is the allowed minimal value\n\
max : {double}, optional\n\
    default = 2147483647.0\n\
    is the allowed maximal value\n\
decimals : {int}, optional\n\
    the maximum number of decimal places (default: 1) \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {tuple (double, bool)} \n\
    A tuple where the first value contains the current double value. The second value is True if the dialog has been accepted, else False. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getInt, getText, getItem&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetDouble_doc,&quot;getDouble(title, label, defaultValue [, min, max, decimals=3]) -&gt; shows a dialog to get a double value from the user\n\
\n\
Parameters \n\
----------- \n\
title : {str}\n\
    is the dialog title \n\
label : {str}\n\
    is the label above the spin box \n\
defaultValue : {double}, optional\n\
    is the default value in the spin box \n\
min : {double}, optional\n\
    default = -2147483647.0\n\
    is the allowed minimal value\n\
max : {double}, optional\n\
    default = 2147483647.0\n\
    is the allowed maximal value\n\
decimals : {int}, optional\n\
    the maximum number of decimal places (default: 1) \n\
\n\
Returns \n\
------- \n\
out : {tuple (double, bool)} \n\
    A tuple where the first value contains the current double value. The second value is True if the dialog has been accepted, else False. \n\
\n\
See Also \n\
--------- \n\
getInt, getText, getItem&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6200a2df9b2f736d8bb5f8ce33ab87ba"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a6200a2df9b2f736d8bb5f8ce33ab87ba" args="(pyUiGetInt_doc,&quot;getInt(title, label, defaultValue [, min, max, step=1]) &#45;&gt; shows a dialog to get an integer value from the user\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
title : {str}\n\
    is the dialog title \n\
label : {str}\n\
    is the label above the spinbox \n\
defaultValue : {int}, optional\n\
    is the default value in the spinbox \n\
min : {int}, optional\n\
    is the allowed minimal value (default: &#45;2147483647) \n\
max : {int}, optional\n\
    is the allowed maximal value (default: 2147483647) \n\
step : {int}, optional\n\
    is the step size if user presses the up/down arrow (default: 1)\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {tuple (int, bool)} \n\
    A tuple where the first value contains the current integer value. The second value is True if the dialog has been accepted, else False. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getDouble, getText, getItem&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetInt_doc,&quot;getInt(title, label, defaultValue [, min, max, step=1]) -&gt; shows a dialog to get an integer value from the user\n\
\n\
Parameters \n\
----------- \n\
title : {str}\n\
    is the dialog title \n\
label : {str}\n\
    is the label above the spinbox \n\
defaultValue : {int}, optional\n\
    is the default value in the spinbox \n\
min : {int}, optional\n\
    is the allowed minimal value (default: -2147483647) \n\
max : {int}, optional\n\
    is the allowed maximal value (default: 2147483647) \n\
step : {int}, optional\n\
    is the step size if user presses the up/down arrow (default: 1)\n\
\n\
Returns \n\
------- \n\
out : {tuple (int, bool)} \n\
    A tuple where the first value contains the current integer value. The second value is True if the dialog has been accepted, else False. \n\
\n\
See Also \n\
--------- \n\
getDouble, getText, getItem&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88d90ff03bb402dad9600d7b334e0560"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a88d90ff03bb402dad9600d7b334e0560" args="(pyUiGetItem_doc,&quot;getItem(title, label, stringList [, currentIndex=0, editable=True]) &#45;&gt; shows a dialog to let the user select an item from a string list\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
title : {str}\n\
    is the dialog title \n\
label : {str}\n\
    is the label above the text box \n\
stringList : {tuple or list}, optional \n\
    is a list or tuple of possible string values \n\
currentIndex : {int}, optional\n\
    defines the preselected value index (default: 0)\n\
editable : {bool}, optional\n\
    defines whether new entries can be added (True) or not (False, default)\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {tuple (str, bool)} \n\
    A tuple where the first value contains the current active or typed string value. The second value is True if the dialog has been accepted, else False. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getInt, getDouble, getText&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetItem_doc,&quot;getItem(title, label, stringList [, currentIndex=0, editable=True]) -&gt; shows a dialog to let the user select an item from a string list\n\
\n\
Parameters \n\
----------- \n\
title : {str}\n\
    is the dialog title \n\
label : {str}\n\
    is the label above the text box \n\
stringList : {tuple or list}, optional \n\
    is a list or tuple of possible string values \n\
currentIndex : {int}, optional\n\
    defines the preselected value index (default: 0)\n\
editable : {bool}, optional\n\
    defines whether new entries can be added (True) or not (False, default)\n\
\n\
Returns \n\
------- \n\
out : {tuple (str, bool)} \n\
    A tuple where the first value contains the current active or typed string value. The second value is True if the dialog has been accepted, else False. \n\
\n\
See Also \n\
--------- \n\
getInt, getDouble, getText&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55cade454c0ed0dba9bc2392103394d6"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a55cade454c0ed0dba9bc2392103394d6" args="(pyUiGetText_doc,&quot;getText(title, label, defaultString) &#45;&gt; opens a dialog in order to ask the user for a string \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
title : {str}\n\
    is the dialog title \n\
label : {str}\n\
    is the label above the text box \n\
defaultString : {str}\n\
    is the default string in the text box\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {tuple (str, bool)} \n\
    A tuple where the first value contains the current string value. The second value is True if the dialog has been accepted, else False. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getInt, getDouble, getItem&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetText_doc,&quot;getText(title, label, defaultString) -&gt; opens a dialog in order to ask the user for a string \n\
Parameters \n\
----------- \n\
title : {str}\n\
    is the dialog title \n\
label : {str}\n\
    is the label above the text box \n\
defaultString : {str}\n\
    is the default string in the text box\n\
\n\
Returns \n\
------- \n\
out : {tuple (str, bool)} \n\
    A tuple where the first value contains the current string value. The second value is True if the dialog has been accepted, else False. \n\
\n\
See Also \n\
--------- \n\
getInt, getDouble, getItem&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65d2ee5abda6b86f7beb61086e7314e2"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a65d2ee5abda6b86f7beb61086e7314e2" args="(pyUiMsgInformation_doc,&quot;msgInformation(title, text [, buttons, defaultButton, parent]) &#45;&gt; opens an information message box \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
title : {str}\n\
    is the message box title \n\
text : {str}\n\
    is the message text \n\
buttons : {int}, optional\n\
    is an or&#45;combination of ui.MsgBox[...]&#45;constants indicating the buttons to display. Use | for the or&#45;combination. \n\
defaultButton : {int}, optional\n\
    is a value of ui.MsgBox[...] which indicates the default button \n\
parent : {ui}, optional\n\
    is the parent dialog of the message box.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
msgCritical, msgQuestion, msgWarning&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiMsgInformation_doc,&quot;msgInformation(title, text [, buttons, defaultButton, parent]) -&gt; opens an information message box \n\
\n\
Parameters \n\
----------- \n\
title : {str}\n\
    is the message box title \n\
text : {str}\n\
    is the message text \n\
buttons : {int}, optional\n\
    is an or-combination of ui.MsgBox[...]-constants indicating the buttons to display. Use | for the or-combination. \n\
defaultButton : {int}, optional\n\
    is a value of ui.MsgBox[...] which indicates the default button \n\
parent : {ui}, optional\n\
    is the parent dialog of the message box.\n\
\n\
See Also \n\
--------- \n\
msgCritical, msgQuestion, msgWarning&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a826b4d74813e000ae91c1e3bea183869"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a826b4d74813e000ae91c1e3bea183869" args="(pyUiMsgQuestion_doc,&quot;msgQuestion(title, text [, buttons, defaultButton, parent]) &#45;&gt; opens a question message box \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
title : {str}\n\
    is the message box title \n\
text : {str}\n\
    is the message text \n\
buttons : {int}, optional\n\
    is an or&#45;combination of ui.MsgBox[...]&#45;constants indicating the buttons to display. Use | for the or&#45;combination. \n\
defaultButton : {int}, optional\n\
    is a value of ui.MsgBox[...] which indicates the default button \n\
parent : {ui}, optional\n\
    is the parent dialog of the message box.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
msgCritical, msgWarning, msgInformation&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiMsgQuestion_doc,&quot;msgQuestion(title, text [, buttons, defaultButton, parent]) -&gt; opens a question message box \n\
\n\
Parameters \n\
----------- \n\
title : {str}\n\
    is the message box title \n\
text : {str}\n\
    is the message text \n\
buttons : {int}, optional\n\
    is an or-combination of ui.MsgBox[...]-constants indicating the buttons to display. Use | for the or-combination. \n\
defaultButton : {int}, optional\n\
    is a value of ui.MsgBox[...] which indicates the default button \n\
parent : {ui}, optional\n\
    is the parent dialog of the message box.\n\
\n\
See Also \n\
--------- \n\
msgCritical, msgWarning, msgInformation&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90b4b9e4613bcd6213df13b16eb39302"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a90b4b9e4613bcd6213df13b16eb39302" args="(pyUiMsgWarning_doc,&quot;msgWarning(title, text [, buttons, defaultButton, parent]) &#45;&gt; opens a warning message box \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
title : {str}\n\
    is the message box title \n\
text : {str}\n\
    is the message text \n\
buttons : {int}, optional\n\
    is an or&#45;combination of ui.MsgBox[...]&#45;constants indicating the buttons to display. Use | for the or&#45;combination. \n\
defaultButton : {int}, optional\n\
    is a value of ui.MsgBox[...] which indicates the default button \n\
parent : {ui}, optional\n\
    is the parent dialog of the message box.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
msgCritical, msgQuestion, msgInformation&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiMsgWarning_doc,&quot;msgWarning(title, text [, buttons, defaultButton, parent]) -&gt; opens a warning message box \n\
\n\
Parameters \n\
----------- \n\
title : {str}\n\
    is the message box title \n\
text : {str}\n\
    is the message text \n\
buttons : {int}, optional\n\
    is an or-combination of ui.MsgBox[...]-constants indicating the buttons to display. Use | for the or-combination. \n\
defaultButton : {int}, optional\n\
    is a value of ui.MsgBox[...] which indicates the default button \n\
parent : {ui}, optional\n\
    is the parent dialog of the message box.\n\
\n\
See Also \n\
--------- \n\
msgCritical, msgQuestion, msgInformation&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a151a3be32bcaf6ae1357e6aba7a3d293"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a151a3be32bcaf6ae1357e6aba7a3d293" args="(pyUiMsgCritical_doc,&quot;msgCritical(title, text [, buttons, defaultButton, parent]) &#45;&gt; opens a critical message box \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
title : {str}\n\
    is the message box title \n\
text : {str}\n\
    is the message text \n\
buttons : {int}, optional\n\
    is an or&#45;combination of ui.MsgBox[...]&#45;constants indicating the buttons to display. Use | for the or&#45;combination. \n\
defaultButton : {int}, optional\n\
    is a value of ui.MsgBox[...] which indicates the default button \n\
parent : {ui}, optional\n\
    is the parent dialog of the message box.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
msgWarning, msgQuestion, msgInformation&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiMsgCritical_doc,&quot;msgCritical(title, text [, buttons, defaultButton, parent]) -&gt; opens a critical message box \n\
\n\
Parameters \n\
----------- \n\
title : {str}\n\
    is the message box title \n\
text : {str}\n\
    is the message text \n\
buttons : {int}, optional\n\
    is an or-combination of ui.MsgBox[...]-constants indicating the buttons to display. Use | for the or-combination. \n\
defaultButton : {int}, optional\n\
    is a value of ui.MsgBox[...] which indicates the default button \n\
parent : {ui}, optional\n\
    is the parent dialog of the message box.\n\
\n\
See Also \n\
--------- \n\
msgWarning, msgQuestion, msgInformation&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73da46be6e6b36d9b34b253e130c9e23"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a73da46be6e6b36d9b34b253e130c9e23" args="(pyUiGetExistingDirectory_doc,&quot;getExistingDirectory(caption, startDirectory [, options, parent]) &#45;&gt; opens a dialog to choose an existing directory \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
caption : {str}\n\
    is the caption of this dialog \n\
startDirectory : {str}\n\
    is the start directory \n\
options : {int}, optional\n\
    is an or&#45;combination of the following options (see 'QFileDialog::Option'): \n\
    \n\
        * 1: ShowDirsOnly [default] \n\
        * 2: DontResolveSymlinks \n\
        * ... (for others see Qt&#45;Help) \n\
parent : {ui}, optional\n\
    is a parent dialog or window, this dialog becomes modal.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {str, None} \n\
    The selected directory is returned as absolute path or None if the dialog has been rejected. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getSaveFileName, getOpenFileName&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetExistingDirectory_doc,&quot;getExistingDirectory(caption, startDirectory [, options, parent]) -&gt; opens a dialog to choose an existing directory \n\
\n\
Parameters \n\
----------- \n\
caption : {str}\n\
    is the caption of this dialog \n\
startDirectory : {str}\n\
    is the start directory \n\
options : {int}, optional\n\
    is an or-combination of the following options (see 'QFileDialog::Option'): \n\
    \n\
        * 1: ShowDirsOnly [default] \n\
        * 2: DontResolveSymlinks \n\
        * ... (for others see Qt-Help) \n\
parent : {ui}, optional\n\
    is a parent dialog or window, this dialog becomes modal.\n\
\n\
Returns \n\
------- \n\
out : {str, None} \n\
    The selected directory is returned as absolute path or None if the dialog has been rejected. \n\
\n\
See Also \n\
--------- \n\
getSaveFileName, getOpenFileName&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ea4918f79b017780b94484105425473"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a7ea4918f79b017780b94484105425473" args="(pyUiGetOpenFileName_doc,&quot;getOpenFileName([caption, startDirectory, filters, selectedFilterIndex, options, parent]) &#45;&gt; opens dialog for chosing an existing file. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
caption : {str}, optional\n\
    This is the optional title of the dialog, default: no title \n\
startDirectory {str}, optional\n\
    optional, if not indicated currentDirectory will be taken\n\
filters : {str}, optional\n\
    default = 0\n\
    possible filter list, entries should be separated by ;; , e.g. 'Images (*.png *.jpg);;Text files (*.txt)' \n\
selectedFilterIndex : {int}, optional \n\
    is the index of filters which is set by default (0 is first entry) \n\
options : {int}, optional\n\
    default =  0 \n\
    or&#45;combination of enum values QFileDialog::Options \n\
parent : {ui}, optional\n\
    is the parent widget of this dialog \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {str, None} \n\
    filename as string or None if dialog has been aborted.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getSaveFileName&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetOpenFileName_doc,&quot;getOpenFileName([caption, startDirectory, filters, selectedFilterIndex, options, parent]) -&gt; opens dialog for chosing an existing file. \n\
\n\
Parameters \n\
----------- \n\
caption : {str}, optional\n\
    This is the optional title of the dialog, default: no title \n\
startDirectory {str}, optional\n\
    optional, if not indicated currentDirectory will be taken\n\
filters : {str}, optional\n\
    default = 0\n\
    possible filter list, entries should be separated by ;; , e.g. 'Images (*.png *.jpg);;Text files (*.txt)' \n\
selectedFilterIndex : {int}, optional \n\
    is the index of filters which is set by default (0 is first entry) \n\
options : {int}, optional\n\
    default =  0 \n\
    or-combination of enum values QFileDialog::Options \n\
parent : {ui}, optional\n\
    is the parent widget of this dialog \n\
\n\
Returns \n\
------- \n\
out : {str, None} \n\
    filename as string or None if dialog has been aborted.\n\
\n\
See Also \n\
--------- \n\
getSaveFileName&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0058e5da6237db71bb2fd856c9d5fbc"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ab0058e5da6237db71bb2fd856c9d5fbc" args="(pyUiGetSaveFileName_doc,&quot;getSaveFileName([caption, startDirectory, filters, selectedFilterIndex, options, parent]) &#45;&gt; opens dialog for chosing a file to save. \n\
\n\
This method creates a modal file dialog to let the user select a file name used for saving a file. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
caption : {str}, optional\n\
    This is the title of the dialog \n\
startDirectory : {String}, optional\n\
    if not indicated, the current working directory will be taken\n\
filters : {str}, optional\n\
    possible filter list, entries should be separated by ;; , e.g. 'Images (*.png *.jpg);;Text files (*.txt)' \n\
selectedFilterIndex : {int}, optional\n\
    default = 0\n\
    is the index of filters which is set by default (0 is first entry) \n\
options : {int}, optional\n\
    default = 0\n\
    or&#45;combination of enum values QFileDialog::Options \n\
parent : {ui}, optional\n\
    is the parent widget of this dialog\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
out : {str, None} \n\
    filename as string or None if dialog has been aborted.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getOpenFileName&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetSaveFileName_doc,&quot;getSaveFileName([caption, startDirectory, filters, selectedFilterIndex, options, parent]) -&gt; opens dialog for chosing a file to save. \n\
\n\
This method creates a modal file dialog to let the user select a file name used for saving a file. \n\
\n\
Parameters \n\
----------- \n\
caption : {str}, optional\n\
    This is the title of the dialog \n\
startDirectory : {String}, optional\n\
    if not indicated, the current working directory will be taken\n\
filters : {str}, optional\n\
    possible filter list, entries should be separated by ;; , e.g. 'Images (*.png *.jpg);;Text files (*.txt)' \n\
selectedFilterIndex : {int}, optional\n\
    default = 0\n\
    is the index of filters which is set by default (0 is first entry) \n\
options : {int}, optional\n\
    default = 0\n\
    or-combination of enum values QFileDialog::Options \n\
parent : {ui}, optional\n\
    is the parent widget of this dialog\n\
\n\
Returns \n\
------- \n\
out : {str, None} \n\
    filename as string or None if dialog has been aborted.\n\
\n\
See Also \n\
--------- \n\
getOpenFileName&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb50d383645a1722d46fb5f5fd4304aa"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="abb50d383645a1722d46fb5f5fd4304aa" args="(pyUiCreateNewPluginWidget_doc,&quot;createNewPluginWidget(widgetName[, mandparams, optparams]) &#45;&gt; creates widget defined by any algorithm plugin and returns the instance of type 'ui' \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
widgetName : {}\n\
    name algorithm widget \n\
    parameters to pass to the plugin. The parameters are parsed and unnamed parameters are used in their \
    incoming order to fill first mandatory parameters and afterwards optional parameters. Parameters may be passed \
    with name as well but after the first named parameter no more unnamed parameters are allowed.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiCreateNewPluginWidget_doc,&quot;createNewPluginWidget(widgetName[, mandparams, optparams]) -&gt; creates widget defined by any algorithm plugin and returns the instance of type 'ui' \n\
Parameters \n\
----------- \n\
widgetName : {}\n\
    name algorithm widget \n\
    parameters to pass to the plugin. The parameters are parsed and unnamed parameters are used in their \
    incoming order to fill first mandatory parameters and afterwards optional parameters. Parameters may be passed \
    with name as well but after the first named parameter no more unnamed parameters are allowed.\n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a229a104cda32f28bd536787dfc8a5687"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a229a104cda32f28bd536787dfc8a5687" args="(PyTimerInit_doc,&quot;timer(interval, callbackFunc, [argTuple]) &#45;&gt; new callback timer \n\
\n\
Creates a timer object that continuously calls a python callback function or method with a certain interval. The timer is active after construction and \n\
stops when this instance is destroyed or stop() is called. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
interval : {double} \n\
    time out interval in ms \n\
callbackFunc: {function, method} \n\
    Python function that should be called when timer event raises \n\
argTuple: {tuple}, optional \n\
    tuple of parameters passed as arguments to the callback function&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyTimerInit_doc,&quot;timer(interval, callbackFunc, [argTuple]) -&gt; new callback timer \n\
\n\
Creates a timer object that continuously calls a python callback function or method with a certain interval. The timer is active after construction and \n\
stops when this instance is destroyed or stop() is called. \n\
\n\
Parameters \n\
----------- \n\
interval : {double} \n\
    time out interval in ms \n\
callbackFunc: {function, method} \n\
    Python function that should be called when timer event raises \n\
argTuple: {tuple}, optional \n\
    tuple of parameters passed as arguments to the callback function&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca71ead38adf55ff2e389fd485242e3f"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aca71ead38adf55ff2e389fd485242e3f" args="(PyTimerStart_doc,&quot;start() &#45;&gt; starts timer\n\
\n\
Starts or restarts the timer with its timeout interval. If the timer is already running, it will be stopped and restarted.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyTimerStart_doc,&quot;start() -&gt; starts timer\n\
\n\
Starts or restarts the timer with its timeout interval. If the timer is already running, it will be stopped and restarted.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d6b6e5828f40765474e855377dfb658"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a2d6b6e5828f40765474e855377dfb658" args="(PyTimerStop_doc,&quot;stop() &#45;&gt; stops timer&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyTimerStop_doc,&quot;stop() -&gt; stops timer&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fca578abc630a5f8cdd17d7e27bb558"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a3fca578abc630a5f8cdd17d7e27bb558" args="(PyTimerIsActive_doc,&quot;isActive() &#45;&gt; returns timer status\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
status : {bool} \n\
    True if the timer is running, otherwise False.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyTimerIsActive_doc,&quot;isActive() -&gt; returns timer status\n\
\n\
Returns \n\
------- \n\
status : {bool} \n\
    True if the timer is running, otherwise False.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8c72b6f475ccee35f305ccf990b9a63"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ad8c72b6f475ccee35f305ccf990b9a63" args="(PyTimerSetInterval_doc,&quot;setInterval(interval) &#45;&gt; sets timer interval in [ms]\n\
\n\
This method sets the timeout interval in milliseconds. The timer calls the callback function continuously after this interval (if started) \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
interval : {int} \n\
    timeout interval in milliseconds. The callback function is continuously called after this timeout once the timer is started.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyTimerSetInterval_doc,&quot;setInterval(interval) -&gt; sets timer interval in [ms]\n\
\n\
This method sets the timeout interval in milliseconds. The timer calls the callback function continuously after this interval (if started) \n\
\n\
Parameters \n\
----------- \n\
interval : {int} \n\
    timeout interval in milliseconds. The callback function is continuously called after this timeout once the timer is started.&quot;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad30ad071fb0c3778689aaa1483696500">CreateFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned char dimensions, const int *sizes, const unsigned char continuous, const uchar *continuousDataPtr, const int *steps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">templated method for create  <a href="#ad30ad071fb0c3778689aaa1483696500"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aed562807073a7bd48efbef4d0bd834cb">CreateFuncWithCVPlanes</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned char dimensions, const int *sizes, const cv::Mat *planes, const unsigned int nrOfPlanes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">templated method for creation with given vector of cv::Mat-planes  <a href="#aed562807073a7bd48efbef4d0bd834cb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a48b3a7f2723479d8cd742f4bf45e2143">FreeFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for freeing allocated data blocks  <a href="#a48b3a7f2723479d8cd742f4bf45e2143"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12d73ecdcc47919a26ba8d340902589e"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a12d73ecdcc47919a26ba8d340902589e" args="(FreeFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (FreeFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a712d73f1c838358d78b69fac25afbda8"></a><!-- doxytag: member="ito::SecureFreeFunc" ref="a712d73f1c838358d78b69fac25afbda8" args="(DataObject *dObj)" -->
template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SecureFreeFunc</b> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b147b959b34d59ef380276d466cd40f"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a6b147b959b34d59ef380276d466cd40f" args="(SecureFreeFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (SecureFreeFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ac375d704a83f05f7ffb2345e3d92401f">CopyToFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, unsigned char regionOnly)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for deeply copying the data of one matrix to another given matrix  <a href="#ac375d704a83f05f7ffb2345e3d92401f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70b00918c766787b2d1cf28f26b73a8f"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a70b00918c766787b2d1cf28f26b73a8f" args="(CopyToFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (CopyToFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae068ebf4f7f7632e6bbf58ca4030c117">DeepCopyPartialFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method to copy the values of the ROI of matrix lhs to the ROI of matrix rhs.  <a href="#ae068ebf4f7f7632e6bbf58ca4030c117"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d6bc2b9a495a2eb034bb4dbf560d04b"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a3d6bc2b9a495a2eb034bb4dbf560d04b" args="(DeepCopyPartialFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (DeepCopyPartialFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab9c26379b46a3de6f731aef5bc68c3f0">ConvertToFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, const int type, const double alpha, const double beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts data in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> lhs to <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> rhs with a given type  <a href="#ab9c26379b46a3de6f731aef5bc68c3f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46c9406cd13e3319f6e4c78a17b3acc7"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a46c9406cd13e3319f6e4c78a17b3acc7" args="(ConvertToFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (ConvertToFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aca27764ec31c2bc8c84b8ecde1d48e2d">ZerosFunc</a> (const int sizeY, const int sizeX, uchar **dstMat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for creation of zero-valued matrix-plane  <a href="#aca27764ec31c2bc8c84b8ecde1d48e2d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a959a36992393397a775dcf93deb711cc"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a959a36992393397a775dcf93deb711cc" args="(ZerosFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (ZerosFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab6bf15ce0d6fe4193e28f2dc8ff203b6">OnesFunc</a> (const int sizeY, const int sizeX, uchar **dstMat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for creation of one-valued matrix-plane  <a href="#ab6bf15ce0d6fe4193e28f2dc8ff203b6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa55fb8a70f604f782396343a4bc14111">OnesFunc&lt; ito::Rgba32 &gt;</a> (const int sizeY, const int sizeX, uchar **dstMat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, overloaded template method for creation of one-valued matrix-plane of RGBA32  <a href="#aa55fb8a70f604f782396343a4bc14111"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a703ce71ad83db052ab6d3f552bdfe51e"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a703ce71ad83db052ab6d3f552bdfe51e" args="(OnesFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (OnesFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a2624af727dd0e527b47944104f86bfe4">RandFunc</a> (const int sizeY, const int sizeX, const double value1, const double value2, const bool randMode, uchar **dstMat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for creation of random-valued matrix-plane  <a href="#a2624af727dd0e527b47944104f86bfe4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8f01949773094d46c7a3c54dc41f13cc">RandFunc&lt; ito::complex128 &gt;</a> (const int sizeY, const int sizeX, const double value1, const double value2, const bool randMode, uchar **dstMat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for low-level, templated method for creation of random-valued matrix-plane of type complex128  <a href="#a8f01949773094d46c7a3c54dc41f13cc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab712cc635923ca500edad215ec837ca1">RandFunc&lt; ito::Rgba32 &gt;</a> (const int sizeY, const int sizeX, const double value1, const double value2, const bool randMode, uchar **dstMat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for low-level, templated method for creation of random-valued matrix-plane of type rgba32  <a href="#ab712cc635923ca500edad215ec837ca1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b5622772cb7e9b8e058588c74e918f0"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a0b5622772cb7e9b8e058588c74e918f0" args="(RandFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (RandFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a82f94c3dcf589bc7d8725df540411b5e">CopyMatFunc</a> (uchar **src, uchar **&amp;dst, bool transposed, const int sizeofs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method that executes a shallow-copy of every matrix-plane in the source-vector and stores the copies in the destination-vector  <a href="#a82f94c3dcf589bc7d8725df540411b5e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab906bd5c49c329cdec15ced6d37dbc4f">AssignScalarFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> type, const void *scalar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated helper method to assign the given scalar to every element within its ROI in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> src.  <a href="#ab906bd5c49c329cdec15ced6d37dbc4f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70cffb505679d9b9f57fa17777909920"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a70cffb505679d9b9f57fa17777909920" args="(AssignScalarFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (AssignScalarFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a5dd3e10e1693f1e30da07735aaa05281">AddFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjRes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for element-wise addition of two given data objects.  <a href="#a5dd3e10e1693f1e30da07735aaa05281"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b1c79b91475d5cb9717d5d26eb51fd3"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a5b1c79b91475d5cb9717d5d26eb51fd3" args="(AddFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (AddFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a19d4cd0a1d97615ef44f688c973f0c4c"></a><!-- doxytag: member="ito::AddScalarFunc" ref="a19d4cd0a1d97615ef44f688c973f0c4c" args="(const DataObject *dObjIn, ito::float64 scalar, DataObject *dObjOut)" -->
template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AddScalarFunc</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjIn, ito::float64 scalar, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2977804e858e95f2f63e9ff04a9b240a"></a><!-- doxytag: member="ito::AddScalarFunc&lt; ito::Rgba32 &gt;" ref="a2977804e858e95f2f63e9ff04a9b240a" args="(const DataObject *dObjIn, ito::float64 scalar, DataObject *dObjOut)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AddScalarFunc&lt; ito::Rgba32 &gt;</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjIn, ito::float64 scalar, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac99f2d9dd8a9d7dc93a2ee8386ab8e9e"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="ac99f2d9dd8a9d7dc93a2ee8386ab8e9e" args="(AddScalarFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (AddScalarFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad2d8c3cc6f057d60ca82b03266db2e24">SubFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjRes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for element-wise subtraction of values from second data object from values of first data object  <a href="#ad2d8c3cc6f057d60ca82b03266db2e24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a5e6e41fcf95987cb8eddcdbaf95b34"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a7a5e6e41fcf95987cb8eddcdbaf95b34" args="(SubFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (SubFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a5c1b3f43be5840d203b2811c77352321">OpMulFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjRes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">brief description  <a href="#a5c1b3f43be5840d203b2811c77352321"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a871edc6ab6966c9e12dc3ab4c08682e6"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a871edc6ab6966c9e12dc3ab4c08682e6" args="(OpMulFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (OpMulFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab074a2771541dde53ff60788300cc57e">OpScalarMulFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const double &amp;factor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which multiplies every element of Data Object with a factor  <a href="#ab074a2771541dde53ff60788300cc57e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aabceaf9b7c05174c8399da0bd64027c7"></a><!-- doxytag: member="ito::OpScalarMulFunc&lt; ito::complex64 &gt;" ref="aabceaf9b7c05174c8399da0bd64027c7" args="(const DataObject *src, const double &amp;factor)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>OpScalarMulFunc&lt; ito::complex64 &gt;</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const double &amp;factor)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="adfc151fe4524b8faed3e224a1928a8a5"></a><!-- doxytag: member="ito::OpScalarMulFunc&lt; ito::complex128 &gt;" ref="adfc151fe4524b8faed3e224a1928a8a5" args="(const DataObject *src, const double &amp;factor)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>OpScalarMulFunc&lt; ito::complex128 &gt;</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const double &amp;factor)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a10292dae014ef11ed5e6992b4de17dd5"></a><!-- doxytag: member="ito::OpScalarMulFunc&lt; ito::Rgba32 &gt;" ref="a10292dae014ef11ed5e6992b4de17dd5" args="(const DataObject *src, const double &amp;factor)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>OpScalarMulFunc&lt; ito::Rgba32 &gt;</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const double &amp;factor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cd67b8ca703db1f6610f6b1e2b62701"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a1cd67b8ca703db1f6610f6b1e2b62701" args="(OpScalarMulFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (OpScalarMulFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8bdbe9e0f2a8158cc8e4af6694e7199a">CmpFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst, int cmpOp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which compares each element in source-matrix1 with its corresponding element in source-matrix2 and saves the result in a destionation matrix  <a href="#a8bdbe9e0f2a8158cc8e4af6694e7199a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a32f1d686e00348be5244f8f01b6d7136">CmpFunc&lt; ito::complex64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for compare function of type complex64  <a href="#a32f1d686e00348be5244f8f01b6d7136"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af7e09f29422f9db84dec13b03bdd6ede">CmpFunc&lt; ito::complex128 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for compare function of type complex128  <a href="#af7e09f29422f9db84dec13b03bdd6ede"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8672ba101025b2928b4a284710e878d"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="ae8672ba101025b2928b4a284710e878d" args="(CmpFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (CmpFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#acd91185af2ccfa90ce18b19f24a57001">ShiftLFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const unsigned char shiftbit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which element-wisely shifts the values of the source matrix by a certain value to the left  <a href="#acd91185af2ccfa90ce18b19f24a57001"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a3a675b71966a82791d5eba43de0a0374">ShiftLFunc&lt; ito::float32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type float32  <a href="#a3a675b71966a82791d5eba43de0a0374"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#add7324b4bc5f6fc83283a472e9ca58c5">ShiftLFunc&lt; ito::float64 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type float64  <a href="#add7324b4bc5f6fc83283a472e9ca58c5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a9bbd413896cb54e3377f7535b2563932">ShiftLFunc&lt; ito::complex64 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type complex64  <a href="#a9bbd413896cb54e3377f7535b2563932"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a3d19da92789a250b5a8c2f95bd2cdfc7">ShiftLFunc&lt; ito::complex128 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type complex128  <a href="#a3d19da92789a250b5a8c2f95bd2cdfc7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#acc20ff592a9d1158c05fc00d96623d4a">ShiftLFunc&lt; ito::Rgba32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type rgba32  <a href="#acc20ff592a9d1158c05fc00d96623d4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5006e9d24601a9faad68be2dafaf3d7"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="aa5006e9d24601a9faad68be2dafaf3d7" args="(ShiftLFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (ShiftLFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a012536094b126f7906e30268a81d376a">ShiftRFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const unsigned char shiftbit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which element-wisely shifts the values of the source matrix by a certain value to the right  <a href="#a012536094b126f7906e30268a81d376a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa4bfa2747f0b55d14e1bf28c52f1d4e6">ShiftRFunc&lt; ito::float32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type float32  <a href="#aa4bfa2747f0b55d14e1bf28c52f1d4e6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a44011c28772f9e51cb33f1c57a780c9a">ShiftRFunc&lt; ito::float64 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type float64  <a href="#a44011c28772f9e51cb33f1c57a780c9a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a5f0ede49fa5819fc3c95d4296e88d201">ShiftRFunc&lt; ito::complex64 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type complex64  <a href="#a5f0ede49fa5819fc3c95d4296e88d201"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8d57c41b81f19337e7bfdc81d9b58db8">ShiftRFunc&lt; ito::complex128 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type complex128  <a href="#a8d57c41b81f19337e7bfdc81d9b58db8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8c637c5f859dca6bef49d76a3ba98cf4">ShiftRFunc&lt; ito::Rgba32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type rgba32  <a href="#a8c637c5f859dca6bef49d76a3ba98cf4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a36f6653fc2e93fa9e05a74ba911e68c0">BitAndFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjRes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which element-wisely executes a bitwise 'and' comparison between values of two dataObjects.  <a href="#a36f6653fc2e93fa9e05a74ba911e68c0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ac3b9612ec312c7e46d300d42bcd02242">BitAndFunc&lt; ito::float32 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise and function of type float32  <a href="#ac3b9612ec312c7e46d300d42bcd02242"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#afba173abe8d18b8d82353e38aea5d465">BitAndFunc&lt; ito::float64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise and function of type float64  <a href="#afba173abe8d18b8d82353e38aea5d465"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a4dcc23c3256b099a16506d298fc3d927">BitAndFunc&lt; ito::complex64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise and function of type complex64  <a href="#a4dcc23c3256b099a16506d298fc3d927"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a78662303641cb24385aad7139c0a1d30">BitAndFunc&lt; ito::complex128 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise and function of type complex128  <a href="#a78662303641cb24385aad7139c0a1d30"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a0a0bad27ae6f994af924da15bc55c0c1">BitAndFunc&lt; ito::Rgba32 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise and function of type rgba32  <a href="#a0a0bad27ae6f994af924da15bc55c0c1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#acb6cabed2d1b3df8a95db570132d0e29">BitOrFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjRes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which element-wisely executes a bitwise 'or' comparison between values of two dataObjects.  <a href="#acb6cabed2d1b3df8a95db570132d0e29"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aade7fb86bff699af4477b297e4d625cf">BitOrFunc&lt; ito::float32 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise or function of type float32  <a href="#aade7fb86bff699af4477b297e4d625cf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad01b8208a17f67c1d7b0ec4262b8a2a0">BitOrFunc&lt; ito::float64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise or function of type float64  <a href="#ad01b8208a17f67c1d7b0ec4262b8a2a0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa25108db00a8349be082338f1417e958">BitOrFunc&lt; ito::complex64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise or function of type complex64  <a href="#aa25108db00a8349be082338f1417e958"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#adfc93c8233d17e52bd44e045897d0916">BitOrFunc&lt; ito::complex128 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise or function of type complex128  <a href="#adfc93c8233d17e52bd44e045897d0916"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a9f3b4656da31b1e0a51d19484d17ef4d">BitOrFunc&lt; ito::Rgba32 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise or function of type rgba32  <a href="#a9f3b4656da31b1e0a51d19484d17ef4d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a11f97d7189ad80ea550fd4325d41a29c">BitXorFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjRes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which element-wisely executes a bitwise 'xor' comparison between values of two dataObjects.  <a href="#a11f97d7189ad80ea550fd4325d41a29c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a33d5ffa96340984f96d02bbec6603638">BitXorFunc&lt; ito::float32 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise xor function of type float32  <a href="#a33d5ffa96340984f96d02bbec6603638"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a7623e7de6c0e8360952a7203c241ce3b">BitXorFunc&lt; ito::float64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise xor function of type float64  <a href="#a7623e7de6c0e8360952a7203c241ce3b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a761fb541ef52a71872a933ce2209a212">BitXorFunc&lt; ito::complex64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise xor function of type complex64  <a href="#a761fb541ef52a71872a933ce2209a212"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aab491ad268dbeb1feceaaf023fc3e94b">BitXorFunc&lt; ito::complex128 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise xor function of type complex128  <a href="#aab491ad268dbeb1feceaaf023fc3e94b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a9ad9e33602b68e433f2846cd58cf1f3e">BitXorFunc&lt; ito::Rgba32 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise xor function of type complex128  <a href="#a9ad9e33602b68e433f2846cd58cf1f3e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a5cacfeb427e8f0e5aa0dcad1b7ba181b">GetRangeFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const int dtop, const int dbottom, const int dleft, const int dright)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for saving a shallow copy of a source cv::Mat_ to a destination cv::Mat_ with respect to given row- and col-ranges  <a href="#a5cacfeb427e8f0e5aa0dcad1b7ba181b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad5c7411f47d3ef288089d9d9b9c65a03">AdjustROIFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, int dtop, int dbottom, int dleft, int dright)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for adjusting the ROI of a data object by the given incremental values  <a href="#ad5c7411f47d3ef288089d9d9b9c65a03"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab6be2a7a7c372536725139e73909c868">EyeFunc</a> (const int size, uchar **dstMat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for creating an eye-matrix  <a href="#ab6be2a7a7c372536725139e73909c868"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aba158d7c2c7d75c44740247048078bd3">ConjFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for calculating the conjugated value of each element within the ROI of this data object  <a href="#aba158d7c2c7d75c44740247048078bd3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ac72c9e2ba2c4df5af96587cac3462da3"></a><!-- doxytag: member="ito::ConjFunc&lt; int8 &gt;" ref="ac72c9e2ba2c4df5af96587cac3462da3" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ac72c9e2ba2c4df5af96587cac3462da3">ConjFunc&lt; int8 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type int8. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a0876eab6cf9601a23060bfea271901e1"></a><!-- doxytag: member="ito::ConjFunc&lt; uint8 &gt;" ref="a0876eab6cf9601a23060bfea271901e1" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a0876eab6cf9601a23060bfea271901e1">ConjFunc&lt; uint8 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type uint8. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a7da477e97b9a39c9c6ee1e79e8abda41"></a><!-- doxytag: member="ito::ConjFunc&lt; int16 &gt;" ref="a7da477e97b9a39c9c6ee1e79e8abda41" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a7da477e97b9a39c9c6ee1e79e8abda41">ConjFunc&lt; int16 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type int16. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a397612dea66e8e18d7a32e19baae0d64"></a><!-- doxytag: member="ito::ConjFunc&lt; uint16 &gt;" ref="a397612dea66e8e18d7a32e19baae0d64" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a397612dea66e8e18d7a32e19baae0d64">ConjFunc&lt; uint16 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type uint16. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad0c1fd7eb3a5572d4eca4c4d3ef57a4b"></a><!-- doxytag: member="ito::ConjFunc&lt; int32 &gt;" ref="ad0c1fd7eb3a5572d4eca4c4d3ef57a4b" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad0c1fd7eb3a5572d4eca4c4d3ef57a4b">ConjFunc&lt; int32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type int32. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a11d688a178ddff88967cdb0d7b812c10"></a><!-- doxytag: member="ito::ConjFunc&lt; uint32 &gt;" ref="a11d688a178ddff88967cdb0d7b812c10" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a11d688a178ddff88967cdb0d7b812c10">ConjFunc&lt; uint32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type uint32. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a929eb1a698c9e07257f9662f134fc079"></a><!-- doxytag: member="ito::ConjFunc&lt; ito::float32 &gt;" ref="a929eb1a698c9e07257f9662f134fc079" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a929eb1a698c9e07257f9662f134fc079">ConjFunc&lt; ito::float32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type float32. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af906ccb4b2e4e2b76abd536283055305"></a><!-- doxytag: member="ito::ConjFunc&lt; ito::float64 &gt;" ref="af906ccb4b2e4e2b76abd536283055305" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af906ccb4b2e4e2b76abd536283055305">ConjFunc&lt; ito::float64 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type float64. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="afcde78c5b5e20be032a7ef27dca29b61"></a><!-- doxytag: member="ito::ConjFunc&lt; ito::Rgba32 &gt;" ref="afcde78c5b5e20be032a7ef27dca29b61" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#afcde78c5b5e20be032a7ef27dca29b61">ConjFunc&lt; ito::Rgba32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type float64. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1be9e96b196d20ffe222e04ec38ec368"></a><!-- doxytag: member="ito::ConjFunc&lt; int64 &gt;" ref="a1be9e96b196d20ffe222e04ec38ec368" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a1be9e96b196d20ffe222e04ec38ec368">ConjFunc&lt; int64 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type int64. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a1dd5ee04f3bb0552ee8b9761c8b766ff">RowFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned int selRow)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which changes the region of interest of the data object to the selected zero-based row index  <a href="#a1dd5ee04f3bb0552ee8b9761c8b766ff"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a60b5aca714c16446343d944b73c43aa1">ColFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned int selCol)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which changes the region of interest of the data object to the selected zero-based col index  <a href="#a60b5aca714c16446343d944b73c43aa1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a0b289da30298faa54d6ccce873640859"></a><!-- doxytag: member="ito::MulFunc" ref="a0b289da30298faa54d6ccce873640859" args="(const DataObject *src1, const DataObject *src2, DataObject *res, const double)" -->
template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MulFunc</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *res, const double)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ac6a8e6996e4df59339fa93085c606bef">DivFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *res, const double)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which does a element-wise division of elements in first source matrix by elements in second source matrix.  <a href="#ac6a8e6996e4df59339fa93085c606bef"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af75605ada5deeee4e1eab2d707ceaa50">DivFunc&lt; Rgba32 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *res, const double)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which does a element-wise division of elements in first source matrix by elements in second source matrix.  <a href="#af75605ada5deeee4e1eab2d707ceaa50"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp , typename _T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a941c59b176dfa3d9b0164fe0d58deefd">CastFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj, double alpha, double beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level templated method to cast each element of source matrix to another type.  <a href="#a941c59b176dfa3d9b0164fe0d58deefd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ace07d683e9c64406a990c456b7fd9900"></a><!-- doxytag: member="ito::GrayScaleCastFunc" ref="ace07d683e9c64406a990c456b7fd9900" args="(const DataObject *dObj, DataObject *resObj)" -->
template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GrayScaleCastFunc</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _CmplxTp , typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a161d495b681827afefce9e0318235f60">AbsFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, double templated method to save the element-wise absolute value of each element in source matrix to result matrix  <a href="#a161d495b681827afefce9e0318235f60"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a33df0458dc28449b54bc8072efd7a99c">AbsFuncReal</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method to save the element-wise absolute value of each element in source matrix to result matrix  <a href="#a33df0458dc28449b54bc8072efd7a99c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a758098011c4f6f08dd9a67916a052cfd">abs</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level value which calculates the absolute value of each element of the input source data object and returns the resulting data object  <a href="#a758098011c4f6f08dd9a67916a052cfd"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _CmplxTp , typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a05f123e54780ea7b53fadfbef4883b66">ArgFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, double templated method to save the element-wise argument of each element in source matrix to result matrix  <a href="#a05f123e54780ea7b53fadfbef4883b66"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a44eaccc88212fb67d3d2e102a7fb51dc">arg</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level value which calculates the argument value of each element of the input source data object and returns the resulting data object  <a href="#a44eaccc88212fb67d3d2e102a7fb51dc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _CmplxTp , typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a9b70d112986bf4af3188641ed32eb9ba">RealFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, double templated method to save the element-wise real value of each element in source matrix to result matrix  <a href="#a9b70d112986bf4af3188641ed32eb9ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a4d864aeb8c51f9ddb98fc6068afd96bf">real</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level value which calculates the real value of each element of the input source data object and returns the resulting data object  <a href="#a4d864aeb8c51f9ddb98fc6068afd96bf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _CmplxTp , typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a88f1f6a29d6bcd1bcd9604ac633622ec">ImagFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, double templated method to save the element-wise imaginary value of each element in source matrix to result matrix  <a href="#a88f1f6a29d6bcd1bcd9604ac633622ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a66331885ebad02c6f99d27ed34a674e7">imag</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level value which calculates the imaginary value of each element of the input source data object and returns the resulting data object  <a href="#a66331885ebad02c6f99d27ed34a674e7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#afa7884cab1fc4d64b4de411e9b0de1d5">MakeContinuousFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;resDObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which copies an incontinuously organized data object to a continuously organized resulting data object  <a href="#afa7884cab1fc4d64b4de411e9b0de1d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a0f596a4a1f37a4fe4e383180bd7c92b8">makeContinuous</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level method which copies an incontinuously organized data object to a continuously organized resulting data object, which is returned  <a href="#a0f596a4a1f37a4fe4e383180bd7c92b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af47411f52b13f2d8f6bb64b7e79e9f06"></a><!-- doxytag: member="ito::Sum" ref="af47411f52b13f2d8f6bb64b7e79e9f06" args="(T a, T b)" -->
template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Sum</b> (T a, T b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a105e4a9c34049e6b19d587313c247536">getDataType</a> (const _Tp *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">method which returns the value of enumeration <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>, which corresponds to the type of the given pointer parameter.  <a href="#a105e4a9c34049e6b19d587313c247536"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8762f2cda530225cfcf859f492fa37e5"></a><!-- doxytag: member="ito::getDataType" ref="a8762f2cda530225cfcf859f492fa37e5" args="(const uint8 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const uint8 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae7202146b25651a594d132e1c99b1926"></a><!-- doxytag: member="ito::getDataType" ref="ae7202146b25651a594d132e1c99b1926" args="(const int8 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const int8 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ab4e795afd915238ab468dd74e33c9c70"></a><!-- doxytag: member="ito::getDataType" ref="ab4e795afd915238ab468dd74e33c9c70" args="(const uint16 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const uint16 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae4061bf9ccd0ce7d75d08581b0b57657"></a><!-- doxytag: member="ito::getDataType" ref="ae4061bf9ccd0ce7d75d08581b0b57657" args="(const int16 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const int16 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a707da0e0d9b2b8a2d76e897228844597"></a><!-- doxytag: member="ito::getDataType" ref="a707da0e0d9b2b8a2d76e897228844597" args="(const uint32 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const uint32 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="abd446c265ece23a732eeba51d50cd29e"></a><!-- doxytag: member="ito::getDataType" ref="abd446c265ece23a732eeba51d50cd29e" args="(const int32 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const int32 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ac0b3a9b86d2c42c485686750698ee249"></a><!-- doxytag: member="ito::getDataType" ref="ac0b3a9b86d2c42c485686750698ee249" args="(const float32 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const float32 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a94a01a27ef5f5be25e588ad476cac7c4"></a><!-- doxytag: member="ito::getDataType" ref="a94a01a27ef5f5be25e588ad476cac7c4" args="(const float64 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const float64 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aada1e8a83f220eaad247a7f2784c0dff"></a><!-- doxytag: member="ito::getDataType" ref="aada1e8a83f220eaad247a7f2784c0dff" args="(const complex64 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const complex64 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="acf63c45b101e3f1b14602940034437e1"></a><!-- doxytag: member="ito::getDataType" ref="acf63c45b101e3f1b14602940034437e1" args="(const complex128 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const complex128 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af185edfa18841a3473ef06bf731e1ccd"></a><!-- doxytag: member="ito::getDataType" ref="af185edfa18841a3473ef06bf731e1ccd" args="(const Rgba32 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const <a class="el" href="classito_1_1_rgba32.html">Rgba32</a> *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#affa9cfef07f2dc18ee2aaa6e5f1327bc">numberConversion</a> (<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> fromType, void *scalar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">templated method for converting a given scalar value to the data type, indicated by the template parameter  <a href="#affa9cfef07f2dc18ee2aaa6e5f1327bc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae4b03fd9ae9c5fd494a375e891cd81c1"></a><!-- doxytag: member="ito::coutFunc" ref="ae4b03fd9ae9c5fd494a375e891cd81c1" args="(std::ostream &amp;out, const DataObject &amp;dObj)" -->
template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>coutFunc</b> (std::ostream &amp;out, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32585288fae2cd57c64f0188bcb3892b"></a><!-- doxytag: member="ito::operator&lt;&lt;" ref="a32585288fae2cd57c64f0188bcb3892b" args="(std::ostream &amp;out, const DataObject &amp;dObj)" -->
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a0f1e0516bec029992b462b17bf445618">convertCmplxTypeToRealType</a> (<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> cmplxType)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">static method which returns the real data type of any given data type  <a href="#a0f1e0516bec029992b462b17bf445618"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad71b2e1bfcedf7815a5aa6156db1e9bc">guessDataTypeFromCVMat</a> (const cv::Mat *mat, <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> &amp;retval)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">static method which guesses the dataObject type from a given cv::Mat*  <a href="#ad71b2e1bfcedf7815a5aa6156db1e9bc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a61005076e5ab614ffb50aa91f8ee860a">getDataType2</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">method which returns the value of enumeration <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>, which corresponds to the template parameter (must be a pointer).  <a href="#a61005076e5ab614ffb50aa91f8ee860a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af520f7cedc55e651155d7d315b4563b7"></a><!-- doxytag: member="ito::getDataType2&lt; uint8 * &gt;" ref="af520f7cedc55e651155d7d315b4563b7" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; uint8 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aafc97dbe89a91bf07eb826097ba21d4e"></a><!-- doxytag: member="ito::getDataType2&lt; int8 * &gt;" ref="aafc97dbe89a91bf07eb826097ba21d4e" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; int8 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ac1e0a3716596173097b513a99ee2dfe2"></a><!-- doxytag: member="ito::getDataType2&lt; uint16 * &gt;" ref="ac1e0a3716596173097b513a99ee2dfe2" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; uint16 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="acc29f26447d36664547cf419d04dfedb"></a><!-- doxytag: member="ito::getDataType2&lt; int16 * &gt;" ref="acc29f26447d36664547cf419d04dfedb" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; int16 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af6f76f3a22f3ee41195c6fb6a5de1b60"></a><!-- doxytag: member="ito::getDataType2&lt; uint32 * &gt;" ref="af6f76f3a22f3ee41195c6fb6a5de1b60" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; uint32 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae0cfa31016812763fa6167b735d44cf3"></a><!-- doxytag: member="ito::getDataType2&lt; int32 * &gt;" ref="ae0cfa31016812763fa6167b735d44cf3" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; int32 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a197c7f4e1a98965b6835e31fcdf21db9"></a><!-- doxytag: member="ito::getDataType2&lt; float32 * &gt;" ref="a197c7f4e1a98965b6835e31fcdf21db9" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; float32 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a05a4ec6b8bbe50091370593b1893ab86"></a><!-- doxytag: member="ito::getDataType2&lt; float64 * &gt;" ref="a05a4ec6b8bbe50091370593b1893ab86" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; float64 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a7c5ad2690e95e3653ca8940e1275be96"></a><!-- doxytag: member="ito::getDataType2&lt; complex64 * &gt;" ref="a7c5ad2690e95e3653ca8940e1275be96" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; complex64 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ab845f7e73c854bcd919cbea83f60ff4a"></a><!-- doxytag: member="ito::getDataType2&lt; complex128 * &gt;" ref="ab845f7e73c854bcd919cbea83f60ff4a" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; complex128 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5d1c846cc6dbb016e1abf477cde9485e"></a><!-- doxytag: member="ito::getDataType2&lt; Rgba32 * &gt;" ref="a5d1c846cc6dbb016e1abf477cde9485e" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; Rgba32 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aff7445a2b9222e042ae3b4a8b4112f60">isZeroValue</a> (_Tp v, _Tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">method returns whether a given variable is equal to zero.  <a href="#aff7445a2b9222e042ae3b4a8b4112f60"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a79bb7ad3e76a44a1b5af294b0ceedc59"></a><!-- doxytag: member="ito::isZeroValue" ref="a79bb7ad3e76a44a1b5af294b0ceedc59" args="(Rgba32 v, Rgba32)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isZeroValue</b> (<a class="el" href="classito_1_1_rgba32.html">Rgba32</a> v, <a class="el" href="classito_1_1_rgba32.html">Rgba32</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2afcd9a420026109fec7b12c123dc361"></a><!-- doxytag: member="ito::isZeroValue" ref="a2afcd9a420026109fec7b12c123dc361" args="(float32 v, float32 epsilon)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isZeroValue</b> (float32 v, float32 epsilon)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aea87840e04872228b63b76e45644cc37"></a><!-- doxytag: member="ito::isZeroValue" ref="aea87840e04872228b63b76e45644cc37" args="(float64 v, float64 epsilon)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isZeroValue</b> (float64 v, float64 epsilon)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6d15db3923bc9c2e5f609e8114aa6118"></a><!-- doxytag: member="ito::isZeroValue" ref="a6d15db3923bc9c2e5f609e8114aa6118" args="(std::complex&lt; ito::float32 &gt; v, std::complex&lt; ito::float32 &gt; epsilon)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isZeroValue</b> (std::complex&lt; ito::float32 &gt; v, std::complex&lt; ito::float32 &gt; epsilon)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a7eb2640d62d636bd8f0e4ed3f5971ff3"></a><!-- doxytag: member="ito::isZeroValue" ref="a7eb2640d62d636bd8f0e4ed3f5971ff3" args="(std::complex&lt; ito::float64 &gt; v, std::complex&lt; ito::float64 &gt; epsilon)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isZeroValue</b> (std::complex&lt; ito::float64 &gt; v, std::complex&lt; ito::float64 &gt; epsilon)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab15adbc6c5994b5e25cf0a3b3ac8f808"></a><!-- doxytag: member="ito::operator==" ref="ab15adbc6c5994b5e25cf0a3b3ac8f808" args="(const ByteArray &amp;a1, const char *a2)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classito_1_1_byte_array.html">ByteArray</a> &amp;a1, const char *a2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc935531ee304aaef96fe7619e0e9c39"></a><!-- doxytag: member="ito::operator==" ref="adc935531ee304aaef96fe7619e0e9c39" args="(const char *a1, const ByteArray &amp;a2)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const char *a1, const <a class="el" href="classito_1_1_byte_array.html">ByteArray</a> &amp;a2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b5235b3d69233ff82ed7d216dc74a87"></a><!-- doxytag: member="ito::operator!=" ref="a8b5235b3d69233ff82ed7d216dc74a87" args="(const ByteArray &amp;a1, const char *a2)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classito_1_1_byte_array.html">ByteArray</a> &amp;a1, const char *a2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85b7958e3950a8682bf1b9b0a3573d75"></a><!-- doxytag: member="ito::operator!=" ref="a85b7958e3950a8682bf1b9b0a3573d75" args="(const char *a1, const ByteArray &amp;a2)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const char *a1, const <a class="el" href="classito_1_1_byte_array.html">ByteArray</a> &amp;a2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ITOMCOMMONQT_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6af758f942701d80f2531249158bb33d">checkParamVector</a> (QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *params)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">checks param vector  <a href="#a6af758f942701d80f2531249158bb33d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ITOMCOMMONQT_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8d4bb116538f127474d6353604b88a55">checkParamVectors</a> (QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramsMand, QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramsOpt, QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramsOut)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">verifies that the three param vectors are not NULL  <a href="#a8d4bb116538f127474d6353604b88a55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ITOMCOMMONQT_EXPORT <a class="el" href="classito_1_1_param.html">ito::Param</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae5f62de950023c3db6e6f899aacc6bd3">getParamByName</a> (QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramVec, const char *name, <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> *retval)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">brief returns a parameter from the parameter-vector, that fits to a specific name  <a href="#ae5f62de950023c3db6e6f899aacc6bd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95c544a621f46e56e7f344c42349e225"></a><!-- doxytag: member="ito::getParamByName" ref="a95c544a621f46e56e7f344c42349e225" args="(QVector&lt; ito::ParamBase &gt; *paramVec, const char *name, ito::RetVal *retval=NULL)" -->
ITOMCOMMONQT_EXPORT <br class="typebreak"/>
<a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getParamByName</b> (QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *paramVec, const char *name, <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> *retval=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb88bcfd3147001e6a36a9eddbe6579d"></a><!-- doxytag: member="ito::createParamHashTable" ref="afb88bcfd3147001e6a36a9eddbe6579d" args="(QVector&lt; ito::Param &gt; *paramVec)" -->
ITOMCOMMONQT_EXPORT QHash<br class="typebreak"/>
&lt; QString, <a class="el" href="classito_1_1_param.html">ito::Param</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>createParamHashTable</b> (QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramVec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad27f538ca78ffe171aa40d09600b1cd0"></a><!-- doxytag: member="ito::checkNumericParamRange" ref="ad27f538ca78ffe171aa40d09600b1cd0" args="(const ito::Param &amp;param, double &amp;value, bool *ok=NULL)" -->
bool ITOMCOMMONQT_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><b>checkNumericParamRange</b> (const <a class="el" href="classito_1_1_param.html">ito::Param</a> &amp;param, double &amp;value, bool *ok=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ITOMCOMMONQT_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aea20a9bf1563f8642db8062c912b2b2c">parseParamName</a> (const QString &amp;name, QString &amp;paramName, bool &amp;hasIndex, int &amp;index, QString &amp;additionalTag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">parses parameter name with respect to regular expression, assigned for parameter-communcation with plugins  <a href="#aea20a9bf1563f8642db8062c912b2b2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15c5ea5d26aca3862f620e329316b5ee"></a><!-- doxytag: member="ito::getParamValue" ref="a15c5ea5d26aca3862f620e329316b5ee" args="(const QMap&lt; QString, Param &gt; *m_params, const QString &amp;key, ito::Param &amp;value, QString &amp;pkey, int &amp;index)" -->
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ITOMCOMMONQT_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><b>getParamValue</b> (const QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *m_params, const QString &amp;key, <a class="el" href="classito_1_1_param.html">ito::Param</a> &amp;value, QString &amp;pkey, int &amp;index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a3f99ca6b24b94df6ac7d7fea70562d"></a><!-- doxytag: member="ito::setParamValue" ref="a7a3f99ca6b24b94df6ac7d7fea70562d" args="(const QMap&lt; QString, Param &gt; *m_params, const QString &amp;key, const ito::ParamBase &amp;value, QString &amp;pkey, int &amp;index)" -->
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ITOMCOMMONQT_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><b>setParamValue</b> (const QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *m_params, const QString &amp;key, const <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &amp;value, QString &amp;pkey, int &amp;index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ITOMCOMMONQT_EXPORT <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6700407b59c1df38ff5f7235e7246fe5">formatDoubleWithUnit</a> (QStringList scaleThisUnitsOnly, QString unitIn, double dVal, double &amp;dValOut, QString &amp;unitOut)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Function to convert double values with unit to scaled values with scaled units (0.01m -&gt; 10mm)  <a href="#a6700407b59c1df38ff5f7235e7246fe5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ITOMCOMMONQT_EXPORT <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a5f90e9d0def8c42d6675f889c410cedf">generateAutoSaveParamFile</a> (QString plugInName, QFile &amp;paramFile)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">loadXML2QLIST loads parameters from an XML-File and saves them to paramList  <a href="#a5f90e9d0def8c42d6675f889c410cedf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0411cd240edb9847b61a997a958bc7a"></a><!-- doxytag: member="ito::loadXML2QLIST" ref="af0411cd240edb9847b61a997a958bc7a" args="(QMap&lt; QString, ito::Param &gt; *paramList, QString id, QFile &amp;paramFile)" -->
ITOMCOMMONQT_EXPORT <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#af0411cd240edb9847b61a997a958bc7a">loadXML2QLIST</a> (QMap&lt; QString, <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramList, QString id, QFile &amp;paramFile)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">saveQLIST2XML writes parameters from paramList to an XML-File <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fa6f7375af9065c79ddb14d3c1d1f4a"></a><!-- doxytag: member="ito::saveQLIST2XML" ref="a7fa6f7375af9065c79ddb14d3c1d1f4a" args="(QMap&lt; QString, ito::Param &gt; *paramList, QString id, QFile &amp;paramFile)" -->
ITOMCOMMONQT_EXPORT <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a7fa6f7375af9065c79ddb14d3c1d1f4a">saveQLIST2XML</a> (QMap&lt; QString, <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramList, QString id, QFile &amp;paramFile)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">mergeQLists copies parameters from newList to oldList and performs some checks <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a88bad237520eadc38db91fa5ea1ac6"></a><!-- doxytag: member="ito::mergeQLists" ref="a4a88bad237520eadc38db91fa5ea1ac6" args="(QMap&lt; QString, ito::Param &gt; *oldList, QMap&lt; QString, ito::Param &gt; *newList, bool checkAutoSave, bool deleteUnchangedParams=false)" -->
ITOMCOMMONQT_EXPORT <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a4a88bad237520eadc38db91fa5ea1ac6">mergeQLists</a> (QMap&lt; QString, <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *oldList, QMap&lt; QString, <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *newList, bool checkAutoSave, bool deleteUnchangedParams=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a dataObject to harddrive in a readable ITO-XML-Format (.ido or .idh) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ITOMCOMMONQT_EXPORT <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aca8826921e5df8a0a37e1a43ed2800cc">saveDOBJ2XML</a> (<a class="el" href="classito_1_1_data_object.html">ito::DataObject</a> *dObjOut, QString folderFileName, bool onlyHeaderObjectFile=false, bool doubleAsBinary=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Import a dataObject from harddrive, saved in the ITO-XML-Format (.ido or .idh)  <a href="#aca8826921e5df8a0a37e1a43ed2800cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ITOMCOMMONQT_EXPORT <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad763de2bc627c32993a7a6e361497065">loadXML2DOBJ</a> (<a class="el" href="classito_1_1_data_object.html">ito::DataObject</a> *dObjIn, QString folderFileName, bool onlyHeaderObjectFile=false, bool appendEnding=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb8d82ddf3963ec68207576239e7c2f9"></a><!-- doxytag: member="ito::paramHelperSetValue" ref="adb8d82ddf3963ec68207576239e7c2f9" args="(ito::Param &amp;param, ito::ParamBase value, const int pos)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>paramHelperSetValue</b> (<a class="el" href="classito_1_1_param.html">ito::Param</a> &amp;param, <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> value, const int pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#af3ff1acd7b8b3e2140db87852be40b77">loadXML2QLIST</a> (QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *paramList, QString id, QFile &amp;paramFile)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a1f0f29281bc5cb69fcd9759a369b09eb">saveQLIST2XML</a> (QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *paramList, QString id, QFile &amp;paramFile)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a487ae8b7490f1de2f8c400eab1859f58">mergeQLists</a> (QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *oldList, QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *newList, bool checkAutoSave, bool deleteUnchangedParams)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a09c6b2139e9995dabe2dbbabd25bab48">writeObjectHeaderToFileV1</a> (QXmlStreamWriter &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut, bool doubleAsBinary, int &amp;elementsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function writes the header of the Object to the xml stream.  This helper function writes the header (dims, sizes, type) of an object and the metaData (complete <a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a> without tagsMap) from the Object to the xml stream. The values of the header are stored as string. The values of each axis-tag / value-tag / rotation matrix are in case of string-type directly written to the stream or in case of double converted to either strings directly (15 significat digits, &gt;32Bit) or stored as lostfree binary (QByteArray::toBase64() to avoid XML-conflict). WARNING: Do not change the header (dims, sizes, type) information or the value of tags exported as binary (d2b).  <a href="#a09c6b2139e9995dabe2dbbabd25bab48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aad6e1f7022d1f9024c771f51f01f78da">writeObjectTagsToFileV1</a> (QXmlStreamWriter &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut, bool doubleAsBinary)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function writes the tags defined in the tagMap (<a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) from the Object to the xml stream.  This helper function writes the tags defined in the tagMap (<a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) from the Object to the xml stream. Therefore the values of each tag are in case of string-type directly written to the stream or in case of double converted to either strings directly (15 significat digits, &gt;32Bit) or stored as lostfree binary (QByteArray::toBase64() to avoid XML-conflict). WARNING: Do not change information or the value of tags exported as binary (d2b).  <a href="#aad6e1f7022d1f9024c771f51f01f78da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#af96b552c35539676c8a13957de2183ad">writeObjectDataToFileV1</a> (QXmlStreamWriter &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut, int elementsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function writes the data(cv::mats) from the Object to the xml stream.  This helper function writes the data(cv::mats) from the Object to the xml stream. Therefore the data is converted using QByteArray::toBase64() to avoid XML-conflict with the binary data.  <a href="#af96b552c35539676c8a13957de2183ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#afecd6942c1876cc35f42046db0a098ea">readTillNext</a> (QXmlStreamReader &amp;stream, int &amp;times, int maxtimes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function reads the stream till the next startElement.  The Qt-Function readNextStartElement sometimes stops at the end-element (:P). So the function tries to read until it reaches the next startelement but only for maxtimes trys the Function checks if the attribute exists and than tries to convert to the value of the attribute either from binary or with string to double functions.  <a href="#afecd6942c1876cc35f42046db0a098ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae98bfefe271214ccda435c4be975f5e4">readDoubleFromXML</a> (QXmlStreamAttributes &amp;attrStream, QString &amp;Element, QString &amp;Attrib, double &amp;val, bool isBinary)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function extracts a double from the xml-Attributes of the Stream  This helper function extracts a double from the xml-Attributes of the Stream copied by the caller with the attrStream = attrStream = stream.attributes();. the Function checks if the attribute exists and than tries to convert to the value of the attribute either from binary or with string to double functions.  <a href="#ae98bfefe271214ccda435c4be975f5e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa3fb95bb073f0055c98ee99e91b9c22a">readStdStringFromXML</a> (QXmlStreamAttributes &amp;attrStream, QString &amp;Element, QString &amp;Attrib, std::string &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function extracts a std::string from the xml-Attributes of the Stream  This helper function extracts a std::string from the xml-Attributes of the Stream copied by the caller with the attrStream = attrStream = stream.attributes();. the Function checks if the attribute exists and than tries to convert to the value of the attribute from QString to std::string.  <a href="#aa3fb95bb073f0055c98ee99e91b9c22a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a49a8ffb4244dbc37882593e3ae344e74">createObjectFromXMLV1</a> (QXmlStreamReader &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObjIn, int &amp;elementsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates an dataObject from the header of the xml-file  This function creates an dataObject from the header of the xml-file by parsing the XML-stream. The first start element, already read by the calling function must contain the attributes dims, dataType and dim0..dimn-2, dimX, dimY.  <a href="#a49a8ffb4244dbc37882593e3ae344e74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a99b23c44aedc092db34847ec3d850a7c">loadObjectHeaderFromXMLV1</a> (QXmlStreamReader &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObjIn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fills the MetaData (<a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) of an allocated dataObject from the values of an xml-file  This function fills the MetaData (<a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) of an allocated dataObject from the values of an xml-file. This includes the axis-Tags (offset, scale, unit, description), value-Tags ((offset), (scale), unit, description) and the rotation matrix. It does not include the tag-Space (std::map&lt;std::string, DataObjectTagType&gt; m_tags) (e.g. protocol ...)  <a href="#a99b23c44aedc092db34847ec3d850a7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a4132d915f47775d5edcab7874885c27d">loadTagSpaceFromXMLV1</a> (QXmlStreamReader &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObjIn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fills the tagsSpace (<a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) of an allocated dataObject from the values of an xml-file  This function fills the tagsSpace (<a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) of an allocated dataObject from the values of an xml-file. This onlye includes the tag-Space (std::map&lt;std::string, DataObjectTagType&gt; m_tags) (e.g. protocol ...) and does not include the axis-Tags (offset, scale, unit, description), value-Tags ((offset), (scale), unit, description) and the rotation matrix.  <a href="#a4132d915f47775d5edcab7874885c27d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a43463b798f2244f8f380ff8af5337c20">loadDataFromXMLV1</a> (QXmlStreamReader &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObjIn, int elementsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies the CDATA from the xml-file to the allocated dataObject.  This function copies the CDATA from the xml-file to the allocated dataObject. The data was before packed (substitution of xml-registered characters) during saving and is unpacked here. The data is stored plane-wise. The function checks if the plane-size if the object is equal to the imported size.  <a href="#a43463b798f2244f8f380ff8af5337c20"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af488d39d5fa87dd219cda2bf3d4ccd4f"></a><!-- doxytag: member="ito::ITOM_API_FUNCS" ref="af488d39d5fa87dd219cda2bf3d4ccd4f" args="" -->
void **&#160;</td><td class="memItemRight" valign="bottom"><b>ITOM_API_FUNCS</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3591ed94bfa2025ea35f80b6b7e1c3a"></a><!-- doxytag: member="ito::ITOM_API_FUNCS_ARR" ref="ac3591ed94bfa2025ea35f80b6b7e1c3a" args="[]" -->
void *&#160;</td><td class="memItemRight" valign="bottom"><b>ITOM_API_FUNCS_ARR</b> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacfb5faee5617334d20f8ff0c2974069"></a><!-- doxytag: member="ito::ITOM_API_FUNCS_GRAPH" ref="aacfb5faee5617334d20f8ff0c2974069" args="" -->
void **&#160;</td><td class="memItemRight" valign="bottom"><b>ITOM_API_FUNCS_GRAPH</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><b>ITOM_API_FUNCS_GRAPH_ARR</b> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a217c8cae666ded4e02d77c9b1ebcca4a"></a><!-- doxytag: member="ito::ROWHEIGHT" ref="a217c8cae666ded4e02d77c9b1ebcca4a" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>ROWHEIGHT</b> = 20</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f09fe6ddeb87be5e31f7d19e5b60d8b"></a><!-- doxytag: member="ito::COLWIDTH" ref="a5f09fe6ddeb87be5e31f7d19e5b60d8b" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>COLWIDTH</b> = 100</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static tCoutFunc&#160;</td><td class="memItemRight" valign="bottom"><b>fListCout</b> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a568df211be05e76f53d2262087e4b0b6"></a><!-- doxytag: member="ito::paramFlagMask" ref="a568df211be05e76f53d2262087e4b0b6" args="" -->
const uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a568df211be05e76f53d2262087e4b0b6">paramFlagMask</a> = 0xFFFF0000</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">bits of type lying within this mask are flags (e.g. typeNoAutosave, typeReadonly...) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9158b33ef1d02a45a7d603ed6ad0906"></a><!-- doxytag: member="ito::paramTypeMask" ref="ad9158b33ef1d02a45a7d603ed6ad0906" args="" -->
const uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad9158b33ef1d02a45a7d603ed6ad0906">paramTypeMask</a> = 0x0000FFFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">bits of param type lying withing this mask describe the type (typeNoAutosave must be included there) <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>&lt; this is for the plugin param save / load</p>
<p>&lt; this is for the dataobject save / load </p>
</div><hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ab4779b960376c89061f1b12ae3738383"></a><!-- doxytag: member="ito::tActuatorStatus" ref="ab4779b960376c89061f1b12ae3738383" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383">ito::tActuatorStatus</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tActuatorStatus enumeration </p>
<p>flags used for describing the status of one axis of an actuator plugin.</p>
<p>These flags are intended to be combined in the status bitmask. Usually the bitmask for each mask is saved in the vector <a class="el" href="classito_1_1_add_in_actuator.html#addb73efdf9d6fa907b20de4e4571aedf">ito::AddInActuator::m_currentStatus</a> of an actuator plugin.</p>
<p>The bitmask is divided into different topical areas (moving flags, switches, general status). </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a599af524525e8c64bddf91298784e767"></a><!-- doxytag: member="actuatorUnknown" ref="ab4779b960376c89061f1b12ae3738383a599af524525e8c64bddf91298784e767" args="" -->actuatorUnknown</em>&nbsp;</td><td>
<p>moving status of axis is unknown </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a8b74ac01caf78e23c95f58b02eaab2a0"></a><!-- doxytag: member="actuatorInterrupted" ref="ab4779b960376c89061f1b12ae3738383a8b74ac01caf78e23c95f58b02eaab2a0" args="" -->actuatorInterrupted</em>&nbsp;</td><td>
<p>movement has been interrupted by the user, axis is immediately stopped </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a159167245176483f6062495f2baadd00"></a><!-- doxytag: member="actuatorMoving" ref="ab4779b960376c89061f1b12ae3738383a159167245176483f6062495f2baadd00" args="" -->actuatorMoving</em>&nbsp;</td><td>
<p>axis is currently moving </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab4779b960376c89061f1b12ae3738383af8836b7f26106593b4d36a5c857ec048"></a><!-- doxytag: member="actuatorAtTarget" ref="ab4779b960376c89061f1b12ae3738383af8836b7f26106593b4d36a5c857ec048" args="" -->actuatorAtTarget</em>&nbsp;</td><td>
<p>axis reached target </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a84db4f5b5d047c90ca78d93b46656874"></a><!-- doxytag: member="actuatorTimeout" ref="ab4779b960376c89061f1b12ae3738383a84db4f5b5d047c90ca78d93b46656874" args="" -->actuatorTimeout</em>&nbsp;</td><td>
<p>no signal from axis, timeout </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab4779b960376c89061f1b12ae3738383ae70cba1af756a2c62c1fc2957643b424"></a><!-- doxytag: member="actuatorEndSwitch" ref="ab4779b960376c89061f1b12ae3738383ae70cba1af756a2c62c1fc2957643b424" args="" -->actuatorEndSwitch</em>&nbsp;</td><td>
<p>axis reached an undefined end switch </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a6edddb993c8b1438045128e4f8a7788f"></a><!-- doxytag: member="actuatorLeftEndSwitch" ref="ab4779b960376c89061f1b12ae3738383a6edddb993c8b1438045128e4f8a7788f" args="" -->actuatorLeftEndSwitch</em>&nbsp;</td><td>
<p>axis reached the specified left end switch (if set, also set actuatorEndSwitch) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a3d4d3a51e6e7e7fee69ae59d359f8be7"></a><!-- doxytag: member="actuatorRightEndSwitch" ref="ab4779b960376c89061f1b12ae3738383a3d4d3a51e6e7e7fee69ae59d359f8be7" args="" -->actuatorRightEndSwitch</em>&nbsp;</td><td>
<p>axis reached the specified right end switch (if set, also set actuatorEndSwitch) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab4779b960376c89061f1b12ae3738383af55796f42d5efcd1ea80324402d4d72f"></a><!-- doxytag: member="actuatorRefSwitch" ref="ab4779b960376c89061f1b12ae3738383af55796f42d5efcd1ea80324402d4d72f" args="" -->actuatorRefSwitch</em>&nbsp;</td><td>
<p>axis reached an undefined reference switch </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a993a882ad6ec2c8f7657483b637a9f87"></a><!-- doxytag: member="actuatorLeftRefSwitch" ref="ab4779b960376c89061f1b12ae3738383a993a882ad6ec2c8f7657483b637a9f87" args="" -->actuatorLeftRefSwitch</em>&nbsp;</td><td>
<p>axis reached the specified left reference switch (if set, also set actuatorRefSwitch) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a85d7cfb84b5000f7ac16726433589e39"></a><!-- doxytag: member="actuatorRightRefSwitch" ref="ab4779b960376c89061f1b12ae3738383a85d7cfb84b5000f7ac16726433589e39" args="" -->actuatorRightRefSwitch</em>&nbsp;</td><td>
<p>axis reached the specified right reference switch (if set, also set actuatorRefSwitch) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a5a1d7a7c2ab70910db005617b3a8571a"></a><!-- doxytag: member="actuatorAvailable" ref="ab4779b960376c89061f1b12ae3738383a5a1d7a7c2ab70910db005617b3a8571a" args="" -->actuatorAvailable</em>&nbsp;</td><td>
<p>axis is generally available </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a83f4cf9f8319fbbeec0b7f75f4d07682"></a><!-- doxytag: member="actuatorEnabled" ref="ab4779b960376c89061f1b12ae3738383a83f4cf9f8319fbbeec0b7f75f4d07682" args="" -->actuatorEnabled</em>&nbsp;</td><td>
<p>axis is enabled for movements </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a067270bd694afa11b542e1768d50b06b"></a><!-- doxytag: member="actMovingMask" ref="ab4779b960376c89061f1b12ae3738383a067270bd694afa11b542e1768d50b06b" args="" -->actMovingMask</em>&nbsp;</td><td>
<p>bitmask that marks all bits related to the movement </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a088d0d001f7e269d045e17084e31a343"></a><!-- doxytag: member="actEndSwitchMask" ref="ab4779b960376c89061f1b12ae3738383a088d0d001f7e269d045e17084e31a343" args="" -->actEndSwitchMask</em>&nbsp;</td><td>
<p>bitmask that marks all bits related to end switches </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab4779b960376c89061f1b12ae3738383afe023404e59f14ea85192ecf4a205d3e"></a><!-- doxytag: member="actRefSwitchMask" ref="ab4779b960376c89061f1b12ae3738383afe023404e59f14ea85192ecf4a205d3e" args="" -->actRefSwitchMask</em>&nbsp;</td><td>
<p>bitmask that marks all bits related to reference switches </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab4779b960376c89061f1b12ae3738383ab8727b678dd0975d5259d4ef6e0c2c71"></a><!-- doxytag: member="actSwitchesMask" ref="ab4779b960376c89061f1b12ae3738383ab8727b678dd0975d5259d4ef6e0c2c71" args="" -->actSwitchesMask</em>&nbsp;</td><td>
<p>bitmask that marks all bits related to reference and end switches </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a13165fe6a2fd39d5092982cf35388dfc"></a><!-- doxytag: member="actStatusMask" ref="ab4779b960376c89061f1b12ae3738383a13165fe6a2fd39d5092982cf35388dfc" args="" -->actStatusMask</em>&nbsp;</td><td>
<p>bitmask that marks all status flags </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a20bda469be01178ac6cf406bcba2ee73"></a><!-- doxytag: member="ito::tAutoLoadPolicy" ref="a20bda469be01178ac6cf406bcba2ee73" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a20bda469be01178ac6cf406bcba2ee73">ito::tAutoLoadPolicy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a20bda469be01178ac6cf406bcba2ee73a8ec2058becac1ccaae65864d6f961cdf"></a><!-- doxytag: member="autoLoadAlways" ref="a20bda469be01178ac6cf406bcba2ee73a8ec2058becac1ccaae65864d6f961cdf" args="" -->autoLoadAlways</em>&nbsp;</td><td>
<p>always loads xml file by addInManager </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a20bda469be01178ac6cf406bcba2ee73ad39587830e30b302adc4421224049c28"></a><!-- doxytag: member="autoLoadNever" ref="a20bda469be01178ac6cf406bcba2ee73ad39587830e30b302adc4421224049c28" args="" -->autoLoadNever</em>&nbsp;</td><td>
<p>never automatically loads parameters from xml-file (default) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a20bda469be01178ac6cf406bcba2ee73a4c932e4379045955c6194e202c0b6b2d"></a><!-- doxytag: member="autoLoadKeywordDefined" ref="a20bda469be01178ac6cf406bcba2ee73a4c932e4379045955c6194e202c0b6b2d" args="" -->autoLoadKeywordDefined</em>&nbsp;</td><td>
<p>only loads parameters if keyword autoLoadParams=1 exists in python-constructor </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d769b26bbab936560f4c95674ff5477"></a><!-- doxytag: member="ito::tAutoSavePolicy" ref="a8d769b26bbab936560f4c95674ff5477" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a8d769b26bbab936560f4c95674ff5477">ito::tAutoSavePolicy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a8d769b26bbab936560f4c95674ff5477a9ca1d2e8fbcc5c11e86bd24fcdec9e50"></a><!-- doxytag: member="autoSaveAlways" ref="a8d769b26bbab936560f4c95674ff5477a9ca1d2e8fbcc5c11e86bd24fcdec9e50" args="" -->autoSaveAlways</em>&nbsp;</td><td>
<p>always saves parameters to xml-file at shutdown </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8d769b26bbab936560f4c95674ff5477a977bb0b86cfdfa0e8486241790087703"></a><!-- doxytag: member="autoSaveNever" ref="a8d769b26bbab936560f4c95674ff5477a977bb0b86cfdfa0e8486241790087703" args="" -->autoSaveNever</em>&nbsp;</td><td>
<p>never saves parameters to xml-file at shutdown (default) </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdba"></a><!-- doxytag: member="ito::tDataType" ref="acc7eee7faabd3db8463dc9b7922afdba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DataType enumeration This enum holds the possible values for <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> matrices. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa35aa1b8e08158b49ebbf6bdfb4b6a508"></a><!-- doxytag: member="tInt8" ref="acc7eee7faabd3db8463dc9b7922afdbaa35aa1b8e08158b49ebbf6bdfb4b6a508" args="" -->tInt8</em>&nbsp;</td><td>
<p>integer, 8bit </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaad21eb4541e782dc23501912f788a38bd"></a><!-- doxytag: member="tUInt8" ref="acc7eee7faabd3db8463dc9b7922afdbaad21eb4541e782dc23501912f788a38bd" args="" -->tUInt8</em>&nbsp;</td><td>
<p>unsigned integer, 8bit </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa142219f864f22d3b2e6f116f5f5cd936"></a><!-- doxytag: member="tInt16" ref="acc7eee7faabd3db8463dc9b7922afdbaa142219f864f22d3b2e6f116f5f5cd936" args="" -->tInt16</em>&nbsp;</td><td>
<p>integer, 16bit </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa68d7e991164d07a036f40379a101112b"></a><!-- doxytag: member="tUInt16" ref="acc7eee7faabd3db8463dc9b7922afdbaa68d7e991164d07a036f40379a101112b" args="" -->tUInt16</em>&nbsp;</td><td>
<p>unsigned integer, 16bit </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa47b295973c6b4b7de62599401c16df62"></a><!-- doxytag: member="tInt32" ref="acc7eee7faabd3db8463dc9b7922afdbaa47b295973c6b4b7de62599401c16df62" args="" -->tInt32</em>&nbsp;</td><td>
<p>integer, 32bit </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaaf08334798ddd5082595350b296a7a868"></a><!-- doxytag: member="tUInt32" ref="acc7eee7faabd3db8463dc9b7922afdbaaf08334798ddd5082595350b296a7a868" args="" -->tUInt32</em>&nbsp;</td><td>
<p>unsigned integer, 32bit (not fully supported) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa17ad621a0158b30fc85eb1e89b93ce3b"></a><!-- doxytag: member="tFloat32" ref="acc7eee7faabd3db8463dc9b7922afdbaa17ad621a0158b30fc85eb1e89b93ce3b" args="" -->tFloat32</em>&nbsp;</td><td>
<p>float, 32bit </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa6b9559a5cfa765160ae209ecdc258ed6"></a><!-- doxytag: member="tFloat64" ref="acc7eee7faabd3db8463dc9b7922afdbaa6b9559a5cfa765160ae209ecdc258ed6" args="" -->tFloat64</em>&nbsp;</td><td>
<p>double (64bit) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa722b93c77819223b8d630ab0fca5a0ec"></a><!-- doxytag: member="tComplex64" ref="acc7eee7faabd3db8463dc9b7922afdbaa722b93c77819223b8d630ab0fca5a0ec" args="" -->tComplex64</em>&nbsp;</td><td>
<p>complex value with real and imaginary part of type float32 </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa39fef9b8e46915c6ba232020e2fe2e7a"></a><!-- doxytag: member="tComplex128" ref="acc7eee7faabd3db8463dc9b7922afdbaa39fef9b8e46915c6ba232020e2fe2e7a" args="" -->tComplex128</em>&nbsp;</td><td>
<p>complex value with real and imaginary part of type float64 </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa8473d2c11cdf726247c29c5ecf7dfbaa"></a><!-- doxytag: member="tRGBA32" ref="acc7eee7faabd3db8463dc9b7922afdbaa8473d2c11cdf726247c29c5ecf7dfbaa" args="" -->tRGBA32</em>&nbsp;</td><td>
<p>a uint32 / vec4u value coded as 0xAARRGGBB </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a43f8ec3cdde4591a8ea77f4faf569773"></a><!-- doxytag: member="ito::tLogLevel" ref="a43f8ec3cdde4591a8ea77f4faf569773" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a43f8ec3cdde4591a8ea77f4faf569773">ito::tLogLevel</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>LogLevel enumeration This enum holds all possible LogLevel values </p>

</div>
</div>
<a class="anchor" id="a8811ca8b85b70b969122b25a7c84e0ee"></a><!-- doxytag: member="ito::tMsgType" ref="a8811ca8b85b70b969122b25a7c84e0ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a8811ca8b85b70b969122b25a7c84e0ee">ito::tMsgType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>MsgType enumeration This enum holds the possible values for any message type (for qDebugStream e.g.) </p>

</div>
</div>
<a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360e"></a><!-- doxytag: member="ito::tPCLPointType" ref="a71867bc7a24c8fcb06b8cf63f5a3360e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360e">ito::tPCLPointType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>PCLPointType enumeration This enum holds the possible values for point types supported by the wrapper of the point-cloud library in itom. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360eaa2585c0961b5f357d98ed732c17b9359"></a><!-- doxytag: member="pclInvalid" ref="a71867bc7a24c8fcb06b8cf63f5a3360eaa2585c0961b5f357d98ed732c17b9359" args="" -->pclInvalid</em>&nbsp;</td><td>
<p>invalid point </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360ea6273432d3a0ca503e1a77d27ad8ab994"></a><!-- doxytag: member="pclXYZ" ref="a71867bc7a24c8fcb06b8cf63f5a3360ea6273432d3a0ca503e1a77d27ad8ab994" args="" -->pclXYZ</em>&nbsp;</td><td>
<p>point with x,y,z-value </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360ea6385e470bdc9a9e3aead145eb0ded4d8"></a><!-- doxytag: member="pclXYZI" ref="a71867bc7a24c8fcb06b8cf63f5a3360ea6385e470bdc9a9e3aead145eb0ded4d8" args="" -->pclXYZI</em>&nbsp;</td><td>
<p>point with x,y,z and intensity value </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360eaefd9ce8422846a24673536424375f223"></a><!-- doxytag: member="pclXYZRGBA" ref="a71867bc7a24c8fcb06b8cf63f5a3360eaefd9ce8422846a24673536424375f223" args="" -->pclXYZRGBA</em>&nbsp;</td><td>
<p>point with x,y,z and r,g,b,a </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360ea5f6680f5c10ff985f0be8ce06780e16a"></a><!-- doxytag: member="pclXYZNormal" ref="a71867bc7a24c8fcb06b8cf63f5a3360ea5f6680f5c10ff985f0be8ce06780e16a" args="" -->pclXYZNormal</em>&nbsp;</td><td>
<p>point with x,y,z value, its normal vector nx,ny,nz and a curvature value </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360ea9c19394acf64356ecfc0ed60bc6c8b52"></a><!-- doxytag: member="pclXYZINormal" ref="a71867bc7a24c8fcb06b8cf63f5a3360ea9c19394acf64356ecfc0ed60bc6c8b52" args="" -->pclXYZINormal</em>&nbsp;</td><td>
<p>point with the same values than pclXYZNormal and an additional intensity value </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360ea6dd64651a1b85540ac80b6efa5eeb738"></a><!-- doxytag: member="pclXYZRGBNormal" ref="a71867bc7a24c8fcb06b8cf63f5a3360ea6dd64651a1b85540ac80b6efa5eeb738" args="" -->pclXYZRGBNormal</em>&nbsp;</td><td>
<p>point with x,y,z and r,g,b and normal vector (including curvature) </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8f52a66afae16e3bb3802d701859fcf"></a><!-- doxytag: member="ito::tPluginLoadStatusFlag" ref="ae8f52a66afae16e3bb3802d701859fcf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcf">ito::tPluginLoadStatusFlag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>PluginLoadStatusFlag enumeration This enum holds the four possible return states for loaded DLLs Ok, Warning, Error and Ignored </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae8f52a66afae16e3bb3802d701859fcfa0c084ed64a1e58022675c2855494b904"></a><!-- doxytag: member="plsfOk" ref="ae8f52a66afae16e3bb3802d701859fcfa0c084ed64a1e58022675c2855494b904" args="" -->plsfOk</em>&nbsp;</td><td>
<p>ok </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae8f52a66afae16e3bb3802d701859fcfae886791877d339615c79aed5c21d35f0"></a><!-- doxytag: member="plsfWarning" ref="ae8f52a66afae16e3bb3802d701859fcfae886791877d339615c79aed5c21d35f0" args="" -->plsfWarning</em>&nbsp;</td><td>
<p>warning </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae8f52a66afae16e3bb3802d701859fcfa89928bf15c88b96936c0f981580994ba"></a><!-- doxytag: member="plsfError" ref="ae8f52a66afae16e3bb3802d701859fcfa89928bf15c88b96936c0f981580994ba" args="" -->plsfError</em>&nbsp;</td><td>
<p>error </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae8f52a66afae16e3bb3802d701859fcfa8e51ce1381d3ccf924b2b6152b554f88"></a><!-- doxytag: member="plsfIgnored" ref="ae8f52a66afae16e3bb3802d701859fcfa8e51ce1381d3ccf924b2b6152b554f88" args="" -->plsfIgnored</em>&nbsp;</td><td>
<p>ignored </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae8f52a66afae16e3bb3802d701859fcfa83b35bae2ed80b743503263abc05ddf8"></a><!-- doxytag: member="plsfRelDbg" ref="ae8f52a66afae16e3bb3802d701859fcfa83b35bae2ed80b743503263abc05ddf8" args="" -->plsfRelDbg</em>&nbsp;</td><td>
<p>is Dbg version </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d8b8f2858876413dd8728084943ab30"></a><!-- doxytag: member="ito::tPluginType" ref="a3d8b8f2858876413dd8728084943ab30" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30">ito::tPluginType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tPluginType enumeration </p>
<p>used to describe the plugin type and subtype (in case of DataIO main type) e.g. typeDataIO|typeGrabber for a frame grabber </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a3d8b8f2858876413dd8728084943ab30a4cab6a4edc95b2ef6846c79aedd818cb"></a><!-- doxytag: member="typeDataIO" ref="a3d8b8f2858876413dd8728084943ab30a4cab6a4edc95b2ef6846c79aedd818cb" args="" -->typeDataIO</em>&nbsp;</td><td>
<p>base type for data input and output (cameras, AD-converter, display windows...) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3d8b8f2858876413dd8728084943ab30a67b1093d817ca4c45de9b4b1075045b1"></a><!-- doxytag: member="typeActuator" ref="a3d8b8f2858876413dd8728084943ab30a67b1093d817ca4c45de9b4b1075045b1" args="" -->typeActuator</em>&nbsp;</td><td>
<p>base type for actuators and motors </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3d8b8f2858876413dd8728084943ab30a8c028979c4b81e7eaa0a7f51e1e62d26"></a><!-- doxytag: member="typeAlgo" ref="a3d8b8f2858876413dd8728084943ab30a8c028979c4b81e7eaa0a7f51e1e62d26" args="" -->typeAlgo</em>&nbsp;</td><td>
<p>base type for algorithm plugin </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3d8b8f2858876413dd8728084943ab30af4dfe66a7744cc365947716d5bdb9f6d"></a><!-- doxytag: member="typeGrabber" ref="a3d8b8f2858876413dd8728084943ab30af4dfe66a7744cc365947716d5bdb9f6d" args="" -->typeGrabber</em>&nbsp;</td><td>
<p>subtype of dataIO for cameras (grabbers), use this type in combination with typeDataIO (OR-combination) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3d8b8f2858876413dd8728084943ab30a95ac93a74aac433a17c998c1810e3e51"></a><!-- doxytag: member="typeADDA" ref="a3d8b8f2858876413dd8728084943ab30a95ac93a74aac433a17c998c1810e3e51" args="" -->typeADDA</em>&nbsp;</td><td>
<p>subtype of dataIO for AD and DA-converters, use this type in combination with typeDataIO (OR-combination) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3d8b8f2858876413dd8728084943ab30ad2e2fbe4821bac18934a307bd89428c2"></a><!-- doxytag: member="typeRawIO" ref="a3d8b8f2858876413dd8728084943ab30ad2e2fbe4821bac18934a307bd89428c2" args="" -->typeRawIO</em>&nbsp;</td><td>
<p>subtype of dataIO for further input-output-devices (like display windows), use this type in combination with typeDataIO (OR-combination) </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="af3656645e7f004701417ecdc79b10202"></a><!-- doxytag: member="ito::tRetValue" ref="af3656645e7f004701417ecdc79b10202" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202">ito::tRetValue</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>RetValue enumeration This enum holds the three possible return states Ok, Warning and Error </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af3656645e7f004701417ecdc79b10202a2ced39cc25866a04f2fb1c9f1d6a542e"></a><!-- doxytag: member="retOk" ref="af3656645e7f004701417ecdc79b10202a2ced39cc25866a04f2fb1c9f1d6a542e" args="" -->retOk</em>&nbsp;</td><td>
<p>ok </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af3656645e7f004701417ecdc79b10202a59b8253725a061086f085758a117002b"></a><!-- doxytag: member="retWarning" ref="af3656645e7f004701417ecdc79b10202a59b8253725a061086f085758a117002b" args="" -->retWarning</em>&nbsp;</td><td>
<p>warning </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af3656645e7f004701417ecdc79b10202a199f41b7779e742e0a3cc281c42c97c0"></a><!-- doxytag: member="retError" ref="af3656645e7f004701417ecdc79b10202a199f41b7779e742e0a3cc281c42c97c0" args="" -->retError</em>&nbsp;</td><td>
<p>error </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a758098011c4f6f08dd9a67916a052cfd"></a><!-- doxytag: member="ito::abs" ref="a758098011c4f6f08dd9a67916a052cfd" args="(const DataObject &amp;dObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> DATAOBJ_EXPORT ito::abs </td>
          <td>(</td>
          <td class="paramtype">const DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level value which calculates the absolute value of each element of the input source data object and returns the resulting data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new data object with absolute values </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if unknown data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a161d495b681827afefce9e0318235f60" title="low-level, double templated method to save the element-wise absolute value of each element in source ...">AbsFunc</a>, <a class="el" href="namespaceito.html#a33df0458dc28449b54bc8072efd7a99c" title="low-level, templated method to save the element-wise absolute value of each element in source matrix ...">AbsFuncReal</a></dd></dl>
<p>calculates the absolute values of each element in the given data object and returns the result as new data object </p>

</div>
</div>
<a class="anchor" id="a161d495b681827afefce9e0318235f60"></a><!-- doxytag: member="ito::AbsFunc" ref="a161d495b681827afefce9e0318235f60" args="(const DataObject *dObj, DataObject *resObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CmplxTp , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::AbsFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>resObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, double templated method to save the element-wise absolute value of each element in source matrix to result matrix </p>
<p>This method takes the absolute value of a complex valued input matrix and stores it in the equivalent real typed result matrix</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is source matrix, must have complex type </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the resulting data object, which has the real data type which corresponds to the complex type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>std::abs </dd></dl>

</div>
</div>
<a class="anchor" id="a33df0458dc28449b54bc8072efd7a99c"></a><!-- doxytag: member="ito::AbsFuncReal" ref="a33df0458dc28449b54bc8072efd7a99c" args="(const DataObject *dObj, DataObject *resObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::AbsFuncReal </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>resObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method to save the element-wise absolute value of each element in source matrix to result matrix </p>
<p>This method takes the absolute value of a real typed input matrix and stores it in the equivalent real typed result matrix</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is source matrix, must have real value </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the resulting data object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>std::abs </dd></dl>

</div>
</div>
<a class="anchor" id="a5dd3e10e1693f1e30da07735aaa05281"></a><!-- doxytag: member="ito::AddFunc" ref="a5dd3e10e1693f1e30da07735aaa05281" args="(const DataObject *dObj1, const DataObject *dObj2, DataObject *dObjRes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::AddFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for element-wise addition of two given data objects. </p>
<p>dObjRes = dObj1 + dObj2</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj1</td><td>is the first data object </td></tr>
    <tr><td class="paramname">*dObj2</td><td>is the second data object </td></tr>
    <tr><td class="paramname">*dObjRes</td><td>is the pointer to the data object, where the values will be written to. This data object must already be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The size check for all data objects must be done before. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>operator +=, operator + </dd></dl>

</div>
</div>
<a class="anchor" id="ad5c7411f47d3ef288089d9d9b9c65a03"></a><!-- doxytag: member="ito::AdjustROIFunc" ref="ad5c7411f47d3ef288089d9d9b9c65a03" args="(DataObject *dObj, int dtop, int dbottom, int dleft, int dright)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::AdjustROIFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dbottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dright</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for adjusting the ROI of a data object by the given incremental values </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is the data object, whose boundaries should be adjusted </td></tr>
    <tr><td class="paramname">dtop</td><td>- The shift of the top submatrix boundary upwards (positive value means upwards) </td></tr>
    <tr><td class="paramname">dbottom</td><td>- The shift of the bottom submatrix boundary downwards (positive value means downwards) </td></tr>
    <tr><td class="paramname">dleft</td><td>- The shift of the left submatrix boundary to the left (positive value means to the left) </td></tr>
    <tr><td class="paramname">dright</td><td>- The shift of the right submatrix boundary to the right (positive value means to the right) </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>for any n-dimensional data object, the ROI of every matrix-plane is adjusted, even if any specific matrix-plane is temporarily not inside of the ROI </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a87c024c43b3d17174e8f0b14fdc09cd6"></a><!-- doxytag: member="ito::apiFCheckAndSetParamVal" ref="a87c024c43b3d17174e8f0b14fdc09cd6" args="(QVariant *tempParam, ito::ParamBase *param, int *set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::apiFCheckAndSetParamVal </td>
          <td>(</td>
          <td class="paramtype">QVariant *&#160;</td>
          <td class="paramname"><em>tempParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper function to check and set initialisation parameters in the initialisation parameter list </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tempParam</td><td>QVariant holding the value to set </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">param</td><td>the param in the parameter list, that is set </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">set</td><td>indicator whether the parameter was set or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk on success, retError otherwise</dd></dl>
<p>The function checks if the types of the passed python parameter and the parameter are compatible and sets the parameter value if it is possible. If the paramter cannot be set an error is returned. </p>

</div>
</div>
<a class="anchor" id="aba757c479378ddaa7db70850c6590f3c"></a><!-- doxytag: member="ito::apiFParseInitParams" ref="aba757c479378ddaa7db70850c6590f3c" args="(QVector&lt; ito::ParamBase &gt; *initParamListMand, QVector&lt; ito::ParamBase &gt; *initParamListOpt, QVector&lt; QVariant &gt; *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::apiFParseInitParams </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *&#160;</td>
          <td class="paramname"><em>initParamListMand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *&#160;</td>
          <td class="paramname"><em>initParamListOpt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; QVariant &gt; *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function to read mandatory and optional parameter lists from a given python parameter list according to the plugins definition </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">initParamListMand</td><td>vector holding the mandatory initialisation parameters (filled with default values), the default values are overwritten with the passed values </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">initParamListOpt</td><td>vector holding the optional initialisation parameters (filled with default values), the default values are overwritten with the passed values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>list with python arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kwds</td><td>list with named python arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns <a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a2ced39cc25866a04f2fb1c9f1d6a542e">ito::retOk</a> if the number and type of parameters was correct, <a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a199f41b7779e742e0a3cc281c42c97c0">ito::retError</a> otherwise</dd></dl>
<p>The function takes as input the vectors with the madatory and optional input parameters used for the plugin initialisation. These vectors must be previously be read using the function getInitParams. The default values of the parameters are overwritten with the values given by python. In case the number or parameters or a parameter type is incorrect the function will abort with an error. </p>

</div>
</div>
<a class="anchor" id="a44eaccc88212fb67d3d2e102a7fb51dc"></a><!-- doxytag: member="ito::arg" ref="a44eaccc88212fb67d3d2e102a7fb51dc" args="(const DataObject &amp;dObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> DATAOBJ_EXPORT ito::arg </td>
          <td>(</td>
          <td class="paramtype">const DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level value which calculates the argument value of each element of the input source data object and returns the resulting data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new data object with argument values </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if undefined data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a05f123e54780ea7b53fadfbef4883b66" title="low-level, double templated method to save the element-wise argument of each element in source matrix...">ArgFunc</a></dd></dl>
<p>calculates the argument of each element in the given data object and returns the result as new data object </p>

</div>
</div>
<a class="anchor" id="a05f123e54780ea7b53fadfbef4883b66"></a><!-- doxytag: member="ito::ArgFunc" ref="a05f123e54780ea7b53fadfbef4883b66" args="(const DataObject *dObj, DataObject *resObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CmplxTp , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ArgFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>resObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, double templated method to save the element-wise argument of each element in source matrix to result matrix </p>
<p>This method takes the element-wise argument of a complex valued input matrix and stores it in the equivalent real typed result matrix</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is source matrix, must have complex type </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the resulting data object, which has the real data type which corresponds to the complex type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>std::abs </dd></dl>

</div>
</div>
<a class="anchor" id="ab906bd5c49c329cdec15ced6d37dbc4f"></a><!-- doxytag: member="ito::AssignScalarFunc" ref="ab906bd5c49c329cdec15ced6d37dbc4f" args="(const DataObject *src, const ito::tDataType type, const void *scalar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::AssignScalarFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated helper method to assign the given scalar to every element within its ROI in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> src. </p>
<p>The scalar value is converted to the type of the source data object</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td>is the source data object whose elements will be modified </td></tr>
    <tr><td class="paramname">type</td><td>is the data type of the scalar value </td></tr>
    <tr><td class="paramname">*scalar</td><td>is a void pointer to the scalar value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::exception</td><td>if conversion of scalar to dataObject's type is not possible </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>numberConcversion </dd></dl>

</div>
</div>
<a class="anchor" id="a36f6653fc2e93fa9e05a74ba911e68c0"></a><!-- doxytag: member="ito::BitAndFunc" ref="a36f6653fc2e93fa9e05a74ba911e68c0" args="(const DataObject *dObj1, const DataObject *dObj2, DataObject *dObjRes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitAndFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which element-wisely executes a bitwise 'and' comparison between values of two dataObjects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj1</td><td>is the first data object </td></tr>
    <tr><td class="paramname">*dObj2</td><td>is the second data object </td></tr>
    <tr><td class="paramname">*dObjRes</td><td>is the data object, where the result is stored </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>for unsupported data types (template specialization) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a78662303641cb24385aad7139c0a1d30"></a><!-- doxytag: member="ito::BitAndFunc&lt; ito::complex128 &gt;" ref="a78662303641cb24385aad7139c0a1d30" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitAndFunc&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise and function of type complex128 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4dcc23c3256b099a16506d298fc3d927"></a><!-- doxytag: member="ito::BitAndFunc&lt; ito::complex64 &gt;" ref="a4dcc23c3256b099a16506d298fc3d927" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitAndFunc&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise and function of type complex64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3b9612ec312c7e46d300d42bcd02242"></a><!-- doxytag: member="ito::BitAndFunc&lt; ito::float32 &gt;" ref="ac3b9612ec312c7e46d300d42bcd02242" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitAndFunc&lt; ito::float32 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise and function of type float32 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afba173abe8d18b8d82353e38aea5d465"></a><!-- doxytag: member="ito::BitAndFunc&lt; ito::float64 &gt;" ref="afba173abe8d18b8d82353e38aea5d465" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitAndFunc&lt; ito::float64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise and function of type float64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a0bad27ae6f994af924da15bc55c0c1"></a><!-- doxytag: member="ito::BitAndFunc&lt; ito::Rgba32 &gt;" ref="a0a0bad27ae6f994af924da15bc55c0c1" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitAndFunc&lt; <a class="el" href="classito_1_1_rgba32.html">ito::Rgba32</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise and function of type rgba32 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb6cabed2d1b3df8a95db570132d0e29"></a><!-- doxytag: member="ito::BitOrFunc" ref="acb6cabed2d1b3df8a95db570132d0e29" args="(const DataObject *dObj1, const DataObject *dObj2, DataObject *dObjRes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitOrFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which element-wisely executes a bitwise 'or' comparison between values of two dataObjects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj1</td><td>is the first data object </td></tr>
    <tr><td class="paramname">*dObj2</td><td>is the second data object </td></tr>
    <tr><td class="paramname">*dObjRes</td><td>is the data object, where the result is stored </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>for unsupported data types (template specialization) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="adfc93c8233d17e52bd44e045897d0916"></a><!-- doxytag: member="ito::BitOrFunc&lt; ito::complex128 &gt;" ref="adfc93c8233d17e52bd44e045897d0916" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitOrFunc&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise or function of type complex128 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa25108db00a8349be082338f1417e958"></a><!-- doxytag: member="ito::BitOrFunc&lt; ito::complex64 &gt;" ref="aa25108db00a8349be082338f1417e958" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitOrFunc&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise or function of type complex64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aade7fb86bff699af4477b297e4d625cf"></a><!-- doxytag: member="ito::BitOrFunc&lt; ito::float32 &gt;" ref="aade7fb86bff699af4477b297e4d625cf" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitOrFunc&lt; ito::float32 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise or function of type float32 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad01b8208a17f67c1d7b0ec4262b8a2a0"></a><!-- doxytag: member="ito::BitOrFunc&lt; ito::float64 &gt;" ref="ad01b8208a17f67c1d7b0ec4262b8a2a0" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitOrFunc&lt; ito::float64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise or function of type float64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f3b4656da31b1e0a51d19484d17ef4d"></a><!-- doxytag: member="ito::BitOrFunc&lt; ito::Rgba32 &gt;" ref="a9f3b4656da31b1e0a51d19484d17ef4d" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitOrFunc&lt; <a class="el" href="classito_1_1_rgba32.html">ito::Rgba32</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise or function of type rgba32 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11f97d7189ad80ea550fd4325d41a29c"></a><!-- doxytag: member="ito::BitXorFunc" ref="a11f97d7189ad80ea550fd4325d41a29c" args="(const DataObject *dObj1, const DataObject *dObj2, DataObject *dObjRes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitXorFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which element-wisely executes a bitwise 'xor' comparison between values of two dataObjects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj1</td><td>is the first data object </td></tr>
    <tr><td class="paramname">*dObj2</td><td>is the second data object </td></tr>
    <tr><td class="paramname">*dObjRes</td><td>is the data object, where the result is stored </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>for unsupported data types (template specialization) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="aab491ad268dbeb1feceaaf023fc3e94b"></a><!-- doxytag: member="ito::BitXorFunc&lt; ito::complex128 &gt;" ref="aab491ad268dbeb1feceaaf023fc3e94b" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitXorFunc&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise xor function of type complex128 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a761fb541ef52a71872a933ce2209a212"></a><!-- doxytag: member="ito::BitXorFunc&lt; ito::complex64 &gt;" ref="a761fb541ef52a71872a933ce2209a212" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitXorFunc&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise xor function of type complex64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33d5ffa96340984f96d02bbec6603638"></a><!-- doxytag: member="ito::BitXorFunc&lt; ito::float32 &gt;" ref="a33d5ffa96340984f96d02bbec6603638" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitXorFunc&lt; ito::float32 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise xor function of type float32 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7623e7de6c0e8360952a7203c241ce3b"></a><!-- doxytag: member="ito::BitXorFunc&lt; ito::float64 &gt;" ref="a7623e7de6c0e8360952a7203c241ce3b" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitXorFunc&lt; ito::float64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise xor function of type float64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ad9e33602b68e433f2846cd58cf1f3e"></a><!-- doxytag: member="ito::BitXorFunc&lt; ito::Rgba32 &gt;" ref="a9ad9e33602b68e433f2846cd58cf1f3e" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitXorFunc&lt; <a class="el" href="classito_1_1_rgba32.html">ito::Rgba32</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise xor function of type complex128 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a941c59b176dfa3d9b0164fe0d58deefd"></a><!-- doxytag: member="ito::CastFunc" ref="a941c59b176dfa3d9b0164fe0d58deefd" args="(const DataObject *dObj, DataObject *resObj, double alpha, double beta)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CastFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>resObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level templated method to cast each element of source matrix to another type. </p>
<p>The result is stored in the result matrix. Optionally a scaling and offsetting is possible.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is the source data object </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the result data object </td></tr>
    <tr><td class="paramname">alpha</td><td>is the scaling factor (default 1.0) </td></tr>
    <tr><td class="paramname">beta</td><td>is the ofset value (default 0.0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if cast failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>cv::saturate_cast </dd></dl>

</div>
</div>
<a class="anchor" id="acaadeb5a84e7fa9f44207f4f6ea80a85"></a><!-- doxytag: member="ito::checkAndSetParamVal" ref="acaadeb5a84e7fa9f44207f4f6ea80a85" args="(PyObject *tempObj, ito::Param *param, int *set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::checkAndSetParamVal </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>tempObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_param.html">ito::Param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper function to check and set initialisation parameters in the initialisation parameter list </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tempObj</td><td>python object holding the value to set </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">param</td><td>the param in the parameter list, that is set </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">set</td><td>indicator whether the parameter was set or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk on success, retError otherwise</dd></dl>
<p>The function checks if the types of the passed python parameter and the parameter are compatible and sets the parameter value if it is possible. If the paramter cannot be set an error is returned. </p>

</div>
</div>
<a class="anchor" id="a6af758f942701d80f2531249158bb33d"></a><!-- doxytag: member="ito::checkParamVector" ref="a6af758f942701d80f2531249158bb33d" args="(QVector&lt; ito::Param &gt; *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::checkParamVector </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>checks param vector </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>is a pointer to QVector&lt;ito::Param&gt;. This pointer is checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classito_1_1_ret_val.html" title="Class for error value management.">ito::RetVal</a>, that contains an error if params is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a8d4bb116538f127474d6353604b88a55"></a><!-- doxytag: member="ito::checkParamVectors" ref="a8d4bb116538f127474d6353604b88a55" args="(QVector&lt; ito::Param &gt; *paramsMand, QVector&lt; ito::Param &gt; *paramsOpt, QVector&lt; ito::Param &gt; *paramsOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::checkParamVectors </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramsMand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramsOpt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramsOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>verifies that the three param vectors are not NULL </p>
<p>If any of the given input parameters of type QVector&lt;ito::Param&gt;* are NULL, a <a class="el" href="classito_1_1_ret_val.html" title="Class for error value management.">ito::RetVal</a> is returned, that contains an error. Use this method in any algorithm-method in order to check the given input.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsMand</td><td>is the first parameter vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsOpt</td><td>is the second parameter vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsOut</td><td>is the third parameter vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classito_1_1_ret_val.html" title="Class for error value management.">ito::RetVal</a>, that contains an error if params is NULL </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a6af758f942701d80f2531249158bb33d" title="checks param vector">checkParamVector</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8bdbe9e0f2a8158cc8e4af6694e7199a"></a><!-- doxytag: member="ito::CmpFunc" ref="a8bdbe9e0f2a8158cc8e4af6694e7199a" args="(const DataObject *src1, const DataObject *src2, DataObject *dst, int cmpOp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CmpFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmpOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which compares each element in source-matrix1 with its corresponding element in source-matrix2 and saves the result in a destionation matrix </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*src1</td><td>is the first source matrix </td></tr>
    <tr><td class="paramname">*src2</td><td>is the second source matrix </td></tr>
    <tr><td class="paramname">*dst</td><td>is the destination matrix, which must have the same ROI than src1 and src2 and must be of type uint8 </td></tr>
    <tr><td class="paramname">cmpOp</td><td>is the compare operator (cv::CMP_EQ, cv::CMP_GT, cv::CMP_GE, cv::CMP_LT, cv::CMP_LE, cv::CMP_NE) </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>no comparison is possible for source matrices of type int8 (due to openCV-problems) </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if source matrix is of type int8 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="af7e09f29422f9db84dec13b03bdd6ede"></a><!-- doxytag: member="ito::CmpFunc&lt; ito::complex128 &gt;" ref="af7e09f29422f9db84dec13b03bdd6ede" args="(const DataObject *, const DataObject *, DataObject *, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CmpFunc&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for compare function of type complex128 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since comparison is not defined for complex input types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a32f1d686e00348be5244f8f01b6d7136"></a><!-- doxytag: member="ito::CmpFunc&lt; ito::complex64 &gt;" ref="a32f1d686e00348be5244f8f01b6d7136" args="(const DataObject *, const DataObject *, DataObject *, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CmpFunc&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for compare function of type complex64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since comparison is not defined for complex input types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60b5aca714c16446343d944b73c43aa1"></a><!-- doxytag: member="ito::ColFunc" ref="a60b5aca714c16446343d944b73c43aa1" args="(DataObject *dObj, const unsigned int selCol)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ColFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>selCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which changes the region of interest of the data object to the selected zero-based col index </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td></td></tr>
    <tr><td class="paramname">unsigned</td><td>int selCol indicates the zero-based col-index (considering any existing ROI) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="aba158d7c2c7d75c44740247048078bd3"></a><!-- doxytag: member="ito::ConjFunc" ref="aba158d7c2c7d75c44740247048078bd3" args="(DataObject *dObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ConjFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for calculating the conjugated value of each element within the ROI of this data object </p>
<p>This method is only valid for complex data types. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>avoid MatIterator </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if data type is not complex. This is done by template specialization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>std::conj </dd></dl>

</div>
</div>
<a class="anchor" id="a0f1e0516bec029992b462b17bf445618"></a><!-- doxytag: member="ito::convertCmplxTypeToRealType" ref="a0f1e0516bec029992b462b17bf445618" args="(ito::tDataType cmplxType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> ito::convertCmplxTypeToRealType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td>
          <td class="paramname"><em>cmplxType</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>static method which returns the real data type of any given data type </p>
<p>If the given data type is already real, the same type is returned. Else the type of the real argument of the given complex type is returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cmplxType</td><td>is the input data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>see method's description </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if the input data type is unknown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9c26379b46a3de6f731aef5bc68c3f0"></a><!-- doxytag: member="ito::ConvertToFunc" ref="ab9c26379b46a3de6f731aef5bc68c3f0" args="(const DataObject &amp;lhs, DataObject &amp;rhs, const int type, const double alpha, const double beta)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ConvertToFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts data in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> lhs to <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> rhs with a given type </p>
<p>Every element of the source data object is copied to the destionation data object by using this transformation<br/>
 elem_destination = static_cast&lt;newType&gt;(elem_source * alpha + beta)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;lhs</td><td>is the left-hand sided data object, whose data should be converted </td></tr>
    <tr><td class="paramname">&amp;rhs</td><td>is the destination data object, whose memory is firstly deleted, then newly allocated </td></tr>
    <tr><td class="paramname">type</td><td>is the type-number of the destination element </td></tr>
    <tr><td class="paramname">alpha</td><td>scaling factor (default: 1.0) </td></tr>
    <tr><td class="paramname">beta</td><td>offset value (default: 0.0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception(CV_StsAssert)</td><td>if conversion type is unknown </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>convertTo, <a class="el" href="namespaceito.html#a941c59b176dfa3d9b0164fe0d58deefd" title="low-level templated method to cast each element of source matrix to another type.">CastFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a82f94c3dcf589bc7d8725df540411b5e"></a><!-- doxytag: member="ito::CopyMatFunc" ref="a82f94c3dcf589bc7d8725df540411b5e" args="(uchar **src, uchar **&amp;dst, bool transposed, const int sizeofs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CopyMatFunc </td>
          <td>(</td>
          <td class="paramtype">uchar **&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar **&amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transposed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method that executes a shallow-copy of every matrix-plane in the source-vector and stores the copies in the destination-vector </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;src</td><td>is the source vector which contains matrix-planes of type cv::Mat_&lt;_Tp&gt; </td></tr>
    <tr><td class="paramname">&amp;dst</td><td>is the destination vector, where the shallow-copies are stored. dst should be empty at the beginning </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>operator =, <a class="el" href="classito_1_1_data_object.html#a32e74ff9c1cd0e9fc73d5f7705bce605" title="copy constructor for data object">DataObject::DataObject(const DataObject&amp; copyConstr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af336f965d8dcb64d35de938c63e18e53"></a><!-- doxytag: member="ito::copyParamVector" ref="af336f965d8dcb64d35de938c63e18e53" args="(const QVector&lt; ito::ParamBase &gt; *paramVecIn, QVector&lt; ito::ParamBase &gt; &amp;paramVecOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::copyParamVector </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramVecIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paramVecOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>makes a deep copy of a vector with values of type <a class="el" href="classito_1_1_param_base.html">ParamBase</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paramVecIn</td><td>is a pointer to a vector of ParamBase-values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">paramVecOut</td><td>is a reference to a vector which is first cleared and then filled with a deep copy of every element of paramVecIn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9596d29ad4cb556064117c73031bd0d"></a><!-- doxytag: member="ito::copyParamVector" ref="ad9596d29ad4cb556064117c73031bd0d" args="(const QVector&lt; ito::Param &gt; *paramVecIn, QVector&lt; ito::Param &gt; &amp;paramVecOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::copyParamVector </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramVecIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paramVecOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>makes a deep copy of a vector with values of type <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins">Param</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paramVecIn</td><td>is a pointer to a vector of Param-values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">paramVecOut</td><td>is a reference to a vector which is first cleared and then filled with a deep copy of every element of paramVecIn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac375d704a83f05f7ffb2345e3d92401f"></a><!-- doxytag: member="ito::CopyToFunc" ref="ac375d704a83f05f7ffb2345e3d92401f" args="(const DataObject &amp;lhs, DataObject &amp;rhs, unsigned char regionOnly)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CopyToFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>regionOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for deeply copying the data of one matrix to another given matrix </p>
<p>At first, the memory of the new matrix is delete. Then the data of the lhs-matrix is deeply copied to the rhs-matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;lhs</td><td>is the matrix whose data is copied </td></tr>
    <tr><td class="paramname">&amp;rhs</td><td>is the matrix where the data is copied to. The old data of rhs is deleted first </td></tr>
    <tr><td class="paramname">regionOnly,if</td><td>true, only the data of the ROI in lhs is copied, hence, the org-size of rhs corresponds to the ROI-size of lhs, else the whole data block is copied and the ROI of rhs is set to the ROI of lhs </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>copyTo, <a class="el" href="namespaceito.html#ad30ad071fb0c3778689aaa1483696500" title="templated method for create">CreateFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad30ad071fb0c3778689aaa1483696500"></a><!-- doxytag: member="ito::CreateFunc" ref="ad30ad071fb0c3778689aaa1483696500" args="(DataObject *dObj, const unsigned char dimensions, const int *sizes, const unsigned char continuous, const uchar *continuousDataPtr, const int *steps)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CreateFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>continuous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>continuousDataPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>templated method for create </p>
<p>creates or initializes matrix with given parameters</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dObj</td><td><a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a>, whose matrix is created here </td></tr>
    <tr><td class="paramname">dimensions</td><td>total number of dimensions (&gt;=1), if dimensions == 1, dimensions will be set to two and a matrix with dimension [1 x orginial dimension] is created </td></tr>
    <tr><td class="paramname">*sizes</td><td>vector with size of dimensions, each element gives the size of elements in each dimension </td></tr>
    <tr><td class="paramname">continuous,indicates</td><td>whether the data stored in this data object is stored in one continuous data block or not. if dimension &lt;= 2, matrix is always continuous be careful, continuous has not the same meaning than the continuous flag in opencv or numpy. </td></tr>
    <tr><td class="paramname">continuousDataPtr</td><td>if this pointer is NULL, new data will be allocated. Else the given data indicates data which will be used by this data object. only possible if continuous is true. m_ownflag will be set to 0 if this pointer is set </td></tr>
    <tr><td class="paramname">*steps</td><td>vector with size of dimensions, indicates how many bytes one has to move in order to get to the next element in the same dimension, the step-size for the last element must be equal to element-size (in byte) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>create </dd></dl>

<p><p>continuous </p>
</p>

</div>
</div>
<a class="anchor" id="aed562807073a7bd48efbef4d0bd834cb"></a><!-- doxytag: member="ito::CreateFuncWithCVPlanes" ref="aed562807073a7bd48efbef4d0bd834cb" args="(DataObject *dObj, const unsigned char dimensions, const int *sizes, const cv::Mat *planes, const unsigned int nrOfPlanes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CreateFuncWithCVPlanes </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat *&#160;</td>
          <td class="paramname"><em>planes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nrOfPlanes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>templated method for creation with given vector of cv::Mat-planes </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dimensions</td><td>is the total number of dimensions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*sizes</td><td>is a vector whose length is equal to dimensions. Each entry indicates the size of the specific dimension. Each matrix-plane is allocated with the size of the last two sizes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>is the desired element data type (see tDataType) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*planes</td><td>is an array of cv::Mat-planes which will be used as matrices for every single 2D-plane. Every Mat must have the same size and type. The type must correspond to the param type, the size must fit to the last two given sizes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrOfPlanes</td><td>is the length of the planes-array. This value must be the same than (sizes[0]*sizes[1]*...*sizes[dimensions-2]) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>create </dd></dl>

</div>
</div>
<a class="anchor" id="a49a8ffb4244dbc37882593e3ae344e74"></a><!-- doxytag: member="ito::createObjectFromXMLV1" ref="a49a8ffb4244dbc37882593e3ae344e74" args="(QXmlStreamReader &amp;stream, DataObject &amp;dObjIn, int &amp;elementsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::createObjectFromXMLV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamReader &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObjIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>elementsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function creates an dataObject from the header of the xml-file  This function creates an dataObject from the header of the xml-file by parsing the XML-stream. The first start element, already read by the calling function must contain the attributes dims, dataType and dim0..dimn-2, dimX, dimY. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>stream The xml-Stream from the xml-file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dObjIn</td><td>Destination dataContainter of type dataObject with size / dims / type speficied in the input xml </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elementsize</td><td>Byte-Size of the current dataObjekt</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#ad763de2bc627c32993a7a6e361497065">loadXML2DOBJ</a>, loadXML2EmptyDOBJ </dd></dl>

<p><p>&lt; Sizes of the new dataObject. Will be freed at end: </p>
</p>

</div>
</div>
<a class="anchor" id="a2ee6d1fc3b644438e7e45011be71540e"></a><!-- doxytag: member="ito::decRefParamPlugins" ref="a2ee6d1fc3b644438e7e45011be71540e" args="(ito::AddInBase *ai)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::decRefParamPlugins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>ai</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>decrements the reference counter of arguments passed to a plugin if necessary </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ai</td><td>AddIn to which the parameters are passed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsMand</td><td>mandatory argument parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsOpt</td><td>optional argument parameters</td></tr>
  </table>
  </dd>
</dl>
<p>This function decrements the reference counter of plugins passed to other plugins as parameters, to enable a closing of the passed plugins when they are no longer used by any other plugin. </p>

</div>
</div>
<a class="anchor" id="ae068ebf4f7f7632e6bbf58ca4030c117"></a><!-- doxytag: member="ito::DeepCopyPartialFunc" ref="ae068ebf4f7f7632e6bbf58ca4030c117" args="(DataObject &amp;lhs, DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DeepCopyPartialFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method to copy the values of the ROI of matrix lhs to the ROI of matrix rhs. </p>
<p>the ROI of rhs must already correspond to the ROI of lhs, hence, rhs must have allocated data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;lhs</td><td>is the original data object </td></tr>
    <tr><td class="paramname">&amp;rhs</td><td>is the data object, where the values are copied to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>deepCopyPartial </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>avoid <a class="el" href="classito_1_1_d_obj_iterator.html">DObjIterator</a> for speed-up </dd></dl>

</div>
</div>
<a class="anchor" id="ac6a8e6996e4df59339fa93085c606bef"></a><!-- doxytag: member="ito::DivFunc" ref="ac6a8e6996e4df59339fa93085c606bef" args="(const DataObject *src1, const DataObject *src2, DataObject *res, const double)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DivFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which does a element-wise division of elements in first source matrix by elements in second source matrix. </p>
<p>The result is stored in a result matrix, optionally the division can be scaled by a scaling factor, which is set to one by default. For fixed point numbers or complex values, a division by zero will throw an error. For floating-point values the following (matlab-like) implementation is used:</p>
<p>1.0/0.0 = Inf, 0.0/0.0 = Nan</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*src1</td><td>is the first source matrix </td></tr>
    <tr><td class="paramname">*src2</td><td>is the second source matrix </td></tr>
    <tr><td class="paramname">*res</td><td>is the result matrix, which must have the same size than the source matrices </td></tr>
    <tr><td class="paramname">double</td><td>scale is the scaling factor (default: 1.0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="af75605ada5deeee4e1eab2d707ceaa50"></a><!-- doxytag: member="ito::DivFunc&lt; Rgba32 &gt;" ref="af75605ada5deeee4e1eab2d707ceaa50" args="(const DataObject *src1, const DataObject *src2, DataObject *res, const double)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DivFunc&lt; <a class="el" href="classito_1_1_rgba32.html">Rgba32</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which does a element-wise division of elements in first source matrix by elements in second source matrix. </p>
<p>The result is stored in a result matrix, optionally the division can be scaled by a scaling factor, which is set to one by default. For fixed point numbers or complex values, a division by zero will throw an error. For floating-point values the following (matlab-like) implementation is used:</p>
<p>1.0/0.0 = Inf, 0.0/0.0 = Nan</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*src1</td><td>is the first source matrix </td></tr>
    <tr><td class="paramname">*src2</td><td>is the second source matrix </td></tr>
    <tr><td class="paramname">*res</td><td>is the result matrix, which must have the same size than the source matrices </td></tr>
    <tr><td class="paramname">double</td><td>scale is the scaling factor (default: 1.0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a8b32235878d1e9594569d92771bfcfcd"></a><!-- doxytag: member="ito::errOutInitParams" ref="a8b32235878d1e9594569d92771bfcfcd" args="(const QVector&lt; ito::Param &gt; *params, const int num, const QString reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ito::errOutInitParams </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper function for error output </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>parameters expected by the plugin </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>parameter where the error occured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reason</td><td>the reason for the error (e.g. parameter missing, wrong type, ...)</td></tr>
  </table>
  </dd>
</dl>
<p>Function used for writing error messages occured during the parsing of the parameters passed for the initialisation of a plugin. The function uses the cerr stream to "post" the error message. If possible the parameter where the error occured is marked with an arrow. Except the error all parameters necessary and optional including their type are written to the console. </p>

</div>
</div>
<a class="anchor" id="ab6be2a7a7c372536725139e73909c868"></a><!-- doxytag: member="ito::EyeFunc" ref="ab6be2a7a7c372536725139e73909c868" args="(const int size, uchar **dstMat)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::EyeFunc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for creating an eye-matrix </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>indicates the size of the square matrix </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is a pointer to which the eye-matrix is assigned to. The eye matrix is of type cv::Mat_&lt;_Tp&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a01723110515894b52457c2e3ffbb3d6f"></a><!-- doxytag: member="ito::findAndDeleteReservedInitKeyWords" ref="a01723110515894b52457c2e3ffbb3d6f" args="(PyObject *kwds, bool *enableAutoLoadParams)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::findAndDeleteReservedInitKeyWords </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>kwds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>enableAutoLoadParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>kwds list with named python arguments </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">enableAutoLoadParams</td><td>if keyword autoLoadParams is found, value of this is set to kwds-item value else false it is set to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6700407b59c1df38ff5f7235e7246fe5"></a><!-- doxytag: member="ito::formatDoubleWithUnit" ref="a6700407b59c1df38ff5f7235e7246fe5" args="(QStringList scaleThisUnitsOnly, QString unitIn, double dVal, double &amp;dValOut, QString &amp;unitOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::formatDoubleWithUnit </td>
          <td>(</td>
          <td class="paramtype">QStringList&#160;</td>
          <td class="paramname"><em>scaleThisUnitsOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>unitIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>dValOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>unitOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>&lt; Function to convert double values with unit to scaled values with scaled units (0.01m -&gt; 10mm) </p>
<p>Function generates the auto save filename from the plugin name and the dll-folder</p>
<p>Compared the abs(dValue) with the 10^(3N) and according to the results µ p M ... are added to the unit Allowed units are SI-Unit except kg and mm. It % is given as unit, values are multiplied by 100 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scaleThisUnitsOnly</td><td>List with scaleable units (e.g. mm, m) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitIn</td><td>Old unit (e.g. mm, m, %) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dVal</td><td>Double value (e.g. mm, m, %) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dValOut</td><td>Scaled value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">unitOut</td><td>Scaled unit m -&gt; mm or µm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a48b3a7f2723479d8cd742f4bf45e2143"></a><!-- doxytag: member="ito::FreeFunc" ref="a48b3a7f2723479d8cd742f4bf45e2143" args="(DataObject *dObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::FreeFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for freeing allocated data blocks </p>
<p>First, the header information of the corresponding data block is deleted. Then the reference counter of the data block is decremented. In the same way, the reference counter for every matrix-plane is incremented by calling the corresponding release-method. If the ref-counter is lower than zero no other instance needs this data block and it is deallocated if the m_owndata-flag is true.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>whose data block should be freed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>freeData </dd></dl>

</div>
</div>
<a class="anchor" id="aa872946454ba282dd90912cb19cce19b"></a><!-- doxytag: member="ito::freeParams" ref="aa872946454ba282dd90912cb19cce19b" args="(int length, char *&amp;cargt, char **&amp;cargs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ito::freeParams </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>cargt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&amp;&#160;</td>
          <td class="paramname"><em>cargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>frees parameter and parameter type arrays generated by the <a class="el" href="namespaceito.html#a8fe6cab8c18f8e06ec5b141d57ab1389">parseParams</a> function </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>number of parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cargt</td><td>array with parameter types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cargs</td><td>array with the parameter pointers / values </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0</dd></dl>
<p>The function frees the arrays generated by the <a class="el" href="namespaceito.html#a8fe6cab8c18f8e06ec5b141d57ab1389">parseParams</a> function, i.e. the array with the parsed parameter values and the array with their types. </p>

</div>
</div>
<a class="anchor" id="a5f90e9d0def8c42d6675f889c410cedf"></a><!-- doxytag: member="ito::generateAutoSaveParamFile" ref="a5f90e9d0def8c42d6675f889c410cedf" args="(QString plugInName, QFile &amp;paramFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::generateAutoSaveParamFile </td>
          <td>(</td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>plugInName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QFile &amp;&#160;</td>
          <td class="paramname"><em>paramFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>loadXML2QLIST loads parameters from an XML-File and saves them to paramList </p>
<p>function for generates the plugin xml file handle </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fName</td><td>filename (is needed e.g. to get filename) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">paramFile</td><td>reference to unopened parameter file</td></tr>
  </table>
  </dd>
</dl>
<p>The function generates the xml parameter file name and returns the a QFile handle. The name has the same name as the plugin in the plugins directory. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#af0411cd240edb9847b61a997a958bc7a" title="saveQLIST2XML writes parameters from paramList to an XML-File">loadXML2QLIST</a>, <a class="el" href="namespaceito.html#a7fa6f7375af9065c79ddb14d3c1d1f4a" title="mergeQLists copies parameters from newList to oldList and performs some checks">saveQLIST2XML</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a105e4a9c34049e6b19d587313c247536"></a><!-- doxytag: member="ito::getDataType" ref="a105e4a9c34049e6b19d587313c247536" args="(const _Tp *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> ito::getDataType </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>method which returns the value of enumeration <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>, which corresponds to the type of the given pointer parameter. </p>
<p>If the parameter type cannot be transformed into a value of <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>, an exception is thrown.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">any</td><td>pointer, whose type should be transformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if the input data type is unknown </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a61005076e5ab614ffb50aa91f8ee860a" title="method which returns the value of enumeration ito::tDataType, which corresponds to the template param...">getDataType2</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a61005076e5ab614ffb50aa91f8ee860a"></a><!-- doxytag: member="ito::getDataType2" ref="a61005076e5ab614ffb50aa91f8ee860a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> ito::getDataType2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>method which returns the value of enumeration <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>, which corresponds to the template parameter (must be a pointer). </p>
<p>If the template parameter cannot be transformed into a value of <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>, an exception is thrown.</p>
<p>Call is <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> result = <a class="el" href="namespaceito.html#a61005076e5ab614ffb50aa91f8ee860a" title="method which returns the value of enumeration ito::tDataType, which corresponds to the template param...">getDataType2&lt;uint8*&gt;()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if the template parameter is unknown (e.g. no pointer). </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a105e4a9c34049e6b19d587313c247536" title="method which returns the value of enumeration ito::tDataType, which corresponds to the type of the gi...">getDataType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab89b2aaf2edbb230bb22d996d713f02d"></a><!-- doxytag: member="ito::getExecFuncsInfo" ref="ab89b2aaf2edbb230bb22d996d713f02d" args="(ito::AddInBase *aib, PyObject *args, PyObject *kwds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::getExecFuncsInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>aib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns a list of execFunction available in a plugin similar to filterHelp </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aib</td><td>the plugin for which the execFuncs names are requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>2 Item-Vector with integer request for additional dictionary return </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>python dictionary with list of functions or specific dictionary for one execFunc with the parameters' names, min, max, current value, (infostring) </dd></dl>

</div>
</div>
<a class="anchor" id="a2a69198fb9449e1750a65dabb3911cd3"></a><!-- doxytag: member="ito::getItomVersionMap" ref="a2a69198fb9449e1750a65dabb3911cd3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QMap&lt; QString, QString &gt; ito::getItomVersionMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function is called to get all version numbers that itom contains. </p>
<p>Use this function to get a map of all parts of itom that are used with their corresponding version.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns a QMap&lt;QString,QString&gt; containing the module and the version of a module. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f9082c16ab511f4da066735faff3262"></a><!-- doxytag: member="ito::getName" ref="a9f9082c16ab511f4da066735faff3262" args="(ito::AddInBase *addInObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::getName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>addInObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns the name of a python plugin </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addInObj</td><td>the plugin whoes name should be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the plugin name </dd></dl>

</div>
</div>
<a class="anchor" id="a2ef056717cc8a683562a568e7caa02cc"></a><!-- doxytag: member="ito::getParam" ref="a2ef056717cc8a683562a568e7caa02cc" args="(ito::AddInBase *addInObj, PyObject *args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::getParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>addInObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return a parameter value </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addInObj</td><td>the addIn whoes parameter is requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>the parameter name </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>python object with the parameter value on success (parameter exists), NULL otherwise</dd></dl>
<p>The function tries to retrieve the value of the parameter with the name given in args. If the parameter does not exist NULL is returned. To actually retrieve the value the getParam function of the plugin is invoked. </p>

</div>
</div>
<a class="anchor" id="ae5f62de950023c3db6e6f899aacc6bd3"></a><!-- doxytag: member="ito::getParamByName" ref="ae5f62de950023c3db6e6f899aacc6bd3" args="(QVector&lt; ito::Param &gt; *paramVec, const char *name, ito::RetVal *retval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_param.html">ito::Param</a> * ito::getParamByName </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> *&#160;</td>
          <td class="paramname"><em>retval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>brief returns a parameter from the parameter-vector, that fits to a specific name </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>description </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a9116ec57a2f79c788a4991e28b4617e8"></a><!-- doxytag: member="ito::getParamList" ref="a9116ec57a2f79c788a4991e28b4617e8" args="(ito::AddInBase *aib)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::getParamList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>aib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns the names of the parameters available in a plugin </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aib</td><td>the plugin for which the parameter names are requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>python object with a string list with the parameters' names </dd></dl>

</div>
</div>
<a class="anchor" id="a1abfad65cf3b738c5d98938d20b9e7fe"></a><!-- doxytag: member="ito::getParamListInfo" ref="a1abfad65cf3b738c5d98938d20b9e7fe" args="(ito::AddInBase *aib, PyObject *args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::getParamListInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>aib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns the all informations of the parameters available in a plugin </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aib</td><td>the plugin for which the parameter names are requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>1 Item-Vector with bool request for additional dictionary return </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>python list of python tuple with the parameters' names, min, max, current value, (infostring) </dd></dl>

</div>
</div>
<a class="anchor" id="a5cacfeb427e8f0e5aa0dcad1b7ba181b"></a><!-- doxytag: member="ito::GetRangeFunc" ref="a5cacfeb427e8f0e5aa0dcad1b7ba181b" args="(DataObject *dObj, const int dtop, const int dbottom, const int dleft, const int dright)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::GetRangeFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dtop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dbottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dright</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for saving a shallow copy of a source cv::Mat_ to a destination cv::Mat_ with respect to given row- and col-ranges </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*SrcMat</td><td>is the source matrix which is firstly cast to cv::Mat_&lt;_Tp&gt;* </td></tr>
    <tr><td class="paramname">rowRange</td><td>is the desired row-range </td></tr>
    <tr><td class="paramname">colRange</td><td>is the desired col-range </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is the pointer to a destination matrix which is also cast to cv::Mat_&lt;_Tp&gt;* </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="ad71b2e1bfcedf7815a5aa6156db1e9bc"></a><!-- doxytag: member="ito::guessDataTypeFromCVMat" ref="ad71b2e1bfcedf7815a5aa6156db1e9bc" args="(const cv::Mat *mat, ito::RetVal &amp;retval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> ito::guessDataTypeFromCVMat </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> &amp;&#160;</td>
          <td class="paramname"><em>retval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>static method which guesses the dataObject type from a given cv::Mat* </p>
<p>If the given data type is already real, the same type is returned. Else the type of the real argument of the given complex type is returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>is the OpenCV matrix. </td></tr>
    <tr><td class="paramname">retval</td><td>an error value will be added if the type cannot be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">ito::DataObject</a> type that fits to the given matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a66331885ebad02c6f99d27ed34a674e7"></a><!-- doxytag: member="ito::imag" ref="a66331885ebad02c6f99d27ed34a674e7" args="(const DataObject &amp;dObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> DATAOBJ_EXPORT ito::imag </td>
          <td>(</td>
          <td class="paramtype">const DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level value which calculates the imaginary value of each element of the input source data object and returns the resulting data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new data object with imaginary values </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if undefined data type (e.g. real data types) </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a05f123e54780ea7b53fadfbef4883b66" title="low-level, double templated method to save the element-wise argument of each element in source matrix...">ArgFunc</a></dd></dl>
<p>calculates the imaginary part of each element in the given data object and returns the result as new data object </p>

</div>
</div>
<a class="anchor" id="a88f1f6a29d6bcd1bcd9604ac633622ec"></a><!-- doxytag: member="ito::ImagFunc" ref="a88f1f6a29d6bcd1bcd9604ac633622ec" args="(const DataObject *dObj, DataObject *resObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CmplxTp , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ImagFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>resObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, double templated method to save the element-wise imaginary value of each element in source matrix to result matrix </p>
<p>This method takes the imaginary value of a complex valued input matrix and stores it in the equivalent real typed result matrix</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is source matrix, must have complex type </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the resulting data object, which has the real data type which corresponds to the complex type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>std::abs </dd></dl>

</div>
</div>
<a class="anchor" id="a9f86dfd2e4d25372a4b35066e423f4b2"></a><!-- doxytag: member="ito::incRefParamPlugins" ref="a9f86dfd2e4d25372a4b35066e423f4b2" args="(ito::AddInBase *ai, QVector&lt; ito::ParamBase &gt; *paramsMand, QVector&lt; ito::ParamBase &gt; *paramsOpt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ito::incRefParamPlugins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramsMand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramsOpt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>increments the reference counter of arguments passed to a plugin if necessary </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ai</td><td>AddIn to which the parameters are passed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsMand</td><td>mandatory argument parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsOpt</td><td>optional argument parameters</td></tr>
  </table>
  </dd>
</dl>
<p>This function increments the reference counter of plugins passed to other plugins as parameters, to avoid the passed plugins are closed while they are still in use by the other plugin. </p>

</div>
</div>
<a class="anchor" id="aff7445a2b9222e042ae3b4a8b4112f60"></a><!-- doxytag: member="ito::isZeroValue" ref="aff7445a2b9222e042ae3b4a8b4112f60" args="(_Tp v, _Tp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool ito::isZeroValue </td>
          <td>(</td>
          <td class="paramtype">_Tp&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Tp&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>method returns whether a given variable is equal to zero. </p>
<p>For floating point variables, this method considers a variable to be zero, if its value lie within the boundaries (-epsilon,epsilon). Epsilon can for example be obtained by std::numeric_limits&lt;_Tp&gt;::epsilon(). For floating point values only parameters of type float32, float64, complex64 or complex128 are treated in the desired way.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is value to check </td></tr>
    <tr><td class="paramname">epsilon</td><td>is epsilon boundary, for fixed-point values this value is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if value is zero or within the epsilon boundaries, else false </dd></dl>

</div>
</div>
<a class="anchor" id="a43463b798f2244f8f380ff8af5337c20"></a><!-- doxytag: member="ito::loadDataFromXMLV1" ref="a43463b798f2244f8f380ff8af5337c20" args="(QXmlStreamReader &amp;stream, DataObject &amp;dObjIn, int elementsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::loadDataFromXMLV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamReader &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObjIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function copies the CDATA from the xml-file to the allocated dataObject.  This function copies the CDATA from the xml-file to the allocated dataObject. The data was before packed (substitution of xml-registered characters) during saving and is unpacked here. The data is stored plane-wise. The function checks if the plane-size if the object is equal to the imported size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>stream The xml-Stream from the xml-file </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>dObjIn allocated dataObject </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementsize</td><td>Size of the each matrix-element</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#ad763de2bc627c32993a7a6e361497065">loadXML2DOBJ</a>, loadXML2EmptyDOBJ, <a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>, <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a99b23c44aedc092db34847ec3d850a7c"></a><!-- doxytag: member="ito::loadObjectHeaderFromXMLV1" ref="a99b23c44aedc092db34847ec3d850a7c" args="(QXmlStreamReader &amp;stream, DataObject &amp;dObjIn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::loadObjectHeaderFromXMLV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamReader &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObjIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function fills the MetaData (<a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) of an allocated dataObject from the values of an xml-file  This function fills the MetaData (<a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) of an allocated dataObject from the values of an xml-file. This includes the axis-Tags (offset, scale, unit, description), value-Tags ((offset), (scale), unit, description) and the rotation matrix. It does not include the tag-Space (std::map&lt;std::string, DataObjectTagType&gt; m_tags) (e.g. protocol ...) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">[in|out]</td><td>stream The xml-Stream from the xml-file </td></tr>
    <tr><td class="paramname">[in|out]</td><td>dObjIn allocated dataObject</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#ad763de2bc627c32993a7a6e361497065">loadXML2DOBJ</a>, loadXML2EmptyDOBJ, <a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>, <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4132d915f47775d5edcab7874885c27d"></a><!-- doxytag: member="ito::loadTagSpaceFromXMLV1" ref="a4132d915f47775d5edcab7874885c27d" args="(QXmlStreamReader &amp;stream, DataObject &amp;dObjIn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::loadTagSpaceFromXMLV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamReader &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObjIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function fills the tagsSpace (<a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) of an allocated dataObject from the values of an xml-file  This function fills the tagsSpace (<a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) of an allocated dataObject from the values of an xml-file. This onlye includes the tag-Space (std::map&lt;std::string, DataObjectTagType&gt; m_tags) (e.g. protocol ...) and does not include the axis-Tags (offset, scale, unit, description), value-Tags ((offset), (scale), unit, description) and the rotation matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">[in|out]</td><td>stream The xml-Stream from the xml-file </td></tr>
    <tr><td class="paramname">[in|out]</td><td>dObjIn allocated dataObject</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#ad763de2bc627c32993a7a6e361497065">loadXML2DOBJ</a>, loadXML2EmptyDOBJ, <a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>, <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad763de2bc627c32993a7a6e361497065"></a><!-- doxytag: member="ito::loadXML2DOBJ" ref="ad763de2bc627c32993a7a6e361497065" args="(ito::DataObject *dObjIn, QString folderFileName, bool onlyHeaderObjectFile=false, bool appendEnding=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::loadXML2DOBJ </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>folderFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyHeaderObjectFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appendEnding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[Out]</td><td>dObjIn Destination dataContainter of type dataObject </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">folderFileName</td><td>Folder and Filename of the Sourcefile</td></tr>
  </table>
  </dd>
</dl>
<p>This function loads data from a xml-file to a dataObject. The file must be compatible to the file-format describted before. There are to possilbe import methods: 1. onlyHeaderObjectFile == false tries to import a ido file with a itoDataObject-note/startelement. 1. onlyHeaderObjectFile == true tries to import a idh file with a itoDataObjectHeader-note/startelement. The dataSpace will be ignored</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a49a8ffb4244dbc37882593e3ae344e74" title="This function creates an dataObject from the header of the xml-file  This function creates an dataObj...">createObjectFromXMLV1</a>, <a class="el" href="namespaceito.html#a99b23c44aedc092db34847ec3d850a7c" title="This function fills the MetaData (DataObjectTags) of an allocated dataObject from the values of an xm...">loadObjectHeaderFromXMLV1</a>, <a class="el" href="namespaceito.html#a4132d915f47775d5edcab7874885c27d" title="This function fills the tagsSpace (DataObjectTags) of an allocated dataObject from the values of an x...">loadTagSpaceFromXMLV1</a>, <a class="el" href="namespaceito.html#a43463b798f2244f8f380ff8af5337c20" title="This function copies the CDATA from the xml-file to the allocated dataObject.  This function copies t...">loadDataFromXMLV1</a> </dd></dl>

<p><p>&lt; Returnvalue for the complete function</p>
<p>&lt; Handle to the source data</p>
<p>&lt; Returnvalue for the complete function</p>
<p>&lt; Handle to the source data </p>
</p>

</div>
</div>
<a class="anchor" id="af3ff1acd7b8b3e2140db87852be40b77"></a><!-- doxytag: member="ito::loadXML2QLIST" ref="af3ff1acd7b8b3e2140db87852be40b77" args="(QMap&lt; QString, Param &gt; *paramList, QString id, QFile &amp;paramFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::loadXML2QLIST </td>
          <td>(</td>
          <td class="paramtype">QMap&lt; QString, Param &gt; *&#160;</td>
          <td class="paramname"><em>paramList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QFile &amp;&#160;</td>
          <td class="paramname"><em>paramFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">paramList</td><td>Empty List of Type QMap. If not empty this function will clear the list before reading </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Identifier of the plugin. Currently implemented as integer number only </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramFile</td><td>Filename of the file. The file will be opened/closed in this function</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads the parameters for a plugin specified with id from an XML file. During initialisation an xml file with the same name as the plugin library in the plugin directory is used to load the plugin parameters. The xml file is checked for the current plugin-file version and type when opened. The parameters have in the calling function afterwards. </p>

</div>
</div>
<a class="anchor" id="a0f596a4a1f37a4fe4e383180bd7c92b8"></a><!-- doxytag: member="ito::makeContinuous" ref="a0f596a4a1f37a4fe4e383180bd7c92b8" args="(const DataObject &amp;dObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> DATAOBJ_EXPORT ito::makeContinuous </td>
          <td>(</td>
          <td class="paramtype">const DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level method which copies an incontinuously organized data object to a continuously organized resulting data object, which is returned </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td>is the source data object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting data object </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#afa7884cab1fc4d64b4de411e9b0de1d5" title="low-level, templated method which copies an incontinuously organized data object to a continuously or...">MakeContinuousFunc</a></dd></dl>
<p>if the given data object is not continuously organized, copies the content to a new continuous data object </p>

</div>
</div>
<a class="anchor" id="afa7884cab1fc4d64b4de411e9b0de1d5"></a><!-- doxytag: member="ito::MakeContinuousFunc" ref="afa7884cab1fc4d64b4de411e9b0de1d5" args="(const DataObject &amp;dObj, DataObject &amp;resDObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::MakeContinuousFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject &amp;&#160;</td>
          <td class="paramname"><em>resDObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which copies an incontinuously organized data object to a continuously organized resulting data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td>is the source data object </td></tr>
    <tr><td class="paramname">&amp;resDObj</td><td>is the resulting data object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a487ae8b7490f1de2f8c400eab1859f58"></a><!-- doxytag: member="ito::mergeQLists" ref="a487ae8b7490f1de2f8c400eab1859f58" args="(QMap&lt; QString, Param &gt; *oldList, QMap&lt; QString, Param &gt; *newList, bool checkAutoSave, bool deleteUnchangedParams)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::mergeQLists </td>
          <td>(</td>
          <td class="paramtype">QMap&lt; QString, Param &gt; *&#160;</td>
          <td class="paramname"><em>oldList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QMap&lt; QString, Param &gt; *&#160;</td>
          <td class="paramname"><em>newList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkAutoSave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteUnchangedParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>oldList Paramlist with all plugin-parameters, which will contain the merged parameters in the end </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>newList New parameter values to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">checkAutoSave</td><td>Flag to enable / disable autosave control to avoid obsolet parameters to overwrite exisiting parameters.</td></tr>
  </table>
  </dd>
</dl>
<p>This function compares the new list with the old list. If new list contains parameters which do not exist in the existing list, the paremeter is ignored and a warning is added to the errormessage stack. If the checkAutoSave parameter is true, parameters in oldList are not altered of the autosave is disabled. In this case a warning is returned. In case the paremters Type is not equal, a warning is returned and the paremeter is not altered. At the moment only parameters of numeric values and strings are merged. </p>

</div>
</div>
<a class="anchor" id="affa9cfef07f2dc18ee2aaa6e5f1327bc"></a><!-- doxytag: member="ito::numberConversion" ref="affa9cfef07f2dc18ee2aaa6e5f1327bc" args="(ito::tDataType fromType, void *scalar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp ito::numberConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td>
          <td class="paramname"><em>fromType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>templated method for converting a given scalar value to the data type, indicated by the template parameter </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fromType</td><td>is the data type of the given scalar </td></tr>
    <tr><td class="paramname">*scalar</td><td>is the pointer to the scalar value, casted to void* </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the converted scalar value </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if the input data type is unknown or if the conversion failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>saturate_cast </dd></dl>

</div>
</div>
<a class="anchor" id="ab6bf15ce0d6fe4193e28f2dc8ff203b6"></a><!-- doxytag: member="ito::OnesFunc" ref="ab6bf15ce0d6fe4193e28f2dc8ff203b6" args="(const int sizeY, const int sizeX, uchar **dstMat)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::OnesFunc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for creation of one-valued matrix-plane </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is the pointer to the already allocated cv::Mat_&lt;type&gt;-matrix-plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>zeros </dd></dl>

</div>
</div>
<a class="anchor" id="aa55fb8a70f604f782396343a4bc14111"></a><!-- doxytag: member="ito::OnesFunc&lt; ito::Rgba32 &gt;" ref="aa55fb8a70f604f782396343a4bc14111" args="(const int sizeY, const int sizeX, uchar **dstMat)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::OnesFunc&lt; <a class="el" href="classito_1_1_rgba32.html">ito::Rgba32</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, overloaded template method for creation of one-valued matrix-plane of RGBA32 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is the pointer to the already allocated cv::Mat_&lt;type&gt;-matrix-plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>zeros </dd></dl>

</div>
</div>
<a class="anchor" id="a5c1b3f43be5840d203b2811c77352321"></a><!-- doxytag: member="ito::OpMulFunc" ref="a5c1b3f43be5840d203b2811c77352321" args="(const DataObject *dObj1, const DataObject *dObj2, DataObject *dObjRes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::OpMulFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>brief description </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>check for right definition of multiplication </dd></dl>

</div>
</div>
<a class="anchor" id="ab074a2771541dde53ff60788300cc57e"></a><!-- doxytag: member="ito::OpScalarMulFunc" ref="ab074a2771541dde53ff60788300cc57e" args="(const DataObject *src, const double &amp;factor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::OpScalarMulFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which multiplies every element of Data Object with a factor </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td></td></tr>
    <tr><td class="paramname">factor</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a8e672322a951881453fcd73de2c771ff"></a><!-- doxytag: member="ito::parseInitParams" ref="a8e672322a951881453fcd73de2c771ff" args="(QVector&lt; ito::Param &gt; *initParamListMand, QVector&lt; ito::Param &gt; *initParamListOpt, PyObject *args, PyObject *kwds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::parseInitParams </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>initParamListMand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>initParamListOpt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function to read mandatory and optional parameter lists from a given python parameter list according to the plugins definition </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">initParamListMand</td><td>vector holding the mandatory initialisation parameters (filled with default values), the default values are overwritten with the passed values </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">initParamListOpt</td><td>vector holding the optional initialisation parameters (filled with default values), the default values are overwritten with the passed values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>list with python arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kwds</td><td>list with named python arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns <a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a2ced39cc25866a04f2fb1c9f1d6a542e">ito::retOk</a> if the number and type of parameters was correct, <a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a199f41b7779e742e0a3cc281c42c97c0">ito::retError</a> otherwise</dd></dl>
<p>The function takes as input the vectors with the madatory and optional input parameters used for the plugin initialisation. These vectors must be previously be read using the function getInitParams. The default values of the parameters are overwritten with the values given by python. In case the number or parameters or a parameter type is incorrect the function will abort with an error. </p>

</div>
</div>
<a class="anchor" id="aea20a9bf1563f8642db8062c912b2b2c"></a><!-- doxytag: member="ito::parseParamName" ref="aea20a9bf1563f8642db8062c912b2b2c" args="(const QString &amp;name, QString &amp;paramName, bool &amp;hasIndex, int &amp;index, QString &amp;additionalTag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::parseParamName </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>paramName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>hasIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>additionalTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>parses parameter name with respect to regular expression, assigned for parameter-communcation with plugins </p>
<p>This method parses any parameter-name with respect to the rules defined for possible names of plugin-parameters.</p>
<p>The regular expression used for the check is "^([a-zA-Z]+\\w*)(\\[(\\d+)\\]){0,1}(:(.*)){0,1}$"</p>
<p>Then the components are:</p>
<p>[0] full string [1] PARAMNAME [2] [INDEX] or empty-string if no index is given [3] INDEX or empty-string if no index is given [4] :ADDITIONALTAG or empty-string if no tag is given [5] ADDITIONALTAG or empty-string if no tag is given</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>is the raw parameter name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">paramName</td><td>is the real parameter name (first part of name; part before the first opening bracket ('[') or if not available the first colon (':')) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hasIndex</td><td>indicates whether the name contains an index part (defined by a number within two brackets (e.g. '[NUMBER]'), which has to be appended to the paramName </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>is the fixed-point index value or -1 if hasIndex is false </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">additionalTag</td><td>is the remaining string of name which is the part after the first colon (':'). If an index part exists, the first colon after the index part is taken. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8fe6cab8c18f8e06ec5b141d57ab1389"></a><!-- doxytag: member="ito::parseParams" ref="a8fe6cab8c18f8e06ec5b141d57ab1389" args="(PyObject *args, int length, char **&amp;cargs, char *&amp;cargt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ito::parseParams </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&amp;&#160;</td>
          <td class="paramname"><em>cargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>cargt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper function that accepts a python parameter list and returns pointers to the parameters' values and a list with their types </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>list with python parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>number of parameters passed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cargs</td><td>pointers to the parsed parameters </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cargt</td><td>list with the parameter's types </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>return 0 if all parameters passed could be parsed to a known type, -1 otherwise</dd></dl>
<p>The function accepts a list of python parameters and tries to parse them to make them available to c/c++ functions. The found parameters pointers are given back in the cargs array ant the parameters' types in the cargt array. To free the generated lists use the <a class="el" href="namespaceito.html#aa872946454ba282dd90912cb19cce19b">freeParams</a> function. </p>

</div>
</div>
<a class="anchor" id="afb4b7505de2474537f0ff7a5e678cf94"></a><!-- doxytag: member="ito::parsePosParams" ref="afb4b7505de2474537f0ff7a5e678cf94" args="(PyObject *args, char **&amp;cargs, char *&amp;cargt, QVector&lt; int &gt; &amp;axisVec, QVector&lt; double &gt; &amp;posVec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::parsePosParams </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&amp;&#160;</td>
          <td class="paramname"><em>cargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>cargt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>axisVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>posVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>helper function to parse the positioning parameters for an actuator </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments passed to the function (in python) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>cargs parsed argument values </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>cargt parsed argument types </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">axisVec</td><td>Vector with axes numbers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">posVec</td><td>Vector with position values </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk of parameters could be parsed, retError otherwise</dd></dl>
<p>Parses the parameters passed to a setPos command in python. For each axis that should be positioned an axis number and a position value are expected. </p>

</div>
</div>
<a class="anchor" id="a870a619f4f3ef4e483e8bf469d89ce97"></a><!-- doxytag: member="ito::plugin_hideToolbox" ref="a870a619f4f3ef4e483e8bf469d89ce97" args="(ito::AddInBase *aib)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::plugin_hideToolbox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>aib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns the list of available parameters </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>the actuator object (python)</td></tr>
  </table>
  </dd>
</dl>
<p>This method simply close the widget </p>

</div>
</div>
<a class="anchor" id="ac145e823451a24a203e1a201da54bbdc"></a><!-- doxytag: member="ito::plugin_showToolbox" ref="ac145e823451a24a203e1a201da54bbdc" args="(ito::AddInBase *aib)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::plugin_showToolbox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>aib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns the list of available parameters </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>the actuator object (python)</td></tr>
  </table>
  </dd>
</dl>
<p>This method simply open the widget </p>

</div>
</div>
<a class="anchor" id="a616eeca3c7b5773bfffeba9839402297"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a616eeca3c7b5773bfffeba9839402297" args="(dataObjectInit_doc,&quot;dataObject([dims [, dtype='uint8'[, continuous = 0][, data = valueOrSequence]]]) &#45;&gt; constructor to get a new dataObject.\n\
\n\
The itom.dataObject represents a multidimensional array of fixed&#45;size items with corresponding meta information (units, axes descriptions, scalings, tags, protocol...). \n\
Recently the following data types (dtype) are supported: \n\
\n\
* Integer&#45;type (int8, uint8, int16, uint16, int32, uint32),\n\
* Floating&#45;type (float32, float64 (=&gt; double)),\n\
* Complex&#45;type  (complex64 (2x float32), complex128 (2x float64)).\n\
* Color&#45;type  (rgba32 (uint32 or uint[4] containing the four 8bit values [R, G, B, Alpha])).\n\
\n\
Arrays can also be constructed using some of the static pre&#45;initialization methods 'zeros', 'ones', 'rand' or 'randN' (refer to the See Also section below). \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
dims : {sequence of integers}, optional \n\
    'dims' is a list or tuple indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns. If not given, an empty data object is created.\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','uint32','float32','float64','complex64','complex128', 'rgba32'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
data : {str}, optional \n\
    'data' is a single value or a sequence with the same amount of values than the data object. The values from data will be assigned to the new data object (filled row by row).\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
The itom.dataObject is a direct wrapper for the underlying C++ class *dataObject*. This array class mainly is based on the class *Mat* of the computer vision library (OpenCV). \n\
\n\
In order to handle huge matrices, the data object can divide one array into chunks in memory.\n\
Each subpart (called matrix&#45;plane) is two&#45;dimensional and covers data of the last two dimensions.\n\
In c++&#45;context each of these matrix&#45;planes is of type cv::Mat_&lt;type&gt; and can be used with every operator given by the openCV&#45;framework (version 2.3.1 or higher).\n\
\n\
The dimensions of the matrix are structured descending. So if we assume to have a n&#45;dimensional matrix A,\n\
where each dimension has its size s_i, the dimensions order is n, .., z, y, x and the corresponding sizes of A are [s_n, s_(n&#45;1),  s_(n&#45;2), ..., s_y, s_x].\n\
\n\
In order to make the data object compatible to continuously organized data structures, like numpy&#45;arrays, \n\
it is also possible to have all matrix&#45;planes in one data&#45;block in memory (not recommended for huge matrices).\n\
Nevertheless, the indicated data structure with the two&#45;dimensional sub&#45;matrix&#45;planes is still existing. \n\
The data organization is equal to the one of openCV, hence, two&#45;dimensional matrices are stored row&#45;by&#45;row (C&#45;style)...\n\
\n\
In addition to OpenCV, itom.dataObject supports complex valued data types for all operators and methods. \n\
\n\
Warning 'uint32' is not fully openCV&#45;compatible and hence causes instability!\n\
\n\
**Deep Copy, Shallow Copy and ROI** \n\
\n\
It is possible to set a n&#45;dimensional region of interest (ROI) to each matrix, the virtual dimensions,\n\
which will be delivered if the user asks for the matrix size.\n\
To avoid copy operations where possible a simple =_Operator will also make a shallow copy of the object.\n\
Shallow copies share the same data (elements and meta data) with the original object, hence manipulations of one object will affect the\n\
original object and all shallow copies.\n\
\n\
The opposite a deep copy of a dataObject (by sourceObject.copy()) creates a complete mew matrix with own meta data object.\n\
\n\
Example:\n\
::\n\
    #Create an object \n\
    dObj = dataObject([5, 10, 10], 'int8')\n\
    \n\
    # Make a shallow copy \n\
    dObjShallow = dObj \n\
    \n\
    # Make a shallow copy on ROI\n\
    dObjROI = dObj[1, :, :] \n\
    \n\
    # Set the value of element [1, 0, 0] to 0\n\
    dObj[1, 0, 0] = 0\n\
    \n\
    # Make a deep copy of the dObjROI\n\
    dObjROICopy = dObjROI.copy()\n\
    \n\
    # Set the value of dObjROICopy element [0, 0, 0] to 127 without effecting other objects\n\
    dObjROICopy[0, 0, 0] = 127\n\
\n\
**Constructor** \n\
\n\
The function dataObject([dims [, dtype='uint8'[, continuous = 0][, data = valueOrSequence]]])\n\
creates a new itom&#45;dataObject filled with undefined data.\n\
If no parameters are given, an uninitilized DataObject (dims = 0, no sizes) is created.\n\
\n\
As second possibility you can also use the copy&#45;constructor 'dataObject(AnyArray)', \n\
where AnyArray must be any array&#45;like structure which is parsable by the numpy&#45;interface.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
ones() : Static method to construct a data object filled with ones. \n\
zeros() : Static method to construct a data object filled with zeros. \n\
rand() : Static method to construct a randomly filled data object (uniform distribution). \n\
randN() : Static method to construct a randomly filled data object (gaussian distribution).&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ito::PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">dataObjectInit_doc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;&#160;</td>
          <td class="paramname"><em>dataObject</em>[dims [, dtype='uint8'[, continuous = 0][, data = valueOrSequence]]]) -&gt; constructor to get a new dataObject.\n\\n\The itom.dataObject represents a multidimensional array of fixed-size items with corresponding meta information (units, axes descriptions, scalings, tags, protocol...). \n\Recently the following data types (dtype) are supported: \n\\n\* Integer-type (int8, uint8, int16, uint16, int32, uint32, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">\n\*Floating-&#160;</td>
          <td class="paramname"><em>type</em>float32, float64(=&gt; double), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">\n\*Complex-type(complex64(2x float32), complex128(2x float64)).\n\*Color-type(rgba32(uint32 or uint[4] containing the four 8bit values[R, G, B, Alpha])).\n\\n\Arrays can also be constructed using some of the static pre-initialization methods 'zeros'&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'ones'&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>brief description </p>
<p>long description</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>description </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>description </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>(see also) keywords (comma-separated) </dd></dl>

</div>
</div>
<a class="anchor" id="a9d28eae15e9624a9b374e03abe6d8f83"></a><!-- doxytag: member="ito::PyWidgetOrFilterHelp" ref="a9d28eae15e9624a9b374e03abe6d8f83" args="(bool getWidgetHelp, PyObject *pArgs, PyObject *pKwds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::PyWidgetOrFilterHelp </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getWidgetHelp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>pArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>pKwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>first try to catch a perfect match with existing filters</p>
<p>Now get the complete filterlist </p>
</p>

</div>
</div>
<a class="anchor" id="a2624af727dd0e527b47944104f86bfe4"></a><!-- doxytag: member="ito::RandFunc" ref="a2624af727dd0e527b47944104f86bfe4" args="(const int sizeY, const int sizeX, const double value1, const double value2, const bool randMode, uchar **dstMat)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::RandFunc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>randMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for creation of random-valued matrix-plane </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">type</td><td>is the desired data-element-type </td></tr>
    <tr><td class="paramname">randMode</td><td>switch mode between uniform distributed(false) and normal distributed noise(true) </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is the pointer to the already allocated cv::Mat_&lt;type&gt;-matrix-plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>zeros </dd></dl>

</div>
</div>
<a class="anchor" id="a8f01949773094d46c7a3c54dc41f13cc"></a><!-- doxytag: member="ito::RandFunc&lt; ito::complex128 &gt;" ref="a8f01949773094d46c7a3c54dc41f13cc" args="(const int sizeY, const int sizeX, const double value1, const double value2, const bool randMode, uchar **dstMat)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::RandFunc&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>randMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for low-level, templated method for creation of random-valued matrix-plane of type complex128 </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a2624af727dd0e527b47944104f86bfe4" title="low-level, templated method for creation of random-valued matrix-plane">RandFunc</a>, zeros, ones </dd></dl>

</div>
</div>
<a class="anchor" id="ab712cc635923ca500edad215ec837ca1"></a><!-- doxytag: member="ito::RandFunc&lt; ito::Rgba32 &gt;" ref="ab712cc635923ca500edad215ec837ca1" args="(const int sizeY, const int sizeX, const double value1, const double value2, const bool randMode, uchar **dstMat)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::RandFunc&lt; <a class="el" href="classito_1_1_rgba32.html">ito::Rgba32</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>randMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for low-level, templated method for creation of random-valued matrix-plane of type rgba32 </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a2624af727dd0e527b47944104f86bfe4" title="low-level, templated method for creation of random-valued matrix-plane">RandFunc</a>, zeros, ones </dd></dl>

</div>
</div>
<a class="anchor" id="ae98bfefe271214ccda435c4be975f5e4"></a><!-- doxytag: member="ito::readDoubleFromXML" ref="ae98bfefe271214ccda435c4be975f5e4" args="(QXmlStreamAttributes &amp;attrStream, QString &amp;Element, QString &amp;Attrib, double &amp;val, bool isBinary)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::readDoubleFromXML </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>Element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>Attrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isBinary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This helper function extracts a double from the xml-Attributes of the Stream  This helper function extracts a double from the xml-Attributes of the Stream copied by the caller with the attrStream = attrStream = stream.attributes();. the Function checks if the attribute exists and than tries to convert to the value of the attribute either from binary or with string to double functions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attrStream</td><td>incomming attribute-stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Element</td><td>name of the element (only for error msg) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Attrib</td><td>name of the attribute to extract </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>val Must be filled with default value and is filled with value from the XML-Stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isBinary</td><td>Must be true if attribute value was stored as binary else false</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#ad763de2bc627c32993a7a6e361497065">loadXML2DOBJ</a>, loadXML2EmptyDOBJ, <a class="el" href="namespaceito.html#a99b23c44aedc092db34847ec3d850a7c" title="This function fills the MetaData (DataObjectTags) of an allocated dataObject from the values of an xm...">loadObjectHeaderFromXMLV1</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa3fb95bb073f0055c98ee99e91b9c22a"></a><!-- doxytag: member="ito::readStdStringFromXML" ref="aa3fb95bb073f0055c98ee99e91b9c22a" args="(QXmlStreamAttributes &amp;attrStream, QString &amp;Element, QString &amp;Attrib, std::string &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::readStdStringFromXML </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>Element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>Attrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This helper function extracts a std::string from the xml-Attributes of the Stream  This helper function extracts a std::string from the xml-Attributes of the Stream copied by the caller with the attrStream = attrStream = stream.attributes();. the Function checks if the attribute exists and than tries to convert to the value of the attribute from QString to std::string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attrStream</td><td>incomming attribute-stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Element</td><td>name of the element (only for error msg) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Attrib</td><td>name of the attribute to extract </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>val Must be filled with default value and is filled with value from the XML-Stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#ad763de2bc627c32993a7a6e361497065">loadXML2DOBJ</a>, loadXML2EmptyDOBJ, <a class="el" href="namespaceito.html#a99b23c44aedc092db34847ec3d850a7c" title="This function fills the MetaData (DataObjectTags) of an allocated dataObject from the values of an xm...">loadObjectHeaderFromXMLV1</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afecd6942c1876cc35f42046db0a098ea"></a><!-- doxytag: member="ito::readTillNext" ref="afecd6942c1876cc35f42046db0a098ea" args="(QXmlStreamReader &amp;stream, int &amp;times, int maxtimes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ito::readTillNext </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamReader &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxtimes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This helper function reads the stream till the next startElement.  The Qt-Function readNextStartElement sometimes stops at the end-element (:P). So the function tries to read until it reaches the next startelement but only for maxtimes trys the Function checks if the attribute exists and than tries to convert to the value of the attribute either from binary or with string to double functions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>incomming xml-stream </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>times Counts of iterations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxtimes</td><td>maximal number of iterations to perform</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#ad763de2bc627c32993a7a6e361497065">loadXML2DOBJ</a>, loadXML2EmptyDOBJ </dd></dl>

</div>
</div>
<a class="anchor" id="a4d864aeb8c51f9ddb98fc6068afd96bf"></a><!-- doxytag: member="ito::real" ref="a4d864aeb8c51f9ddb98fc6068afd96bf" args="(const DataObject &amp;dObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> DATAOBJ_EXPORT ito::real </td>
          <td>(</td>
          <td class="paramtype">const DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level value which calculates the real value of each element of the input source data object and returns the resulting data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new data object with real values </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if undefined data type (e.g. real data types) </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a05f123e54780ea7b53fadfbef4883b66" title="low-level, double templated method to save the element-wise argument of each element in source matrix...">ArgFunc</a></dd></dl>
<p>calculates the real part of each element in the given data object and returns the result as new data object </p>

</div>
</div>
<a class="anchor" id="a9b70d112986bf4af3188641ed32eb9ba"></a><!-- doxytag: member="ito::RealFunc" ref="a9b70d112986bf4af3188641ed32eb9ba" args="(const DataObject *dObj, DataObject *resObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CmplxTp , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::RealFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>resObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, double templated method to save the element-wise real value of each element in source matrix to result matrix </p>
<p>This method takes the real value of a complex valued input matrix and stores it in the equivalent real typed result matrix</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is source matrix, must have complex type </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the resulting data object, which has the real data type which corresponds to the complex type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>std::abs </dd></dl>

</div>
</div>
<a class="anchor" id="a1dd5ee04f3bb0552ee8b9761c8b766ff"></a><!-- doxytag: member="ito::RowFunc" ref="a1dd5ee04f3bb0552ee8b9761c8b766ff" args="(DataObject *dObj, const unsigned int selRow)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::RowFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>selRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which changes the region of interest of the data object to the selected zero-based row index </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td></td></tr>
    <tr><td class="paramname">selRow</td><td>indicates the zero-based row-index (considering any existing ROI) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="aca8826921e5df8a0a37e1a43ed2800cc"></a><!-- doxytag: member="ito::saveDOBJ2XML" ref="aca8826921e5df8a0a37e1a43ed2800cc" args="(ito::DataObject *dObjOut, QString folderFileName, bool onlyHeaderObjectFile=false, bool doubleAsBinary=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::saveDOBJ2XML </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>folderFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyHeaderObjectFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doubleAsBinary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Import a dataObject from harddrive, saved in the ITO-XML-Format (.ido or .idh) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dObjOut</td><td><a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> to save </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">folderFileName</td><td>Name of the folder and the filename e.g. c:\bla.xml or c://bla.xml </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doubleAsBinary</td><td>If true, double are exported as binary, by defaults they are saved as strings</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes data and meta data of a dataObject to the harddrive. The file format is based on xml. The data of the dataObject are converted to binary without XML-registed signs by QByteArray::toBase64()). The metaData and tagSpace are either saved as binary (QByteArray::toBase64()) or saves as strings with 15 signifiant digits (more than 32-Bit). So for most applications doubleAsBinary==false is enough.</p>
<p>Lyda </p>
<dl class="date"><dt><b>Date:</b></dt><dd>04.2012 </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a09c6b2139e9995dabe2dbbabd25bab48" title="This helper function writes the header of the Object to the xml stream.  This helper function writes ...">writeObjectHeaderToFileV1</a>, <a class="el" href="namespaceito.html#aad6e1f7022d1f9024c771f51f01f78da" title="This helper function writes the tags defined in the tagMap (DataObjectTags) from the Object to the xm...">writeObjectTagsToFileV1</a>, <a class="el" href="namespaceito.html#af96b552c35539676c8a13957de2183ad" title="This helper function writes the data(cv::mats) from the Object to the xml stream.  This helper functi...">writeObjectDataToFileV1</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1f0f29281bc5cb69fcd9759a369b09eb"></a><!-- doxytag: member="ito::saveQLIST2XML" ref="a1f0f29281bc5cb69fcd9759a369b09eb" args="(QMap&lt; QString, Param &gt; *paramList, QString id, QFile &amp;paramFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::saveQLIST2XML </td>
          <td>(</td>
          <td class="paramtype">QMap&lt; QString, Param &gt; *&#160;</td>
          <td class="paramname"><em>paramList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QFile &amp;&#160;</td>
          <td class="paramname"><em>paramFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>paramList List of Type QMap with the parameters to save. The parameters are deleted during writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Identifier of the plugin. Currently implemented as integer number only </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramFile</td><td>Filename of the file. The file will be opened/closed in this function</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes the parameters of a plugin to an XML file. During plugin closing this function is executed with a file name with same name as the plugin library in the plugin directory The xml file is checked for the current plugin-file version and type when opened. In case of a type conflict the parameter is currently not saved. </p>

<p><p>&lt; passed all elements without success, so add new one </p>
</p>

</div>
</div>
<a class="anchor" id="a8d52a7127228d59e411619e569fbee41"></a><!-- doxytag: member="ito::setParam" ref="a8d52a7127228d59e411619e569fbee41" args="(ito::AddInBase *addInObj, PyObject *args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::setParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>addInObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>set a parameter value </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addInObj</td><td>the addIn whoes parameter is requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>the parameter name and value in a python object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Py_Return_None on success, NULL otherwise</dd></dl>
<p>The function tries to set the value of the parameter with the name given in args. If the parameter does not exist or is incompatible with the value passed, NULL is returned. To actually set the value the setParam function of the plugin is invoked. </p>

</div>
</div>
<a class="anchor" id="acd91185af2ccfa90ce18b19f24a57001"></a><!-- doxytag: member="ito::ShiftLFunc" ref="acd91185af2ccfa90ce18b19f24a57001" args="(DataObject *src, const unsigned char shiftbit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftLFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>shiftbit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which element-wisely shifts the values of the source matrix by a certain value to the left </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td></td></tr>
    <tr><td class="paramname">shiftbit</td><td>are the number bits the values are shifted </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>for unsupported data types (template specialization) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a3d19da92789a250b5a8c2f95bd2cdfc7"></a><!-- doxytag: member="ito::ShiftLFunc&lt; ito::complex128 &gt;" ref="a3d19da92789a250b5a8c2f95bd2cdfc7" args="(DataObject *, const unsigned char)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftLFunc&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for shift function of type complex128 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9bbd413896cb54e3377f7535b2563932"></a><!-- doxytag: member="ito::ShiftLFunc&lt; ito::complex64 &gt;" ref="a9bbd413896cb54e3377f7535b2563932" args="(DataObject *, const unsigned char)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftLFunc&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for shift function of type complex64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a675b71966a82791d5eba43de0a0374"></a><!-- doxytag: member="ito::ShiftLFunc&lt; ito::float32 &gt;" ref="a3a675b71966a82791d5eba43de0a0374" args="(DataObject *, const unsigned char)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftLFunc&lt; ito::float32 &gt; </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for shift function of type float32 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add7324b4bc5f6fc83283a472e9ca58c5"></a><!-- doxytag: member="ito::ShiftLFunc&lt; ito::float64 &gt;" ref="add7324b4bc5f6fc83283a472e9ca58c5" args="(DataObject *, const unsigned char)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftLFunc&lt; ito::float64 &gt; </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for shift function of type float64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc20ff592a9d1158c05fc00d96623d4a"></a><!-- doxytag: member="ito::ShiftLFunc&lt; ito::Rgba32 &gt;" ref="acc20ff592a9d1158c05fc00d96623d4a" args="(DataObject *, const unsigned char)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftLFunc&lt; <a class="el" href="classito_1_1_rgba32.html">ito::Rgba32</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for shift function of type rgba32 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a012536094b126f7906e30268a81d376a"></a><!-- doxytag: member="ito::ShiftRFunc" ref="a012536094b126f7906e30268a81d376a" args="(DataObject *src, const unsigned char shiftbit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftRFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>shiftbit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which element-wisely shifts the values of the source matrix by a certain value to the right </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td></td></tr>
    <tr><td class="paramname">shiftbit</td><td>are the number bits the values are shifted </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>for unsupported data types (template specialization) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a8d57c41b81f19337e7bfdc81d9b58db8"></a><!-- doxytag: member="ito::ShiftRFunc&lt; ito::complex128 &gt;" ref="a8d57c41b81f19337e7bfdc81d9b58db8" args="(DataObject *, const unsigned char)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftRFunc&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for shift function of type complex128 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f0ede49fa5819fc3c95d4296e88d201"></a><!-- doxytag: member="ito::ShiftRFunc&lt; ito::complex64 &gt;" ref="a5f0ede49fa5819fc3c95d4296e88d201" args="(DataObject *, const unsigned char)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftRFunc&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for shift function of type complex64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4bfa2747f0b55d14e1bf28c52f1d4e6"></a><!-- doxytag: member="ito::ShiftRFunc&lt; ito::float32 &gt;" ref="aa4bfa2747f0b55d14e1bf28c52f1d4e6" args="(DataObject *, const unsigned char)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftRFunc&lt; ito::float32 &gt; </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for shift function of type float32 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a44011c28772f9e51cb33f1c57a780c9a"></a><!-- doxytag: member="ito::ShiftRFunc&lt; ito::float64 &gt;" ref="a44011c28772f9e51cb33f1c57a780c9a" args="(DataObject *, const unsigned char)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftRFunc&lt; ito::float64 &gt; </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for shift function of type float64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c637c5f859dca6bef49d76a3ba98cf4"></a><!-- doxytag: member="ito::ShiftRFunc&lt; ito::Rgba32 &gt;" ref="a8c637c5f859dca6bef49d76a3ba98cf4" args="(DataObject *, const unsigned char)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftRFunc&lt; <a class="el" href="classito_1_1_rgba32.html">ito::Rgba32</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for shift function of type rgba32 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2d8c3cc6f057d60ca82b03266db2e24"></a><!-- doxytag: member="ito::SubFunc" ref="ad2d8c3cc6f057d60ca82b03266db2e24" args="(const DataObject *dObj1, const DataObject *dObj2, DataObject *dObjRes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::SubFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for element-wise subtraction of values from second data object from values of first data object </p>
<p>dObjRes = dObj1 - dObj2</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj1</td><td>is the first data object </td></tr>
    <tr><td class="paramname">*dObj2</td><td>is the second data object </td></tr>
    <tr><td class="paramname">*dObjRes</td><td>is the pointer to the data object, where the values will be written to. This data object must already be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The size check for all data objects must be done before. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>operator -=, operator - </dd></dl>

</div>
</div>
<a class="anchor" id="af96b552c35539676c8a13957de2183ad"></a><!-- doxytag: member="ito::writeObjectDataToFileV1" ref="af96b552c35539676c8a13957de2183ad" args="(QXmlStreamWriter &amp;stream, DataObject *dObjOut, int elementsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::writeObjectDataToFileV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamWriter &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This helper function writes the data(cv::mats) from the Object to the xml stream.  This helper function writes the data(cv::mats) from the Object to the xml stream. Therefore the data is converted using QByteArray::toBase64() to avoid XML-conflict with the binary data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>stream outgoing xml-stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dObjOut</td><td>The allocated src-Object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementsize</td><td>Size of each matrix element in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#aca8826921e5df8a0a37e1a43ed2800cc" title="Import a dataObject from harddrive, saved in the ITO-XML-Format (.ido or .idh)">saveDOBJ2XML</a>, saveDOBJSpecificData2XML </dd></dl>

</div>
</div>
<a class="anchor" id="a09c6b2139e9995dabe2dbbabd25bab48"></a><!-- doxytag: member="ito::writeObjectHeaderToFileV1" ref="a09c6b2139e9995dabe2dbbabd25bab48" args="(QXmlStreamWriter &amp;stream, DataObject *dObjOut, bool doubleAsBinary, int &amp;elementsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::writeObjectHeaderToFileV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamWriter &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doubleAsBinary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>elementsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This helper function writes the header of the Object to the xml stream.  This helper function writes the header (dims, sizes, type) of an object and the metaData (complete <a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a> without tagsMap) from the Object to the xml stream. The values of the header are stored as string. The values of each axis-tag / value-tag / rotation matrix are in case of string-type directly written to the stream or in case of double converted to either strings directly (15 significat digits, &gt;32Bit) or stored as lostfree binary (QByteArray::toBase64() to avoid XML-conflict). WARNING: Do not change the header (dims, sizes, type) information or the value of tags exported as binary (d2b). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>stream outgoing xml-stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dObjOut</td><td>The allocated src-Object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doubleAsBinary</td><td>Toggle binary export for double</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#aca8826921e5df8a0a37e1a43ed2800cc" title="Import a dataObject from harddrive, saved in the ITO-XML-Format (.ido or .idh)">saveDOBJ2XML</a>, saveDOBJSpecificData2XML, <a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aad6e1f7022d1f9024c771f51f01f78da"></a><!-- doxytag: member="ito::writeObjectTagsToFileV1" ref="aad6e1f7022d1f9024c771f51f01f78da" args="(QXmlStreamWriter &amp;stream, DataObject *dObjOut, bool doubleAsBinary)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::writeObjectTagsToFileV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamWriter &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doubleAsBinary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This helper function writes the tags defined in the tagMap (<a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) from the Object to the xml stream.  This helper function writes the tags defined in the tagMap (<a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) from the Object to the xml stream. Therefore the values of each tag are in case of string-type directly written to the stream or in case of double converted to either strings directly (15 significat digits, &gt;32Bit) or stored as lostfree binary (QByteArray::toBase64() to avoid XML-conflict). WARNING: Do not change information or the value of tags exported as binary (d2b). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>stream outgoing xml-stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dObjOut</td><td>The allocated src-Object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doubleAsBinary</td><td>Toggle binary export for double</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#aca8826921e5df8a0a37e1a43ed2800cc" title="Import a dataObject from harddrive, saved in the ITO-XML-Format (.ido or .idh)">saveDOBJ2XML</a>, saveDOBJSpecificData2XML, <a class="el" href="class_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aca27764ec31c2bc8c84b8ecde1d48e2d"></a><!-- doxytag: member="ito::ZerosFunc" ref="aca27764ec31c2bc8c84b8ecde1d48e2d" args="(const int sizeY, const int sizeX, uchar **dstMat)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ZerosFunc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for creation of zero-valued matrix-plane </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is the pointer to the already allocated cv::Mat_&lt;type&gt;-matrix-plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>zeros </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a5f4e931b9ffb4d53504b835419bbf5d5"></a><!-- doxytag: member="ito::fListCout" ref="a5f4e931b9ffb4d53504b835419bbf5d5" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tCoutFunc ito::fListCout[]<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
{
   coutFunc&lt;int8&gt;,
   coutFunc&lt;uint8&gt;,
   coutFunc&lt;int16&gt;,
   coutFunc&lt;uint16&gt;,
   coutFunc&lt;int32&gt;,
   coutFunc&lt;uint32&gt;,
   coutFunc&lt;ito::float32&gt;,
   coutFunc&lt;ito::float64&gt;,
   coutFunc&lt;ito::complex64&gt;,
   coutFunc&lt;ito::complex128&gt;,
   coutFunc&lt;ito::Rgba32&gt;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0a87731c8a17f2acd5a5f3de4ae3f262"></a><!-- doxytag: member="ito::ITOM_API_FUNCS_GRAPH_ARR" ref="a0a87731c8a17f2acd5a5f3de4ae3f262" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ito::ITOM_API_FUNCS_GRAPH_ARR[]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mnumberOfColorBars,     
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetColorBarName,       
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetColorBarIdx,        
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetFigure,             
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetPluginList,         
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mstartLiveData,         
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mstopLiveData,          
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mconnectLiveData,       
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mdisconnectLiveData,    
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetColorBarIdxFromName,
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetFigureSetting,      
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetPluginWidget,       
        NULL
    }
</pre></div>
</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceito.html">ito</a>      </li>
      <li class="footer">Generated on Tue Nov 11 2014 12:33:43 for itom by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
