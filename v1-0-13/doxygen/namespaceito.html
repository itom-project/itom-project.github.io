<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>itom: ito Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="q_itoM48.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">itom
   &#160;<span id="projectnumber">1.0.13</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('namespaceito.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ito Namespace Reference</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1api_functions.html">apiFunctions</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1api_functions_graph.html">apiFunctionsGraph</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_i_o_helper.html">IOHelper</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_helper.html">ParamHelper</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_plugin_load_status.html">PluginLoadStatus</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct provides a structure for saving the load status of any plugins or designerWidgets.  <a href="structito_1_1_plugin_load_status.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_plug_in_model.html">PlugInModel</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for visualizing the available (loaded) plugins  <a href="classito_1_1_plug_in_model.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_designer_plugin.html">DesignerPlugin</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_user_info_struct.html">UserInfoStruct</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_user_model.html">UserModel</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for for visualizing the available users  <a href="classito_1_1_user_model.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_manager.html">AddInManager</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for AddIn management  <a href="classito_1_1_add_in_manager.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_algo_interface_validator.html">AlgoInterfaceValidator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The class <a class="el" href="classito_1_1_algo_interface_validator.html" title="The class AlgoInterfaceValidator provides validators and checks in order to verify that a certain fil...">AlgoInterfaceValidator</a> provides validators and checks in order to verify that a certain filter or algoWidget that pretends to implement a certain interface really fits to the requirements and conditions of this interface.  <a href="classito_1_1_algo_interface_validator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dummy_itom_designer_plugin.html">DummyItomDesignerPlugin</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_figure_plugin.html">FigurePlugin</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_figure_category.html">FigureCategory</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_designer_widget_organizer.html">DesignerWidgetOrganizer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_help_system.html">HelpSystem</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_itom_palette_base.html">ItomPaletteBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_palette_organizer.html">PaletteOrganizer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_process_organizer.html">ProcessOrganizer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_qsci_api_manager.html">QsciApiManager</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_ui_container.html">UiContainer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Every instance of this class contains information about one user interface (main window, dialog, dock widget...) which is organized by <a class="el" href="classito_1_1_ui_organizer.html">UiOrganizer</a>.  <a href="structito_1_1_ui_container.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_ui_container_item.html">UiContainerItem</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_ui_organizer.html">UiOrganizer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_user_interaction_watcher.html">UserInteractionWatcher</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_user_organizer.html">UserOrganizer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_wrapper.html">WidgetWrapper</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">One instance of this class acts as wrapper for several import public methods of classes, derived from QObject, which should be made available by the call-method in python.  <a href="classito_1_1_widget_wrapper.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_common.html">PythonCommon</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_data_object.html">PythonDataObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_figure.html">PythonFigure</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_itom.html">PythonItom</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_python_q_object_marshal.html">PythonQObjectMarshal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_np_data_object.html">PythonNpDataObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_numeric.html">PythonNumeric</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_plot_item.html">PythonPlotItem</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_plugins.html">PythonPlugins</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class summing up the functionality of itom - hardware python plugins  <a href="classito_1_1_python_plugins.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_proxy.html">PythonProxy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_region.html">PythonRegion</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_shared_pointer_guard.html">PythonSharedPointerGuard</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_param_conversion.html">PythonParamConversion</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_ui.html">PythonUi</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_timer_callback.html">TimerCallback</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_timer.html">PythonTimer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_py_workspace_item.html">PyWorkspaceItem</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_py_workspace_container.html">PyWorkspaceContainer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_q_debug_stream.html">QDebugStream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_filter_dialog.html">AbstractFilterDialog</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_loaded_plugins.html">DialogLoadedPlugins</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_new_plugin_instance.html">DialogNewPluginInstance</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_open_file_with_filter.html">DialogOpenFileWithFilter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_picker_sort_filter_proxy_model.html">PickerSortFilterProxyModel</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_plugin_picker.html">DialogPluginPicker</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_properties.html">DialogProperties</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_replace.html">DialogReplace</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_save_file_with_filter.html">DialogSaveFileWithFilter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_select_user.html">DialogSelectUser</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_input_parser.html">ParamInputParser</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_figure_plugins.html">WidgetPropFigurePlugins</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_figure_plugin_delegate.html">FigurePluginDelegate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_dock_widget.html">AbstractDockWidget</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract dock widget class which inherits QDockWidget. The content of QDockWidget consists of an instance of QMainWindow. The real widget is then placed as central widget of this QMainWindow. QMainWindow has the ability to show a menubar as well as a toolbar, which is used in different versions depending on docked state. Inherit <a class="el" href="classito_1_1_abstract_dock_widget.html" title="abstract dock widget class which inherits QDockWidget. The content of QDockWidget consists of an inst...">AbstractDockWidget</a> in order to realize content of QMainWindow.  <a href="classito_1_1_abstract_dock_widget.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_py_scintilla_widget.html">AbstractPyScintillaWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_a_i_manager_widget.html">AIManagerWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_break_point_dock_widget.html">BreakPointDockWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_call_stack_dock_widget.html">CallStackDockWidget</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">docking  <a href="classito_1_1_call_stack_dock_widget.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_figure_widget.html">FigureWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_file_system_dock_widget.html">FileSystemDockWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_help_dock_widget.html">HelpDockWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_last_command_dock_widget.html">LastCommandDockWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_main_window.html">MainWindow</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_script_dock_widget.html">ScriptDockWidget</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">widget containing one or multiple script editors (tabbed). This widget can either be a docking widget, docked in a docking area in the main window or it can be a floatable window which has a standard window behaviour.  <a href="classito_1_1_script_dock_widget.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_script_editor_widget.html">ScriptEditorWidget</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_itom_qsci_printer.html">ItomQsciPrinter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_user_management.html">DialogUserManagement</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_workspace_dock_widget.html">WorkspaceDockWidget</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">docking widget for contents of type workspace widget  <a href="classito_1_1_workspace_dock_widget.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_range.html">Range</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">each range value has a start and end point. Optionally range can be marked as <a class="el" href="classito_1_1_range.html#a9019bdda86a9b42d3e804a26f6c46602">Range::all()</a>, which indicates a full range  <a href="classito_1_1_range.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object_tag_type.html">DataObjectTagType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object_tags.html">DataObjectTags</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class for handling tags for class <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a>  This class contains meta-information for the dataObject. In case of a deep copy it is also deep copied. In case of a shallow copy it is also shallow copied. To copy the axis metainformation into another/new object use copyAxisTagsTo to copy m_axisOffsets, m_axisScales, m_axisDescription, m_axisUnit, m_valueOffset, m_valueScale, m_valueDescription, m_valueUnit, m_rotMatrix. To copy the tag-space, e.g. the protocol, use copyTagMapTo to copy m_tags.  <a href="classito_1_1_data_object_tags.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_d_obj_const_iterator.html">DObjConstIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_d_obj_iterator.html">DObjIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html">DataObject</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">dataObject contains a n-dimensional matrix  <a href="classito_1_1_data_object.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_grabber.html">AddInGrabber</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherit from <a class="el" href="classito_1_1_add_in_grabber.html" title="Inherit from AddInGrabber if you write a camera/grabber plugin. Please call the constructor of AddInG...">AddInGrabber</a> if you write a camera/grabber plugin. Please call the constructor of <a class="el" href="classito_1_1_add_in_grabber.html" title="Inherit from AddInGrabber if you write a camera/grabber plugin. Please call the constructor of AddInG...">AddInGrabber</a> within your plugin constructor.  <a href="classito_1_1_add_in_grabber.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_exec_func_params.html">ExecFuncParams</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_filter_params.html">FilterParams</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_interface_base.html">AddInInterfaceBase</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">class of the AddIn - Library (DLL) - Interface  <a href="classito_1_1_add_in_interface_base.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_base.html">AddInBase</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all plugins.  <a href="classito_1_1_add_in_base.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_data_i_o.html">AddInDataIO</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for all dataIO plugin classes  <a href="classito_1_1_add_in_data_i_o.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_actuator.html">AddInActuator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for all actuator plugin classes  <a href="classito_1_1_add_in_actuator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_algo.html">AddInAlgo</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for all "algorithm" plugin classes  <a href="classito_1_1_add_in_algo.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1thread_actuator.html">threadActuator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to give plugin-Developer an easy access to actuators in other threads.  <a href="classito_1_1thread_actuator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1thread_camera.html">threadCamera</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to give plugin-Developer an easy access to cameras in other threads.  <a href="classito_1_1thread_camera.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_ret_val.html">RetVal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for error value management.  <a href="classito_1_1_ret_val.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_base.html">ParamBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_meta.html">ParamMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all meta-information classes.  <a href="classito_1_1_param_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_char_meta.html">CharMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html">Param</a> of type Char or CharArray.  <a href="classito_1_1_char_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_int_meta.html">IntMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html">Param</a> of type Int or IntArray.  <a href="classito_1_1_int_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_double_meta.html">DoubleMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html">Param</a> of type Double or DoubleArray.  <a href="classito_1_1_double_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_h_w_meta.html">HWMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html">Param</a> of type HWPtr.  <a href="classito_1_1_h_w_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_string_meta.html">StringMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html">Param</a> of type String.  <a href="classito_1_1_string_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_d_obj_meta.html">DObjMeta</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html">Param</a> of type DObjPtr.  <a href="classito_1_1_d_obj_meta.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param.html">Param</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_param_helper.html">ItomParamHelper</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_param_helper_3_01double_01_4.html">ItomParamHelper&lt; double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_param_helper_3_01int_01_4.html">ItomParamHelper&lt; int &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_param_helper_3_01char_01_4.html">ItomParamHelper&lt; char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_param_helper_3_01unsigned_01char_01_4.html">ItomParamHelper&lt; unsigned char &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_plugin_info.html">PluginInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_palette.html">ItomPalette</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8687199b7dac9cb1f0ead88af22bb714"></a><!-- doxytag: member="ito::tCreateFunc" ref="a8687199b7dac9cb1f0ead88af22bb714" args=")(DataObject *dObj, const unsigned char dimensions, const size_t *sizes, const unsigned char continuous, const uchar *continuousDataPtr, const size_t *steps)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCreateFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned char dimensions, const size_t *sizes, const unsigned char continuous, const uchar *continuousDataPtr, const size_t *steps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9695a8cceed190f4fc9830d1f5e7edda"></a><!-- doxytag: member="ito::tCreateFuncWithCVPlanes" ref="a9695a8cceed190f4fc9830d1f5e7edda" args=")(DataObject *dObj, const unsigned char dimensions, const size_t *sizes, const cv::Mat *planes, const unsigned int nrOfPlanes)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCreateFuncWithCVPlanes</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned char dimensions, const size_t *sizes, const cv::Mat *planes, const unsigned int nrOfPlanes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a579607698d3a482cb1e9488b028a1490"></a><!-- doxytag: member="ito::tFreeFunc" ref="a579607698d3a482cb1e9488b028a1490" args=")(DataObject *dObj)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tFreeFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05d2661eb508cabfe3ed9bfd8475adf1"></a><!-- doxytag: member="ito::tSecureFreeFunc" ref="a05d2661eb508cabfe3ed9bfd8475adf1" args=")(DataObject *dObj)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tSecureFreeFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e225dc89c9782086d9bfcf6c61192aa"></a><!-- doxytag: member="ito::tCopyToFunc" ref="a9e225dc89c9782086d9bfcf6c61192aa" args=")(const DataObject &amp;lhs, DataObject &amp;rhs, unsigned char regionOnly)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCopyToFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, unsigned char regionOnly)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56f51a787377536fbbb35cf54edcdc72"></a><!-- doxytag: member="ito::tDeepCopyPartialFunc" ref="a56f51a787377536fbbb35cf54edcdc72" args=")(DataObject &amp;lhs, DataObject &amp;rhs)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tDeepCopyPartialFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a218ed5a3f3d9439c7ceb3920210f1306"></a><!-- doxytag: member="ito::tConvertToFunc" ref="a218ed5a3f3d9439c7ceb3920210f1306" args=")(const DataObject &amp;lhs, DataObject &amp;rhs, const int type, const double alpha, const double beta)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tConvertToFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, const int type, const double alpha, const double beta)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b555dfaef5de4077a8609764983c755"></a><!-- doxytag: member="ito::tZerosFunc" ref="a4b555dfaef5de4077a8609764983c755" args=")(const size_t sizeY, const size_t sizeX, int **dstMat)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tZerosFunc</b> )(const size_t sizeY, const size_t sizeX, int **dstMat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace851d7b3bd76772ea9d9f10a2b46aa3"></a><!-- doxytag: member="ito::tOnesFunc" ref="ace851d7b3bd76772ea9d9f10a2b46aa3" args=")(const size_t sizeY, const size_t sizeX, int **dstMat)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tOnesFunc</b> )(const size_t sizeY, const size_t sizeX, int **dstMat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e818b3a565254231f6688fba903fc60"></a><!-- doxytag: member="ito::tRandFunc" ref="a8e818b3a565254231f6688fba903fc60" args=")(const size_t sizeY, const size_t sizeX, const double value1, const double value2, const bool randMode, int **dstMat)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tRandFunc</b> )(const size_t sizeY, const size_t sizeX, const double value1, const double value2, const bool randMode, int **dstMat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad975671ad6418f45eaf21bf2e53f68e8"></a><!-- doxytag: member="ito::tCopyMatFunc" ref="ad975671ad6418f45eaf21bf2e53f68e8" args=")(int **src, int **&amp;dst, bool transposed)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCopyMatFunc</b> )(int **src, int **&amp;dst, bool transposed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca6e3dd9430a6b79e04f46ec987b7c9b"></a><!-- doxytag: member="ito::tAssignScalarFunc" ref="aca6e3dd9430a6b79e04f46ec987b7c9b" args=")(const DataObject *src, const ito::tDataType type, const void *scalar)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tAssignScalarFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> type, const void *scalar)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f18c87103be0d305e4c941bc7716002"></a><!-- doxytag: member="ito::tAddFunc" ref="a3f18c87103be0d305e4c941bc7716002" args=")(const DataObject *src1, const DataObject *src2, DataObject *dst)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tAddFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47d2abf030ce88e0dc393d5239766e59"></a><!-- doxytag: member="ito::tAddScalarFunc" ref="a47d2abf030ce88e0dc393d5239766e59" args=")(const DataObject *dObjIn, ito::float64 scalar, DataObject *dObjOut)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tAddScalarFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjIn, ito::float64 scalar, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a181299e491f51cebccffe55e7ab9e48c"></a><!-- doxytag: member="ito::tSubFunc" ref="a181299e491f51cebccffe55e7ab9e48c" args=")(const DataObject *src1, const DataObject *src2, DataObject *dst)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tSubFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abceb8e48e57030a10d4f7331ef1d38fc"></a><!-- doxytag: member="ito::tOpMulFunc" ref="abceb8e48e57030a10d4f7331ef1d38fc" args=")(const DataObject *src1, const DataObject *src2, DataObject *dst)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tOpMulFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c45a3fd79b4fb810d489496fd048cd5"></a><!-- doxytag: member="ito::tOpScalarMulFunc" ref="a9c45a3fd79b4fb810d489496fd048cd5" args=")(const DataObject *src, const double factor)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tOpScalarMulFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const double factor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa35e5b801b599ca73dfc85e25bf5076c"></a><!-- doxytag: member="ito::tCmpFunc" ref="aa35e5b801b599ca73dfc85e25bf5076c" args=")(const DataObject *src1, const DataObject *src2, DataObject *dst, int cmpOp)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCmpFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst, int cmpOp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8843ed96e703e61ff5f47da85a508dc"></a><!-- doxytag: member="ito::tShiftLFunc" ref="ab8843ed96e703e61ff5f47da85a508dc" args=")(DataObject *src, const unsigned char shiftbit)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tShiftLFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const unsigned char shiftbit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e185821ebaeb2090928c53b806786f4"></a><!-- doxytag: member="ito::tShiftRFunc" ref="a9e185821ebaeb2090928c53b806786f4" args=")(DataObject *src, const unsigned char shiftbit)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tShiftRFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const unsigned char shiftbit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac46799d32f26674c9214c4ce3707370e"></a><!-- doxytag: member="ito::tBitAndFunc" ref="ac46799d32f26674c9214c4ce3707370e" args=")(const DataObject *src1, const DataObject *src2, DataObject *dst)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tBitAndFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa30e6492db24fb4b187d300c4e19190"></a><!-- doxytag: member="ito::tBitOrFunc" ref="aaa30e6492db24fb4b187d300c4e19190" args=")(const DataObject *src1, const DataObject *src2, DataObject *dst)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tBitOrFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea25eb675491904693c2e37bdb5801ee"></a><!-- doxytag: member="ito::tBitXorFunc" ref="aea25eb675491904693c2e37bdb5801ee" args=")(const DataObject *src1, const DataObject *src2, DataObject *dst)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tBitXorFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af74c540c806191b37b2aa846d2ed1f5b"></a><!-- doxytag: member="ito::tGetRangeFunc" ref="af74c540c806191b37b2aa846d2ed1f5b" args=")(DataObject *dObj, const int dtop, const int dbottom, const int dleft, const int dright)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tGetRangeFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const int dtop, const int dbottom, const int dleft, const int dright)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fce076240bb1af1ff9dde93ea87c914"></a><!-- doxytag: member="ito::tAdjustROIFunc" ref="a8fce076240bb1af1ff9dde93ea87c914" args=")(DataObject *dObj, int dtop, int dbottom, int dleft, int dright)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tAdjustROIFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, int dtop, int dbottom, int dleft, int dright)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3368dae64e3f6ff523c5a48d8295b211"></a><!-- doxytag: member="ito::tEyeFunc" ref="a3368dae64e3f6ff523c5a48d8295b211" args=")(const size_t size, int **dstMat)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tEyeFunc</b> )(const size_t size, int **dstMat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1939d9a44426c4c6fa500836032a5500"></a><!-- doxytag: member="ito::tConjFunc" ref="a1939d9a44426c4c6fa500836032a5500" args=")(DataObject *dObj)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tConjFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2912a735b82241ff7939136deecb8ca"></a><!-- doxytag: member="ito::tRowFunc" ref="ad2912a735b82241ff7939136deecb8ca" args=")(DataObject *dObj, const unsigned int selRow)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tRowFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned int selRow)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51d4e7953b9556acdce6d2ff68bb7fa8"></a><!-- doxytag: member="ito::tColFunc" ref="a51d4e7953b9556acdce6d2ff68bb7fa8" args=")(DataObject *dObj, const unsigned int selCol)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tColFunc</b> )(<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned int selCol)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a201a8fc0b1eac2edad8e8aa131d7c79e"></a><!-- doxytag: member="ito::tMulFunc" ref="a201a8fc0b1eac2edad8e8aa131d7c79e" args=")(const DataObject *src1, const DataObject *src2, DataObject *res, const double scale)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tMulFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *res, const double scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbcda67c8239ce15691839180fb6adc9"></a><!-- doxytag: member="ito::tDivFunc" ref="adbcda67c8239ce15691839180fb6adc9" args=")(const DataObject *src1, const DataObject *src2, DataObject *res, const double scale)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tDivFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *res, const double scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a674b0080f512e406c6d2d719a5d040ba"></a><!-- doxytag: member="ito::tAbsFunc" ref="a674b0080f512e406c6d2d719a5d040ba" args=")(const DataObject *dObj, DataObject *resObj)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tAbsFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf2f6ec8dc42e5c9a47697c93242b35f"></a><!-- doxytag: member="ito::tArgFunc" ref="acf2f6ec8dc42e5c9a47697c93242b35f" args=")(const DataObject *dObj, DataObject *resObj)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tArgFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dfc73f3786787fbd2f36bbb83b1b74c"></a><!-- doxytag: member="ito::tRealFunc" ref="a3dfc73f3786787fbd2f36bbb83b1b74c" args=")(const DataObject *dObj, DataObject *resObj)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tRealFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a264cf4c255ff6dfbbf4c7a613653f0e9"></a><!-- doxytag: member="ito::tImagFunc" ref="a264cf4c255ff6dfbbf4c7a613653f0e9" args=")(const DataObject *dObj, DataObject *resObj)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tImagFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a859f5e5658f1c4a388b86c2b94d9f46a"></a><!-- doxytag: member="ito::tMakeContinuousFunc" ref="a859f5e5658f1c4a388b86c2b94d9f46a" args=")(const DataObject &amp;dObj, DataObject &amp;resDObj)" -->
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tMakeContinuousFunc</b> )(const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;resDObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdb47b5b70eea8dac2f49e41e6048be8"></a><!-- doxytag: member="ito::tCoutFunc" ref="acdb47b5b70eea8dac2f49e41e6048be8" args=")(std::ostream &amp;out, const DataObject &amp;dObj)" -->
typedef std::ostream &amp;(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCoutFunc</b> )(std::ostream &amp;out, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfb68169378e1801c903a3c11472ed1b"></a><!-- doxytag: member="ito::int8" ref="adfb68169378e1801c903a3c11472ed1b" args="" -->
typedef int8_t&#160;</td><td class="memItemRight" valign="bottom"><b>int8</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af28e9c7a6873a87cb6a6d4c9e8293380"></a><!-- doxytag: member="ito::int16" ref="af28e9c7a6873a87cb6a6d4c9e8293380" args="" -->
typedef int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>int16</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7d30f17fdb55cf4b8832bf284045732"></a><!-- doxytag: member="ito::int32" ref="af7d30f17fdb55cf4b8832bf284045732" args="" -->
typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>int32</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a109f9ea5c8d2dbe9dc1647c0d20bfc"></a><!-- doxytag: member="ito::uint8" ref="a8a109f9ea5c8d2dbe9dc1647c0d20bfc" args="" -->
typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>uint8</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ed4f11b7fc17f66fb746c9ec331a1f9"></a><!-- doxytag: member="ito::uint16" ref="a0ed4f11b7fc17f66fb746c9ec331a1f9" args="" -->
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>uint16</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c56952b10680ef46b594cfeaf56f898"></a><!-- doxytag: member="ito::uint32" ref="a8c56952b10680ef46b594cfeaf56f898" args="" -->
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>uint32</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afca36c5597ed39e5ef07b688d29e16a4"></a><!-- doxytag: member="ito::float32" ref="afca36c5597ed39e5ef07b688d29e16a4" args="" -->
typedef float&#160;</td><td class="memItemRight" valign="bottom"><b>float32</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1dc6b3b1081db881220b71b74e70319"></a><!-- doxytag: member="ito::float64" ref="ab1dc6b3b1081db881220b71b74e70319" args="" -->
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>float64</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46b874ecd64788e7d33c8d2b1f76febe"></a><!-- doxytag: member="ito::complex64" ref="a46b874ecd64788e7d33c8d2b1f76febe" args="" -->
typedef std::complex<br class="typebreak"/>
&lt; ito::float32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>complex64</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63b9394bb5bcc3baf7409f0e5f8ebfe2"></a><!-- doxytag: member="ito::complex128" ref="a63b9394bb5bcc3baf7409f0e5f8ebfe2" args="" -->
typedef std::complex<br class="typebreak"/>
&lt; ito::float64 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>complex128</b></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcf">tPluginLoadStatusFlag</a> { <a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcfa0c084ed64a1e58022675c2855494b904">plsfOk</a> =  0x0, 
<a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcfae886791877d339615c79aed5c21d35f0">plsfWarning</a> =  0x1, 
<a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcfa89928bf15c88b96936c0f981580994ba">plsfError</a> =  0x2, 
<a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcfa8e51ce1381d3ccf924b2b6152b554f88">plsfIgnored</a> =  0x4
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>userFeatures</b> { <br/>
&#160;&#160;<b>featDeveloper</b> =  1, 
<b>featFileSystem</b> =  2, 
<b>featUserManag</b> =  4, 
<b>featPlugins</b> =  8, 
<br/>
&#160;&#160;<b>featConsole</b> =  16, 
<b>featConsoleRW</b> =  32
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30">tPluginType</a> { <br/>
&#160;&#160;<a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30a4cab6a4edc95b2ef6846c79aedd818cb">typeDataIO</a> =  0x1, 
<a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30a67b1093d817ca4c45de9b4b1075045b1">typeActuator</a> =  0x2, 
<a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30a8c028979c4b81e7eaa0a7f51e1e62d26">typeAlgo</a> =  0x4, 
<a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30af4dfe66a7744cc365947716d5bdb9f6d">typeGrabber</a> =  0x80, 
<br/>
&#160;&#160;<a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30a95ac93a74aac433a17c998c1810e3e51">typeADDA</a> =  0x100, 
<a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30ad2e2fbe4821bac18934a307bd89428c2">typeRawIO</a> =  0x200
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>tActuatorStatus</b> { <br/>
&#160;&#160;<b>actuatorUnknown</b> =  0x0001, 
<b>actuatorInterrupted</b> =  0x0002, 
<b>actuatorMoving</b> =  0x0004, 
<b>actuatorAtTarget</b> =  0x0008, 
<br/>
&#160;&#160;<b>actuatorTimeout</b> =  0x0010, 
<b>actuatorEndSwitch</b> =  0x0100, 
<b>actuatorLeftEndSwitch</b> =  0x0200, 
<b>actuatorRightEndSwitch</b> =  0x0400, 
<br/>
&#160;&#160;<b>actuatorRefSwitch</b> =  0x0800, 
<b>actuatorLeftRefSwitch</b> =  0x1000, 
<b>actuatorRightRefSwitch</b> =  0x2000, 
<b>actuatorAvailable</b> =  0x4000, 
<br/>
&#160;&#160;<b>actuatorEnabled</b> =  0x8000, 
<b>actMovingMask</b> =  actuatorUnknown | actuatorInterrupted | actuatorMoving | actuatorAtTarget | actuatorTimeout, 
<b>actEndSwitchMask</b> =  actuatorEndSwitch | actuatorLeftEndSwitch | actuatorRightEndSwitch, 
<b>actRefSwitchMask</b> =  actuatorRefSwitch | actuatorLeftRefSwitch | actuatorRightRefSwitch, 
<br/>
&#160;&#160;<b>actSwitchesMask</b> =  actEndSwitchMask | actRefSwitchMask, 
<b>actStatusMask</b> =  actuatorAvailable | actuatorEnabled
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a20bda469be01178ac6cf406bcba2ee73">tAutoLoadPolicy</a> { <a class="el" href="namespaceito.html#a20bda469be01178ac6cf406bcba2ee73a8ec2058becac1ccaae65864d6f961cdf">autoLoadAlways</a> =  0x1, 
<a class="el" href="namespaceito.html#a20bda469be01178ac6cf406bcba2ee73ad39587830e30b302adc4421224049c28">autoLoadNever</a> =  0x2, 
<a class="el" href="namespaceito.html#a20bda469be01178ac6cf406bcba2ee73a4c932e4379045955c6194e202c0b6b2d">autoLoadKeywordDefined</a> =  0x4
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8d769b26bbab936560f4c95674ff5477">tAutoSavePolicy</a> { <a class="el" href="namespaceito.html#a8d769b26bbab936560f4c95674ff5477a9ca1d2e8fbcc5c11e86bd24fcdec9e50">autoSaveAlways</a> =  0x1, 
<a class="el" href="namespaceito.html#a8d769b26bbab936560f4c95674ff5477a977bb0b86cfdfa0e8486241790087703">autoSaveNever</a> =  0x2
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>PlotDataType</b> { <br/>
&#160;&#160;<b>DataObjLine</b> =  0x0001, 
<b>DataObjPlane</b> =  0x0002, 
<b>DataObjPlaneStack</b> =  0x0004, 
<b>PointCloud</b> =  0x0008, 
<br/>
&#160;&#160;<b>PolygonMesh</b> =  0x0010
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>PlotDataFormat</b> { <br/>
&#160;&#160;<b>Format_Gray8</b> =  0x0001, 
<b>Format_Gray16</b> =  0x0002, 
<b>Format_Gray32</b> =  0x0004, 
<b>Format_RGB32</b> =  0x0008, 
<br/>
&#160;&#160;<b>Format_ARGB32</b> =  0x0010, 
<b>Format_CMYK32</b> =  0x0020, 
<b>Format_Float32</b> =  0x0040, 
<b>Format_Float64</b> =  0x0080, 
<br/>
&#160;&#160;<b>Format_Complex</b> =  0x0100
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>PlotFeature</b> { <br/>
&#160;&#160;<b>Static</b> =  0x0001, 
<b>Live</b> =  0x0002, 
<b>Cartesian</b> =  0x0004, 
<b>Polar</b> =  0x0008, 
<br/>
&#160;&#160;<b>Cylindrical</b> =  0x0010, 
<b>OpenGl</b> =  0x0020, 
<b>Cuda</b> =  0x0040, 
<b>X3D</b> =  0x0080, 
<br/>
&#160;&#160;<b>PlotLine</b> =  0x0100, 
<b>PlotImage</b> =  0x0200, 
<b>PlotISO</b> =  0x0400, 
<b>Plot3D</b> =  0x0800
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>tPalette</b> { <br/>
&#160;&#160;<b>tPaletteNoType</b> =  0x00, 
<b>tPaletteGray</b> =  0x01, 
<b>tPaletteRGB</b> =  0x02, 
<b>tPaletteFC</b> =  0x04, 
<br/>
&#160;&#160;<b>tPaletteIndexed</b> =  0x08, 
<b>tPaletteLinear</b> =  0x10, 
<b>tPaletteReadOnly</b> =  0x20
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a43f8ec3cdde4591a8ea77f4faf569773">tLogLevel</a> { <br/>
&#160;&#160;<b>logNone</b> =  0x0, 
<b>logError</b> =  0x1, 
<b>logWarning</b> =  0x2, 
<b>logInfo</b> =  0x4, 
<br/>
&#160;&#160;<b>logAll</b> =  logInfo | logWarning | logError
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202">tRetValue</a> { <a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a2ced39cc25866a04f2fb1c9f1d6a542e">retOk</a> =  0x0, 
<a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a59b8253725a061086f085758a117002b">retWarning</a> =  0x1, 
<a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a199f41b7779e742e0a3cc281c42c97c0">retError</a> =  0x2
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8811ca8b85b70b969122b25a7c84e0ee">tMsgType</a> { <br/>
&#160;&#160;<b>msgReturnInfo</b>, 
<b>msgReturnWarning</b>, 
<b>msgReturnError</b>, 
<b>msgTextInfo</b>, 
<br/>
&#160;&#160;<b>msgTextWarning</b>, 
<b>msgTextError</b>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>tPythonDbgCmd</b> { <br/>
&#160;&#160;<b>pyDbgNone</b> = 0, 
<b>pyDbgContinue</b> = 1, 
<b>pyDbgStep</b> = 2, 
<b>pyDbgStepOut</b> = 4, 
<br/>
&#160;&#160;<b>pyDbgStepOver</b> = 8, 
<b>pyDbgQuit</b> = 16
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>tPythonTransitions</b> { <br/>
&#160;&#160;<b>pyTransBeginRun</b> =  1, 
<b>pyTransEndRun</b> =  2, 
<b>pyTransBeginDebug</b> =  4, 
<b>pyTransEndDebug</b> =  8, 
<br/>
&#160;&#160;<b>pyTransDebugWaiting</b> =  16, 
<b>pyTransDebugContinue</b> =  32, 
<b>pyTransDebugExecCmdBegin</b> =  64, 
<b>pyTransDebugExecCmdEnd</b> =  128
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>tCompareResult</b> { <b>tCmpEqual</b>, 
<b>tCmpCompatible</b>, 
<b>tCmpFailed</b>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>tPythonState</b> { <br/>
&#160;&#160;<b>pyStateIdle</b> =  1, 
<b>pyStateRunning</b> =  2, 
<b>pyStateDebugging</b> =  4, 
<b>pyStateDebuggingWaiting</b> =  8, 
<br/>
&#160;&#160;<b>pyStateDebuggingWaitingButBusy</b> =  16
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">tDataType</a> { <br/>
&#160;&#160;<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa35aa1b8e08158b49ebbf6bdfb4b6a508">tInt8</a> =  0, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaad21eb4541e782dc23501912f788a38bd">tUInt8</a> =  1, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa142219f864f22d3b2e6f116f5f5cd936">tInt16</a> =  2, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa68d7e991164d07a036f40379a101112b">tUInt16</a> =  3, 
<br/>
&#160;&#160;<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa47b295973c6b4b7de62599401c16df62">tInt32</a> =  4, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaaf08334798ddd5082595350b296a7a868">tUInt32</a> =  5, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa17ad621a0158b30fc85eb1e89b93ce3b">tFloat32</a> =  6, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa6b9559a5cfa765160ae209ecdc258ed6">tFloat64</a> =  7, 
<br/>
&#160;&#160;<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa722b93c77819223b8d630ab0fca5a0ec">tComplex64</a> =  8, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa39fef9b8e46915c6ba232020e2fe2e7a">tComplex128</a> =  9
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360e">tPCLPointType</a> { <br/>
&#160;&#160;<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360eaa2585c0961b5f357d98ed732c17b9359">pclInvalid</a> =  0x0000, 
<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360ea6273432d3a0ca503e1a77d27ad8ab994">pclXYZ</a> =  0x0001, 
<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360ea6385e470bdc9a9e3aead145eb0ded4d8">pclXYZI</a> =  0x0002, 
<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360eaefd9ce8422846a24673536424375f223">pclXYZRGBA</a> =  0x0004, 
<br/>
&#160;&#160;<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360ea5f6680f5c10ff985f0be8ce06780e16a">pclXYZNormal</a> =  0x0008, 
<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360ea9c19394acf64356ecfc0ed60bc6c8b52">pclXYZINormal</a> =  0x0010, 
<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360ea6dd64651a1b85540ac80b6efa5eeb738">pclXYZRGBNormal</a> =  0x0020
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a87c024c43b3d17174e8f0b14fdc09cd6">apiFCheckAndSetParamVal</a> (QVariant *tempParam, <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> *param, int *set)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aba757c479378ddaa7db70850c6590f3c">apiFParseInitParams</a> (QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *initParamListMand, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *initParamListOpt, QVector&lt; QVariant &gt; *params)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a69198fb9449e1750a65dabb3911cd3"></a><!-- doxytag: member="ito::getItomVersionMap" ref="a2a69198fb9449e1750a65dabb3911cd3" args="()" -->
QMap&lt; QString, QString &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getItomVersionMap</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a2ee6d1fc3b644438e7e45011be71540e">decRefParamPlugins</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *ai)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a9f86dfd2e4d25372a4b35066e423f4b2">incRefParamPlugins</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *ai, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *paramsMand, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *paramsOpt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#acaadeb5a84e7fa9f44207f4f6ea80a85">checkAndSetParamVal</a> (PyObject *tempObj, <a class="el" href="classito_1_1_param.html">ito::Param</a> *param, int *set)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0733e868f1be90670675e6984876ba2f"></a><!-- doxytag: member="ito::checkAndSetParamVal" ref="a0733e868f1be90670675e6984876ba2f" args="(PyObject *pyObj, const ito::Param *defaultParam, ito::ParamBase &amp;outParam, int *set)" -->
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a0733e868f1be90670675e6984876ba2f">checkAndSetParamVal</a> (PyObject *pyObj, const <a class="el" href="classito_1_1_param.html">ito::Param</a> *defaultParam, <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &amp;outParam, int *set)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to print out parameters to a dictionary and the itom-console. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf912efb6f05537ad7a277850ebe17e7"></a><!-- doxytag: member="ito::PrntOutParams" ref="adf912efb6f05537ad7a277850ebe17e7" args="(const QVector&lt; ito::Param &gt; *params, bool asErr, bool addInfos, const int num)" -->
PyObject *&#160;</td><td class="memItemRight" valign="bottom"><b>PrntOutParams</b> (const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *params, bool asErr, bool addInfos, const int num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8b32235878d1e9594569d92771bfcfcd">errOutInitParams</a> (const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *params, const int num, const QString reason)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8e672322a951881453fcd73de2c771ff">parseInitParams</a> (QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *initParamListMand, QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *initParamListOpt, PyObject *args, PyObject *kwds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a141b897a464e5d831cf05c76f19f24b4"></a><!-- doxytag: member="ito::parseInitParams" ref="a141b897a464e5d831cf05c76f19f24b4" args="(const QVector&lt; ito::Param &gt; *defaultParamListMand, const QVector&lt; ito::Param &gt; *defaultParamListOpt, PyObject *args, PyObject *kwds, QVector&lt; ito::ParamBase &gt; &amp;paramListMandOut, QVector&lt; ito::ParamBase &gt; &amp;paramListOptOut)" -->
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseInitParams</b> (const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *defaultParamListMand, const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *defaultParamListOpt, PyObject *args, PyObject *kwds, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;paramListMandOut, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;paramListOptOut)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#af336f965d8dcb64d35de938c63e18e53">copyParamVector</a> (const QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *paramVecIn, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;paramVecOut)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad9596d29ad4cb556064117c73031bd0d">copyParamVector</a> (const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramVecIn, QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; &amp;paramVecOut)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1c6bd4bcdbd9f72e50bbbe132b204db"></a><!-- doxytag: member="ito::copyParamVector" ref="ac1c6bd4bcdbd9f72e50bbbe132b204db" args="(const QVector&lt; ito::Param &gt; *paramVecIn, QVector&lt; ito::ParamBase &gt; &amp;paramVecOut)" -->
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>copyParamVector</b> (const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramVecIn, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;paramVecOut)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecf6fce61a26436009f63cd0e37da946"></a><!-- doxytag: member="ito::createEmptyParamBaseFromParamVector" ref="aecf6fce61a26436009f63cd0e37da946" args="(const QVector&lt; ito::Param &gt; *paramVecIn, QVector&lt; ito::ParamBase &gt; &amp;paramVecOut)" -->
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aecf6fce61a26436009f63cd0e37da946">createEmptyParamBaseFromParamVector</a> (const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramVecIn, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;paramVecOut)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function searches for reserves Keywords (e.g. autoLoadParams) sets the corresponding bool parameter to the right value and than deletes the keyword. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a01723110515894b52457c2e3ffbb3d6f">findAndDeleteReservedInitKeyWords</a> (PyObject *kwds, bool *enableAutoLoadParams)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeddc375b0c7a21152f858961b7914412"></a><!-- doxytag: member="ito::buildFilterOutputValues" ref="aeddc375b0c7a21152f858961b7914412" args="(QVector&lt; QVariant &gt; *outVals, ito::RetVal &amp;retValue)" -->
PyObject *&#160;</td><td class="memItemRight" valign="bottom"><b>buildFilterOutputValues</b> (QVector&lt; QVariant &gt; *outVals, <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> &amp;retValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a273b3666f4857c488a6eca7be2ce22c0">PyDoc_STRVAR</a> (dataObjectInit_doc,&quot;dataObject([dims [, dtype='uint8'[, continuous = 0][, data = valueOrSequence]]]) -&gt; constructor to get a new dataObject.\n\
\n\
Parameters \n\
----------- \n\
dims : {List of Integer}, optional \n\
    'dims' is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns. If not given, an empty data object is created.\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','uint32','float32','float64','complex64','complex128'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
data : {str}, optional \n\
    'data' is a single value or a sequence with the same amount of values than the data object. The values from data will be assigned to the new data object (filled row by row).\n\
\n\
Returns \n\
------- \n\
dataObject {dataObject}\n\
\n\
Notes \n\
------ \n\
\n\
The itom.dataObject contains a n-dimensional matrix and corresponding meta-data.\n\
It has a direct c++-representation for the python-c++ interface.\n\
The n-dimensional matrix can have different element types.\n\
Recently the following types are supported:\n\
\n\
* Integer-type (int8, uint8, int16, uint16, int32, uint32),\n\
\n\
* Floating-type (float32, float64 (=&gt; double)),\n\
\n\
* Complex-type  (complex64 (2x float32), complex128 (2x float64)).\n\
\n\
\n\
Warning 'uint32' is not fully openCV-compatible and hence causes instability!\n\
\n\
In order to handle huge matrices, the data object can divide one matrix into subparts in memory.\n\
Each subpart (called matrix-plane) is two-dimensional and covers data of the last two dimensions.\n\
In c++-context each of these matrix-planes is of type cv::Mat_&lt;type&gt; and can be used with every operator given by the openCV-framework (version 2.3.1 or higher).\n\
\n\
The dimensions of the matrix are structured descending. So if we assume to have a n-dimensional matrix A,\n\
where each dimension has its size s_i, the dimensions order is n, .., z, y, x and the corresponding sizes of A are [s_n, s_(n-1),  s_(n-2), ..., s_y, s_x].\n\
\n\
In order to make the data object compatible to continuously organized data structures, like numpy-arrays, \n\
it is also possible to have all matrix-planes in one data-block in memory (not recommended for huge matrices).\n\
Nevertheless, the indicated data structure with the two-dimensional sub-matrix-planes is still existing. \n\
The data organization is equal to the one of open-cv, hence, two-dimensional matrices are stored row-by-row (C-style)...\n\
\n\
\n\
Deep Copy, Shallow Copy and ROI \n\
\n\
It is possible to set a n-dimensional region of interest (ROI) to each matrix, the virtual dimensions,\n\
which will be delivered if the user asks for the matrix size.\n\
To avoid copy operations where possible a simple =_Operator will also make a shallow copy of the object.\n\
Shallow copies share the same data (elements and meta data) with the original object, hence manipulations of one object will affect the\n\
original object and all shallow copies.\n\
\n\
The opposite a deep copy of a dataObject (by sourceObject.copy()) creates a complete mew matrix with own meta data object.\n\
\n\
Example:\n\
::\n\
    #Create an object \n\
    dObj = dataObject([5, 10, 10], 'int8')\n\
    \n\
    # Make a shallow copy \n\
    dObjShallow = dObj \n\
    \n\
    # Make a shallow copy on ROI\n\
    dObjROI = dObj[1, :, :] \n\
    \n\
    # Set the value of element [1, 0, 0] to 0\n\
    dObj[1, 0, 0] = 0\n\
    \n\
    # Make a deep copy of the dObjROI\n\
    dObjROICopy = dObjROI.copy()\n\
    \n\
    # Set the value of dObjROICopy element [0, 0, 0] to 127 without effecting other objects\n\
    dObjROICopy[0, 0, 0] = 127\n\
    \n\
    \n\
**Constructor** \n\
The function dataObject([dims [, dtype='uint8'[, continuous = 0][, data = valueOrSequence]]])\n\
creates a new itom-dataObject filled with undefined data.\n\
If no parameters are given, an uninitilized DataObject (dims = 0, no sizes) is created.\n\
\n\
As second possibility you can also use the copy-constructor 'dataObject(AnyArray)', \n\
where AnyArray must be any array-like structure which is parsable by the numpy-interface.\n\
\n\
Further static methods for object construction are dataObject.zeros(..), dataObject.ones(..),\n\
dataObject.rand(..), dataObject.randN(..) and dataObject.eye(..).\n\
&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">brief description  <a href="#a273b3666f4857c488a6eca7be2ce22c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23f8b7f2a9b2478d81371edf627f9869"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a23f8b7f2a9b2478d81371edf627f9869" args="(dataObjectAttDims_doc,&quot;number of dimensions of this data object\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
{int} : ReadOnly \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttDims_doc,&quot;number of dimensions of this data object\n\
Notes \n\
----- \n\
{int} : ReadOnly \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e5e151f2a4c1d3f909a666eead74fd7"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a6e5e151f2a4c1d3f909a666eead74fd7" args="(dataObjectAttType_doc,&quot;get type string of data in this data object \n\
This attribute returns the dataObject&#45;Type as a string.\n\
This type string has one of these values: 'uint8', 'int8', 'uint16', 'int16', 'uint32', 'int32', \n\
'float32', 'float64', 'complex64', 'complex128'\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
{str} : ReadOnly\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttType_doc,&quot;get type string of data in this data object \n\
This attribute returns the dataObject-Type as a string.\n\
This type string has one of these values: 'uint8', 'int8', 'uint16', 'int16', 'uint32', 'int32', \n\
'float32', 'float64', 'complex64', 'complex128'\n\
\n\
Notes \n\
----- \n\
{str} : ReadOnly\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b36e24acb85b20aac9d2797e686f9b8"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a7b36e24acb85b20aac9d2797e686f9b8" args="(dataObjectAttContinuous_doc,&quot;true if matrix is continuously organized, else false. \n\
If matrix is continuously organized this function returns true, else false. \n\
If true, the whole matrix is allocated in one huge block in memory, hence, \n\
this data object can be transformed into a numpy representation (npDataObject) \n\
without reallocating memory.\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
{bool} : ReadOnly\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttContinuous_doc,&quot;true if matrix is continuously organized, else false. \n\
If matrix is continuously organized this function returns true, else false. \n\
If true, the whole matrix is allocated in one huge block in memory, hence, \n\
this data object can be transformed into a numpy representation (npDataObject) \n\
without reallocating memory.\n\
Notes \n\
----- \n\
{bool} : ReadOnly\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9957a5c1d14d9a61e013bf0c494e35f3"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a9957a5c1d14d9a61e013bf0c494e35f3" args="(dataObjectAttTags_doc,&quot;tag dictionary for this data object. \n\
\n\
By this attribute you get access to the read&#45;only tag dictionary or you can set an entire new dictionary. \n\
You can add single elements using the method setTag(key,value) or you can delete tags using deleteTag(key).\n\
The value of the tags can be either numeric or string values.\n\
Do NOT use 'special character' within the tag key because they are not XML&#45;save.\n\
setter: The dataObject dictionary is filled with the entries in 'newDictionary'.\n\
getter: A readonly dictionary with all Metadata&#45;Tags of the dataObject.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
{bool} : ReadWrite\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttTags_doc,&quot;tag dictionary for this data object. \n\
\n\
By this attribute you get access to the read-only tag dictionary or you can set an entire new dictionary. \n\
You can add single elements using the method setTag(key,value) or you can delete tags using deleteTag(key).\n\
The value of the tags can be either numeric or string values.\n\
Do NOT use 'special character' within the tag key because they are not XML-save.\n\
setter: The dataObject dictionary is filled with the entries in 'newDictionary'.\n\
getter: A readonly dictionary with all Metadata-Tags of the dataObject.\n\
\n\
Notes \n\
----- \n\
{bool} : ReadWrite\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac63ee51c243c5ed8b639c2043a567714"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ac63ee51c243c5ed8b639c2043a567714" args="(dataObjectAttAxisScales_doc,&quot;tuple containing the axis scales [unit/px]. \n\
\n\
This attribute gives access to the internal axis scales [unit/px] expressed as \n\
a tuple double values. One entry for each object dimensions is due. \n\
This tuple is readonly, but you can either set an entire new tuple or change \n\
specific elements using the method setAxisScale(index,value)\n\
\n\
Definition: Unit&#45;Coordinate = ( px&#45;Coordinate &#45; Offset)* Scale\n\
setter: Tuple of double value with size equal object dims.\n\
getter: Readonly tuple of double value with size equal object dims.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
{tuple of double} : ReadWrite\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttAxisScales_doc,&quot;tuple containing the axis scales [unit/px]. \n\
\n\
This attribute gives access to the internal axis scales [unit/px] expressed as \n\
a tuple double values. One entry for each object dimensions is due. \n\
This tuple is readonly, but you can either set an entire new tuple or change \n\
specific elements using the method setAxisScale(index,value)\n\
\n\
Definition: Unit-Coordinate = ( px-Coordinate - Offset)* Scale\n\
setter: Tuple of double value with size equal object dims.\n\
getter: Readonly tuple of double value with size equal object dims.\n\
\n\
Notes \n\
----- \n\
{tuple of double} : ReadWrite\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4962854d5532ce3a381a818cea16dc2d"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a4962854d5532ce3a381a818cea16dc2d" args="(dataObjectAttAxisOffsets_doc,&quot;tuple containing the axis offsets [px]. \n\
\n\
This attribute gives access to the internal axis offsets [px] expressed as \n\
a tuple double values. One entry for each object dimensions is due. \n\
This tuple is readonly, but you can either set an entire new tuple or change \n\
specific elements using the method setAxisOffset(index,value).\n\
\n\
Definition: Unit&#45;Coordinate = ( px&#45;Coordinate &#45; Offset)* Scale\n\
setter: Tuple of double value with size equal object dims.\n\
\n\
getter: Readonly tuple of double value with size equal object dims.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
{tuple of double} : ReadWrite\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttAxisOffsets_doc,&quot;tuple containing the axis offsets [px]. \n\
\n\
This attribute gives access to the internal axis offsets [px] expressed as \n\
a tuple double values. One entry for each object dimensions is due. \n\
This tuple is readonly, but you can either set an entire new tuple or change \n\
specific elements using the method setAxisOffset(index,value).\n\
\n\
Definition: Unit-Coordinate = ( px-Coordinate - Offset)* Scale\n\
setter: Tuple of double value with size equal object dims.\n\
\n\
getter: Readonly tuple of double value with size equal object dims.\n\
\n\
Notes \n\
----- \n\
{tuple of double} : ReadWrite\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5a512f2a1e45205491eafc1f0f98e5b"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ad5a512f2a1e45205491eafc1f0f98e5b" args="(pyDataObjectSetAxisOffsets_doc,&quot;&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSetAxisOffsets_doc,&quot;&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab98569ab6f81dc3ce8ebc00c19efddca"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ab98569ab6f81dc3ce8ebc00c19efddca" args="(dataObjectAttAxisDescriptions_doc,&quot;tuple containing the axis descriptions. \n\
\n\
This attribute gives access to the internal axis descriptions expressed as \n\
a tuple strings. One entry for each object dimensions is due. \n\
This tuple is readonly, but you can either set an entire new tuple or change \n\
specific elements using the method setAxisDescription(index,value)\n\
\n\
setter: Tuple of double value with size equal object dims.\n\
\n\
getter: Readonly tuple of double value with size equal object dims.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
{tuple of str} : ReadWrite\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttAxisDescriptions_doc,&quot;tuple containing the axis descriptions. \n\
\n\
This attribute gives access to the internal axis descriptions expressed as \n\
a tuple strings. One entry for each object dimensions is due. \n\
This tuple is readonly, but you can either set an entire new tuple or change \n\
specific elements using the method setAxisDescription(index,value)\n\
\n\
setter: Tuple of double value with size equal object dims.\n\
\n\
getter: Readonly tuple of double value with size equal object dims.\n\
\n\
Notes \n\
----- \n\
{tuple of str} : ReadWrite\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66234adf4e94a78354ea235bac083dad"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a66234adf4e94a78354ea235bac083dad" args="(pyDataObjectSetAxisDescriptions_doc,&quot;&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSetAxisDescriptions_doc,&quot;&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2d027e4c6b5102031851e9ae703a979"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="af2d027e4c6b5102031851e9ae703a979" args="(dataObjectAttAxisUnits_doc,&quot;tuple containing the axis units. \n\
\n\
This attribute gives access to the internal axis units expressed as \n\
a tuple strings. One entry for each object dimensions is due. \n\
This tuple is readonly, but you can either set an entire new tuple or change \n\
 specific elements using the method setAxisUnit(index,value)\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
setter: Tuple of double value with size equal object dims.\n\
\n\
getter: Readonly tuple of double value with size equal object dims.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
{tuple of str} : ReadWrite\n\
 &quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttAxisUnits_doc,&quot;tuple containing the axis units. \n\
\n\
This attribute gives access to the internal axis units expressed as \n\
a tuple strings. One entry for each object dimensions is due. \n\
This tuple is readonly, but you can either set an entire new tuple or change \n\
 specific elements using the method setAxisUnit(index,value)\n\
Parameters  \n\
------------\n\
setter: Tuple of double value with size equal object dims.\n\
\n\
getter: Readonly tuple of double value with size equal object dims.\n\
\n\
Notes \n\
----- \n\
{tuple of str} : ReadWrite\n\
 &quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1db1d4594a974f3bf71c47b95c010477"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a1db1d4594a974f3bf71c47b95c010477" args="(pyDataObjectSetAxisUnits_doc,&quot;&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSetAxisUnits_doc,&quot;&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f98d533e87e0e5f150fac2f9857626b"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a9f98d533e87e0e5f150fac2f9857626b" args="(dataObjectAttValueUnit_doc,&quot;value unit string.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
{str} : ReadWrite\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttValueUnit_doc,&quot;value unit string.\n\
\n\
Notes \n\
----- \n\
{str} : ReadWrite\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab365fe4e3a488c196bebbe5e81ded440"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ab365fe4e3a488c196bebbe5e81ded440" args="(dataObjectAttValueDescription_doc,&quot;value unit description. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
{str} : ReadWrite \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttValueDescription_doc,&quot;value unit description. \n\
\n\
Notes \n\
----- \n\
{str} : ReadWrite \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae55c9447b4a0fb5c291205afcd9ecd5"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aae55c9447b4a0fb5c291205afcd9ecd5" args="(dataObjectAttValueScale_doc,&quot;value scale [default: 1.0]. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
{float???} : ReadWrite \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttValueScale_doc,&quot;value scale [default: 1.0]. \n\
\n\
Notes \n\
----- \n\
{float???} : ReadWrite \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af88692476dd6ca288c076244b9eafca1"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="af88692476dd6ca288c076244b9eafca1" args="(dataObjectAttValueOffset_doc,&quot;value offset [default: 0.0].\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
{float???} : ReadOnly \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttValueOffset_doc,&quot;value offset [default: 0.0].\n\
\n\
Notes \n\
----- \n\
{float???} : ReadOnly \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a290af7ceea18d8db58ffb27561887448"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a290af7ceea18d8db58ffb27561887448" args="(dataObjectAttValue_doc,&quot;get/set the values within the ROI as a one&#45;dimensional tuple.\n\
\n\
This method gets or sets the values within the ROI. If this attribute is called by means of a getter, \n\
a tuple is returned which is created by iterating through the values of the data object (row&#45;wise). \n\
In the same way of iterating, the values are set to the data object if you provide a tuple of the size of the data object \n\
or its ROI, respectively. \n\
\n\
Example ::\n\
\n\
	b = dataObject[1,1:10,1,1].value\n\
	# or for the first value \n\
	b = dataObject[1,1:10,1,1].value[0]\n\
	# The elements of the tuple are adressed with b[idx].&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttValue_doc,&quot;get/set the values within the ROI as a one-dimensional tuple.\n\
\n\
This method gets or sets the values within the ROI. If this attribute is called by means of a getter, \n\
a tuple is returned which is created by iterating through the values of the data object (row-wise). \n\
In the same way of iterating, the values are set to the data object if you provide a tuple of the size of the data object \n\
or its ROI, respectively. \n\
\n\
Example ::\n\
\n\
	b = dataObject[1,1:10,1,1].value\n\
	# or for the first value \n\
	b = dataObject[1,1:10,1,1].value[0]\n\
	# The elements of the tuple are adressed with b[idx].&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa561d6b04c25c85c298da606e3a087d0"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aa561d6b04c25c85c298da606e3a087d0" args="(dataObjectAttRotationalMatrix_doc,&quot;Access the 3x3 rotational matrix in the dataObject tagspace \n\
\n\
This attribute gives access to the xyRotationalMatrix in the metaData&#45;Tagspace.\n\
The getter method retuns a 3x3&#45;Array deepcopied from the internal matrix,\n\
Implemented to offer compability to x3p format.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
{3x3 array of doubles} : ReadWrite\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttRotationalMatrix_doc,&quot;Access the 3x3 rotational matrix in the dataObject tagspace \n\
\n\
This attribute gives access to the xyRotationalMatrix in the metaData-Tagspace.\n\
The getter method retuns a 3x3-Array deepcopied from the internal matrix,\n\
Implemented to offer compability to x3p format.\n\
\n\
Notes \n\
----- \n\
{3x3 array of doubles} : ReadWrite\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2500d8d437a70bb989417b7407a73f73"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a2500d8d437a70bb989417b7407a73f73" args="(pyDataObjectSetAxisOffset_doc,&quot;setAxisOffset([axisNum [,axisOffset]]) &#45;&gt; Set the offset of the specified axis.  \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
axisNum : {int}\n\
    The addressed axis\n\
axisOffset : {double}\n\
    New axis offset in [px]\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
Set the axis offset in [px] of axisNum to axisOffset, Unit&#45;Coordinate = ( px&#45;Coordinate &#45; Offset)* Scale\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSetAxisOffset_doc,&quot;setAxisOffset([axisNum [,axisOffset]]) -&gt; Set the offset of the specified axis.  \n\
\n\
Parameters  \n\
------------\n\
axisNum : {int}\n\
    The addressed axis\n\
axisOffset : {double}\n\
    New axis offset in [px]\n\
\n\
Notes \n\
----- \n\
Set the axis offset in [px] of axisNum to axisOffset, Unit-Coordinate = ( px-Coordinate - Offset)* Scale\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40838dd7c39d653415a7d3a2c94743dd"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a40838dd7c39d653415a7d3a2c94743dd" args="(pyDataObjectSetAxisScale_doc,&quot;setAxisScale([axisNum [,axisScale]]) &#45;&gt; Set the scale of the specified axis.  \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
axisNum : {int}\n\
    The addressed axis\n\
axisScale : {double}\n\
    New axis scale in [unit / px]\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
Set the axis scale in [unit / px] of axisNum to axisScale, Unit&#45;Coordinate = ( px&#45;Coordinate &#45; Offset)* Scale\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSetAxisScale_doc,&quot;setAxisScale([axisNum [,axisScale]]) -&gt; Set the scale of the specified axis.  \n\
\n\
Parameters  \n\
------------\n\
axisNum : {int}\n\
    The addressed axis\n\
axisScale : {double}\n\
    New axis scale in [unit / px]\n\
\n\
Notes \n\
----- \n\
Set the axis scale in [unit / px] of axisNum to axisScale, Unit-Coordinate = ( px-Coordinate - Offset)* Scale\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1347a3cd2d2e6b41844e73f2bcc4ca09"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a1347a3cd2d2e6b41844e73f2bcc4ca09" args="(pyDataObjectSetAxisDescription_doc,&quot;setAxisDescription([axisNum [, axisDescription]]) &#45;&gt; Set the description of the specified axis.  \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
axisNum : {int}\n\
    The addressed axis\n\
axisDescription : {str}\n\
    New axis description\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
Set the axis description (e.g. intensity) of axisNum\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSetAxisDescription_doc,&quot;setAxisDescription([axisNum [, axisDescription]]) -&gt; Set the description of the specified axis.  \n\
\n\
Parameters  \n\
------------\n\
axisNum : {int}\n\
    The addressed axis\n\
axisDescription : {str}\n\
    New axis description\n\
\n\
Notes \n\
----- \n\
Set the axis description (e.g. intensity) of axisNum\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f3a2f5f6587211cb5cda72ebaf3c48a"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a6f3a2f5f6587211cb5cda72ebaf3c48a" args="(pyDataObjectSetAxisUnit_doc,&quot;setAxisUnit([axisNum [, axisUnit]]) &#45;&gt; Set the unit of the specified axis.  \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
axisNum : {int}\n\
    The addressed axis\n\
axisUnit : {str}\n\
    New axis unit\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
Set the axis unit (e.g. mm) of axisNum\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSetAxisUnit_doc,&quot;setAxisUnit([axisNum [, axisUnit]]) -&gt; Set the unit of the specified axis.  \n\
\n\
Parameters  \n\
------------\n\
axisNum : {int}\n\
    The addressed axis\n\
axisUnit : {str}\n\
    New axis unit\n\
\n\
Notes \n\
----- \n\
Set the axis unit (e.g. mm) of axisNum\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a653329b0de611a2142caf482e663c613"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a653329b0de611a2142caf482e663c613" args="(pyDataObjectSetTag_doc,&quot;setTag(key, tagvalue) &#45;&gt; Set the value of tag specified by key. \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
key : {str}\n\
    the name of the tag to set\n\
tagvalue : {str or double}\n\
    the new value of the tag, either string or double value\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
Set the value of a tag within the meta data tagspace. If tag does not exist, it is created.\n\
Do NOT use 'special character' within the tag key because they are not XML&#45;save.\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSetTag_doc,&quot;setTag(key, tagvalue) -&gt; Set the value of tag specified by key. \n\
\n\
Parameters  \n\
------------\n\
key : {str}\n\
    the name of the tag to set\n\
tagvalue : {str or double}\n\
    the new value of the tag, either string or double value\n\
\n\
Notes \n\
----- \n\
Set the value of a tag within the meta data tagspace. If tag does not exist, it is created.\n\
Do NOT use 'special character' within the tag key because they are not XML-save.\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a880895511d0d88feb4057452c4c1763a"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a880895511d0d88feb4057452c4c1763a" args="(pyDataObjectDeleteTag_doc,&quot;deleteTag(key) &#45;&gt; Delete the tag specified by key. \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
key : {str}\n\
    the name of the tag to be deleted\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
Remove a tag from the tag space the tag space.\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectDeleteTag_doc,&quot;deleteTag(key) -&gt; Delete the tag specified by key. \n\
\n\
Parameters  \n\
------------\n\
key : {str}\n\
    the name of the tag to be deleted\n\
\n\
Notes \n\
----- \n\
Remove a tag from the tag space the tag space.\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe5fe9b9b04214593556bbf61ad4b4ec"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="afe5fe9b9b04214593556bbf61ad4b4ec" args="(pyDataObjectTagExists_doc,&quot;existTag(key) &#45;&gt; return 1 if tag exists, else return 0. \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
key : {str}\n\
    the name of the tag\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
checkExists : {bool}\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
Checks if a specific tag already exists and return the result as a boolean value.\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectTagExists_doc,&quot;existTag(key) -&gt; return 1 if tag exists, else return 0. \n\
\n\
Parameters  \n\
------------\n\
key : {str}\n\
    the name of the tag\n\
\n\
Returns \n\
-------- \n\
checkExists : {bool}\n\
\n\
Notes \n\
----- \n\
Checks if a specific tag already exists and return the result as a boolean value.\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff26d04f61062018bff6f530418a40e3"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aff26d04f61062018bff6f530418a40e3" args="(pyDataObjectGetTagListSize_doc,&quot;getTagListSize() &#45;&gt; returns the number of tags in tag map\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectGetTagListSize_doc,&quot;getTagListSize() -&gt; returns the number of tags in tag map\n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dacfae5c183e131f3633c925605de5f"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a2dacfae5c183e131f3633c925605de5f" args="(pyDataObjectAddToProtocol_doc,&quot;addToProtocol([newLine]) &#45;&gt; Appends a protocol line to the protocol. ROIs are added automatically. \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
newLine : {str}\n\
    The text to be added to the protocol.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
Appends a protocol line to the protocol. The current ROIs of the dataObject are added automatically.\n\
Also a new line is added automatically to the protocol. The content of the protocol can be addressed by 'dataObject.tags['protocol']' \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectAddToProtocol_doc,&quot;addToProtocol([newLine]) -&gt; Appends a protocol line to the protocol. ROIs are added automatically. \n\
\n\
Parameters  \n\
------------\n\
newLine : {str}\n\
    The text to be added to the protocol.\n\
\n\
Notes \n\
----- \n\
Appends a protocol line to the protocol. The current ROIs of the dataObject are added automatically.\n\
Also a new line is added automatically to the protocol. The content of the protocol can be addressed by 'dataObject.tags['protocol']' \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafa340fafec7ac8788ce406e06dd29ee"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aafa340fafec7ac8788ce406e06dd29ee" args="(pyDataObjectName_doc,&quot;name() &#45;&gt; prints the content of the dataObject in a readable form. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectName_doc,&quot;name() -&gt; prints the content of the dataObject in a readable form. \n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50f15d22f1f588c9a508f5992c4dd557"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a50f15d22f1f588c9a508f5992c4dd557" args="(pyDataObjectData_doc,&quot;data() &#45;&gt; prints the content of the dataObject in a readable form. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
When calling this method, the complete content of the dataObject is printed to the standard output stream. \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectData_doc,&quot;data() -&gt; prints the content of the dataObject in a readable form. \n\
\n\
Notes \n\
----- \n\
When calling this method, the complete content of the dataObject is printed to the standard output stream. \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7546f6d32d434195e7c64cbd29e910f"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="af7546f6d32d434195e7c64cbd29e910f" args="(pyDataObjectConj_doc,&quot;conj() &#45;&gt; complex&#45;conjugates all elements of this dataObject (inline). \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
doctodo \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
Every value of this dataObject is replaced by its complex&#45;conjugate value. If the data type of this dataObject \n\
is no complex data type, a TypeError is raised. \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectConj_doc,&quot;conj() -&gt; complex-conjugates all elements of this dataObject (inline). \n\
\n\
Returns \n\
------- \n\
doctodo \n\
\n\
Notes \n\
----- \n\
Every value of this dataObject is replaced by its complex-conjugate value. If the data type of this dataObject \n\
is no complex data type, a TypeError is raised. \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7101b997a0d787a0695cdcfe6f10853d"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a7101b997a0d787a0695cdcfe6f10853d" args="(pyDataObjectConjugate_doc,&quot;conjugate() &#45;&gt; returns a copy of this dataObject where every element is complex&#45;conjugated. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
copy of this dataObject \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
If the data type of this dataObject is no complex data type, a TypeError is raised.\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectConjugate_doc,&quot;conjugate() -&gt; returns a copy of this dataObject where every element is complex-conjugated. \n\
\n\
Returns \n\
------- \n\
copy of this dataObject \n\
\n\
Notes \n\
----- \n\
If the data type of this dataObject is no complex data type, a TypeError is raised.\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aeb5fa07c074e245a0e4e91f800a822"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a7aeb5fa07c074e245a0e4e91f800a822" args="(pyDataObjectAdj_doc,&quot;adj() &#45;&gt; Adjugate all elements (inline)\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectAdj_doc,&quot;adj() -&gt; Adjugate all elements (inline)\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a79ab1ec3d13cc5629ab22beaa982d6"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a1a79ab1ec3d13cc5629ab22beaa982d6" args="(pyDataObjectAdjugate_doc,&quot;adjugate() &#45;&gt; Return the adjugate, element&#45;wise\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectAdjugate_doc,&quot;adjugate() -&gt; Return the adjugate, element-wise\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25bea4c0094d05ab859247f23020d70e"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a25bea4c0094d05ab859247f23020d70e" args="(pyDataObjectTrans_doc,&quot;trans() &#45;&gt; returns transposed matrix\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectTrans_doc,&quot;trans() -&gt; returns transposed matrix\n\
\n\
Returns \n\
-------- \n\
doctodo\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f72bd0db020b30fa0fb97ed424298ee"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a0f72bd0db020b30fa0fb97ed424298ee" args="(pyDataObjectMakeContinuous_doc,&quot;makeContinuous() &#45;&gt; return continuous representation of dataObject (if not continuous yet, else returns shallow copy of original data object\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectMakeContinuous_doc,&quot;makeContinuous() -&gt; return continuous representation of dataObject (if not continuous yet, else returns shallow copy of original data object\n\
\n\
Returns \n\
-------- \n\
doctodo\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ce9abaf0a1f8afab05e30dcf0693836"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a6ce9abaf0a1f8afab05e30dcf0693836" args="(pyDataObjectSize_doc,&quot;size([index]) &#45;&gt; returns the size of this dataObject (tuple of the sizes in all dimensions or size in dimension indicated by optional value index). \n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
index : {PyDataObject}, optional\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSize_doc,&quot;size([index]) -&gt; returns the size of this dataObject (tuple of the sizes in all dimensions or size in dimension indicated by optional value index). \n\
\n\
Parameters  \n\
------------\n\
index : {PyDataObject}, optional\n\
\n\
Returns \n\
-------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad15605fdfa9b8441270bee73ff90f502"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ad15605fdfa9b8441270bee73ff90f502" args="(pyDataObjectCopy_doc,&quot;copy(region_only=0) &#45;&gt; todo\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
regionOnly : {}, optional \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectCopy_doc,&quot;copy(region_only=0) -&gt; todo\n\
\n\
Parameters \n\
----------- \n\
regionOnly : {}, optional \n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7cbf9a9f422e07cf45f8172f0e9248d"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="af7cbf9a9f422e07cf45f8172f0e9248d" args="(pyDataObjectMul_doc,&quot;mul() &#45;&gt; a.mul(b) returns element wise multiplication of a*b and returns result\n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
doctodo\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectMul_doc,&quot;mul() -&gt; a.mul(b) returns element wise multiplication of a*b and returns result\n\
\n\
Parameters  \n\
------------\n\
doctodo\n\
\n\
Returns \n\
-------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf14f7f49d4c06b19cc7a6bdb480fbef"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aaf14f7f49d4c06b19cc7a6bdb480fbef" args="(pyDataObjectDiv_doc,&quot;div() &#45;&gt; a.div(b) returns element wise division of a./b and returns result\n\
\n\
Parameters  \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
doctodo \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
doctodo \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectDiv_doc,&quot;div() -&gt; a.div(b) returns element wise division of a./b and returns result\n\
\n\
Parameters  \n\
------------\n\
doctodo \n\
\n\
Returns \n\
-------- \n\
doctodo \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a379a8ec686d5d4da4d1f46d6f0f7dad9"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a379a8ec686d5d4da4d1f46d6f0f7dad9" args="(pyDataObjectReshape_doc,&quot;reshape(newSizes) &#45;&gt; Returns reshaped shallow copy of data object  \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
reshaped shallow copy of data object\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
Not implemented yet.\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectReshape_doc,&quot;reshape(newSizes) -&gt; Returns reshaped shallow copy of data object  \n\
\n\
Returns \n\
------- \n\
reshaped shallow copy of data object\n\
\n\
Notes \n\
----- \n\
Not implemented yet.\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c7f70c5e0361ee989c0d825aa2e0160"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a8c7f70c5e0361ee989c0d825aa2e0160" args="(pyDataObjectAstype_doc,&quot;astype() &#45;&gt; todo\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectAstype_doc,&quot;astype() -&gt; todo\n\
\n\
Returns \n\
-------- \n\
\n\
Notes \n\
----- \n\
doctodo \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac43d248eaad10bf73c774d1482528dcf"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ac43d248eaad10bf73c774d1482528dcf" args="(pyDataObjectLocateROI_doc,&quot;locateROI() &#45;&gt; todo\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
locateROI returns a tuple with two elements. The first is a list with the original sizes of this matrix, the second is a list with the offset for each axe in order to get from the original first element to the first element in the given ROI \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectLocateROI_doc,&quot;locateROI() -&gt; todo\n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
locateROI returns a tuple with two elements. The first is a list with the original sizes of this matrix, the second is a list with the offset for each axe in order to get from the original first element to the first element in the given ROI \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0c91868579a73b0618b91167274813c"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ae0c91868579a73b0618b91167274813c" args="(pyDataObjectAdjustROI_doc,&quot;adjustROI() &#45;&gt; \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectAdjustROI_doc,&quot;adjustROI() -&gt; \n\
\n\
Returns \n\
-------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69659a0b0572de324eab86a521e0d313"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a69659a0b0572de324eab86a521e0d313" args="(pyDataObjectSqueeze_doc,&quot;squeeze() &#45;&gt; returns a squeezed shallow copy (if possible) of this data object. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
ShallowCopy : {dataObject}\n\
    At least 2D or more object with all dimensions bigger than 1 expept the x/y&#45;Dimension.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
This method removes every dimension with size equal to 1. Take care, that \n\
none of the last two dimensions is considered by this squeeze&#45;command. \n\
The squeezed return value is a shallow copy of the original dataObject and hence changes in its values\n\
will also change the original data set.\n\
(This command is equal to numpy.squeeze)&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSqueeze_doc,&quot;squeeze() -&gt; returns a squeezed shallow copy (if possible) of this data object. \n\
\n\
Returns \n\
-------- \n\
ShallowCopy : {dataObject}\n\
    At least 2D or more object with all dimensions bigger than 1 expept the x/y-Dimension.\n\
\n\
Notes \n\
----- \n\
\n\
This method removes every dimension with size equal to 1. Take care, that \n\
none of the last two dimensions is considered by this squeeze-command. \n\
The squeezed return value is a shallow copy of the original dataObject and hence changes in its values\n\
will also change the original data set.\n\
(This command is equal to numpy.squeeze)&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37f80a3941857199cf5b836e1c4d4ec2"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a37f80a3941857199cf5b836e1c4d4ec2" args="(dataObjectAttTagDict_doc,&quot;new dictionary with all tags inside \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
{dict} : ReadOnly\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttTagDict_doc,&quot;new dictionary with all tags inside \n\
\n\
Notes \n\
----- \n\
{dict} : ReadOnly\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a860b17c3941d7c8f8834c6fcad000f80"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a860b17c3941d7c8f8834c6fcad000f80" args="(dataObjectArray_StructGet_doc,&quot;__array_struct__ &#45;&gt; general python&#45;array interface (do not call this directly) \n\
                                           This interface makes the data object compatible to every array structure in python \n\
                                           which does equally implement the array interface (e.g. NumPy). This method is \n\
                                           therefore a helper method for the array interface.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectArray_StructGet_doc,&quot;__array_struct__ -&gt; general python-array interface (do not call this directly) \n\
                                           This interface makes the data object compatible to every array structure in python \n\
                                           which does equally implement the array interface (e.g. NumPy). This method is \n\
                                           therefore a helper method for the array interface.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add87ed3c2c37aa8feaea80bb34d2952b"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="add87ed3c2c37aa8feaea80bb34d2952b" args="(dataObjectArray_Interface_doc,&quot;__array_interface__ &#45;&gt; general python&#45;array interface (do not call this directly) \n\
                                           This interface makes the data object compatible to every array structure in python \n\
                                           which does equally implement the array interface (e.g. NumPy).&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectArray_Interface_doc,&quot;__array_interface__ -&gt; general python-array interface (do not call this directly) \n\
                                           This interface makes the data object compatible to every array structure in python \n\
                                           which does equally implement the array interface (e.g. NumPy).&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c17e574703375081c707e3eae3f952e"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a8c17e574703375081c707e3eae3f952e" args="(dataObject_Array__doc,&quot;__array__([dtype]) &#45;&gt; returns a numpy.ndarray from this dataObject. If possible a shallow copy is returned. \n\
                                   If no desired dtype is given and if the this dataObject is continuous, a ndarray sharing its memory with this dataObject is returned. \n\
                                   If the desired dtype does not fit to the type of this dataObject, a casted deep copy is returned. This is also the case if \n\
                                   this dataObject is not continuous. Then a continuous dataObject is created that is the base object of the returned ndarray.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObject_Array__doc,&quot;__array__([dtype]) -&gt; returns a numpy.ndarray from this dataObject. If possible a shallow copy is returned. \n\
                                   If no desired dtype is given and if the this dataObject is continuous, a ndarray sharing its memory with this dataObject is returned. \n\
                                   If the desired dtype does not fit to the type of this dataObject, a casted deep copy is returned. This is also the case if \n\
                                   this dataObject is not continuous. Then a continuous dataObject is created that is the base object of the returned ndarray.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6546b309a69a825636072be12b0fa68d"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a6546b309a69a825636072be12b0fa68d" args="(pyDataObjectToList_doc,&quot;tolist() &#45;&gt; returns nested list of content of data object\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectToList_doc,&quot;tolist() -&gt; returns nested list of content of data object\n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6db8088f9be0a303c072669463f32e59"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a6db8088f9be0a303c072669463f32e59" args="(pyDataObjectStaticZeros_doc,&quot;zeros([dims [, dtype='uint8'[, continuous = 0]]]) &#45;&gt; creates new dataObject filled with zeros.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
dims : {List of Integer} \n\
    'dims' is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','uint32','float32','float64','complex64','complex128'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
The dataObject : {dataObject}\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
Creates a new itom&#45;dataObject filled with zeros.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectStaticZeros_doc,&quot;zeros([dims [, dtype='uint8'[, continuous = 0]]]) -&gt; creates new dataObject filled with zeros.\n\
\n\
Parameters \n\
---------- \n\
dims : {List of Integer} \n\
    'dims' is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','uint32','float32','float64','complex64','complex128'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
\n\
Returns \n\
------- \n\
The dataObject : {dataObject}\n\
\n\
Notes \n\
----- \n\
\n\
Creates a new itom-dataObject filled with zeros.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2e42e9bd11804756a252f2cb2894218"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="af2e42e9bd11804756a252f2cb2894218" args="(pyDataObjectStaticOnes_doc,&quot;ones([dims [, dtype='uint8'[, continuous = 0]]]) &#45;&gt; creates new dataObject filled with ones.  \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
dims : {List of Integer} \n\
    'dims' is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','float32','float64','complex64','complex128'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
The dataObject : {dataObject}\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
Creates a new itom&#45;dataObject filled with ones.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectStaticOnes_doc,&quot;ones([dims [, dtype='uint8'[, continuous = 0]]]) -&gt; creates new dataObject filled with ones.  \n\
\n\
Parameters \n\
----------- \n\
dims : {List of Integer} \n\
    'dims' is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','float32','float64','complex64','complex128'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
\n\
Returns \n\
------- \n\
The dataObject : {dataObject}\n\
\n\
Notes \n\
----- \n\
\n\
Creates a new itom-dataObject filled with ones.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a451ecc9318c06f5294b8426f3fadee4a"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a451ecc9318c06f5294b8426f3fadee4a" args="(pyDataObjectStaticRand_doc,&quot;rand([dims [, dtype='uint8'[, continuous = 0]]]) &#45;&gt; creates new dataObject filled with uniform distributed random values.  \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
dims : {List of Integer} \n\
    'dims' is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns.\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','float32','float64','complex64','complex128'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
The dataObject : {dataObject}\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
Creates a new itom&#45;dataObject filled with uniform distributed random numbers.\n\
In case of an integer type, the uniform noise is from min&lt;ObjectType&gt;(inclusiv) to max&lt;ObjectType&gt;(inclusiv).\n\
For floating point types, the noise is between 0(inclusiv) and 1(exclusiv).&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectStaticRand_doc,&quot;rand([dims [, dtype='uint8'[, continuous = 0]]]) -&gt; creates new dataObject filled with uniform distributed random values.  \n\
\n\
Parameters \n\
----------- \n\
dims : {List of Integer} \n\
    'dims' is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns.\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','float32','float64','complex64','complex128'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
\n\
Returns \n\
------- \n\
The dataObject : {dataObject}\n\
\n\
Notes \n\
----- \n\
\n\
Creates a new itom-dataObject filled with uniform distributed random numbers.\n\
In case of an integer type, the uniform noise is from min&lt;ObjectType&gt;(inclusiv) to max&lt;ObjectType&gt;(inclusiv).\n\
For floating point types, the noise is between 0(inclusiv) and 1(exclusiv).&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a193b74370a27eb3e03e32579f3d16949"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a193b74370a27eb3e03e32579f3d16949" args="(pyDataObjectStaticRandN_doc,&quot;randN([dims [, dtype='uint8'[, continuous = 0]]]) &#45;&gt; creates new dataObject filled with gaussian distributed random values.  \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
dims : {List of Integer} \n\
    'dims' is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns.\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32', 'float32','float64','complex64','complex128'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
The dataObject : {dataObject}\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
Creates a new itom&#45;dataObject filled with gaussian distributed random numbers.\n\
In case of an integer type, the gausian noise mean value is (max+min)/2.0 and the standard deviation is (max&#45;min/)6.0 to max.\n\
For floating point types, the noise mean value is 0 and the standard deviation is 1.0/3.0.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectStaticRandN_doc,&quot;randN([dims [, dtype='uint8'[, continuous = 0]]]) -&gt; creates new dataObject filled with gaussian distributed random values.  \n\
\n\
Parameters \n\
----------- \n\
dims : {List of Integer} \n\
    'dims' is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns.\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32', 'float32','float64','complex64','complex128'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
\n\
Returns \n\
------- \n\
The dataObject : {dataObject}\n\
\n\
Notes \n\
----- \n\
\n\
Creates a new itom-dataObject filled with gaussian distributed random numbers.\n\
In case of an integer type, the gausian noise mean value is (max+min)/2.0 and the standard deviation is (max-min/)6.0 to max.\n\
For floating point types, the noise mean value is 0 and the standard deviation is 1.0/3.0.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9114e5037ef3b9a4d6803b42856e1f6d"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a9114e5037ef3b9a4d6803b42856e1f6d" args="(pyDataObjectStaticEye_doc,&quot;eye([dims [, dtype='uint8'[, continuous = 0]]]) &#45;&gt; creates a 2D, square, eye&#45;matrix.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
size : {int}, \n\
    the size of the square matrix (single value)\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','uint32','float32','float64','complex64','complex128'\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
The dataObject : {dataObject}\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
Static method for creating a two&#45;dimensional, square, eye&#45;matrix of type itom&#45;dataObject.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectStaticEye_doc,&quot;eye([dims [, dtype='uint8'[, continuous = 0]]]) -&gt; creates a 2D, square, eye-matrix.\n\
\n\
Parameters \n\
----------- \n\
size : {int}, \n\
    the size of the square matrix (single value)\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','uint32','float32','float64','complex64','complex128'\n\
\n\
Returns \n\
------- \n\
The dataObject : {dataObject}\n\
\n\
Notes \n\
----- \n\
\n\
Static method for creating a two-dimensional, square, eye-matrix of type itom-dataObject.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7466be0eb8d68831a0dc9cfeb16b792"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="af7466be0eb8d68831a0dc9cfeb16b792" args="(pyDataObjectIterLen_doc,&quot;Private method returning an estimate of len(list(it)).&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectIterLen_doc,&quot;Private method returning an estimate of len(list(it)).&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95729a740cf724488c527c103f1440a9"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a95729a740cf724488c527c103f1440a9" args="(pyFigureInit_doc,&quot;figure([handle, [rows = 1, cols = 1]]) &#45;&gt; creates figure window.\n\
\n\
The class itom.figure represents a standalone figure window, that can have various subplots. If an instance of this class \n\
is created without further parameters a new figure is created and opened having one subplot area (currently empty) and the numeric \n\
handle to this figure is returned:: \n\
    \n\
    h = figure() \n\
\n\
Subplots are arranged in a regular grid whose size is defined by the optional parameters 'rows' and 'cols'. If you create a figure \n\
instance with a given handle, the instance is either a reference to an existing figure that has got this handle or if it does not exist, \n\
a new figure with the desired handle is opened and the handle is returned, too. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
handle : {int} \n\
    numeric handle of the desired figure. \n\
rows : {int, default: 1} \n\
    number of rows this figure should have (defines the size of the subplot&#45;grid) \n\
cols : {int, default: 1} \n\
    number of columns this figure should have (defines the size of the subplot&#45;grid)&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigureInit_doc,&quot;figure([handle, [rows = 1, cols = 1]]) -&gt; creates figure window.\n\
\n\
The class itom.figure represents a standalone figure window, that can have various subplots. If an instance of this class \n\
is created without further parameters a new figure is created and opened having one subplot area (currently empty) and the numeric \n\
handle to this figure is returned:: \n\
    \n\
    h = figure() \n\
\n\
Subplots are arranged in a regular grid whose size is defined by the optional parameters 'rows' and 'cols'. If you create a figure \n\
instance with a given handle, the instance is either a reference to an existing figure that has got this handle or if it does not exist, \n\
a new figure with the desired handle is opened and the handle is returned, too. \n\
\n\
Parameters \n\
------------- \n\
handle : {int} \n\
    numeric handle of the desired figure. \n\
rows : {int, default: 1} \n\
    number of rows this figure should have (defines the size of the subplot-grid) \n\
cols : {int, default: 1} \n\
    number of columns this figure should have (defines the size of the subplot-grid)&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcbae707809fa46b642b6cc097ce2d9e"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="afcbae707809fa46b642b6cc097ce2d9e" args="(pyFigurePlot_doc,&quot;plot(data, [areaIndex, className]) &#45;&gt; plots a dataObject in the current or given area of this figure\n\
Plot an existing dataObject in not dockable, not blocking window. \n\
The style of the plot will depend on the object dimensions.\n\
If x&#45;dim or y&#45;dim are equal to 1, plot will be a lineplot else a 2D&#45;plot.\n\
\n\
Parameters\n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
data : {DataObject} \n\
    Is the data object whose region of interest will be plotted.\n\
areaIndex: {int}, optional \n\
    \n\
className : {str}, optional \n\
    class name of desired plot (if not indicated default plot will be used (see application settings) \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigurePlot_doc,&quot;plot(data, [areaIndex, className]) -&gt; plots a dataObject in the current or given area of this figure\n\
Plot an existing dataObject in not dockable, not blocking window. \n\
The style of the plot will depend on the object dimensions.\n\
If x-dim or y-dim are equal to 1, plot will be a lineplot else a 2D-plot.\n\
\n\
Parameters\n\
-----------\n\
data : {DataObject} \n\
    Is the data object whose region of interest will be plotted.\n\
areaIndex: {int}, optional \n\
    \n\
className : {str}, optional \n\
    class name of desired plot (if not indicated default plot will be used (see application settings) \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a907ae5d64d2813a786897e9d1c3901cc"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a907ae5d64d2813a786897e9d1c3901cc" args="(pyFigureLiveImage_doc,&quot;liveImage(cam, [areaIndex, className]) &#45;&gt; shows a camera live image in the current or given area of this figure\n\
Creates a plot&#45;image (2D) and automatically grabs images into this window.\n\
This function is not blocking.\n\
\n\
Parameters\n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
cam : {dataIO&#45;Instance} \n\
    Camera grabber device from which images are acquired.\n\
areaIndex: {int}, optional \n\
    \n\
className : {str}, optional \n\
    class name of desired plot (if not indicated default plot will be used (see application settings) \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigureLiveImage_doc,&quot;liveImage(cam, [areaIndex, className]) -&gt; shows a camera live image in the current or given area of this figure\n\
Creates a plot-image (2D) and automatically grabs images into this window.\n\
This function is not blocking.\n\
\n\
Parameters\n\
-----------\n\
cam : {dataIO-Instance} \n\
    Camera grabber device from which images are acquired.\n\
areaIndex: {int}, optional \n\
    \n\
className : {str}, optional \n\
    class name of desired plot (if not indicated default plot will be used (see application settings) \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a499d493462db6b3dfd286ce562c54f0c"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a499d493462db6b3dfd286ce562c54f0c" args="(pyFigureShow_doc,&quot;show() &#45;&gt; shows figure \n\
\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigureShow_doc,&quot;show() -&gt; shows figure \n\
\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3263e380c929b4cc91e36e09f148d354"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a3263e380c929b4cc91e36e09f148d354" args="(pyFigureHide_doc,&quot;hide() &#45;&gt; hides figure without deleting it\n\
\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigureHide_doc,&quot;hide() -&gt; hides figure without deleting it\n\
\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77a5665b381dccef36470f8c51837455"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a77a5665b381dccef36470f8c51837455" args="(pyFigureSubplot_doc,&quot;subplot(index) &#45;&gt; returns plotItem of desired subplot\n\
\n\
This method closes and deletes any specific figure (given by handle) or all opened figures. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
index : {unsigned int} \n\
    index to desired subplot. The subplot at the top, left position has the index 0 whereas the index is incremented row&#45;wise.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigureSubplot_doc,&quot;subplot(index) -&gt; returns plotItem of desired subplot\n\
\n\
This method closes and deletes any specific figure (given by handle) or all opened figures. \n\
\n\
Parameters \n\
----------- \n\
index : {unsigned int} \n\
    index to desired subplot. The subplot at the top, left position has the index 0 whereas the index is incremented row-wise.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af557696cdd8e91c0f817143135038480"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="af557696cdd8e91c0f817143135038480" args="(pyFigure_docked_doc,&quot;dock status of figure (True|False) \n\
\n\
this attribute controls the dock appearance of this figure. If it is docked, the figure is integrated into the main window \n\
of itom, else it is a independent window. \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigure_docked_doc,&quot;dock status of figure (True|False) \n\
\n\
this attribute controls the dock appearance of this figure. If it is docked, the figure is integrated into the main window \n\
of itom, else it is a independent window. \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a121751eff3d9fc6345a1eb964eedb906"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a121751eff3d9fc6345a1eb964eedb906" args="(pyFigure_Close_doc,&quot;close(handle|'all') &#45;&gt; static method to close any specific or all open figures (unless any figure&#45;instance still keeps track of them)\n\
\n\
This method closes and deletes any specific figure (given by handle) or all opened figures. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
handle : {dataIO&#45;Instance} \n\
    any figure handle (&gt;0) or 'all' in order to close all opened figures \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
If any instance of class 'figure' still keeps a reference to any figure, it is only closed and deleted if the last instance is deleted, too.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigure_Close_doc,&quot;close(handle|'all') -&gt; static method to close any specific or all open figures (unless any figure-instance still keeps track of them)\n\
\n\
This method closes and deletes any specific figure (given by handle) or all opened figures. \n\
\n\
Parameters \n\
----------- \n\
handle : {dataIO-Instance} \n\
    any figure handle (&gt;0) or 'all' in order to close all opened figures \n\
\n\
Notes \n\
------- \n\
If any instance of class 'figure' still keeps a reference to any figure, it is only closed and deleted if the last instance is deleted, too.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1bde55711b394182795c8b69665dc35"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="af1bde55711b394182795c8b69665dc35" args="(pyOpenEmptyScriptEditor_doc,&quot;scriptEditor() &#45;&gt; opens new, empty script editor window (undocked) \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
Opens a new and empty itom script editor window. The window is undocked and non blocking.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyOpenEmptyScriptEditor_doc,&quot;scriptEditor() -&gt; opens new, empty script editor window (undocked) \n\
\n\
Notes \n\
----- \n\
\n\
Opens a new and empty itom script editor window. The window is undocked and non blocking.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12391bad343c0db0224e4b67a4a69615"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a12391bad343c0db0224e4b67a4a69615" args="(pyNewScript_doc,&quot;newScript() &#45;&gt; opens an empty, new script in the current script window.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
Creates a new itom script in the latest opened editor window.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyNewScript_doc,&quot;newScript() -&gt; opens an empty, new script in the current script window.\n\
\n\
Notes \n\
----- \n\
\n\
Creates a new itom script in the latest opened editor window.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac590fb123242dea70b38a82f297a6f6f"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ac590fb123242dea70b38a82f297a6f6f" args="(pyOpenScript_doc,&quot;openScript(filename) &#45;&gt; opens the given script in current script window.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filename : {str} \n\
    Path and File of the file to open. Unter windows not case sensitiv.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
Open an existing itom script from the harddrive into the latest opened editor window.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyOpenScript_doc,&quot;openScript(filename) -&gt; opens the given script in current script window.\n\
\n\
Parameters \n\
----------- \n\
filename : {str} \n\
    Path and File of the file to open. Unter windows not case sensitiv.\n\
\n\
Notes \n\
----- \n\
\n\
Open an existing itom script from the harddrive into the latest opened editor window.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f1d3dadd580dcc11a4377c6220495dc"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a1f1d3dadd580dcc11a4377c6220495dc" args="(pyPlotImage_doc,&quot;plot(data, [className]) &#45;&gt; plots a dataObject in a newly created figure \n\
\n\
Plot an existing dataObject in not dockable, not blocking window. \n\
The style of the plot will depend on the object dimensions.\n\
If x&#45;dim or y&#45;dim are equal to 1, plot will be a lineplot else a 2D&#45;plot.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
data : {DataObject} \n\
    Is the data object whose region of interest will be plotted.\n\
className : {str}, optional \n\
    class name of desired plot (if not indicated default plot will be used (see application settings) \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlotImage_doc,&quot;plot(data, [className]) -&gt; plots a dataObject in a newly created figure \n\
\n\
Plot an existing dataObject in not dockable, not blocking window. \n\
The style of the plot will depend on the object dimensions.\n\
If x-dim or y-dim are equal to 1, plot will be a lineplot else a 2D-plot.\n\
\n\
Parameters \n\
----------- \n\
data : {DataObject} \n\
    Is the data object whose region of interest will be plotted.\n\
className : {str}, optional \n\
    class name of desired plot (if not indicated default plot will be used (see application settings) \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa29f35343ebe0227148ca461c32babcc"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aa29f35343ebe0227148ca461c32babcc" args="(pyLiveImage_doc,&quot;liveImage(cam, [className]) &#45;&gt; shows a camera live image in a newly created figure\n\
\n\
Creates a plot&#45;image (2D) and automatically grabs images into this window.\n\
This function is not blocking.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
cam : {dataIO&#45;Instance} \n\
    Camera grabber device from which images are acquired.\n\
className : {str}, optional \n\
    class name of desired plot (if not indicated default plot will be used (see application settings)&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyLiveImage_doc,&quot;liveImage(cam, [className]) -&gt; shows a camera live image in a newly created figure\n\
\n\
Creates a plot-image (2D) and automatically grabs images into this window.\n\
This function is not blocking.\n\
\n\
Parameters \n\
----------- \n\
cam : {dataIO-Instance} \n\
    Camera grabber device from which images are acquired.\n\
className : {str}, optional \n\
    class name of desired plot (if not indicated default plot will be used (see application settings)&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa42dc8403786d9a2bf7a19c41eeaee7a">PyWidgetOrFilterHelp</a> (bool getWidgetHelp, PyObject *pArgs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b9f7becafc5888b6a1cb158e296c423"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a4b9f7becafc5888b6a1cb158e296c423" args="(pyFilterHelp_doc,&quot;filterHelp([filterName, dictionary = 0, furtherInfos = 0]) &#45;&gt; generates an online help for the given filter(s). \n \
                               Generates an online help for the given widget or returns a list of available filter.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filterName : {str}, optional \n\
    is the fullname or a part of any filter&#45;name which should be displayed. \n\
    If filterName is none or no filter matches filterName casesensitiv a list with all suitable filters is given. \n\
dictionary : {dict}, optional \n\
    if dictionary == 1, function returns an Py_Dictionary with parameters \n\
    Default value is 0.\n\
furtherInfos : {int}, optional \n\
    defines if a complete parameter&#45;list of name&#45;related filters to the given filterName should be displayed (1) \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Returns none or a PyDictionary depending on the value of dictionary.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFilterHelp_doc,&quot;filterHelp([filterName, dictionary = 0, furtherInfos = 0]) -&gt; generates an online help for the given filter(s). \n \
                               Generates an online help for the given widget or returns a list of available filter.\n\
\n\
Parameters \n\
----------- \n\
filterName : {str}, optional \n\
    is the fullname or a part of any filter-name which should be displayed. \n\
    If filterName is none or no filter matches filterName casesensitiv a list with all suitable filters is given. \n\
dictionary : {dict}, optional \n\
    if dictionary == 1, function returns an Py_Dictionary with parameters \n\
    Default value is 0.\n\
furtherInfos : {int}, optional \n\
    defines if a complete parameter-list of name-related filters to the given filterName should be displayed (1) \n\
\n\
Returns \n\
------- \n\
Returns none or a PyDictionary depending on the value of dictionary.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8bd57e0c563fd856b33302b7542b409"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ad8bd57e0c563fd856b33302b7542b409" args="(pyWidgetHelp_doc,&quot;widgetHelp([widgetName, dictionary = 0, furtherInfos = 0]) &#45;&gt; generates an online help for the given widget(s). \n \
Generates an online help for the given widget or returns a list of available widgets. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
widgetName : {str}, optional \n\
    is the fullname or a part of any widget&#45;name which should be displayed. \n\
    If widgetName is none or no widget matches widgetName casesensitiv a list with all suitable widgets is given. \n\
dictionary : {dict}, optional \n\
    if dictionary == 1, function returns an Py_Dictionary with parameters \n\
    Default value is 0.\n\
furtherInfos : {int}, optional \n\
    defines if a complete parameter&#45;list of name&#45;related widgets to the given widgetName should be displayed (1) \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Returns none or a PyDictionary depending on the value of dictionary.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyWidgetHelp_doc,&quot;widgetHelp([widgetName, dictionary = 0, furtherInfos = 0]) -&gt; generates an online help for the given widget(s). \n \
Generates an online help for the given widget or returns a list of available widgets. \n\
\n\
Parameters \n\
----------- \n\
widgetName : {str}, optional \n\
    is the fullname or a part of any widget-name which should be displayed. \n\
    If widgetName is none or no widget matches widgetName casesensitiv a list with all suitable widgets is given. \n\
dictionary : {dict}, optional \n\
    if dictionary == 1, function returns an Py_Dictionary with parameters \n\
    Default value is 0.\n\
furtherInfos : {int}, optional \n\
    defines if a complete parameter-list of name-related widgets to the given widgetName should be displayed (1) \n\
\n\
Returns \n\
------- \n\
Returns none or a PyDictionary depending on the value of dictionary.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b63ad70b7bab97f41205a28872eac90"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a4b63ad70b7bab97f41205a28872eac90" args="(pyPluginLoaded_doc,&quot;pluginLoaded(pluginname) &#45;&gt; checks if a certain plugin was loaded.\n\
Checks if a specified plugin is loaded and returns the result as a boolean expression. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
pluginname :  {str} \n\
    The name of a specified plugin as usually displayed in the plugin window.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
True, if the plugin has been loaded and can be used, else False.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginLoaded_doc,&quot;pluginLoaded(pluginname) -&gt; checks if a certain plugin was loaded.\n\
Checks if a specified plugin is loaded and returns the result as a boolean expression. \n\
\n\
Parameters \n\
----------- \n\
pluginname :  {str} \n\
    The name of a specified plugin as usually displayed in the plugin window.\n\
\n\
Returns \n\
------- \n\
True, if the plugin has been loaded and can be used, else False.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dc960d13636c0fad9b675f0d3106549"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a8dc960d13636c0fad9b675f0d3106549" args="(pyPluginHelp_doc,&quot;pluginHelp(pluginName [, dictionary = False]) &#45;&gt; generates an online help for the specified plugin.\n\
                              Gets (also print to console) the initialisation parameters of the plugin specified pluginName (str, as specified in the plugin window).\n\
If dictionary is True, a dict with all plugin parameters is returned.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
pluginName : {str} \n\
    is the fullname of a plugin as specified in the plugin window.\n\
dictionary : {bool}, optional \n\
	if dictionary == True, function returns an dict with plugin parameters (default: False)\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Returns None or a dict depending on the value of parameter dictionary.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginHelp_doc,&quot;pluginHelp(pluginName [, dictionary = False]) -&gt; generates an online help for the specified plugin.\n\
                              Gets (also print to console) the initialisation parameters of the plugin specified pluginName (str, as specified in the plugin window).\n\
If dictionary is True, a dict with all plugin parameters is returned.\n\
\n\
Parameters \n\
----------- \n\
pluginName : {str} \n\
    is the fullname of a plugin as specified in the plugin window.\n\
dictionary : {bool}, optional \n\
	if dictionary == True, function returns an dict with plugin parameters (default: False)\n\
\n\
Returns \n\
------- \n\
Returns None or a dict depending on the value of parameter dictionary.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a517c9c6b66023238706230579cf9a388"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a517c9c6b66023238706230579cf9a388" args="(pyITOMVersion_doc,&quot;version([toggle&#45;output [, include&#45;plugins]])) &#45;&gt; retrieve complete information about itom version numbers\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
toggle&#45;output : {bool}, optional\n\
    default = false\n\
    if true, output will be written to a dictionary else to console.\n\
dictionary : {bool}, optional \n\
    default = false\n\
    if true, add informations about plugIn versions.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
None (display outPut) or PyDictionary with version information.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
Retrieve complete version information of ITOM and if specified version information of loaded plugins\n\
and print it either to the console or to a PyDictionary.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyITOMVersion_doc,&quot;version([toggle-output [, include-plugins]])) -&gt; retrieve complete information about itom version numbers\n\
\n\
Parameters \n\
----------- \n\
toggle-output : {bool}, optional\n\
    default = false\n\
    if true, output will be written to a dictionary else to console.\n\
dictionary : {bool}, optional \n\
    default = false\n\
    if true, add informations about plugIn versions.\n\
\n\
Returns \n\
------- \n\
None (display outPut) or PyDictionary with version information.\n\
\n\
Notes \n\
----- \n\
\n\
Retrieve complete version information of ITOM and if specified version information of loaded plugins\n\
and print it either to the console or to a PyDictionary.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a540ba07efd58ca13dde2c913400cbeaa"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a540ba07efd58ca13dde2c913400cbeaa" args="(pyAddButton_doc,&quot;addButton(toolbarName, buttonName, code [, icon, argtuple]) &#45;&gt; adds a button to a toolbar in the main window \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
toolbarName : {str} \n\
    The name of the toolbar.\n\
buttonName : {str} \n\
    The name (str, identifier) of the button to create.\n\
code : {str, Method, Function}\n\
    The code to be executed if button is pressed.\n\
icon : {str}, optional \n\
    The filename of an icon&#45;file. This can also be relative to the application directory of 'itom'.\n\
argtuple : {tuple}, optional \n\
    Arguments, which will be passed to method (in order to avoid cyclic references try to only use basic element types).\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
This function adds a button to a toolbar in the main window.\n\
If the button is pressed the simple python command specified by python&#45;code is executed.\n\
If the toolbar specified by toolbarName do not exist, the toolbar is created.\n\
The button representation will be the optional icon or if icon is not loadable 'buttonName' will be displayed.\n\
\n\
ITOM comes with basic icons addressable by ':/.../iconname.png', e.g. ':/gui/icons/close.png'.\n\
Find available via iconbrower under 'Editor&#45;Menu/Edit/iconbrower' or crtl&#45;b&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyAddButton_doc,&quot;addButton(toolbarName, buttonName, code [, icon, argtuple]) -&gt; adds a button to a toolbar in the main window \n\
\n\
Parameters \n\
----------- \n\
toolbarName : {str} \n\
    The name of the toolbar.\n\
buttonName : {str} \n\
    The name (str, identifier) of the button to create.\n\
code : {str, Method, Function}\n\
    The code to be executed if button is pressed.\n\
icon : {str}, optional \n\
    The filename of an icon-file. This can also be relative to the application directory of 'itom'.\n\
argtuple : {tuple}, optional \n\
    Arguments, which will be passed to method (in order to avoid cyclic references try to only use basic element types).\n\
\n\
Notes \n\
----- \n\
\n\
This function adds a button to a toolbar in the main window.\n\
If the button is pressed the simple python command specified by python-code is executed.\n\
If the toolbar specified by toolbarName do not exist, the toolbar is created.\n\
The button representation will be the optional icon or if icon is not loadable 'buttonName' will be displayed.\n\
\n\
ITOM comes with basic icons addressable by ':/.../iconname.png', e.g. ':/gui/icons/close.png'.\n\
Find available via iconbrower under 'Editor-Menu/Edit/iconbrower' or crtl-b&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b739d3f8a2efb42d290d88ad03c76b0"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a9b739d3f8a2efb42d290d88ad03c76b0" args="(pyRemoveButton_doc,&quot;removeButton(toolbarName, buttonName) &#45;&gt; removes a button from a given toolbar. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
toolbarName : {str} \n\
    The name of the toolbar.\n\
buttonName : {str} \n\
    The name (str, identifier) of the button to remove.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
This function removes a button from a toolbar in the main window.\n\
If the toolbar is empty after removal, it is deleted.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRemoveButton_doc,&quot;removeButton(toolbarName, buttonName) -&gt; removes a button from a given toolbar. \n\
\n\
Parameters \n\
----------- \n\
toolbarName : {str} \n\
    The name of the toolbar.\n\
buttonName : {str} \n\
    The name (str, identifier) of the button to remove.\n\
\n\
Notes \n\
----- \n\
\n\
This function removes a button from a toolbar in the main window.\n\
If the toolbar is empty after removal, it is deleted.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a609321e578437b6b04632587795b8afc"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a609321e578437b6b04632587795b8afc" args="(pyAddMenu_doc,&quot;addMenu(type, key [, name, code, icon, argtuple]) &#45;&gt; adds an element to the menu bar. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
type : {Int}\n\
    The type of the menu&#45;element (BUTTON:0 [default], SEPARATOR:1, MENU:2). Use the corresponding constans in module 'itom'.\n\
key : {str} \n\
    A slash&#45;separated string where every sub&#45;element is the key&#45;name for the menu&#45;element in the specific level.\n\
name : {str}, optional \n\
    The text of the menu&#45;element. If not indicated, the last sub&#45;element of key is taken.\n\
code : {str, Method, Function}, optional \n\
    The code to be executed if menu element is pressed.\n\
icon : {str}, optional \n\
    The filename of an icon&#45;file. This can also be relative to the application directory of 'itom'.\n\
argtuple : {tuple}, optional \n\
    Arguments, which will be passed to method (in order to avoid cyclic references try to only use basic element types).\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
This function adds an element to the main window menu bar. \n\
The root element of every menu&#45;list must be a MENU&#45;element. Such a MENU&#45;element can contain sub&#45;elements. \n\
The following sub&#45;elements can be either another MENU, a SEPARATOR or a BUTTON. Only the BUTTON itself \n\
triggers a signal, which then executes the code, given by a string or a reference to a callable python method \n\
or function. Remember, that this reference is only stored as a weak pointer. \n\
If you want to directly add a sub&#45;element, you can give a slash&#45;separated string in the key&#45;parameter. \n\
Every sub&#45;component of this string then represents the menu&#45;element in its specific level. Only the element in the last \n\
can be something else than MENU.\n\
\n\
ITOM comes with basic icons addressable by ':/.../iconname.png', e.g. ':/gui/icons/close.png'.\n\
Find available via iconbrower under 'Editor&#45;Menu/Edit/iconbrower' or crtl&#45;b&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyAddMenu_doc,&quot;addMenu(type, key [, name, code, icon, argtuple]) -&gt; adds an element to the menu bar. \n\
\n\
Parameters \n\
----------- \n\
type : {Int}\n\
    The type of the menu-element (BUTTON:0 [default], SEPARATOR:1, MENU:2). Use the corresponding constans in module 'itom'.\n\
key : {str} \n\
    A slash-separated string where every sub-element is the key-name for the menu-element in the specific level.\n\
name : {str}, optional \n\
    The text of the menu-element. If not indicated, the last sub-element of key is taken.\n\
code : {str, Method, Function}, optional \n\
    The code to be executed if menu element is pressed.\n\
icon : {str}, optional \n\
    The filename of an icon-file. This can also be relative to the application directory of 'itom'.\n\
argtuple : {tuple}, optional \n\
    Arguments, which will be passed to method (in order to avoid cyclic references try to only use basic element types).\n\
\n\
Notes \n\
----- \n\
\n\
This function adds an element to the main window menu bar. \n\
The root element of every menu-list must be a MENU-element. Such a MENU-element can contain sub-elements. \n\
The following sub-elements can be either another MENU, a SEPARATOR or a BUTTON. Only the BUTTON itself \n\
triggers a signal, which then executes the code, given by a string or a reference to a callable python method \n\
or function. Remember, that this reference is only stored as a weak pointer. \n\
If you want to directly add a sub-element, you can give a slash-separated string in the key-parameter. \n\
Every sub-component of this string then represents the menu-element in its specific level. Only the element in the last \n\
can be something else than MENU.\n\
\n\
ITOM comes with basic icons addressable by ':/.../iconname.png', e.g. ':/gui/icons/close.png'.\n\
Find available via iconbrower under 'Editor-Menu/Edit/iconbrower' or crtl-b&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab938a59e7d9a78416c0af265db2f6965"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ab938a59e7d9a78416c0af265db2f6965" args="(pyRemoveMenu_doc,&quot;removeMenu(key) &#45;&gt; remove a menu element with the given key. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
key : {str} \n\
    The name (str, identifier) of the menu entry to remove.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
This function remove a menu element with the given key. \n\
key is a slash separated list. The sub&#45;components then \n\
lead the way to the final element, which should be removed.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRemoveMenu_doc,&quot;removeMenu(key) -&gt; remove a menu element with the given key. \n\
\n\
Parameters \n\
----------- \n\
key : {str} \n\
    The name (str, identifier) of the menu entry to remove.\n\
\n\
Notes \n\
----- \n\
\n\
This function remove a menu element with the given key. \n\
key is a slash separated list. The sub-components then \n\
lead the way to the final element, which should be removed.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a526e9a841beb815a6d8098909d5807a8"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a526e9a841beb815a6d8098909d5807a8" args="(getScreenInfo_doc,&quot;getScreenInfo() &#45;&gt; returns dictionary with information about all available screens. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
ScreenInfo : {PyDict} \n\
    Returns a PyDictionary containing:\n\
screenCount : {int} \n\
    number of available screens \n\
primaryScreen : {int} \n\
    index (0&#45;based) of primary screen \n\
geometry : {tuple} \n\
    tuple with dictionaries for each screen containing data for width (w), height (h) and its top&#45;left&#45;position (x, y)\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
This function returns a PyDictionary which contains informations about the current screen configuration of this PC.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (getScreenInfo_doc,&quot;getScreenInfo() -&gt; returns dictionary with information about all available screens. \n\
\n\
Returns \n\
------- \n\
ScreenInfo : {PyDict} \n\
    Returns a PyDictionary containing:\n\
screenCount : {int} \n\
    number of available screens \n\
primaryScreen : {int} \n\
    index (0-based) of primary screen \n\
geometry : {tuple} \n\
    tuple with dictionaries for each screen containing data for width (w), height (h) and its top-left-position (x, y)\n\
\n\
Notes \n\
----- \n\
\n\
This function returns a PyDictionary which contains informations about the current screen configuration of this PC.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a423e79ac0b5ff477e9cd2e77de1725"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a0a423e79ac0b5ff477e9cd2e77de1725" args="(pySaveMatlabMat_doc,&quot;saveMatlabMat(filename, dictionary[, matrixName]) &#45;&gt; saves strings, numbers, arrays or combinations to a Matlab matrix. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filename : {str} \n\
    Filename to which the data will be written (.mat will be added if not available)\n\
dictionary : {dictionary, list, tuple} \n\
    dictionary, list or tuple with elements of type number, string, array (dataObject, numpy.ndarray, npDataObject...)\n\
matrix&#45;name : {string or list or tuple of strings}, optional \n\
    string or list or tuple of string (same length than object&#45;sequence)\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
This function saves strings, numbers, arrays or combinations to a Matlab matrix (file). \n\
List or Tuples will be included to new dictionary (element&#45;wise entry with name matrix1,...,matrixN or names given by last optional matrix&#45;name sequence).&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pySaveMatlabMat_doc,&quot;saveMatlabMat(filename, dictionary[, matrixName]) -&gt; saves strings, numbers, arrays or combinations to a Matlab matrix. \n\
\n\
Parameters \n\
----------- \n\
filename : {str} \n\
    Filename to which the data will be written (.mat will be added if not available)\n\
dictionary : {dictionary, list, tuple} \n\
    dictionary, list or tuple with elements of type number, string, array (dataObject, numpy.ndarray, npDataObject...)\n\
matrix-name : {string or list or tuple of strings}, optional \n\
    string or list or tuple of string (same length than object-sequence)\n\
\n\
Notes \n\
----- \n\
\n\
This function saves strings, numbers, arrays or combinations to a Matlab matrix (file). \n\
List or Tuples will be included to new dictionary (element-wise entry with name matrix1,...,matrixN or names given by last optional matrix-name sequence).&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a521db476e5bdc0b6dbe4e49bca23d56a"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a521db476e5bdc0b6dbe4e49bca23d56a" args="(pyLoadMatlabMat_doc,&quot;loadMatlabMat(filename) &#45;&gt; loads matlab mat&#45;file by using scipy methods and returns the loaded dictionary. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filename : {str} \n\
    Filename from which the data will be imported (.mat will be added if not available)\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
PyDictionary with content of the Matlab&#45;file\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
This function loads matlab mat&#45;file by using scipy methods and returns the loaded dictionary.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyLoadMatlabMat_doc,&quot;loadMatlabMat(filename) -&gt; loads matlab mat-file by using scipy methods and returns the loaded dictionary. \n\
\n\
Parameters \n\
----------- \n\
filename : {str} \n\
    Filename from which the data will be imported (.mat will be added if not available)\n\
\n\
Returns \n\
------- \n\
PyDictionary with content of the Matlab-file\n\
\n\
Notes \n\
----- \n\
\n\
This function loads matlab mat-file by using scipy methods and returns the loaded dictionary.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52dddae68ff35bd34ce7d7bf07576973"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a52dddae68ff35bd34ce7d7bf07576973" args="(pyFilter_doc,&quot;filter(name [, furtherParameters, ...]) &#45;&gt; invoke a filter (or algorithm) function within an algorithm&#45;plugin. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
name : {str} \n\
    The name of the filter\n\
furtherParameters : {variant} \n\
    Further parameters depend on the filter&#45;methods itself (give the mandatory and then optional parameters in their defined order).\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
output parameters : {variant} \n\
    The returned values depend on the definition of each filter. In general it is a tuple of all output parameters that are defined by the filter function.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
This function is used to invoke itom filter&#45;functions or algorithms, declared within itom&#45;algorithm plugins.\n\
The parameters (arguments) depends on the specific filter function (see filterHelp(name)),\n\
By filterHelp() a list of available filter functions is retrieved.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFilter_doc,&quot;filter(name [, furtherParameters, ...]) -&gt; invoke a filter (or algorithm) function within an algorithm-plugin. \n\
\n\
Parameters \n\
----------- \n\
name : {str} \n\
    The name of the filter\n\
furtherParameters : {variant} \n\
    Further parameters depend on the filter-methods itself (give the mandatory and then optional parameters in their defined order).\n\
\n\
Returns \n\
------- \n\
output parameters : {variant} \n\
    The returned values depend on the definition of each filter. In general it is a tuple of all output parameters that are defined by the filter function.\n\
\n\
Notes \n\
----- \n\
\n\
This function is used to invoke itom filter-functions or algorithms, declared within itom-algorithm plugins.\n\
The parameters (arguments) depends on the specific filter function (see filterHelp(name)),\n\
By filterHelp() a list of available filter functions is retrieved.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94abdefd43ea8857c2eb7d52c54fc0b1"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a94abdefd43ea8857c2eb7d52c54fc0b1" args="(pySaveDataObject_doc,&quot;saveDataObject(filename, dataObject [, tagsAsBinary]) &#45;&gt; save a dataObject to harddrive. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filename : {str} \n\
    Filename and Path of the destination (.ido will be added if no .*&#45;ending is available)\n\
dataObject : {DataObject} \n\
    An allocated dataObject of n&#45;Dimensions.\n\
tagsAsBinary : {bool}, optional \n\
    Optional tag to toogle if numeric&#45;tags should be saved (metaData) as binary or by default as string.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
This function writes an ito::dataObject to the file specified by filename. The data is stored as binary. \n\
The value of string&#45;Tags is encoded to avoid XML&#45;conflics. The value of numerical&#45;Tags are saved as string\n\
with 15 significat digits (&gt;32bit, tagsAsBinary == False, default) or as binary (tagsAsBinary == True).\n\
Tagnames which contains special characters leads to XML&#45;conflics.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pySaveDataObject_doc,&quot;saveDataObject(filename, dataObject [, tagsAsBinary]) -&gt; save a dataObject to harddrive. \n\
\n\
Parameters \n\
----------- \n\
filename : {str} \n\
    Filename and Path of the destination (.ido will be added if no .*-ending is available)\n\
dataObject : {<a class="el" href="classito_1_1_data_object.html">DataObject</a>} \n\
    An allocated dataObject of n-Dimensions.\n\
tagsAsBinary : {bool}, optional \n\
    Optional tag to toogle if numeric-tags should be saved (metaData) as binary or by default as string.\n\
\n\
Notes \n\
----- \n\
\n\
This function writes an ito::dataObject to the file specified by filename. The data is stored as binary. \n\
The value of string-Tags is encoded to avoid XML-conflics. The value of numerical-Tags are saved as string\n\
with 15 significat digits (&gt;32bit, tagsAsBinary == False, default) or as binary (tagsAsBinary == True).\n\
Tagnames which contains special characters leads to XML-conflics.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60de44e1539a9a137262944f670e5599"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a60de44e1539a9a137262944f670e5599" args="(pyLoadDataObject_doc,&quot;loadDataObject(filename, dataObject [, doNotAppendIDO]) &#45;&gt; load a dataObject from the harddrive to an existing dataObject. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filename : {str} \n\
    Filename and Path of the destination (.ido will be added if not available)\n\
dataObject : {DataObject} \n\
    A pre&#45;allocated dataObject (empty Objects are allowed).\n\
doNotAppendIDO : {bool}, optional \n\
    Optional tag to avoid adding &#45;ido&#45;Tag, default is False.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
This function reads an ito::dataObject from the file specified by filename. \n\
MetaData saveType (string, binary) are extracted from the file and restored within the object.\n\
The value of string&#45;Tags must be encoded to avoid XML&#45;conflics.\n\
Tagnames which contains special characters leads to XML&#45;conflics.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyLoadDataObject_doc,&quot;loadDataObject(filename, dataObject [, doNotAppendIDO]) -&gt; load a dataObject from the harddrive to an existing dataObject. \n\
\n\
Parameters \n\
----------- \n\
filename : {str} \n\
    Filename and Path of the destination (.ido will be added if not available)\n\
dataObject : {<a class="el" href="classito_1_1_data_object.html">DataObject</a>} \n\
    A pre-allocated dataObject (empty Objects are allowed).\n\
doNotAppendIDO : {bool}, optional \n\
    Optional tag to avoid adding -ido-Tag, default is False.\n\
\n\
Notes \n\
----- \n\
\n\
This function reads an ito::dataObject from the file specified by filename. \n\
MetaData saveType (string, binary) are extracted from the file and restored within the object.\n\
The value of string-Tags must be encoded to avoid XML-conflics.\n\
Tagnames which contains special characters leads to XML-conflics.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3761da85037d882454c19943c690c8b6"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a3761da85037d882454c19943c690c8b6" args="(getDefaultScaleAbleUnits_doc,&quot;getDefaultScaleAbleUnits() &#45;&gt; Get a PythonList with standard scaleable units. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
List with strings containing all scaleable units : {PyList}\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
Get a PythonList with standard scaleable units. Used together with itom.ScaleValueAndUnit(...)&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (getDefaultScaleAbleUnits_doc,&quot;getDefaultScaleAbleUnits() -&gt; Get a PythonList with standard scaleable units. \n\
\n\
Returns \n\
------- \n\
List with strings containing all scaleable units : {PyList}\n\
\n\
Notes \n\
----- \n\
\n\
Get a PythonList with standard scaleable units. Used together with itom.ScaleValueAndUnit(...)&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab33e045027e6629a9a9782f6972b8140"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ab33e045027e6629a9a9782f6972b8140" args="(ScaleValueAndUnit_doc,&quot;ScaleValueAndUnit(ScaleableUnits, value, valueUnit) &#45;&gt; Scale a value and its unit and returns [value, 'Unit'] \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
ScaleableUnits : {PyList of Strings} \n\
    A string list with all scaleable units\n\
value : {double} \n\
    The value to be scaled\n\
valueUnit : {str} \n\
    The value unit to be scaled\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
PyTuple with scaled value and scaled unit\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
Rescale a value with SI&#45;unit (e.g. 0.01 mm to 10 micrometer). Used together with itom.getDefaultScaleAbleUnits()&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (ScaleValueAndUnit_doc,&quot;ScaleValueAndUnit(ScaleableUnits, value, valueUnit) -&gt; Scale a value and its unit and returns [value, 'Unit'] \n\
\n\
Parameters \n\
----------- \n\
ScaleableUnits : {PyList of Strings} \n\
    A string list with all scaleable units\n\
value : {double} \n\
    The value to be scaled\n\
valueUnit : {str} \n\
    The value unit to be scaled\n\
\n\
Returns \n\
------- \n\
PyTuple with scaled value and scaled unit\n\
\n\
Notes \n\
----- \n\
\n\
Rescale a value with SI-unit (e.g. 0.01 mm to 10 micrometer). Used together with itom.getDefaultScaleAbleUnits()&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7bede675e5fc948e133add1a99bc2a0"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ae7bede675e5fc948e133add1a99bc2a0" args="(getAppPath_doc,&quot;getAppPath() &#45;&gt; returns absolute path of application base directory.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Path : {str}\n\
    string with absolute path of this application\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
This function returns the absolute path of application base directory.\n\
The return value is independent of the current working diractory&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (getAppPath_doc,&quot;getAppPath() -&gt; returns absolute path of application base directory.\n\
\n\
Returns \n\
------- \n\
Path : {str}\n\
    string with absolute path of this application\n\
\n\
Notes \n\
----- \n\
\n\
This function returns the absolute path of application base directory.\n\
The return value is independent of the current working diractory&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1547b96bd34c2fcc5b6f089d895f0af"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aa1547b96bd34c2fcc5b6f089d895f0af" args="(getCurrentPath_doc,&quot;getCurrentPath() &#45;&gt; returns absolute path of current working directory.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Path : {str}\n\
    string with current working path\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
This function returns the current working path of the application.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (getCurrentPath_doc,&quot;getCurrentPath() -&gt; returns absolute path of current working directory.\n\
\n\
Returns \n\
------- \n\
Path : {str}\n\
    string with current working path\n\
\n\
Notes \n\
----- \n\
\n\
This function returns the current working path of the application.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cb51219bdcd9fa36ee316726d5a4758"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a9cb51219bdcd9fa36ee316726d5a4758" args="(setCurrentPath_doc,&quot;setCurrentPath(newPath) &#45;&gt; sets absolute path of current working directory \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
newPath : {str} \n\
    The new working path of this application\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Success : {bool} \n\
    True in case of success else False\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
sets absolute path of current working directory returns True if currentPath could be changed, else False.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (setCurrentPath_doc,&quot;setCurrentPath(newPath) -&gt; sets absolute path of current working directory \n\
\n\
Parameters \n\
----------- \n\
newPath : {str} \n\
    The new working path of this application\n\
\n\
Returns \n\
------- \n\
Success : {bool} \n\
    True in case of success else False\n\
\n\
Notes \n\
----- \n\
\n\
sets absolute path of current working directory returns True if currentPath could be changed, else False.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c9784acb507b7723e27e19cf242cb04"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a2c9784acb507b7723e27e19cf242cb04" args="(pyItom_FigureClose_doc,&quot;close(handle|'all') &#45;&gt; method to close any specific or all open figures (unless any figure&#45;instance still keeps track of them)\n\
\n\
This method closes and deletes any specific figure (given by handle) or all opened figures. This method always calls the static method \n\
close of class figure.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
handle : {dataIO&#45;Instance} \n\
    any figure handle (&gt;0) or 'all' in order to close all opened figures \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
If any instance of class 'figure' still keeps a reference to any figure, it is only closed and deleted if the last instance is deleted, too. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
figure.close&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a2c9784acb507b7723e27e19cf242cb04">PyDoc_STRVAR</a> (pyItom_FigureClose_doc,&quot;close(handle|'all') -&gt; method to close any specific or all open figures (unless any figure-instance still keeps track of them)\n\
\n\
This method closes and deletes any specific figure (given by handle) or all opened figures. This method always calls the static method \n\
close of class figure.\n\
\n\
Parameters \n\
----------- \n\
handle : {dataIO-Instance} \n\
    any figure handle (&gt;0) or 'all' in order to close all opened figures \n\
\n\
Notes \n\
------- \n\
If any instance of class 'figure' still keeps a reference to any figure, it is only closed and deleted if the last instance is deleted, too. \n\
\n\
See Also \n\
--------- \n\
figure.close&quot;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">*static*/ PyObject* PythonItom::PyGetGlobalDict(PyObject* /*pSelf*/) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2afdb667c6dcbe6892ace138e1b29374"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a2afdb667c6dcbe6892ace138e1b29374" args="(pyLoadIDC_doc,&quot;loadIDC(filename) &#45;&gt; loads a pickled idc&#45;file and returns the content as dictionary\n\
\n\
This methods loads the given idc&#45;file using the method load from the python&#45;buildin module pickle and returns the loaded dictionary.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filename : {String} \n\
    absolute filename or filename relative to the current directory. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
pickle.load&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyLoadIDC_doc,&quot;loadIDC(filename) -&gt; loads a pickled idc-file and returns the content as dictionary\n\
\n\
This methods loads the given idc-file using the method load from the python-buildin module pickle and returns the loaded dictionary.\n\
\n\
Parameters \n\
----------- \n\
filename : {String} \n\
    absolute filename or filename relative to the current directory. \n\
\n\
See Also \n\
--------- \n\
pickle.load&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6cb827bbc5e365f931a197aadb3fc87"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aa6cb827bbc5e365f931a197aadb3fc87" args="(pySaveIDC_doc,&quot;saveIDC(filename, dict [,overwriteIfExists = True]) &#45;&gt; saves the given dictionary as pickled idc&#45;file.\n\
\n\
This method saves the given dictionary as pickled icd&#45;file using the method dump from the builtin module pickle.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filename : {string} \n\
    absolute filename or filename relative to the current directory. \n\
dict : {dict} \n\
    dictionary which should be pickled. \n\
overwriteIfExists : {bool}, default: True \n\
    if True, an existing file will be overwritten. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
pickle.dump&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pySaveIDC_doc,&quot;saveIDC(filename, dict [,overwriteIfExists = True]) -&gt; saves the given dictionary as pickled idc-file.\n\
\n\
This method saves the given dictionary as pickled icd-file using the method dump from the builtin module pickle.\n\
\n\
Parameters \n\
----------- \n\
filename : {string} \n\
    absolute filename or filename relative to the current directory. \n\
dict : {dict} \n\
    dictionary which should be pickled. \n\
overwriteIfExists : {bool}, default: True \n\
    if True, an existing file will be overwritten. \n\
\n\
See Also \n\
--------- \n\
pickle.dump&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a233d059c94b86c423ba60a0b63c8b2aa"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a233d059c94b86c423ba60a0b63c8b2aa" args="(pyAMax_doc,&quot;amax(dataObject) &#45;&gt; returns the maximum value of the data object.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyAMax_doc,&quot;amax(dataObject) -&gt; returns the maximum value of the data object.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adaee83b20c465541a861f36383fdebe8"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="adaee83b20c465541a861f36383fdebe8" args="(pyPlotItemInit_doc,&quot;plotItem(figure[, subplotIdx]) &#45;&gt; instance of the plot or subplot of a figure.\n\
\n\
Use can use this constructor to access any plot or subplot (if more than one plot) of a figure. The subplotIndex \n\
row&#45;wisely addresses the subplots, beginning with 0. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
doc&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlotItemInit_doc,&quot;plotItem(figure[, subplotIdx]) -&gt; instance of the plot or subplot of a figure.\n\
\n\
Use can use this constructor to access any plot or subplot (if more than one plot) of a figure. The subplotIndex \n\
row-wisely addresses the subplots, beginning with 0. \n\
\n\
Parameters \n\
------------ \n\
doc&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8736310f3371417c066220d55e7ff9b"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ad8736310f3371417c066220d55e7ff9b" args="(pyPlotItem_pickPoints_doc,&quot;pickPoints(points [,maxNrPoints]) &#45;&gt; method to let the user pick points on a plot (only if plot supports this) \n\
\n\
This method lets the user select one or multiple points (up to maxNrPoints) at the current plot (if the plot supports this).\n\
\n\
Parameters\n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;\n\
points : {DataObject} \n\
    resulting data object containing the 2D positions of the selected points [2 x nrOfSelectedPoints].\n\
maxNrPoints: {int}, optional \n\
    let the user select up to this number of points [default: infinity]. Selection can be stopped pressing Space or Esc.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlotItem_pickPoints_doc,&quot;pickPoints(points [,maxNrPoints]) -&gt; method to let the user pick points on a plot (only if plot supports this) \n\
\n\
This method lets the user select one or multiple points (up to maxNrPoints) at the current plot (if the plot supports this).\n\
\n\
Parameters\n\
-----------\n\
points : {<a class="el" href="classito_1_1_data_object.html">DataObject</a>} \n\
    resulting data object containing the 2D positions of the selected points [2 x nrOfSelectedPoints].\n\
maxNrPoints: {int}, optional \n\
    let the user select up to this number of points [default: infinity]. Selection can be stopped pressing Space or Esc.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00d7429593a5005f06f3771fd138ca2e"></a><!-- doxytag: member="ito::SetLoadPluginReturnValueMessage" ref="a00d7429593a5005f06f3771fd138ca2e" args="(ito::RetVal &amp;retval, QString &amp;pluginName)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SetLoadPluginReturnValueMessage</b> (<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> &amp;retval, QString &amp;pluginName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac93fa1ac62ef835a87df499d15dab9e6"></a><!-- doxytag: member="ito::SetLoadPluginReturnValueMessage" ref="ac93fa1ac62ef835a87df499d15dab9e6" args="(ito::RetVal &amp;retval, const char *pluginName)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SetLoadPluginReturnValueMessage</b> (<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> &amp;retval, const char *pluginName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f5ce9e5d182f84dd9e0856508c640c5"></a><!-- doxytag: member="ito::SetReturnValueMessage" ref="a0f5ce9e5d182f84dd9e0856508c640c5" args="(ito::RetVal &amp;retval, QString &amp;functionName)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SetReturnValueMessage</b> (<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> &amp;retval, QString &amp;functionName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fc307076dfedfe3d7bd90e2b4cca254"></a><!-- doxytag: member="ito::SetReturnValueMessage" ref="a6fc307076dfedfe3d7bd90e2b4cca254" args="(ito::RetVal &amp;retval, const char *functionName)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>SetReturnValueMessage</b> (<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> &amp;retval, const char *functionName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a90c5cf34449ff20eee13db30581826b2">checkDObjBppComp</a> (const int bpp, const int type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8fe6cab8c18f8e06ec5b141d57ab1389">parseParams</a> (PyObject *args, int length, char **&amp;cargs, char *&amp;cargt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa872946454ba282dd90912cb19cce19b">freeParams</a> (int length, char *&amp;cargt, char **&amp;cargs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a9116ec57a2f79c788a4991e28b4617e8">getParamList</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a1abfad65cf3b738c5d98938d20b9e7fe">getParamListInfo</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib, PyObject *args)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e18e0ad6d36852be18a0a8427b31886"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a9e18e0ad6d36852be18a0a8427b31886" args="(pyPlugInGetExecFuncsInfo_doc,&quot;getExecFuncsInfo([funcName [, detailLevel]]) &#45;&gt; plots a list of available execFuncs or a detailed description to the specified execFunc. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
funcName : {str}, optional \n\
    is the fullname or a part of any execFunc&#45;name which should be displayed. \n\
    If funcName is none or no execFunc matches funcName casesensitiv a list with all suitable execFuncs is given. \n\
detailLevel : {dict}, optional \n\
    if dictionary == 1, function returns an Py_Dictionary with parameters \n\
    Default value is 0.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
None or Dict\n\
    depending on the value of *detailLevel*.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
Generates an online help with all execFuncs for this plugIn or returns a list of available execFuncs.\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlugInGetExecFuncsInfo_doc,&quot;getExecFuncsInfo([funcName [, detailLevel]]) -&gt; plots a list of available execFuncs or a detailed description to the specified execFunc. \n\
\n\
Parameters \n\
----------- \n\
funcName : {str}, optional \n\
    is the fullname or a part of any execFunc-name which should be displayed. \n\
    If funcName is none or no execFunc matches funcName casesensitiv a list with all suitable execFuncs is given. \n\
detailLevel : {dict}, optional \n\
    if dictionary == 1, function returns an Py_Dictionary with parameters \n\
    Default value is 0.\n\
\n\
Returns \n\
------- \n\
None or Dict\n\
    depending on the value of *detailLevel*.\n\
\n\
Notes \n\
----- \n\
Generates an online help with all execFuncs for this plugIn or returns a list of available execFuncs.\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a0ec801556013f5ca4f9060457ec5d912">getExecFuncsInfo</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib, PyObject *args)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a1d523bfed1668a22a48f33721d83768e">getName</a> (_Tp *addInObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0039bf5249d18fd0d228cad6137002e"></a><!-- doxytag: member="ito::execFunc" ref="ac0039bf5249d18fd0d228cad6137002e" args="(ito::AddInBase *aib, PyObject *args, PyObject *kwds)" -->
PyObject *&#160;</td><td class="memItemRight" valign="bottom"><b>execFunc</b> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib, PyObject *args, PyObject *kwds)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a969b92362da351d422ab748c7c850115">getParam</a> (_Tp *addInObj, PyObject *args)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a121177b97c7372af887a6a01bafc0054">setParam</a> (_Tp *addInObj, PyObject *args)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adaa20a610ca18253ef78eb5952c94970"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="adaa20a610ca18253ef78eb5952c94970" args="(pyActuatorInit_doc,&quot;actuator(name[, mandparams, optparams]) &#45;&gt; constructor \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
name : {str} \n\
    is the fullname (case sensitive) of a 'actuator'&#45;plugin as specified in the plugin&#45;window. \n\
initParameters : {variant}, mandatory &amp; optional \n\
    Parameters to pass to the plugin, content and type depend on the specific plugin.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Returns none or a PyDictionary depending on the value of detailLevel.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
This is the constructor for a actuator&#45;type plugins. It initializes an new instance\n\
if the plugin specified by 'name'. The initialisation parameters are parsed and unnamed parameters are used in their \n\
incoming order to fill first mandatory parameters and afterwards optional parameters. Parameters may be passed \n\
with name as well but after the first named parameter no more unnamed parameters are allowed.\n\
See pluginHelp(name) for detail information about the specific initialisation parameters.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorInit_doc,&quot;actuator(name[, mandparams, optparams]) -&gt; constructor \n\
\n\
Parameters \n\
----------- \n\
name : {str} \n\
    is the fullname (case sensitive) of a 'actuator'-plugin as specified in the plugin-window. \n\
initParameters : {variant}, mandatory &amp; optional \n\
    Parameters to pass to the plugin, content and type depend on the specific plugin.\n\
\n\
Returns \n\
------- \n\
Returns none or a PyDictionary depending on the value of detailLevel.\n\
\n\
Notes \n\
----- \n\
\n\
This is the constructor for a actuator-type plugins. It initializes an new instance\n\
if the plugin specified by 'name'. The initialisation parameters are parsed and unnamed parameters are used in their \n\
incoming order to fill first mandatory parameters and afterwards optional parameters. Parameters may be passed \n\
with name as well but after the first named parameter no more unnamed parameters are allowed.\n\
See pluginHelp(name) for detail information about the specific initialisation parameters.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb27abd7125128cd29fd8f161c357e1d"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aeb27abd7125128cd29fd8f161c357e1d" args="(pyActuatorName_doc,&quot;name() &#45;&gt; returns the plugin name\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
name of the Plugin\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorName_doc,&quot;name() -&gt; returns the plugin name\n\
\n\
Returns \n\
------- \n\
name of the Plugin\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96bc5fadd989d8b8746cb22c45d7cfc4"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a96bc5fadd989d8b8746cb22c45d7cfc4" args="(pyActuatorGetParamList_doc,&quot;getParamList() &#45;&gt; returns the list of available parameters of the plugin\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
list of available parameters of the plugin\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorGetParamList_doc,&quot;getParamList() -&gt; returns the list of available parameters of the plugin\n\
\n\
Returns \n\
------- \n\
list of available parameters of the plugin\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f193cf99bfa220ceec1c86362e52add"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a2f193cf99bfa220ceec1c86362e52add" args="(pyActuatorGetParamListInfo_doc,&quot;getParamListInfo([detailLevel]) &#45;&gt; plots informations about plugin parameters. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
detailLevel : {dict}, optional \n\
    if dictionary == 1, function returns an Py_Dictionary with parameters \n\
    Default value is 0.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Returns none or a PyDictionary depending on the value of detailLevel.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
Generates an online help for available parameters and additional informations of the plugin.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorGetParamListInfo_doc,&quot;getParamListInfo([detailLevel]) -&gt; plots informations about plugin parameters. \n\
\n\
Parameters \n\
----------- \n\
detailLevel : {dict}, optional \n\
    if dictionary == 1, function returns an Py_Dictionary with parameters \n\
    Default value is 0.\n\
\n\
Returns \n\
------- \n\
Returns none or a PyDictionary depending on the value of detailLevel.\n\
\n\
Notes \n\
----- \n\
\n\
Generates an online help for available parameters and additional informations of the plugin.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72fe4432376de80019246915f611683a"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a72fe4432376de80019246915f611683a" args="(pyActuatorGetParam_doc,&quot;getParam(name) &#45;&gt; value of the parameter 'name'.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
name : {str???}\n\
    name of the parameter to get value for\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorGetParam_doc,&quot;getParam(name) -&gt; value of the parameter 'name'.\n\
\n\
Parameters \n\
----------- \n\
name : {str???}\n\
    name of the parameter to get value for\n\
\n\
Returns \n\
------- \n\
doctodo\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a354e3f592a82eec62174aacee2c30489"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a354e3f592a82eec62174aacee2c30489" args="(pyActuatorSetParam_doc,&quot;setParam(name, value) &#45;&gt; sets parameter 'name' to the given value.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
name : {str???}\n\
    name of the parameter which value is set\n\
value : {str, int, double, ...}\n\
    value that will be set. The value is checked against the param's parameter definition before involing the setParam method\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorSetParam_doc,&quot;setParam(name, value) -&gt; sets parameter 'name' to the given value.\n\
\n\
Parameters \n\
----------- \n\
name : {str???}\n\
    name of the parameter which value is set\n\
value : {str, int, double, ...}\n\
    value that will be set. The value is checked against the param's parameter definition before involing the setParam method\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a7a72acb4356303cb47ea80e7cc720f"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a1a7a72acb4356303cb47ea80e7cc720f" args="(pyActuatorCalib_doc,&quot;calib(axis[, axis1, ...]) &#45;&gt; starts calibration of given axes (0&#45;based).\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
axis : {axis???}\n\
    axis that should be calibrated\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorCalib_doc,&quot;calib(axis[, axis1, ...]) -&gt; starts calibration of given axes (0-based).\n\
\n\
Parameters \n\
----------- \n\
axis : {axis???}\n\
    axis that should be calibrated\n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e0bcc465113e4fd3740f302beb704c7"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a8e0bcc465113e4fd3740f302beb704c7" args="(pyActuatorSetOrigin_doc,&quot;setOrigin(axis[, axis1, ...]) &#45;&gt; defines the actual position of the given axes to value 0. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
axis : {axis}\n\
    axis for which the origin should be set\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorSetOrigin_doc,&quot;setOrigin(axis[, axis1, ...]) -&gt; defines the actual position of the given axes to value 0. \n\
\n\
Parameters \n\
----------- \n\
axis : {axis}\n\
    axis for which the origin should be set\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c12329c42b2e52ea14bb631eb2828ab"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a6c12329c42b2e52ea14bb631eb2828ab" args="(pyActuatorGetStatus_doc,&quot;getStatus() &#45;&gt; retrieve the actuator status.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorGetStatus_doc,&quot;getStatus() -&gt; retrieve the actuator status.\n\
\n\
Returns \n\
------- \n\
doctodo\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac22bdeac9d6709079774d11353098e72"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ac22bdeac9d6709079774d11353098e72" args="(pyActuatorGetPos_doc,&quot;getPos(axis[, axis1, ...]) &#45;&gt; returns the actual positions of the given axes.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
axis : {axis???}\n\
    axis for which the position should be returned\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorGetPos_doc,&quot;getPos(axis[, axis1, ...]) -&gt; returns the actual positions of the given axes.\n\
\n\
Parameters \n\
----------- \n\
axis : {axis???}\n\
    axis for which the position should be returned\n\
\n\
Returns \n\
------- \n\
doctodo\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2b3d420a37e1415f6d37377610da6e6"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ab2b3d420a37e1415f6d37377610da6e6" args="(PyActuatorPlugin_getType_doc,&quot;getType() &#45;&gt; returns actuator type\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
actuator type\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyActuatorPlugin_getType_doc,&quot;getType() -&gt; returns actuator type\n\
\n\
Returns \n\
------- \n\
actuator type\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb74ed44e443d23dc1b4cf1a52d6f659"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="adb74ed44e443d23dc1b4cf1a52d6f659" args="(PyActuatorPlugin_execFunc_doc,&quot;exec(funcName [, param1, ...]) &#45;&gt; invoke a function 'funcName' within an actuator&#45;plugin.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
funcName : {str} \n\
    The name of the filter\n\
param1 : {variant} \n\
    Further parameters depend on the function itself.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Variable return values.\n\
    The return values depend on the function itself.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
This function is used to invoke a plugIn&#45;Specific execFunc, declared within the corresponding plugin.\n\
The parameters (arguments), output parameters / return values depends on the function\n\
(see plugin.getExecFuncsInfo() or plugin.getExecFuncsInfo(funcName)).&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyActuatorPlugin_execFunc_doc,&quot;exec(funcName [, param1, ...]) -&gt; invoke a function 'funcName' within an actuator-plugin.\n\
\n\
Parameters \n\
----------- \n\
funcName : {str} \n\
    The name of the filter\n\
param1 : {variant} \n\
    Further parameters depend on the function itself.\n\
\n\
Returns \n\
------- \n\
Variable return values.\n\
    The return values depend on the function itself.\n\
\n\
Notes \n\
----- \n\
\n\
This function is used to invoke a plugIn-Specific execFunc, declared within the corresponding plugin.\n\
The parameters (arguments), output parameters / return values depends on the function\n\
(see plugin.getExecFuncsInfo() or plugin.getExecFuncsInfo(funcName)).&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c7726082184ce9733ccfc2a8fc4bbb2"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a3c7726082184ce9733ccfc2a8fc4bbb2" args="(pyActuatorShowConfiguration_doc,&quot;showConfiguration() &#45;&gt; open configuration dialog of the plugin\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorShowConfiguration_doc,&quot;showConfiguration() -&gt; open configuration dialog of the plugin\n\
\n\
Notes \n\
----- \n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55d0dbb12ba16520a952578690017e11"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a55d0dbb12ba16520a952578690017e11" args="(pyActuatorShowToolbox_doc,&quot;showToolbox() &#45;&gt; open toolbox of the plugin\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorShowToolbox_doc,&quot;showToolbox() -&gt; open toolbox of the plugin\n\
\n\
Notes \n\
----- \n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59689bacc1a62701b54dcdff67111fde"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a59689bacc1a62701b54dcdff67111fde" args="(pyActuatorHideToolbox_doc,&quot;hideToolbox() &#45;&gt; hides toolbox of the plugin\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorHideToolbox_doc,&quot;hideToolbox() -&gt; hides toolbox of the plugin\n\
\n\
Notes \n\
----- \n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#afb4b7505de2474537f0ff7a5e678cf94">parsePosParams</a> (PyObject *args, char **&amp;cargs, char *&amp;cargt, QVector&lt; int &gt; &amp;axisVec, QVector&lt; double &gt; &amp;posVec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2b1dfd1b6fab85a4fb03c80c68f578d"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aa2b1dfd1b6fab85a4fb03c80c68f578d" args="(pyActuatorSetPosAbs_doc,&quot;setPosAbs(axis0, pos0 [, axis1, pos1, ...]) &#45;&gt; moves axis to given absolute value (in mm).\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
axis : {axis???}, optional \n\
    axis that should be moved absolute\n\
pos : {???} \n\
    new position for axis\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorSetPosAbs_doc,&quot;setPosAbs(axis0, pos0 [, axis1, pos1, ...]) -&gt; moves axis to given absolute value (in mm).\n\
\n\
Parameters \n\
----------- \n\
axis : {axis???}, optional \n\
    axis that should be moved absolute\n\
pos : {???} \n\
    new position for axis\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8623e7f577492acc1b6d0e038c814219"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a8623e7f577492acc1b6d0e038c814219" args="(pyActuatorSetPosRel_doc,&quot;setPosRel(axis, pos[, axis1, pos1, ...]) &#45;&gt; relatively moves given axes by the given distances [in mm].\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
axis : {axis???} \n\
    axis that should be moved relative \n\
pos : {???}\n\
    position increment/decrement for axis\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorSetPosRel_doc,&quot;setPosRel(axis, pos[, axis1, pos1, ...]) -&gt; relatively moves given axes by the given distances [in mm].\n\
\n\
Parameters \n\
----------- \n\
axis : {axis???} \n\
    axis that should be moved relative \n\
pos : {???}\n\
    position increment/decrement for axis\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a377b2877032a7a71694293822a5d29e9"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a377b2877032a7a71694293822a5d29e9" args="(pyDataIOInit_doc,&quot;dataIO(name[, mandparams, optparams]) &#45;&gt; constructor \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
name : {str} \n\
    is the fullname (case sensitive) of a 'dataIO'&#45;plugin as specified in the plugin&#45;window. \n\
    initParameters : {variant}, mandatory &amp; optional \n\
    Parameters to pass to the plugin, content and type depend on the specific plugin.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Returns none or a PyDictionary depending on the value of detailLevel.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
This is the constructor for a dataIO&#45;type plugins. It initializes an new instance\n\
if the plugin specified by 'name'. The initialisation parameters are parsed and unnamed parameters are used in their \n\
incoming order to fill first mandatory parameters and afterwards optional parameters. Parameters may be passed \n\
with name as well but after the first named parameter no more unnamed parameters are allowed.\n\
See pluginHelp(name) for detail information about the specific initialisation parameters.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataIOInit_doc,&quot;dataIO(name[, mandparams, optparams]) -&gt; constructor \n\
\n\
Parameters \n\
----------- \n\
name : {str} \n\
    is the fullname (case sensitive) of a 'dataIO'-plugin as specified in the plugin-window. \n\
    initParameters : {variant}, mandatory &amp; optional \n\
    Parameters to pass to the plugin, content and type depend on the specific plugin.\n\
\n\
Returns \n\
------- \n\
Returns none or a PyDictionary depending on the value of detailLevel.\n\
\n\
Notes \n\
----- \n\
\n\
This is the constructor for a dataIO-type plugins. It initializes an new instance\n\
if the plugin specified by 'name'. The initialisation parameters are parsed and unnamed parameters are used in their \n\
incoming order to fill first mandatory parameters and afterwards optional parameters. Parameters may be passed \n\
with name as well but after the first named parameter no more unnamed parameters are allowed.\n\
See pluginHelp(name) for detail information about the specific initialisation parameters.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a9760d9a6faa1c9b855f95e80d55c36"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a3a9760d9a6faa1c9b855f95e80d55c36" args="(PyDataIOPlugin_name_doc,&quot;name() &#45;&gt; returns name of plugin.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Name of the Plugin : {str}\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_name_doc,&quot;name() -&gt; returns name of plugin.\n\
\n\
Returns \n\
------- \n\
Name of the Plugin : {str}\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a697a7805f5b45b27c6dba7b257f922"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a5a697a7805f5b45b27c6dba7b257f922" args="(PyDataIOPlugin_getParamList_doc,&quot;getParamList() &#45;&gt; returns list of possible parameters.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
List of possible Parameters\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_getParamList_doc,&quot;getParamList() -&gt; returns list of possible parameters.\n\
\n\
Returns \n\
------- \n\
List of possible Parameters\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d54651d9f096d09ea6941f3673466fc"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a4d54651d9f096d09ea6941f3673466fc" args="(PyDataIOPlugin_getParamListInfo_doc,&quot;getParamListInfo([detailLevel]) &#45;&gt; plots informations about plugin parameters. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
detailLevel : {dict}, optional \n\
    if dictionary == 1, function returns an Py_Dictionary with parameters \n\
    Default value is 0.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Returns none or a PyDictionary depending on the value of detailLevel.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
Generates an online help for available parameters and additional informations of the plugin.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_getParamListInfo_doc,&quot;getParamListInfo([detailLevel]) -&gt; plots informations about plugin parameters. \n\
\n\
Parameters \n\
----------- \n\
detailLevel : {dict}, optional \n\
    if dictionary == 1, function returns an Py_Dictionary with parameters \n\
    Default value is 0.\n\
\n\
Returns \n\
------- \n\
Returns none or a PyDictionary depending on the value of detailLevel.\n\
\n\
Notes \n\
----- \n\
\n\
Generates an online help for available parameters and additional informations of the plugin.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a937703fc7031d222a14168c0d8dcfa32"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a937703fc7031d222a14168c0d8dcfa32" args="(PyDataIOPlugin_getParam_doc,&quot;getParam(name) &#45;&gt; returns the value of the given parameter.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
name : {str???}\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Value of the given parameter\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_getParam_doc,&quot;getParam(name) -&gt; returns the value of the given parameter.\n\
\n\
Parameters \n\
----------- \n\
name : {str???}\n\
\n\
Returns \n\
------- \n\
Value of the given parameter\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afea93fc0bde9d081eb73f488e70c1142"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="afea93fc0bde9d081eb73f488e70c1142" args="(PyDataIOPlugin_setParam_doc,&quot;setParam(name,value) &#45;&gt; sets value of parameter, given by name.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
name : {str???}\n\
value : {str, int, double, ...}\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_setParam_doc,&quot;setParam(name,value) -&gt; sets value of parameter, given by name.\n\
\n\
Parameters \n\
----------- \n\
name : {str???}\n\
value : {str, int, double, ...}\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10dcf3759a5d5488eb821b882b8a31c6"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a10dcf3759a5d5488eb821b882b8a31c6" args="(PyDataIOPlugin_startDevice_doc,&quot;startDevice([count=1]) &#45;&gt; starts the given dataIO&#45;plugin. \n\
If you call startDevice multiple times, the device is only started at the first call, the next calls \n\
only increment a internal counter. This is necessary, since every connected live image needs to start the device \n\
without knownledge about any previous start. A call to stopDevice decrements this counter and closes the hardware device \n\
if that counter drops to 0 again. No acquisition is possible, if the device has not been started, hence the counter is 0. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
count : {unsigned integer}, optional \n\
    default = 1\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
if count &gt; 1, startDevice is executed 'count' times, in order to increment the grabber internal start counter. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_startDevice_doc,&quot;startDevice([count=1]) -&gt; starts the given dataIO-plugin. \n\
If you call startDevice multiple times, the device is only started at the first call, the next calls \n\
only increment a internal counter. This is necessary, since every connected live image needs to start the device \n\
without knownledge about any previous start. A call to stopDevice decrements this counter and closes the hardware device \n\
if that counter drops to 0 again. No acquisition is possible, if the device has not been started, hence the counter is 0. \n\
\n\
Parameters \n\
----------- \n\
count : {unsigned integer}, optional \n\
    default = 1\n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
if count &gt; 1, startDevice is executed 'count' times, in order to increment the grabber internal start counter. \n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afeefee4769e8dd35f487f7b2449e46f4"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="afeefee4769e8dd35f487f7b2449e46f4" args="(PyDataIOPlugin_stopDevice_doc,&quot;stopDevice([count=1]) &#45;&gt; stops the given dataIO&#45;plugin. \n\
Usually no acquisition is possible, if the device is not started. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
count : {Integer &gt; 0}, optional\n\
    default = 1\n\
    if count &gt; 1, stopDevice is executed 'count' times, in order to decrement the grabber internal start counter. \n\
    You can also use &#45;1 as count argument, then stopDevice is repeated until the internal start counter is 0. The number of effective counts is then returned \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
None or the number of cycles that have been necessary to finally decrement the grabber's internal start counter to 0 (only if count==&#45;1)\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_stopDevice_doc,&quot;stopDevice([count=1]) -&gt; stops the given dataIO-plugin. \n\
Usually no acquisition is possible, if the device is not started. \n\
\n\
Parameters \n\
----------- \n\
count : {Integer &gt; 0}, optional\n\
    default = 1\n\
    if count &gt; 1, stopDevice is executed 'count' times, in order to decrement the grabber internal start counter. \n\
    You can also use -1 as count argument, then stopDevice is repeated until the internal start counter is 0. The number of effective counts is then returned \n\
\n\
Returns \n\
----------- \n\
None or the number of cycles that have been necessary to finally decrement the grabber's internal start counter to 0 (only if count==-1)\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a754f1b42fe7cb24d455af558d3e415b0"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a754f1b42fe7cb24d455af558d3e415b0" args="(PyDataIOPlugin_acquire_doc,&quot;acquire(trigger=dataIO.TRIGGER_SOFTWARE) &#45;&gt; triggers the camera acquisition \n\
Use this command to start the image acquisition depending on the trigger parameter. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
trigger : {Integer}, optional\n\
    default = 0, dataIO.TRIGGER_SOFTWARE\n\
    In case of dataIO.TRIGGER_SOFTWARE (0) the acquisition is immediately started after this command. \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_acquire_doc,&quot;acquire(trigger=dataIO.TRIGGER_SOFTWARE) -&gt; triggers the camera acquisition \n\
Use this command to start the image acquisition depending on the trigger parameter. \n\
\n\
Parameters \n\
----------- \n\
trigger : {Integer}, optional\n\
    default = 0, dataIO.TRIGGER_SOFTWARE\n\
    In case of dataIO.TRIGGER_SOFTWARE (0) the acquisition is immediately started after this command. \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a863e95de5894bee9f1065a5a7f13cc98"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a863e95de5894bee9f1065a5a7f13cc98" args="(PyDataIOPlugin_getVal_doc,&quot;getVal(buffer=dataObject|byteArray|bytes [,length=maxlength]) &#45;&gt; returns shallow copy of internal camera image if dataObject&#45;buffer is provided. Else values from plugin are copied to given byte or byte&#45;array buffer. \n\
\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
doctodo \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
shallow copy of internal camera image\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
Cameras, Grabber: \n\
&#45; buffer (dataObject), no length value: The image in dataObject is only a shallow copy of the camera internal memory. Therefore this content \n\
    may change if a new image has been acquired by the camera. Therefore consider to make a deep copy of this image or use the method copyVal. \n\
\n\
further IO&#45;devices: \n\
&#45; buffer (allocated byteArray, bytes...) and optional a length with the maximum number of characters which should be requested by the plugin. \n\
If length is not provided it is set to the length of the given buffer. Finally the number of effectively set characters is returned.\n\
\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_getVal_doc,&quot;getVal(buffer=dataObject|byteArray|bytes [,length=maxlength]) -&gt; returns shallow copy of internal camera image if dataObject-buffer is provided. Else values from plugin are copied to given byte or byte-array buffer. \n\
\n\
\n\
Parameters \n\
----------- \n\
doctodo \n\
\n\
Returns \n\
------- \n\
shallow copy of internal camera image\n\
\n\
Notes \n\
----- \n\
Cameras, Grabber: \n\
- buffer (dataObject), no length value: The image in dataObject is only a shallow copy of the camera internal memory. Therefore this content \n\
    may change if a new image has been acquired by the camera. Therefore consider to make a deep copy of this image or use the method copyVal. \n\
\n\
further IO-devices: \n\
- buffer (allocated byteArray, bytes...) and optional a length with the maximum number of characters which should be requested by the plugin. \n\
If length is not provided it is set to the length of the given buffer. Finally the number of effectively set characters is returned.\n\
\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55864f5674f1cb77cb380fddfdb5f23a"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a55864f5674f1cb77cb380fddfdb5f23a" args="(PyDataIOPlugin_copyVal_doc,&quot;copyVal(dataObject) &#45;&gt; gets deep copy of data of this plugin, stored in the given data object. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
dataObject : {doctodo}\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
The object is not changed / adepted to the grabber and must be allocated properly before copyVal is called\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_copyVal_doc,&quot;copyVal(dataObject) -&gt; gets deep copy of data of this plugin, stored in the given data object. \n\
\n\
Parameters \n\
----------- \n\
dataObject : {doctodo}\n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
The object is not changed / adepted to the grabber and must be allocated properly before copyVal is called\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d41fe48691a2d081c0556238e5f9872"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a7d41fe48691a2d081c0556238e5f9872" args="(PyDataIOPlugin_setVal_doc,&quot;setVal(dataObject) &#45;&gt; transfers given dataObject to dataIO&#45;plugin.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
dataObject : {dataObject???}\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_setVal_doc,&quot;setVal(dataObject) -&gt; transfers given dataObject to dataIO-plugin.\n\
\n\
Parameters \n\
----------- \n\
dataObject : {dataObject???}\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ad331d73836efbe9ceb2d8c47656224"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a9ad331d73836efbe9ceb2d8c47656224" args="(PyDataIOPlugin_enableAutoGrabbing_doc,&quot;enableAutoGrabbing() &#45;&gt; enables auto grabbing for the grabber (camera...), \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
such that live images will continuously get new data. \n\
[Recommended if the measurement routine does not need any camera image at the moment.]\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_enableAutoGrabbing_doc,&quot;enableAutoGrabbing() -&gt; enables auto grabbing for the grabber (camera...), \n\
\n\
Notes \n\
----- \n\
such that live images will continuously get new data. \n\
[Recommended if the measurement routine does not need any camera image at the moment.]\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a236def206378091956e461a5fcb13217"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a236def206378091956e461a5fcb13217" args="(PyDataIOPlugin_disableAutoGrabbing_doc,&quot;disableAutoGrabbing() &#45;&gt; Disables auto grabbing for the grabber (camera...), \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
such that live images only will be updated if a new image is manually grabbed. \n\
[Recommended if the measurement routine requires camera images by itself.]\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_disableAutoGrabbing_doc,&quot;disableAutoGrabbing() -&gt; Disables auto grabbing for the grabber (camera...), \n\
\n\
Notes \n\
----- \n\
such that live images only will be updated if a new image is manually grabbed. \n\
[Recommended if the measurement routine requires camera images by itself.]\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a241fe33f504d7d9f2723fbe3ee837f2a"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a241fe33f504d7d9f2723fbe3ee837f2a" args="(PyDataIOPlugin_setAutoGrabbing_doc,&quot;setAutoGrabbing(on) &#45;&gt; Sets auto grabbing of the grabber device on or off\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
on : {bool}\n\
    * TRUE = on\n\
    * FALSE = off\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
such that live images only will be updated if a new image is manually grabbed (on).\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_setAutoGrabbing_doc,&quot;setAutoGrabbing(on) -&gt; Sets auto grabbing of the grabber device on or off\n\
\n\
Parameters \n\
----------- \n\
on : {bool}\n\
    * TRUE = on\n\
    * FALSE = off\n\
\n\
Notes \n\
----- \n\
such that live images only will be updated if a new image is manually grabbed (on).\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fb61d7a210c851736a024a1c1246112"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a7fb61d7a210c851736a024a1c1246112" args="(PyDataIOPlugin_getAutoGrabbing_doc,&quot;getAutoGrabbing() &#45;&gt; returns the status of the auto grabbing flag. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
auto grabbing flag : {bool}\n\
    * false = auto grabbing off \n\
    * true = auto grabbing on. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
See methods enableAutoGrabbing() or disableAutoGrabbing().\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
enableAutoGrabbing()\n\
disableAutoGrabbing()\n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_getAutoGrabbing_doc,&quot;getAutoGrabbing() -&gt; returns the status of the auto grabbing flag. \n\
\n\
Returns \n\
------- \n\
auto grabbing flag : {bool}\n\
    * false = auto grabbing off \n\
    * true = auto grabbing on. \n\
\n\
Notes \n\
----- \n\
See methods enableAutoGrabbing() or disableAutoGrabbing().\n\
\n\
See Also \n\
--------- \n\
enableAutoGrabbing()\n\
disableAutoGrabbing()\n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a888a6b42b8b5f2c6f387ac55e8319fd9"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a888a6b42b8b5f2c6f387ac55e8319fd9" args="(PyDataIOPlugin_getType_doc,&quot;getType() &#45;&gt; returns dataIO type\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
dataIO type\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_getType_doc,&quot;getType() -&gt; returns dataIO type\n\
\n\
Returns \n\
------- \n\
dataIO type\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adab1b1449f492f260be58f844b0d51a6"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="adab1b1449f492f260be58f844b0d51a6" args="(PyDataIOPlugin_execFunc_doc,&quot;exec(funcName [, param1, ...]) &#45;&gt; invoke a function 'funcName' within an dataIO&#45;plugin.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
funcName : {str} \n\
    The name of the filter\n\
paramN : {variant} \n\
    Further parameters depend on the function itself.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Variable return values.\n\
    The return values depend on the function itself.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
This function is used to invoke a plugIn&#45;Specific execFunc, declared within the corresponding plugin.\n\
The parameters (arguments), output parameters / return values depends on the function\n\
(see plugin.getExecFuncsInfo() or plugin.getExecFuncsInfo(funcName)).&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_execFunc_doc,&quot;exec(funcName [, param1, ...]) -&gt; invoke a function 'funcName' within an dataIO-plugin.\n\
\n\
Parameters \n\
----------- \n\
funcName : {str} \n\
    The name of the filter\n\
paramN : {variant} \n\
    Further parameters depend on the function itself.\n\
\n\
Returns \n\
------- \n\
Variable return values.\n\
    The return values depend on the function itself.\n\
\n\
Notes \n\
----- \n\
\n\
This function is used to invoke a plugIn-Specific execFunc, declared within the corresponding plugin.\n\
The parameters (arguments), output parameters / return values depends on the function\n\
(see plugin.getExecFuncsInfo() or plugin.getExecFuncsInfo(funcName)).&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73daadde88274bfbf4101b8714731cf4"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a73daadde88274bfbf4101b8714731cf4" args="(pyDataIOShowConfiguration_doc,&quot;showConfiguration() &#45;&gt; open configuration dialog of the plugin\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataIOShowConfiguration_doc,&quot;showConfiguration() -&gt; open configuration dialog of the plugin\n\
\n\
Notes \n\
----- \n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2b3818c3638b5c2e2160d567d8418a3"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="af2b3818c3638b5c2e2160d567d8418a3" args="(pyDataIOShowToolbox_doc,&quot;showToolbox() &#45;&gt; open toolbox of the plugin\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataIOShowToolbox_doc,&quot;showToolbox() -&gt; open toolbox of the plugin\n\
\n\
Notes \n\
----- \n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4dea7fff5fc193c401176416fca6bc8d"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a4dea7fff5fc193c401176416fca6bc8d" args="(pyDataIOHideToolbox_doc,&quot;hideToolbox() &#45;&gt; hides toolbox of the plugin\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataIOHideToolbox_doc,&quot;hideToolbox() -&gt; hides toolbox of the plugin\n\
\n\
Notes \n\
----- \n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac49a7a56e7d8137da818c36248f05140"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ac49a7a56e7d8137da818c36248f05140" args="(PyAlgoPlugin_getParamList_doc,&quot;getParamList() &#45;&gt; returns list of available parameters.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyAlgoPlugin_getParamList_doc,&quot;getParamList() -&gt; returns list of available parameters.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4733bebd5e9def4f36e4d6b761309096"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a4733bebd5e9def4f36e4d6b761309096" args="(PyAlgoPlugin_getParamListInfo_doc,&quot;getParamListInfo([detailLevel]) &#45;&gt; plots informations about plugin parameters. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
detailLevel : {dict}, optional \n\
    if dictionary == 1, function returns an Py_Dictionary with parameters \n\
    Default value is 0.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
Returns none or a PyDictionary depending on the value of detailLevel.\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
Generates an online help for available parameters and additional informations of the plugin.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyAlgoPlugin_getParamListInfo_doc,&quot;getParamListInfo([detailLevel]) -&gt; plots informations about plugin parameters. \n\
\n\
Parameters \n\
----------- \n\
detailLevel : {dict}, optional \n\
    if dictionary == 1, function returns an Py_Dictionary with parameters \n\
    Default value is 0.\n\
\n\
Returns \n\
------- \n\
Returns none or a PyDictionary depending on the value of detailLevel.\n\
\n\
Notes \n\
----- \n\
\n\
Generates an online help for available parameters and additional informations of the plugin.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9393e8a57c60f2cd281a41b9099ff2b"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ac9393e8a57c60f2cd281a41b9099ff2b" args="(PyAlgoPlugin_getType_doc,&quot;getType() &#45;&gt; returns AlgoPlugin type&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyAlgoPlugin_getType_doc,&quot;getType() -&gt; returns AlgoPlugin type&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87012b03942d7c1576593908602b50f4"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a87012b03942d7c1576593908602b50f4" args="(pyRegion_doc,&quot;region([x, y, w, h [,type=region.RECTANGLE]]) &#45;&gt; creates a rectangular or elliptical region. \n\
\n\
This class is a wrapper for the class QRegion of Qt. It provides possibilities for creating pixel&#45;based regions. Furtherone you can \n\
calculate new regions based on the intersection, union or subtraction of other regions. Based on the region it is possible to get \n\
a uint8 masked dataObject, where every point within the entire region has the value 255 and all other values 0 \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
x : {int} \n\
    x&#45;coordinate of the reference corner of the region \n\
y : {int} \n\
    y&#45;coordinate of the reference corner of the region \n\
w : {int} \n\
    width of the region \n\
h : {int} \n\
    height of the region \n\
type : {int}, optional \n\
    region.RECTANGLE creates a rectangular region (default). region.ELLIPSE creates an elliptical region, which is placed inside of the \n\
    given boundaries. \n\
\n\
Notes\n\
&#45;&#45;&#45;&#45;&#45; \n\
It is also possible to create an empty instance of the region.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegion_doc,&quot;region([x, y, w, h [,type=region.RECTANGLE]]) -&gt; creates a rectangular or elliptical region. \n\
\n\
This class is a wrapper for the class QRegion of Qt. It provides possibilities for creating pixel-based regions. Furtherone you can \n\
calculate new regions based on the intersection, union or subtraction of other regions. Based on the region it is possible to get \n\
a uint8 masked dataObject, where every point within the entire region has the value 255 and all other values 0 \n\
\n\
Parameters \n\
----------- \n\
x : {int} \n\
    x-coordinate of the reference corner of the region \n\
y : {int} \n\
    y-coordinate of the reference corner of the region \n\
w : {int} \n\
    width of the region \n\
h : {int} \n\
    height of the region \n\
type : {int}, optional \n\
    region.RECTANGLE creates a rectangular region (default). region.ELLIPSE creates an elliptical region, which is placed inside of the \n\
    given boundaries. \n\
\n\
Notes\n\
----- \n\
It is also possible to create an empty instance of the region.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96dfea3db9a15ff33434a8f27c115dd2"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a96dfea3db9a15ff33434a8f27c115dd2" args="(pyRegionContains_doc,&quot;contains(x,y[,w,h]) &#45;&gt; returns True if the given point or rectangle is fully contained in this region, otherwise returns False. \n\
\n\
This method returns True, if the given point (x,y) or region (x,y,w,h) is fully contained in this region. Otherwise returns False.\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
x : {int} \n\
    x&#45;coordinate of one corner of the new rectangular region \n\
y : {int} \n\
    y&#45;coordinate of one corner of the new rectangular region \n\
w : {int}, optional \n\
    width of the new rectangular region. If not given, point is assumed. \n\
h : {int}, optional \n\
    height of the new rectangular region. If not given, point is assumed. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
True or False&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionContains_doc,&quot;contains(x,y[,w,h]) -&gt; returns True if the given point or rectangle is fully contained in this region, otherwise returns False. \n\
\n\
This method returns True, if the given point (x,y) or region (x,y,w,h) is fully contained in this region. Otherwise returns False.\n\
Parameters \n\
----------- \n\
x : {int} \n\
    x-coordinate of one corner of the new rectangular region \n\
y : {int} \n\
    y-coordinate of one corner of the new rectangular region \n\
w : {int}, optional \n\
    width of the new rectangular region. If not given, point is assumed. \n\
h : {int}, optional \n\
    height of the new rectangular region. If not given, point is assumed. \n\
\n\
Returns \n\
------- \n\
True or False&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45e7d18be28e5021c13e7f3b5f7476c4"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a45e7d18be28e5021c13e7f3b5f7476c4" args="(pyRegionIntersected_doc,&quot;intersected(x,y,w,h | region) &#45;&gt; returns a region which is the intersection of a new region and this region. \n\
\n\
This method returns a new region, which is the intersection of this region and the given, new region. The intersection only contains points that are \n\
part of both given regions. \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
x : {int} \n\
    x&#45;coordinate of one corner of the new rectangular region \n\
y : {int} \n\
    y&#45;coordinate of one corner of the new rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region&#45;object} \n\
    another instance of region \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
new intersected region. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionIntersected_doc,&quot;intersected(x,y,w,h | region) -&gt; returns a region which is the intersection of a new region and this region. \n\
\n\
This method returns a new region, which is the intersection of this region and the given, new region. The intersection only contains points that are \n\
part of both given regions. \n\
Parameters \n\
----------- \n\
x : {int} \n\
    x-coordinate of one corner of the new rectangular region \n\
y : {int} \n\
    y-coordinate of one corner of the new rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region-object} \n\
    another instance of region \n\
\n\
Returns \n\
------- \n\
new intersected region. \n\
\n\
Notes \n\
----- \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70e48f62938499cc5967aaa832aaa640"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a70e48f62938499cc5967aaa832aaa640" args="(pyRegionIntersects_doc,&quot;intersects(x,y,w,h | region) &#45;&gt; returns True if this region intersects with the given region, else False. \n\
\n\
This method returns True, if this region intersects with the new region, otherwise returns False. \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
x : {int} \n\
    x&#45;coordinate of one corner of the new rectangular region \n\
y : {int} \n\
    y&#45;coordinate of one corner of the new rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region&#45;object} \n\
    another instance of region \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
True or False \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionIntersects_doc,&quot;intersects(x,y,w,h | region) -&gt; returns True if this region intersects with the given region, else False. \n\
\n\
This method returns True, if this region intersects with the new region, otherwise returns False. \n\
Parameters \n\
----------- \n\
x : {int} \n\
    x-coordinate of one corner of the new rectangular region \n\
y : {int} \n\
    y-coordinate of one corner of the new rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region-object} \n\
    another instance of region \n\
\n\
Returns \n\
------- \n\
True or False \n\
\n\
Notes \n\
----- \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85f6a07cf252a06adc4402d2bc33759f"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a85f6a07cf252a06adc4402d2bc33759f" args="(pyRegionSubtracted_doc,&quot;subtracted(x,y,w,h | region) &#45;&gt; returns a region which is the new region subtracted from this region. \n\
\n\
This method returns a new region, which is the given, new region subtracted from this region. \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
x : {int} \n\
    x&#45;coordinate of one corner of the new rectangular region \n\
y : {int} \n\
    y&#45;coordinate of one corner of the new rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region&#45;object} \n\
    another instance of region \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
new subtracted region. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionSubtracted_doc,&quot;subtracted(x,y,w,h | region) -&gt; returns a region which is the new region subtracted from this region. \n\
\n\
This method returns a new region, which is the given, new region subtracted from this region. \n\
Parameters \n\
----------- \n\
x : {int} \n\
    x-coordinate of one corner of the new rectangular region \n\
y : {int} \n\
    y-coordinate of one corner of the new rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region-object} \n\
    another instance of region \n\
\n\
Returns \n\
------- \n\
new subtracted region. \n\
\n\
Notes \n\
----- \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4cfa1de885c6814a2f629554c196875"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ad4cfa1de885c6814a2f629554c196875" args="(pyRegionTranslate_doc,&quot;translate(x,y) &#45;&gt; translateds this region by the given coordinates. \n\
\n\
This method translates this region by the given coordinates. \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
x : {int} \n\
    translation in x&#45;direction \n\
y : {int} \n\
    translation in y&#45;direction \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
translated&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionTranslate_doc,&quot;translate(x,y) -&gt; translateds this region by the given coordinates. \n\
\n\
This method translates this region by the given coordinates. \n\
Parameters \n\
----------- \n\
x : {int} \n\
    translation in x-direction \n\
y : {int} \n\
    translation in y-direction \n\
\n\
See Also \n\
--------- \n\
translated&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2598f46c67cedf95b82f75c2ddbe1fbf"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a2598f46c67cedf95b82f75c2ddbe1fbf" args="(pyRegionTranslated_doc,&quot;translated(x,y) &#45;&gt; returns a region, translated by the given coordinates. \n\
\n\
This method returns a new region, which is translated by the given coordinates in x and y direction. \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
x : {int} \n\
    translation in x&#45;direction \n\
y : {int} \n\
    translation in y&#45;direction \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
new translated region.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
translate&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionTranslated_doc,&quot;translated(x,y) -&gt; returns a region, translated by the given coordinates. \n\
\n\
This method returns a new region, which is translated by the given coordinates in x and y direction. \n\
Parameters \n\
----------- \n\
x : {int} \n\
    translation in x-direction \n\
y : {int} \n\
    translation in y-direction \n\
\n\
Returns \n\
------- \n\
new translated region.\n\
\n\
See Also \n\
--------- \n\
translate&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ef00615e5fb483ba0eb43ec8984d697"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a9ef00615e5fb483ba0eb43ec8984d697" args="(pyRegionUnited_doc,&quot;united(x,y,w,h | region) &#45;&gt; returns a region which is the union of the given region with this region. \n\
\n\
This method returns a new region, which is the union of this region with the region given as parameters. Union means that all values, that\n\
are contained in any of both regions is part of the overall region, too. \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
x : {int} \n\
    x&#45;coordinate of one corner of a rectangular region \n\
y : {int} \n\
    y&#45;coordinate of one corner of a rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region&#45;object} \n\
    another instance of region \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
new united region. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionUnited_doc,&quot;united(x,y,w,h | region) -&gt; returns a region which is the union of the given region with this region. \n\
\n\
This method returns a new region, which is the union of this region with the region given as parameters. Union means that all values, that\n\
are contained in any of both regions is part of the overall region, too. \n\
Parameters \n\
----------- \n\
x : {int} \n\
    x-coordinate of one corner of a rectangular region \n\
y : {int} \n\
    y-coordinate of one corner of a rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region-object} \n\
    another instance of region \n\
\n\
Returns \n\
------- \n\
new united region. \n\
\n\
Notes \n\
----- \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c9509489c3f894f6f979c1e9a6bdbfb"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a4c9509489c3f894f6f979c1e9a6bdbfb" args="(pyRegionXored_doc,&quot;xored(x,y,w,h | region) &#45;&gt; returns a region which is an xor combination of the given region with this region. \n\
\n\
This method returns a new region, which is defined by an xor&#45;combination of this region with the region given as parameters. \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
x : {int} \n\
    x&#45;coordinate of one corner of a rectangular region \n\
y : {int} \n\
    y&#45;coordinate of one corner of a rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region&#45;object} \n\
    another instance of region \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
new xored region. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionXored_doc,&quot;xored(x,y,w,h | region) -&gt; returns a region which is an xor combination of the given region with this region. \n\
\n\
This method returns a new region, which is defined by an xor-combination of this region with the region given as parameters. \n\
Parameters \n\
----------- \n\
x : {int} \n\
    x-coordinate of one corner of a rectangular region \n\
y : {int} \n\
    y-coordinate of one corner of a rectangular region \n\
w : {int} \n\
    width of the new rectangular region \n\
h : {int} \n\
    height of the new rectangular region \n\
region : {region-object} \n\
    another instance of region \n\
\n\
Returns \n\
------- \n\
new xored region. \n\
\n\
Notes \n\
----- \n\
You can either use the parameters 'x','y','w','h' OR 'region'.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84b450ebde4123fda504dfc6b16769ca"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a84b450ebde4123fda504dfc6b16769ca" args="(pyRegionCreateMask_doc,&quot;createMask() &#45;&gt; creates mask data object based on this region. \n\
\n\
Returns a uint8&#45;dataObject whose size corresponds to the width and height of the bounding rectangle. \n\
All pixels contained in the region have a value of 255 while the rest is set to 0. The offset value of \n\
the dataObject is set such that it fits to the real position of the region, since the first element \n\
in the dataObject corresponds to the left upper corner of the bounding rectangle.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionCreateMask_doc,&quot;createMask() -&gt; creates mask data object based on this region. \n\
\n\
Returns a uint8-dataObject whose size corresponds to the width and height of the bounding rectangle. \n\
All pixels contained in the region have a value of 255 while the rest is set to 0. The offset value of \n\
the dataObject is set such that it fits to the real position of the region, since the first element \n\
in the dataObject corresponds to the left upper corner of the bounding rectangle.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad044eb205d1937d1f36325ecb0af60aa"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ad044eb205d1937d1f36325ecb0af60aa" args="(PyUiItemInit_doc,&quot;&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemInit_doc,&quot;&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a808bd9b029c0f427d8d271a74417a34d"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a808bd9b029c0f427d8d271a74417a34d" args="(PyUiItemCall_doc,&quot;call(slotOrPublicMethod [,argument1, argument2, ...]) &#45;&gt; calls any public slot of this widget or any accessible public method.  \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
slotOrPublicMethod : {str} \n\
    name of the slot or method \n\
arguments : {various types}, optional\n\
    Here you must indicate every argument, that the definition of the slot indicates. The type must be convertable into the \n\
    requested C++ based argument type.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
Use this method, to invoke any public slot or wrapped method of the underlying *uiItem*. For instance, see the Qt&#45;help for slots of \n\
the widget of element you are wrapping by this instance of *uiItem*. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemCall_doc,&quot;call(slotOrPublicMethod [,argument1, argument2, ...]) -&gt; calls any public slot of this widget or any accessible public method.  \n\
\n\
Parameters \n\
----------- \n\
slotOrPublicMethod : {str} \n\
    name of the slot or method \n\
arguments : {various types}, optional\n\
    Here you must indicate every argument, that the definition of the slot indicates. The type must be convertable into the \n\
    requested C++ based argument type.\n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
Use this method, to invoke any public slot or wrapped method of the underlying *uiItem*. For instance, see the Qt-help for slots of \n\
the widget of element you are wrapping by this instance of *uiItem*. \n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf6dd35b9f99a79ffb9e23422cd687dc"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="acf6dd35b9f99a79ffb9e23422cd687dc" args="(PyUiItemConnect_doc,&quot;connect(signalSignature, callableMethod) &#45;&gt; connects the signal of the widget with the given callable python method \n\
\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
signalSignature : {str} \n\
    This must be the valid signature, known from the Qt&#45;method *connect* (e.g. 'clicked(bool)') \n\
callableMethod : {python method or function} \n\
    valid method or function that is called if the signal is emitted. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
This instance of *uiItem* wraps a widget, that is defined by a C++&#45;class, that is finally derived from *QWidget*. See Qt&#45;help for more information \n\
about the capabilities of every specific widget. Every widget can send various signals. Use this method to connect any signal to any \n\
callable python method (bounded or unbounded). This method must have the same number of arguments than the signal and the types of the \n\
signal definition must be convertable into a python object. \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
disconnect, invokeKeyboardInterrupt&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemConnect_doc,&quot;connect(signalSignature, callableMethod) -&gt; connects the signal of the widget with the given callable python method \n\
\n\
\n\
Parameters \n\
----------- \n\
signalSignature : {str} \n\
    This must be the valid signature, known from the Qt-method *connect* (e.g. 'clicked(bool)') \n\
callableMethod : {python method or function} \n\
    valid method or function that is called if the signal is emitted. \n\
\n\
Notes \n\
----- \n\
This instance of *uiItem* wraps a widget, that is defined by a C++-class, that is finally derived from *QWidget*. See Qt-help for more information \n\
about the capabilities of every specific widget. Every widget can send various signals. Use this method to connect any signal to any \n\
callable python method (bounded or unbounded). This method must have the same number of arguments than the signal and the types of the \n\
signal definition must be convertable into a python object. \n\
\n\
Returns \n\
------- \n\
\n\
See Also \n\
--------- \n\
disconnect, invokeKeyboardInterrupt&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1af247b5969057307cb95c570dbd4b08"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a1af247b5969057307cb95c570dbd4b08" args="(PyUiItemConnectKeyboardInterrupt_doc,&quot;invokeKeyboardInterrupt(signalSignature) &#45;&gt; connects the given signal with a slot immediately invoking a python interrupt signal. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
signalSignature : {str} \n\
    This must be the valid signature, known from the Qt&#45;method *connect* (e.g. 'clicked(bool)') \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
If you use the connect method to link a signal with a python method or function, this method can only be executed if python is in an idle status. \n\
However, if you want raise the python interrupt signal if a specific signal is emitted, this interruption should be immediately invoked. Therefore \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
connect&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemConnectKeyboardInterrupt_doc,&quot;invokeKeyboardInterrupt(signalSignature) -&gt; connects the given signal with a slot immediately invoking a python interrupt signal. \n\
\n\
Parameters \n\
----------- \n\
signalSignature : {str} \n\
    This must be the valid signature, known from the Qt-method *connect* (e.g. 'clicked(bool)') \n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
If you use the connect method to link a signal with a python method or function, this method can only be executed if python is in an idle status. \n\
However, if you want raise the python interrupt signal if a specific signal is emitted, this interruption should be immediately invoked. Therefore \n\
\n\
See Also \n\
--------- \n\
connect&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f6748c0b54e31d99852fe3075ab0e2f"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a6f6748c0b54e31d99852fe3075ab0e2f" args="(PyUiItemDisconnect_doc,&quot;disconnect(signalSignature, callableMethod) &#45;&gt; disconnects a connection which must have been established with exactly the same parameters.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
signalSignature : {str} \n\
callableMethod : {python method or function} \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemDisconnect_doc,&quot;disconnect(signalSignature, callableMethod) -&gt; disconnects a connection which must have been established with exactly the same parameters.\n\
\n\
Parameters \n\
----------- \n\
signalSignature : {str} \n\
callableMethod : {python method or function} \n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5784284f61ddd86caf1f31c1c0a5860b"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a5784284f61ddd86caf1f31c1c0a5860b" args="(PyUiItemGetProperty_doc,&quot;getProperty(propertyName | listOfPropertyNames) &#45;&gt; returns tuple of requested properties (single property or tuple of properties)\n\
Use this method or the operator [] in order to get the value of one specific property of this widget or of multiple properties. \n\
Multiple properties are given by a tuple or list of property names. For one single property, its value is returned as it is. \n\
If the property names are passed as sequence, a sequence of same size is returned with the corresponding values. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
property : {string, string&#45;list} \n\
	Name of one property or sequence (tuple,list...) of property names \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
returns the value of one single property or a list of values, if a sequence of names is given as parameter. \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
setProperty \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemGetProperty_doc,&quot;getProperty(propertyName | listOfPropertyNames) -&gt; returns tuple of requested properties (single property or tuple of properties)\n\
Use this method or the operator [] in order to get the value of one specific property of this widget or of multiple properties. \n\
Multiple properties are given by a tuple or list of property names. For one single property, its value is returned as it is. \n\
If the property names are passed as sequence, a sequence of same size is returned with the corresponding values. \n\
\n\
Parameters \n\
----------- \n\
property : {string, string-list} \n\
	Name of one property or sequence (tuple,list...) of property names \n\
\n\
Returns \n\
------- \n\
returns the value of one single property or a list of values, if a sequence of names is given as parameter. \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
setProperty \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4447904de994eb92ed6a9209496406b3"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a4447904de994eb92ed6a9209496406b3" args="(PyUiItemSetProperty_doc,&quot;setProperty(propertyDict) &#45;&gt; each property in the parameter dictionary is set to the dictionaries value.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
propertyDict : {dict}\n\
	Dictionary with properties (keyword) and the values that should be set.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getProperty \n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemSetProperty_doc,&quot;setProperty(propertyDict) -&gt; each property in the parameter dictionary is set to the dictionaries value.\n\
\n\
Parameters \n\
----------- \n\
propertyDict : {dict}\n\
	Dictionary with properties (keyword) and the values that should be set.\n\
\n\
See Also \n\
--------- \n\
getProperty \n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa037ab52cb5e7c1a0b3e5bb6c35e91ed"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aa037ab52cb5e7c1a0b3e5bb6c35e91ed" args="(PyUiItemGetPropertyInfo_doc,&quot;getPropertyInfo([propertyName]) &#45;&gt; returns information about the property 'propertyName' of this widget or all properties, if no name indicated.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
propertyName : {tuple}, optional \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemGetPropertyInfo_doc,&quot;getPropertyInfo([propertyName]) -&gt; returns information about the property 'propertyName' of this widget or all properties, if no name indicated.\n\
\n\
Parameters \n\
----------- \n\
propertyName : {tuple}, optional \n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d7dbec8961f1a7e1ffe3fecb871aa47"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a3d7dbec8961f1a7e1ffe3fecb871aa47" args="(PyUiItemGetAttribute_doc,&quot;getAttribute(attributeNumber) &#45;&gt; returns specified attribute of corresponding widget.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
attributeNumber : {int} \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemGetAttribute_doc,&quot;getAttribute(attributeNumber) -&gt; returns specified attribute of corresponding widget.\n\
\n\
Parameters \n\
----------- \n\
attributeNumber : {int} \n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd40d46ff677b4ac223fb565ea6b1664"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="afd40d46ff677b4ac223fb565ea6b1664" args="(PyUiItemSetAttribute_doc,&quot;setAttribute(attributeNumber, value) &#45;&gt; sets attribute of corresponding widget.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
attributeNumber : {int} \n\
value : {bool} \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemSetAttribute_doc,&quot;setAttribute(attributeNumber, value) -&gt; sets attribute of corresponding widget.\n\
\n\
Parameters \n\
----------- \n\
attributeNumber : {int} \n\
value : {bool} \n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c6536481d9aaade542bdf3115cc2f1d"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a8c6536481d9aaade542bdf3115cc2f1d" args="(PyUiItemSetWindowFlags_doc,&quot;setWindowFlags(flags) &#45;&gt; sets window flags of corresponding widget.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
flags : {int} \n\
window flags to set (or&#45;combination, see Qt::WindowFlags)&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemSetWindowFlags_doc,&quot;setWindowFlags(flags) -&gt; sets window flags of corresponding widget.\n\
\n\
Parameters \n\
----------- \n\
flags : {int} \n\
window flags to set (or-combination, see Qt::WindowFlags)&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab586c7e1f6554cce82027c0020ac8be7"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ab586c7e1f6554cce82027c0020ac8be7" args="(PyUiItemGetWindowFlags_doc,&quot;getWindowFlags(flags) &#45;&gt; gets window flags of corresponding widget. \n\
\n\
The flags&#45;value is an or&#45;combination of the enumeration Qt::WindowFlag. See Qt documentation for more information.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemGetWindowFlags_doc,&quot;getWindowFlags(flags) -&gt; gets window flags of corresponding widget. \n\
\n\
The flags-value is an or-combination of the enumeration Qt::WindowFlag. See Qt documentation for more information.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a805a1bc059801589f25bd20d4c44371d"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a805a1bc059801589f25bd20d4c44371d" args="(pyUiInit_doc,&quot;ui(filename, [type, dialogButtonBar, dialogButtons, childOfMainWindow, deleteOnClose]) &#45;&gt; instance of user interface \n\
\n\
The class **ui** wraps a user interface, externally designed and given by a ui&#45;file. If your user interface is a dialog or window, \n\
chose *ui.TYPEWINDOW* as type, if the user interface is a widget (simplest case), chose *ui.TYPEDIALOG* and your widget \n\
will be embedded in a dialog, provided by *itom*. This dialog can be equiped with a button bar, whose buttons are already \n\
connected to *itom* internal methods. If you then show your dialog in a modal mode, *itom* knows which button has been \n\
clicked in order to accept or reject the dialog. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filename : {str} \n\
    path to user interface file (*.ui), absolute or relative to current directory \n\
type : {int}, optional \n\
    display type: \n\
        * 0 (ui.TYPEDIALOG): ui&#45;file is embedded in auto&#45;created dialog (default), \n\
        * 1 (ui.TYPEWINDOW): ui&#45;file is handled as main window, \n\
        * 2 (ui.TYPEDOCKWIDGET): ui&#45;file is handled as dock&#45;widget and appended to the main&#45;window dock area \n\
dialogButtonBar :  {int}, optional \n\
    Only for type ui.TYPEDIALOG (0). Indicates whether buttons should automatically be added to the dialog: \n\
		* 0 (ui.BUTTONBAR_NO): do not add any buttons (default) \n\
        * 1 (ui.BUTTONBAR_HORIZONTAL): add horizontal button bar \n\
        * 2 (ui.BUTTONBAR_VERTICAL): add vertical button bar \n\
dialogButtons : {dict}, optional \n\
    every dictionary&#45;entry is one button. key is the role, value is the button text \n\
childOfMainWindow :  {bool}, optional \n\
    for type TYPEDIALOG and TYPEWINDOW only. Indicates whether window should be a child of itom main window (default: True) \n\
deleteOnClose : {bool}, optional \n\
    Indicates whether window should be deleted if user closes it or if it is hidden (default: Hidden, False)&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiInit_doc,&quot;ui(filename, [type, dialogButtonBar, dialogButtons, childOfMainWindow, deleteOnClose]) -&gt; instance of user interface \n\
\n\
The class **ui** wraps a user interface, externally designed and given by a ui-file. If your user interface is a dialog or window, \n\
chose *ui.TYPEWINDOW* as type, if the user interface is a widget (simplest case), chose *ui.TYPEDIALOG* and your widget \n\
will be embedded in a dialog, provided by *itom*. This dialog can be equiped with a button bar, whose buttons are already \n\
connected to *itom* internal methods. If you then show your dialog in a modal mode, *itom* knows which button has been \n\
clicked in order to accept or reject the dialog. \n\
\n\
Parameters \n\
----------- \n\
filename : {str} \n\
    path to user interface file (*.ui), absolute or relative to current directory \n\
type : {int}, optional \n\
    display type: \n\
        * 0 (ui.TYPEDIALOG): ui-file is embedded in auto-created dialog (default), \n\
        * 1 (ui.TYPEWINDOW): ui-file is handled as main window, \n\
        * 2 (ui.TYPEDOCKWIDGET): ui-file is handled as dock-widget and appended to the main-window dock area \n\
dialogButtonBar :  {int}, optional \n\
    Only for type ui.TYPEDIALOG (0). Indicates whether buttons should automatically be added to the dialog: \n\
		* 0 (ui.BUTTONBAR_NO): do not add any buttons (default) \n\
        * 1 (ui.BUTTONBAR_HORIZONTAL): add horizontal button bar \n\
        * 2 (ui.BUTTONBAR_VERTICAL): add vertical button bar \n\
dialogButtons : {dict}, optional \n\
    every dictionary-entry is one button. key is the role, value is the button text \n\
childOfMainWindow :  {bool}, optional \n\
    for type TYPEDIALOG and TYPEWINDOW only. Indicates whether window should be a child of itom main window (default: True) \n\
deleteOnClose : {bool}, optional \n\
    Indicates whether window should be deleted if user closes it or if it is hidden (default: Hidden, False)&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a637f2c2d4e95850405c8b45915f5caf8"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a637f2c2d4e95850405c8b45915f5caf8" args="(pyUiShow_doc,&quot;show(modal) &#45;&gt; shows initialized UI&#45;Dialog \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
modal : {int} \n\
    * 0: non&#45;modal (default)\n\
    * 1: modal (python waits until dialog is hidden)\n\
    * 2: modal (python returns immediately)\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiShow_doc,&quot;show(modal) -&gt; shows initialized UI-Dialog \n\
\n\
Parameters \n\
----------- \n\
modal : {int} \n\
    * 0: non-modal (default)\n\
    * 1: modal (python waits until dialog is hidden)\n\
    * 2: modal (python returns immediately)\n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4c0518653bdade4500aa9e7a0623a3a"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ad4c0518653bdade4500aa9e7a0623a3a" args="(pyUiHide_doc,&quot;hide() &#45;&gt; hides initialized UI&#45;Dialog\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiHide_doc,&quot;hide() -&gt; hides initialized UI-Dialog\n\
\n\
Parameters \n\
----------- \n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0772070c08b95986f4718801c82838f9"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a0772070c08b95986f4718801c82838f9" args="(pyUiIsVisible_doc,&quot;isVisible() &#45;&gt; returns true if dialog is still visible\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
dialog visible : {bool}\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiIsVisible_doc,&quot;isVisible() -&gt; returns true if dialog is still visible\n\
\n\
Parameters \n\
----------- \n\
\n\
Returns \n\
------- \n\
dialog visible : {bool}\n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7b0adf12c6258018b2556c1b59d0ae8"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ae7b0adf12c6258018b2556c1b59d0ae8" args="(pyUiGetDouble_doc,&quot;getDouble(title, label, defaultValue [, min, max, decimals=3]) &#45;&gt; shows a dialog to get a double value from the user\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
title : {str}\n\
    is the dialog title \n\
label : {str}\n\
    is the label above the spin box \n\
defaultValue : {double}, optional\n\
    is the default value in the spin box \n\
min : {double}, optional\n\
    default = &#45;2147483647.0\n\
    is the allowed minimal value\n\
max : {double}, optional\n\
    default = 2147483647.0\n\
    is the allowed maximal value\n\
decimals : {int}, optional\n\
    the maximum number of decimal places (default: 1) \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
A tuple where the first value contains the current double value. The second value is True if the dialog has been accepted, else False. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getInt, getText, getItem&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetDouble_doc,&quot;getDouble(title, label, defaultValue [, min, max, decimals=3]) -&gt; shows a dialog to get a double value from the user\n\
\n\
Parameters \n\
----------- \n\
title : {str}\n\
    is the dialog title \n\
label : {str}\n\
    is the label above the spin box \n\
defaultValue : {double}, optional\n\
    is the default value in the spin box \n\
min : {double}, optional\n\
    default = -2147483647.0\n\
    is the allowed minimal value\n\
max : {double}, optional\n\
    default = 2147483647.0\n\
    is the allowed maximal value\n\
decimals : {int}, optional\n\
    the maximum number of decimal places (default: 1) \n\
\n\
Returns \n\
------- \n\
A tuple where the first value contains the current double value. The second value is True if the dialog has been accepted, else False. \n\
\n\
See Also \n\
--------- \n\
getInt, getText, getItem&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1533f21636f06b280633c64e9dca9ef"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ac1533f21636f06b280633c64e9dca9ef" args="(pyUiGetInt_doc,&quot;getInt(title, label, defaultValue [, min, max, step=1]) &#45;&gt; shows a dialog to get an integer value from the user\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
title : {str}\n\
    is the dialog title \n\
label : {str}\n\
    is the label above the spinbox \n\
defaultValue : {int}, optional\n\
    is the default value in the spinbox \n\
min : {int}, optional\n\
    is the allowed minimal value (default: &#45;2147483647) \n\
max : {int}, optional\n\
    is the allowed maximal value (default: 2147483647) \n\
step : {int}, optional\n\
    is the step size if user presses the up/down arrow (default: 1)\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
A tuple where the first value contains the current integer value. The second value is True if the dialog has been accepted, else False. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getDouble, getText, getItem&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetInt_doc,&quot;getInt(title, label, defaultValue [, min, max, step=1]) -&gt; shows a dialog to get an integer value from the user\n\
\n\
Parameters \n\
----------- \n\
title : {str}\n\
    is the dialog title \n\
label : {str}\n\
    is the label above the spinbox \n\
defaultValue : {int}, optional\n\
    is the default value in the spinbox \n\
min : {int}, optional\n\
    is the allowed minimal value (default: -2147483647) \n\
max : {int}, optional\n\
    is the allowed maximal value (default: 2147483647) \n\
step : {int}, optional\n\
    is the step size if user presses the up/down arrow (default: 1)\n\
\n\
Returns \n\
------- \n\
A tuple where the first value contains the current integer value. The second value is True if the dialog has been accepted, else False. \n\
\n\
See Also \n\
--------- \n\
getDouble, getText, getItem&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada63ce9e76325460a24f3360fe9538a4"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ada63ce9e76325460a24f3360fe9538a4" args="(pyUiGetItem_doc,&quot;getItem(title, label, stringList [, currentIndex=0, editable=True]) &#45;&gt; shows a dialog to let the user select an item from a string list\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
title : {str}\n\
    is the dialog title \n\
label : {str}\n\
    is the label above the text box \n\
stringList : {tuple or list}, optional \n\
    is a list or tuple of possible string values \n\
currentIndex : {int}, optional\n\
    defines the preselected value index (default: 0)\n\
editable : {bool}, optional\n\
    defines whether new entries can be added (True) or not (False, default)\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
A tuple where the first value contains the current active or typed string value. The second value is True if the dialog has been accepted, else False. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getInt, getDouble, getText&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetItem_doc,&quot;getItem(title, label, stringList [, currentIndex=0, editable=True]) -&gt; shows a dialog to let the user select an item from a string list\n\
\n\
Parameters \n\
----------- \n\
title : {str}\n\
    is the dialog title \n\
label : {str}\n\
    is the label above the text box \n\
stringList : {tuple or list}, optional \n\
    is a list or tuple of possible string values \n\
currentIndex : {int}, optional\n\
    defines the preselected value index (default: 0)\n\
editable : {bool}, optional\n\
    defines whether new entries can be added (True) or not (False, default)\n\
\n\
Returns \n\
------- \n\
A tuple where the first value contains the current active or typed string value. The second value is True if the dialog has been accepted, else False. \n\
\n\
See Also \n\
--------- \n\
getInt, getDouble, getText&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a82b3988f07369d212a20501040b611be"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a82b3988f07369d212a20501040b611be" args="(pyUiGetText_doc,&quot;getText(title, label, defaultString) &#45;&gt; opens a dialog in order to ask the user for a string \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
title : {str}\n\
    is the dialog title \n\
label : {str}\n\
    is the label above the text box \n\
defaultString : {str}\n\
    is the default string in the text box\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
A tuple where the first value contains the current string value. The second value is True if the dialog has been accepted, else False. \n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getInt, getDouble, getItem&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetText_doc,&quot;getText(title, label, defaultString) -&gt; opens a dialog in order to ask the user for a string \n\
Parameters \n\
----------- \n\
title : {str}\n\
    is the dialog title \n\
label : {str}\n\
    is the label above the text box \n\
defaultString : {str}\n\
    is the default string in the text box\n\
\n\
Returns \n\
------- \n\
A tuple where the first value contains the current string value. The second value is True if the dialog has been accepted, else False. \n\
\n\
See Also \n\
--------- \n\
getInt, getDouble, getItem&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94586b64c4d85e1ea44d76b5758179de"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a94586b64c4d85e1ea44d76b5758179de" args="(pyUiMsgInformation_doc,&quot;msgInformation(title, text [, buttons, defaultButton, parent]) &#45;&gt; opens an information message box \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
title : {str}\n\
    is the message box title \n\
text : {str}\n\
    is the message text \n\
buttons : {int}, optional\n\
    is an or&#45;combination of ui.MsgBox[...]&#45;constants indicating the buttons to display. Use | for the or&#45;combination. \n\
defaultButton : {int}, optional\n\
    is a value of ui.MsgBox[...] which indicates the default button \n\
parent : {ui}, optional\n\
    is the parent dialog of the message box.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiMsgInformation_doc,&quot;msgInformation(title, text [, buttons, defaultButton, parent]) -&gt; opens an information message box \n\
\n\
Parameters \n\
----------- \n\
title : {str}\n\
    is the message box title \n\
text : {str}\n\
    is the message text \n\
buttons : {int}, optional\n\
    is an or-combination of ui.MsgBox[...]-constants indicating the buttons to display. Use | for the or-combination. \n\
defaultButton : {int}, optional\n\
    is a value of ui.MsgBox[...] which indicates the default button \n\
parent : {ui}, optional\n\
    is the parent dialog of the message box.\n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62ad3303a730a7eaaf13b45335a57e8f"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a62ad3303a730a7eaaf13b45335a57e8f" args="(pyUiMsgQuestion_doc,&quot;msgQuestion(title, text [, buttons, defaultButton, parent]) &#45;&gt; opens a question message box \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
title : {str}\n\
    is the message box title \n\
text : {str}\n\
    is the message text \n\
buttons : {int}, optional\n\
    is an or&#45;combination of ui.MsgBox[...]&#45;constants indicating the buttons to display. Use | for the or&#45;combination. \n\
defaultButton : {int}, optional\n\
    is a value of ui.MsgBox[...] which indicates the default button \n\
parent : {ui}, optional\n\
    is the parent dialog of the message box.\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiMsgQuestion_doc,&quot;msgQuestion(title, text [, buttons, defaultButton, parent]) -&gt; opens a question message box \n\
\n\
Parameters \n\
----------- \n\
title : {str}\n\
    is the message box title \n\
text : {str}\n\
    is the message text \n\
buttons : {int}, optional\n\
    is an or-combination of ui.MsgBox[...]-constants indicating the buttons to display. Use | for the or-combination. \n\
defaultButton : {int}, optional\n\
    is a value of ui.MsgBox[...] which indicates the default button \n\
parent : {ui}, optional\n\
    is the parent dialog of the message box.\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2841d926a05fc0035a79432159a31bb7"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a2841d926a05fc0035a79432159a31bb7" args="(pyUiMsgWarning_doc,&quot;msgWarning(title, text [, buttons, defaultButton, parent]) &#45;&gt; opens a warning message box \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
title : {str}\n\
    is the message box title \n\
text : {str}\n\
    is the message text \n\
buttons : {int}, optional\n\
    is an or&#45;combination of ui.MsgBox[...]&#45;constants indicating the buttons to display. Use | for the or&#45;combination. \n\
defaultButton : {int}, optional\n\
    is a value of ui.MsgBox[...] which indicates the default button \n\
parent : {ui}, optional\n\
    is the parent dialog of the message box.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiMsgWarning_doc,&quot;msgWarning(title, text [, buttons, defaultButton, parent]) -&gt; opens a warning message box \n\
\n\
Parameters \n\
----------- \n\
title : {str}\n\
    is the message box title \n\
text : {str}\n\
    is the message text \n\
buttons : {int}, optional\n\
    is an or-combination of ui.MsgBox[...]-constants indicating the buttons to display. Use | for the or-combination. \n\
defaultButton : {int}, optional\n\
    is a value of ui.MsgBox[...] which indicates the default button \n\
parent : {ui}, optional\n\
    is the parent dialog of the message box.\n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae56e55185bc11835d5c3fc5943430a51"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="ae56e55185bc11835d5c3fc5943430a51" args="(pyUiMsgCritical_doc,&quot;msgCritical(title, text [, buttons, defaultButton, parent]) &#45;&gt; opens a critical message box \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
title : {str}\n\
    is the message box title \n\
text : {str}\n\
    is the message text \n\
buttons : {int}, optional\n\
    is an or&#45;combination of ui.MsgBox[...]&#45;constants indicating the buttons to display. Use | for the or&#45;combination. \n\
defaultButton : {int}, optional\n\
    is a value of ui.MsgBox[...] which indicates the default button \n\
parent : {ui}, optional\n\
    is the parent dialog of the message box.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiMsgCritical_doc,&quot;msgCritical(title, text [, buttons, defaultButton, parent]) -&gt; opens a critical message box \n\
\n\
Parameters \n\
----------- \n\
title : {str}\n\
    is the message box title \n\
text : {str}\n\
    is the message text \n\
buttons : {int}, optional\n\
    is an or-combination of ui.MsgBox[...]-constants indicating the buttons to display. Use | for the or-combination. \n\
defaultButton : {int}, optional\n\
    is a value of ui.MsgBox[...] which indicates the default button \n\
parent : {ui}, optional\n\
    is the parent dialog of the message box.\n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a628e66387b3060f4d7433c0462902a64"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a628e66387b3060f4d7433c0462902a64" args="(pyUiGetExistingDirectory_doc,&quot;getExistingDirectory(caption, startDirectory [, options, parent]) &#45;&gt; opens a dialog to choose an existing directory \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
caption : {str}\n\
    is the caption of this dialog \n\
startDirectory : {str}\n\
    is the start directory \n\
options : {int}, optional\n\
    is an or&#45;combination of the following options (see 'QFileDialog::Option'): \n\
        * 1: ShowDirsOnly [default] \n\
        * 2: DontResolveSymlinks \n\
        * ... (for others see Qt&#45;Help) \n\
parent : {ui}, optional\n\
    is a parent dialog or window, this dialog becomes modal.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
The selected directory is returned as absolute path or None if the dialog has been rejected.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetExistingDirectory_doc,&quot;getExistingDirectory(caption, startDirectory [, options, parent]) -&gt; opens a dialog to choose an existing directory \n\
\n\
Parameters \n\
----------- \n\
caption : {str}\n\
    is the caption of this dialog \n\
startDirectory : {str}\n\
    is the start directory \n\
options : {int}, optional\n\
    is an or-combination of the following options (see 'QFileDialog::Option'): \n\
        * 1: ShowDirsOnly [default] \n\
        * 2: DontResolveSymlinks \n\
        * ... (for others see Qt-Help) \n\
parent : {ui}, optional\n\
    is a parent dialog or window, this dialog becomes modal.\n\
\n\
Returns \n\
------- \n\
The selected directory is returned as absolute path or None if the dialog has been rejected.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b7b663f40eb4fe5b4e54edea4fcaae9"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a7b7b663f40eb4fe5b4e54edea4fcaae9" args="(pyUiGetOpenFileName_doc,&quot;getOpenFileName([caption, startDirectory, filters, selectedFilterIndex, options, parent]) &#45;&gt; opens dialog for chosing an existing file. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
caption : {str}, optional\n\
    This is the optional title of the dialog, default: no title \n\
startDirectory {str}, optional\n\
    optional, if not indicated currentDirectory will be taken\n\
filters : {str}, optional\n\
    default = 0\n\
    possible filter list, entries should be separated by ;; , e.g. 'Images (*.png *.jpg);;Text files (*.txt)' \n\
selectedFilterIndex : {int}, optional \n\
    is the index of filters which is set by default (0 is first entry) \n\
options : {int}, optional\n\
    default =  0 \n\
    or&#45;combination of enum values QFileDialog::Options \n\
parent : {ui}, optional\n\
    is the parent widget of this dialog \n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filename as string or None if dialog has been aborted.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getSaveFileName&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetOpenFileName_doc,&quot;getOpenFileName([caption, startDirectory, filters, selectedFilterIndex, options, parent]) -&gt; opens dialog for chosing an existing file. \n\
\n\
Parameters \n\
----------- \n\
caption : {str}, optional\n\
    This is the optional title of the dialog, default: no title \n\
startDirectory {str}, optional\n\
    optional, if not indicated currentDirectory will be taken\n\
filters : {str}, optional\n\
    default = 0\n\
    possible filter list, entries should be separated by ;; , e.g. 'Images (*.png *.jpg);;Text files (*.txt)' \n\
selectedFilterIndex : {int}, optional \n\
    is the index of filters which is set by default (0 is first entry) \n\
options : {int}, optional\n\
    default =  0 \n\
    or-combination of enum values QFileDialog::Options \n\
parent : {ui}, optional\n\
    is the parent widget of this dialog \n\
\n\
Returns \n\
------- \n\
filename as string or None if dialog has been aborted.\n\
\n\
See Also \n\
--------- \n\
getSaveFileName&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5970fef381511195077f852a66bd3a95"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a5970fef381511195077f852a66bd3a95" args="(pyUiGetSaveFileName_doc,&quot;getSaveFileName([caption, startDirectory, filters, selectedFilterIndex, options, parent]) &#45;&gt; opens dialog for chosing a file to save. \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
caption : {str}, optional\n\
    This is the title of the dialog \n\
startDirectory : {String}, optional\n\
    if not indicated, the current working directory will be taken\n\
filters : {str}, optional\n\
    possible filter list, entries should be separated by ;; , e.g. 'Images (*.png *.jpg);;Text files (*.txt)' \n\
selectedFilterIndex : {int}, optional\n\
    default = 0\n\
    is the index of filters which is set by default (0 is first entry) \n\
options : {int}, optional\n\
    default = 0\n\
    or&#45;combination of enum values QFileDialog::Options \n\
parent : {ui}, optional\n\
    is the parent widget of this dialog\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
filename as string or None if dialog has been aborted.\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
getOpenFileName&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetSaveFileName_doc,&quot;getSaveFileName([caption, startDirectory, filters, selectedFilterIndex, options, parent]) -&gt; opens dialog for chosing a file to save. \n\
Parameters \n\
----------- \n\
caption : {str}, optional\n\
    This is the title of the dialog \n\
startDirectory : {String}, optional\n\
    if not indicated, the current working directory will be taken\n\
filters : {str}, optional\n\
    possible filter list, entries should be separated by ;; , e.g. 'Images (*.png *.jpg);;Text files (*.txt)' \n\
selectedFilterIndex : {int}, optional\n\
    default = 0\n\
    is the index of filters which is set by default (0 is first entry) \n\
options : {int}, optional\n\
    default = 0\n\
    or-combination of enum values QFileDialog::Options \n\
parent : {ui}, optional\n\
    is the parent widget of this dialog\n\
\n\
Returns \n\
------- \n\
filename as string or None if dialog has been aborted.\n\
\n\
See Also \n\
--------- \n\
getOpenFileName&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb50d383645a1722d46fb5f5fd4304aa"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="abb50d383645a1722d46fb5f5fd4304aa" args="(pyUiCreateNewPluginWidget_doc,&quot;createNewPluginWidget(widgetName[, mandparams, optparams]) &#45;&gt; creates widget defined by any algorithm plugin and returns the instance of type 'ui' \n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
widgetName : {}\n\
    name algorithm widget \n\
    parameters to pass to the plugin. The parameters are parsed and unnamed parameters are used in their \
    incoming order to fill first mandatory parameters and afterwards optional parameters. Parameters may be passed \
    with name as well but after the first named parameter no more unnamed parameters are allowed.\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45; \n\
doctodo\n\
\n\
See Also \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiCreateNewPluginWidget_doc,&quot;createNewPluginWidget(widgetName[, mandparams, optparams]) -&gt; creates widget defined by any algorithm plugin and returns the instance of type 'ui' \n\
Parameters \n\
----------- \n\
widgetName : {}\n\
    name algorithm widget \n\
    parameters to pass to the plugin. The parameters are parsed and unnamed parameters are used in their \
    incoming order to fill first mandatory parameters and afterwards optional parameters. Parameters may be passed \
    with name as well but after the first named parameter no more unnamed parameters are allowed.\n\
\n\
Returns \n\
------- \n\
\n\
Notes \n\
----- \n\
doctodo\n\
\n\
See Also \n\
--------- \n\
\n\
&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a364cfd750089e196a7fe7446f5b7a4bf"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a364cfd750089e196a7fe7446f5b7a4bf" args="(PyTimerInit_doc,&quot;timer(interval, callbackFunc, [argTuple]) &#45;&gt; new callback timer \n\
\n\
Creates a timer object that continuously calls a python callback function or method with a certain interval. The timer is active after construction and \n\
stops when this instance is destroyed or stop() is called. \n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
interval : {double} \n\
    time out interval in ms \n\
callbackFunc: {function or method} \n\
    Python function that should be called when timer event raises \n\
argTuple: {tuple}, optional \n\
    tuple of parameters passed as arguments to the callback function&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyTimerInit_doc,&quot;timer(interval, callbackFunc, [argTuple]) -&gt; new callback timer \n\
\n\
Creates a timer object that continuously calls a python callback function or method with a certain interval. The timer is active after construction and \n\
stops when this instance is destroyed or stop() is called. \n\
\n\
Parameters \n\
----------- \n\
interval : {double} \n\
    time out interval in ms \n\
callbackFunc: {function or method} \n\
    Python function that should be called when timer event raises \n\
argTuple: {tuple}, optional \n\
    tuple of parameters passed as arguments to the callback function&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca71ead38adf55ff2e389fd485242e3f"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="aca71ead38adf55ff2e389fd485242e3f" args="(PyTimerStart_doc,&quot;start() &#45;&gt; starts timer\n\
\n\
Starts or restarts the timer with its timeout interval. If the timer is already running, it will be stopped and restarted.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyTimerStart_doc,&quot;start() -&gt; starts timer\n\
\n\
Starts or restarts the timer with its timeout interval. If the timer is already running, it will be stopped and restarted.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d6b6e5828f40765474e855377dfb658"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a2d6b6e5828f40765474e855377dfb658" args="(PyTimerStop_doc,&quot;stop() &#45;&gt; stops timer&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyTimerStop_doc,&quot;stop() -&gt; stops timer&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fca578abc630a5f8cdd17d7e27bb558"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a3fca578abc630a5f8cdd17d7e27bb558" args="(PyTimerIsActive_doc,&quot;isActive() &#45;&gt; returns timer status\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
status : {bool} \n\
    True if the timer is running, otherwise False.&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyTimerIsActive_doc,&quot;isActive() -&gt; returns timer status\n\
\n\
Returns \n\
------- \n\
status : {bool} \n\
    True if the timer is running, otherwise False.&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c94b74ed036e73abec0c396f7b33b1b"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a7c94b74ed036e73abec0c396f7b33b1b" args="(PyTimerSetInterval_doc,&quot;setInterval(interval) &#45;&gt; sets timer interval in [ms]\n\
\n\
This method sets the timeout interval in milliseconds. The timer calls the callback function continuously after this interval (if started)&quot;)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyTimerSetInterval_doc,&quot;setInterval(interval) -&gt; sets timer interval in [ms]\n\
\n\
This method sets the timeout interval in milliseconds. The timer calls the callback function continuously after this interval (if started)&quot;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a685ec2e9d5eecc4f7292a12aa70fc6ed">CreateFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned char dimensions, const size_t *sizes, const unsigned char continuous, const uchar *continuousDataPtr, const size_t *steps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">templated method for create  <a href="#a685ec2e9d5eecc4f7292a12aa70fc6ed"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8fc8e0a61a894c95d468407a59147fec">CreateFuncWithCVPlanes</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned char dimensions, const size_t *sizes, const cv::Mat *planes, const unsigned int nrOfPlanes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">templated method for creation with given vector of cv::Mat-planes  <a href="#a8fc8e0a61a894c95d468407a59147fec"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a708f5dc838bfbc92c937b6e6c40df6df">FreeFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for freeing allocated data blocks  <a href="#a708f5dc838bfbc92c937b6e6c40df6df"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12d73ecdcc47919a26ba8d340902589e"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a12d73ecdcc47919a26ba8d340902589e" args="(FreeFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (FreeFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3dcdb513572138377a5cb93dc672a62c"></a><!-- doxytag: member="ito::SecureFreeFunc" ref="a3dcdb513572138377a5cb93dc672a62c" args="(DataObject *dObj)" -->
template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SecureFreeFunc</b> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b147b959b34d59ef380276d466cd40f"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a6b147b959b34d59ef380276d466cd40f" args="(SecureFreeFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (SecureFreeFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a12bc247542bd015830ad21b2b6ead367">CopyToFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, unsigned char regionOnly)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for deeply copying the data of one matrix to another given matrix  <a href="#a12bc247542bd015830ad21b2b6ead367"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70b00918c766787b2d1cf28f26b73a8f"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a70b00918c766787b2d1cf28f26b73a8f" args="(CopyToFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (CopyToFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a22e7789c41c3399ac8d291feceb40df2">DeepCopyPartialFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method to copy the values of the ROI of matrix lhs to the ROI of matrix rhs.  <a href="#a22e7789c41c3399ac8d291feceb40df2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d6bc2b9a495a2eb034bb4dbf560d04b"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a3d6bc2b9a495a2eb034bb4dbf560d04b" args="(DeepCopyPartialFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (DeepCopyPartialFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a008c12f351e9ca61ebdbb3522b94119e">ConvertToFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, const int type, const double alpha, const double beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts data in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> lhs to <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> rhs with a given type  <a href="#a008c12f351e9ca61ebdbb3522b94119e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46c9406cd13e3319f6e4c78a17b3acc7"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a46c9406cd13e3319f6e4c78a17b3acc7" args="(ConvertToFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (ConvertToFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a37ad10fe5e1dc2a8141837dfed93decb">ZerosFunc</a> (const size_t sizeY, const size_t sizeX, int **dstMat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for creation of zero-valued matrix-plane  <a href="#a37ad10fe5e1dc2a8141837dfed93decb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a959a36992393397a775dcf93deb711cc"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a959a36992393397a775dcf93deb711cc" args="(ZerosFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (ZerosFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aca6e2a03961f1f443ab7c232e501e1ab">OnesFunc</a> (const size_t sizeY, const size_t sizeX, int **dstMat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for creation of one-valued matrix-plane  <a href="#aca6e2a03961f1f443ab7c232e501e1ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a703ce71ad83db052ab6d3f552bdfe51e"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a703ce71ad83db052ab6d3f552bdfe51e" args="(OnesFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (OnesFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a86d06938dd4238f988302e46a9ee9735">RandFunc</a> (const size_t sizeY, const size_t sizeX, const double value1, const double value2, const bool randMode, int **dstMat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for creation of random-valued matrix-plane  <a href="#a86d06938dd4238f988302e46a9ee9735"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6ac69b3f30314c1478a433ae9eabbe7a">RandFunc&lt; ito::complex128 &gt;</a> (const size_t sizeY, const size_t sizeX, const double value1, const double value2, const bool randMode, int **dstMat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for low-level, templated method for creation of random-valued matrix-plane of type complex128  <a href="#a6ac69b3f30314c1478a433ae9eabbe7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b5622772cb7e9b8e058588c74e918f0"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a0b5622772cb7e9b8e058588c74e918f0" args="(RandFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (RandFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae443f37579ec5020b3885006d1ba3c4a">CopyMatFunc</a> (int **src, int **&amp;dst, bool transposed)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method that executes a shallow-copy of every matrix-plane in the source-vector and stores the copies in the destination-vector  <a href="#ae443f37579ec5020b3885006d1ba3c4a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a7a6fe8474818648fbd90616fcf518eef">AssignScalarFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> type, const void *scalar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated helper method to assign the given scalar to every element within its ROI in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> src.  <a href="#a7a6fe8474818648fbd90616fcf518eef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70cffb505679d9b9f57fa17777909920"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a70cffb505679d9b9f57fa17777909920" args="(AssignScalarFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (AssignScalarFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae16131a91987cc5836aaf3f3918319b4">AddFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjRes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for element-wise addition of two given data objects.  <a href="#ae16131a91987cc5836aaf3f3918319b4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b1c79b91475d5cb9717d5d26eb51fd3"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a5b1c79b91475d5cb9717d5d26eb51fd3" args="(AddFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (AddFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa83bfed0f50e7016e9ccf313e7a95296"></a><!-- doxytag: member="ito::AddScalarFunc" ref="aa83bfed0f50e7016e9ccf313e7a95296" args="(const DataObject *dObjIn, ito::float64 scalar, DataObject *dObjOut)" -->
template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AddScalarFunc</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjIn, ito::float64 scalar, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac99f2d9dd8a9d7dc93a2ee8386ab8e9e"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="ac99f2d9dd8a9d7dc93a2ee8386ab8e9e" args="(AddScalarFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (AddScalarFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af1b438d0eb2715bbea3a573820950808">SubFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjRes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for element-wise subtraction of values from second data object from values of first data object  <a href="#af1b438d0eb2715bbea3a573820950808"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a5e6e41fcf95987cb8eddcdbaf95b34"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a7a5e6e41fcf95987cb8eddcdbaf95b34" args="(SubFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (SubFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6e47940e1e59401ab78b8844ef709634">OpMulFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjRes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">brief description  <a href="#a6e47940e1e59401ab78b8844ef709634"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a871edc6ab6966c9e12dc3ab4c08682e6"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a871edc6ab6966c9e12dc3ab4c08682e6" args="(OpMulFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (OpMulFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad433fae6723437f656c2efa63b14c3f2">OpScalarMulFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const double factor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which multiplies every element of Data Object with a factor  <a href="#ad433fae6723437f656c2efa63b14c3f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cd67b8ca703db1f6610f6b1e2b62701"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="a1cd67b8ca703db1f6610f6b1e2b62701" args="(OpScalarMulFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (OpScalarMulFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a5dee1bec1740d52cf1ba8ff4dec6ae90">CmpFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst, int cmpOp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which compares each element in source-matrix1 with its corresponding element in source-matrix2 and saves the result in a destionation matrix  <a href="#a5dee1bec1740d52cf1ba8ff4dec6ae90"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a46383208b047fa54490f63567d1d1930">CmpFunc&lt; ito::complex64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for compare function of type complex64  <a href="#a46383208b047fa54490f63567d1d1930"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad1f436259eb8eba0d9cbdc9fa0f375a4">CmpFunc&lt; ito::complex128 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, int)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for compare function of type complex128  <a href="#ad1f436259eb8eba0d9cbdc9fa0f375a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8672ba101025b2928b4a284710e878d"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="ae8672ba101025b2928b4a284710e878d" args="(CmpFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (CmpFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a66a9c5dc6bb068b2ce6be93f0fcf4b9f">ShiftLFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const unsigned char shiftbit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which element-wisely shifts the values of the source matrix by a certain value to the left  <a href="#a66a9c5dc6bb068b2ce6be93f0fcf4b9f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6d19fd38859c027dcf514812e987c9ee">ShiftLFunc&lt; ito::float32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type float32  <a href="#a6d19fd38859c027dcf514812e987c9ee"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8de5cddc9cbf637156d3acc27566e4b1">ShiftLFunc&lt; ito::float64 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type float64  <a href="#a8de5cddc9cbf637156d3acc27566e4b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa2674629cfb1e34316dd627781bfa3c0">ShiftLFunc&lt; ito::complex64 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type complex64  <a href="#aa2674629cfb1e34316dd627781bfa3c0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a23c24130d3ca6d2a459d5bf2a8a4b92b">ShiftLFunc&lt; ito::complex128 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type complex128  <a href="#a23c24130d3ca6d2a459d5bf2a8a4b92b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5006e9d24601a9faad68be2dafaf3d7"></a><!-- doxytag: member="ito::MAKEFUNCLIST" ref="aa5006e9d24601a9faad68be2dafaf3d7" args="(ShiftLFunc)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (ShiftLFunc)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab8040457b6c031cbefb51fbdae76a3bb">ShiftRFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const unsigned char shiftbit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which element-wisely shifts the values of the source matrix by a certain value to the right  <a href="#ab8040457b6c031cbefb51fbdae76a3bb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aabb30836cf7a7a0a3f21cf6fc35848eb">ShiftRFunc&lt; ito::float32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type float32  <a href="#aabb30836cf7a7a0a3f21cf6fc35848eb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8b338e54a07664315beb473504a2c8d1">ShiftRFunc&lt; ito::float64 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type float64  <a href="#a8b338e54a07664315beb473504a2c8d1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad405a0a85400adc16e1c3b1f4e1884b9">ShiftRFunc&lt; ito::complex64 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type complex64  <a href="#ad405a0a85400adc16e1c3b1f4e1884b9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af06888f8baac8366f96641426371bb39">ShiftRFunc&lt; ito::complex128 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type complex128  <a href="#af06888f8baac8366f96641426371bb39"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af958d9bca56f7971bc30feac415bdaae">BitAndFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjRes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which element-wisely executes a bitwise 'and' comparison between values of two dataObjects.  <a href="#af958d9bca56f7971bc30feac415bdaae"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab899e141a3847b1a7035c5e56332d6e9">BitAndFunc&lt; ito::float32 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise and function of type float32  <a href="#ab899e141a3847b1a7035c5e56332d6e9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aef3d086c4a7eed78b88a34ad1219dd06">BitAndFunc&lt; ito::float64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise and function of type float64  <a href="#aef3d086c4a7eed78b88a34ad1219dd06"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa80cc5a38859d11ae5b8b5d4f9c8c3c9">BitAndFunc&lt; ito::complex64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise and function of type complex64  <a href="#aa80cc5a38859d11ae5b8b5d4f9c8c3c9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#afc2da43a120dd1da62b1d0dfac9ed4b1">BitAndFunc&lt; ito::complex128 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise and function of type complex128  <a href="#afc2da43a120dd1da62b1d0dfac9ed4b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a5f26f22cf37ce14606bd6dde853f1e8b">BitOrFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjRes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which element-wisely executes a bitwise 'or' comparison between values of two dataObjects.  <a href="#a5f26f22cf37ce14606bd6dde853f1e8b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a3b0b5996a50ddcab865510a424d3d7a4">BitOrFunc&lt; ito::float32 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise or function of type float32  <a href="#a3b0b5996a50ddcab865510a424d3d7a4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae82f393b489f72f5206cfe1fc7e43f93">BitOrFunc&lt; ito::float64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise or function of type float64  <a href="#ae82f393b489f72f5206cfe1fc7e43f93"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6f4a9bac68a02e69f63828971fb69676">BitOrFunc&lt; ito::complex64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise or function of type complex64  <a href="#a6f4a9bac68a02e69f63828971fb69676"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6bf39908f4328b8cf684b090560adb3a">BitOrFunc&lt; ito::complex128 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise or function of type complex128  <a href="#a6bf39908f4328b8cf684b090560adb3a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a7e15e2fb2cba5fe01f96cc66b65c8345">BitXorFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjRes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which element-wisely executes a bitwise 'xor' comparison between values of two dataObjects.  <a href="#a7e15e2fb2cba5fe01f96cc66b65c8345"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af127d3f60daba576c1b4245e96817e52">BitXorFunc&lt; ito::float32 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise xor function of type float32  <a href="#af127d3f60daba576c1b4245e96817e52"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a55c68147de5f601fd5ea7b53735c5096">BitXorFunc&lt; ito::float64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise xor function of type float64  <a href="#a55c68147de5f601fd5ea7b53735c5096"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a98551d38290fbe3f94b77ef58972dda8">BitXorFunc&lt; ito::complex64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise xor function of type complex64  <a href="#a98551d38290fbe3f94b77ef58972dda8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#adf73d910b4e9d9c344b2b389f9973720">BitXorFunc&lt; ito::complex128 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise xor function of type complex128  <a href="#adf73d910b4e9d9c344b2b389f9973720"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a26e60a4adfd0270199d3cb0b21230c29">GetRangeFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const int dtop, const int dbottom, const int dleft, const int dright)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for saving a shallow copy of a source cv::Mat_ to a destination cv::Mat_ with respect to given row- and col-ranges  <a href="#a26e60a4adfd0270199d3cb0b21230c29"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#abea3cec515d7dfc29dd5a2ac1002c7e6">AdjustROIFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, int dtop, int dbottom, int dleft, int dright)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for adjusting the ROI of a data object by the given incremental values  <a href="#abea3cec515d7dfc29dd5a2ac1002c7e6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8dc77804bd6f6c2afa1b1cae477337ff">EyeFunc</a> (const size_t size, int **dstMat)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for creating an eye-matrix  <a href="#a8dc77804bd6f6c2afa1b1cae477337ff"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab7900df15bdd04f8f3b229e3b03e126f">ConjFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for calculating the conjugated value of each element within the ROI of this data object  <a href="#ab7900df15bdd04f8f3b229e3b03e126f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2152b55aa6ffffbd308988036921c366"></a><!-- doxytag: member="ito::ConjFunc&lt; int8 &gt;" ref="a2152b55aa6ffffbd308988036921c366" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a2152b55aa6ffffbd308988036921c366">ConjFunc&lt; int8 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type int8. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6c5eb910cdbd6181467afb726667e299"></a><!-- doxytag: member="ito::ConjFunc&lt; uint8 &gt;" ref="a6c5eb910cdbd6181467afb726667e299" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6c5eb910cdbd6181467afb726667e299">ConjFunc&lt; uint8 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type uint8. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ada701c5317bb987499c5c60b2a2e3791"></a><!-- doxytag: member="ito::ConjFunc&lt; int16 &gt;" ref="ada701c5317bb987499c5c60b2a2e3791" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ada701c5317bb987499c5c60b2a2e3791">ConjFunc&lt; int16 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type int16. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af8df9376088030094eec904d16fde735"></a><!-- doxytag: member="ito::ConjFunc&lt; uint16 &gt;" ref="af8df9376088030094eec904d16fde735" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af8df9376088030094eec904d16fde735">ConjFunc&lt; uint16 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type uint16. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad09333065564b7f43febdbcfaf80966d"></a><!-- doxytag: member="ito::ConjFunc&lt; int32 &gt;" ref="ad09333065564b7f43febdbcfaf80966d" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad09333065564b7f43febdbcfaf80966d">ConjFunc&lt; int32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type int32. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af059de0f69d7423b432a0495a1eb1185"></a><!-- doxytag: member="ito::ConjFunc&lt; uint32 &gt;" ref="af059de0f69d7423b432a0495a1eb1185" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af059de0f69d7423b432a0495a1eb1185">ConjFunc&lt; uint32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type uint32. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a45ce3961d006b5f2afa1a3d7fe98f498"></a><!-- doxytag: member="ito::ConjFunc&lt; ito::float32 &gt;" ref="a45ce3961d006b5f2afa1a3d7fe98f498" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a45ce3961d006b5f2afa1a3d7fe98f498">ConjFunc&lt; ito::float32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type float32. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a584dd8ae5ea74e47de0f229545a6a43e"></a><!-- doxytag: member="ito::ConjFunc&lt; ito::float64 &gt;" ref="a584dd8ae5ea74e47de0f229545a6a43e" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a584dd8ae5ea74e47de0f229545a6a43e">ConjFunc&lt; ito::float64 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type float64. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3b5867dd1dfd785a687af3de732ddcee"></a><!-- doxytag: member="ito::ConjFunc&lt; int64 &gt;" ref="a3b5867dd1dfd785a687af3de732ddcee" args="(DataObject *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a3b5867dd1dfd785a687af3de732ddcee">ConjFunc&lt; int64 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type float64. throws cv::Exception, since the data type is not complex. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8c9e2a64719008df18f75938fb711078">RowFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned int selRow)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which changes the region of interest of the data object to the selected zero-based row index  <a href="#a8c9e2a64719008df18f75938fb711078"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab29e3016de474b08d29924f0fffa7ad4">ColFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned int selCol)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which changes the region of interest of the data object to the selected zero-based col index  <a href="#ab29e3016de474b08d29924f0fffa7ad4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2ec1a7c2c0078e1b856d739a25637728"></a><!-- doxytag: member="ito::MulFunc" ref="a2ec1a7c2c0078e1b856d739a25637728" args="(const DataObject *src1, const DataObject *src2, DataObject *res, const double)" -->
template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MulFunc</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *res, const double)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a4863495020c813812170b8bdfcc46221">DivFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *res, const double)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which does a element-wise division of elements in first source matrix by elements in second source matrix.  <a href="#a4863495020c813812170b8bdfcc46221"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp , typename _T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a82f12dc309c241c93ff581a406690e58">CastFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj, double alpha, double beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level templated method to cast each element of source matrix to another type.  <a href="#a82f12dc309c241c93ff581a406690e58"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _CmplxTp , typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae7089fa30e7e66b8d57438c07b7c644b">AbsFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, double templated method to save the element-wise absolute value of each element in source matrix to result matrix  <a href="#ae7089fa30e7e66b8d57438c07b7c644b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a3f34b4f966d79c5eadb25216a4950620">AbsFuncReal</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method to save the element-wise absolute value of each element in source matrix to result matrix  <a href="#a3f34b4f966d79c5eadb25216a4950620"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad4074d9dd3e2267c0a869416fb138576">abs</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level value which calculates the absolute value of each element of the input source data object and returns the resulting data object  <a href="#ad4074d9dd3e2267c0a869416fb138576"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _CmplxTp , typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a0e126a9e14968fd29e231b9efab55a3b">ArgFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, double templated method to save the element-wise argument of each element in source matrix to result matrix  <a href="#a0e126a9e14968fd29e231b9efab55a3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a1c335baddf31bc92594dc3c0694d63ff">arg</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level value which calculates the argument value of each element of the input source data object and returns the resulting data object  <a href="#a1c335baddf31bc92594dc3c0694d63ff"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _CmplxTp , typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a5756b35dfcc4d0bec5d7c69451cfaebe">RealFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, double templated method to save the element-wise real value of each element in source matrix to result matrix  <a href="#a5756b35dfcc4d0bec5d7c69451cfaebe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#abb7959b977b8d0f79c590380996596b8">real</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level value which calculates the real value of each element of the input source data object and returns the resulting data object  <a href="#abb7959b977b8d0f79c590380996596b8"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _CmplxTp , typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af94ef257b87ce7243e79b454cf1cd1f3">ImagFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, double templated method to save the element-wise imaginary value of each element in source matrix to result matrix  <a href="#af94ef257b87ce7243e79b454cf1cd1f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a4c62ac398a6883ba109b6e821b6a2e6a">imag</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level value which calculates the imaginary value of each element of the input source data object and returns the resulting data object  <a href="#a4c62ac398a6883ba109b6e821b6a2e6a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aca2f517b2e6d28b2664e7939d7eb7be6">MakeContinuousFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;resDObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which copies an incontinuously organized data object to a continuously organized resulting data object  <a href="#aca2f517b2e6d28b2664e7939d7eb7be6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a15ebf0f0e1afe1bba069394c128372aa">makeContinuous</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level method which copies an incontinuously organized data object to a continuously organized resulting data object, which is returned  <a href="#a15ebf0f0e1afe1bba069394c128372aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cb407fe1f17eae0d2c9891941620137"></a><!-- doxytag: member="ito::DataObject::copyFromData2D&lt; ito::float32 &gt;" ref="a7cb407fe1f17eae0d2c9891941620137" args="(const float32 *, const size_t, const size_t)" -->
template <a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DataObject::copyFromData2D&lt; ito::float32 &gt;</b> (const float32 *, const size_t, const size_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea8cba16b2687094408b45bd51c00f4c"></a><!-- doxytag: member="ito::DataObject::copyFromData2D&lt; ito::float64 &gt;" ref="aea8cba16b2687094408b45bd51c00f4c" args="(const float64 *, const size_t, const size_t)" -->
template <a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DataObject::copyFromData2D&lt; ito::float64 &gt;</b> (const float64 *, const size_t, const size_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9959937221f45bc2109eec43500e9f4"></a><!-- doxytag: member="ito::DataObject::copyFromData2D&lt; ito::complex64 &gt;" ref="ae9959937221f45bc2109eec43500e9f4" args="(const complex64 *, const size_t, const size_t)" -->
template <a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DataObject::copyFromData2D&lt; ito::complex64 &gt;</b> (const complex64 *, const size_t, const size_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b5b23a6290f8d96de1e65d4c952887a"></a><!-- doxytag: member="ito::DataObject::copyFromData2D&lt; ito::complex128 &gt;" ref="a7b5b23a6290f8d96de1e65d4c952887a" args="(const complex128 *, const size_t, const size_t)" -->
template <a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DataObject::copyFromData2D&lt; ito::complex128 &gt;</b> (const complex128 *, const size_t, const size_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf60e1575d7771dea2cc24f195847988"></a><!-- doxytag: member="ito::DataObject::copyFromData2D&lt; ito::float32 &gt;" ref="abf60e1575d7771dea2cc24f195847988" args="(const float32 *, const size_t, const size_t, const int, const int, const size_t, const size_t)" -->
template <a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DataObject::copyFromData2D&lt; ito::float32 &gt;</b> (const float32 *, const size_t, const size_t, const int, const int, const size_t, const size_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e3d3f8ef3caacfd16672724b0647e89"></a><!-- doxytag: member="ito::DataObject::copyFromData2D&lt; ito::float64 &gt;" ref="a2e3d3f8ef3caacfd16672724b0647e89" args="(const float64 *, const size_t, const size_t, const int, const int, const size_t, const size_t)" -->
template <a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DataObject::copyFromData2D&lt; ito::float64 &gt;</b> (const float64 *, const size_t, const size_t, const int, const int, const size_t, const size_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb4fdb17b96a8bf9362f126150d2386d"></a><!-- doxytag: member="ito::DataObject::copyFromData2D&lt; ito::complex64 &gt;" ref="aeb4fdb17b96a8bf9362f126150d2386d" args="(const complex64 *, const size_t, const size_t, const int, const int, const size_t, const size_t)" -->
template <a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DataObject::copyFromData2D&lt; ito::complex64 &gt;</b> (const complex64 *, const size_t, const size_t, const int, const int, const size_t, const size_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af721808441cf61b133cc8a42010d7d2f"></a><!-- doxytag: member="ito::DataObject::copyFromData2D&lt; ito::complex128 &gt;" ref="af721808441cf61b133cc8a42010d7d2f" args="(const complex128 *, const size_t, const size_t, const int, const int, const size_t, const size_t)" -->
template <a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>DataObject::copyFromData2D&lt; ito::complex128 &gt;</b> (const complex128 *, const size_t, const size_t, const int, const int, const size_t, const size_t)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa39aa15421565efbfdd04e1534c0a84f">numberConversion</a> (<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> fromType, void *scalar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">templated method for converting a given scalar value to the data type, indicated by the template parameter  <a href="#aa39aa15421565efbfdd04e1534c0a84f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a248c800c524f6a5d606a47e7015f7c89"></a><!-- doxytag: member="ito::coutFunc" ref="a248c800c524f6a5d606a47e7015f7c89" args="(std::ostream &amp;out, const DataObject &amp;dObj)" -->
template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>coutFunc</b> (std::ostream &amp;out, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32585288fae2cd57c64f0188bcb3892b"></a><!-- doxytag: member="ito::operator&lt;&lt;" ref="a32585288fae2cd57c64f0188bcb3892b" args="(std::ostream &amp;out, const DataObject &amp;dObj)" -->
static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a0f1e0516bec029992b462b17bf445618">convertCmplxTypeToRealType</a> (<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> cmplxType)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">static method which returns the real data object of any given data type  <a href="#a0f1e0516bec029992b462b17bf445618"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a339187d27cca1e266efc6193653cf448">getDataType</a> (const _Tp *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">method which returns the value of enumeration <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>, which corresponds to the type of the given pointer parameter.  <a href="#a339187d27cca1e266efc6193653cf448"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aef07fe7ede18a6c0b0f8536515b87c94"></a><!-- doxytag: member="ito::getDataType" ref="aef07fe7ede18a6c0b0f8536515b87c94" args="(const uint8 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const uint8 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2bbef4263650910d0c963588283bf9ca"></a><!-- doxytag: member="ito::getDataType" ref="a2bbef4263650910d0c963588283bf9ca" args="(const int8 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const int8 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="af14df31920222d339b848b1192681a3a"></a><!-- doxytag: member="ito::getDataType" ref="af14df31920222d339b848b1192681a3a" args="(const uint16 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const uint16 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="adcf2e87cdc1b9804a86156d451c378ee"></a><!-- doxytag: member="ito::getDataType" ref="adcf2e87cdc1b9804a86156d451c378ee" args="(const int16 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const int16 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a81cfd4d664e1de45affac918d4497995"></a><!-- doxytag: member="ito::getDataType" ref="a81cfd4d664e1de45affac918d4497995" args="(const uint32 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const uint32 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d84834ce11845a31ac5ef667d133536"></a><!-- doxytag: member="ito::getDataType" ref="a4d84834ce11845a31ac5ef667d133536" args="(const int32 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const int32 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ac4771a594b59e3bb23e2f97a2166f602"></a><!-- doxytag: member="ito::getDataType" ref="ac4771a594b59e3bb23e2f97a2166f602" args="(const float32 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const float32 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a7f04e3f80b177156ecc41b9965fcda82"></a><!-- doxytag: member="ito::getDataType" ref="a7f04e3f80b177156ecc41b9965fcda82" args="(const float64 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const float64 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="abdbd7d556dbb7e5fb4685799c8cd75f2"></a><!-- doxytag: member="ito::getDataType" ref="abdbd7d556dbb7e5fb4685799c8cd75f2" args="(const complex64 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const complex64 *)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a876459d01741aa2cc18a6945ab267939"></a><!-- doxytag: member="ito::getDataType" ref="a876459d01741aa2cc18a6945ab267939" args="(const complex128 *)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const complex128 *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a63c174f39bf79b06c140758b074cfdd0">getDataType2</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">method which returns the value of enumeration <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>, which corresponds to the template parameter (must be a pointer).  <a href="#a63c174f39bf79b06c140758b074cfdd0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5a2ea61f8b082b8db1d09dd7427d21b5"></a><!-- doxytag: member="ito::getDataType2&lt; uint8 * &gt;" ref="a5a2ea61f8b082b8db1d09dd7427d21b5" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; uint8 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a2836f84ae9979d301e6a0879dd001f6c"></a><!-- doxytag: member="ito::getDataType2&lt; int8 * &gt;" ref="a2836f84ae9979d301e6a0879dd001f6c" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; int8 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a13d84db4ecaad22a0bb8283f6d3a93e0"></a><!-- doxytag: member="ito::getDataType2&lt; uint16 * &gt;" ref="a13d84db4ecaad22a0bb8283f6d3a93e0" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; uint16 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a744e4c9b696b0fec1e4f162bb0055f01"></a><!-- doxytag: member="ito::getDataType2&lt; int16 * &gt;" ref="a744e4c9b696b0fec1e4f162bb0055f01" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; int16 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f297ac84fceae1dea363c45a7dff4e1"></a><!-- doxytag: member="ito::getDataType2&lt; uint32 * &gt;" ref="a1f297ac84fceae1dea363c45a7dff4e1" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; uint32 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa592e1b1b52384b7bf70d1f799996d1c"></a><!-- doxytag: member="ito::getDataType2&lt; int32 * &gt;" ref="aa592e1b1b52384b7bf70d1f799996d1c" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; int32 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c9558058bd3f1e0c679a54b3513ab76"></a><!-- doxytag: member="ito::getDataType2&lt; float32 * &gt;" ref="a3c9558058bd3f1e0c679a54b3513ab76" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; float32 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8cc64619ef98e392d195206b3e7dcbb8"></a><!-- doxytag: member="ito::getDataType2&lt; float64 * &gt;" ref="a8cc64619ef98e392d195206b3e7dcbb8" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; float64 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5b18930fcd326f853942fb7cca4a60c1"></a><!-- doxytag: member="ito::getDataType2&lt; complex64 * &gt;" ref="a5b18930fcd326f853942fb7cca4a60c1" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; complex64 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad1e723d4e92edc5c2f4f0c4b512c7124"></a><!-- doxytag: member="ito::getDataType2&lt; complex128 * &gt;" ref="ad1e723d4e92edc5c2f4f0c4b512c7124" args="()" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; complex128 * &gt;</b> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af4d3d4b43bba61b878804856808198e6">isZeroValue</a> (_Tp v, _Tp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">method returns whether a given variable is equal to zero.  <a href="#af4d3d4b43bba61b878804856808198e6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aee0c918231d83e719101cb150133a3a6"></a><!-- doxytag: member="ito::isZeroValue" ref="aee0c918231d83e719101cb150133a3a6" args="(float32 v, float32 epsilon)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isZeroValue</b> (float32 v, float32 epsilon)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a606c101d2a0ebf367b4d862701fc38fe"></a><!-- doxytag: member="ito::isZeroValue" ref="a606c101d2a0ebf367b4d862701fc38fe" args="(float64 v, float64 epsilon)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isZeroValue</b> (float64 v, float64 epsilon)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aaec9cf0f60fc8526da8569e4ff040d89"></a><!-- doxytag: member="ito::isZeroValue" ref="aaec9cf0f60fc8526da8569e4ff040d89" args="(std::complex&lt; ito::float32 &gt; v, std::complex&lt; ito::float32 &gt; epsilon)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isZeroValue</b> (std::complex&lt; ito::float32 &gt; v, std::complex&lt; ito::float32 &gt; epsilon)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f8d0210c6e22d340b1dfd7f9e6129b9"></a><!-- doxytag: member="ito::isZeroValue" ref="a1f8d0210c6e22d340b1dfd7f9e6129b9" args="(std::complex&lt; ito::float64 &gt; v, std::complex&lt; ito::float64 &gt; epsilon)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isZeroValue</b> (std::complex&lt; ito::float64 &gt; v, std::complex&lt; ito::float64 &gt; epsilon)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6af758f942701d80f2531249158bb33d">checkParamVector</a> (QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *params)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">checks param vector  <a href="#a6af758f942701d80f2531249158bb33d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8d4bb116538f127474d6353604b88a55">checkParamVectors</a> (QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramsMand, QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramsOpt, QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramsOut)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">verifies that the three param vectors are not NULL  <a href="#a8d4bb116538f127474d6353604b88a55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_param.html">ito::Param</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae5f62de950023c3db6e6f899aacc6bd3">getParamByName</a> (QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramVec, const char *name, <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> *retval)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">brief returns a parameter from the parameter-vector, that fits to a specific name  <a href="#ae5f62de950023c3db6e6f899aacc6bd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0d71bc40c115fde2a2b47a8c2abe488"></a><!-- doxytag: member="ito::getParamByName" ref="ab0d71bc40c115fde2a2b47a8c2abe488" args="(QVector&lt; ito::ParamBase &gt; *paramVec, const char *name, ito::RetVal *retval)" -->
<a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getParamByName</b> (QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *paramVec, const char *name, <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> *retval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb88bcfd3147001e6a36a9eddbe6579d"></a><!-- doxytag: member="ito::createParamHashTable" ref="afb88bcfd3147001e6a36a9eddbe6579d" args="(QVector&lt; ito::Param &gt; *paramVec)" -->
QHash&lt; QString, <a class="el" href="classito_1_1_param.html">ito::Param</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>createParamHashTable</b> (QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramVec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1b0714f8537fa3fdb60e6e22adc512b"></a><!-- doxytag: member="ito::checkNumericParamRange" ref="af1b0714f8537fa3fdb60e6e22adc512b" args="(const ito::Param &amp;param, double value, bool *ok)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>checkNumericParamRange</b> (const <a class="el" href="classito_1_1_param.html">ito::Param</a> &amp;param, double value, bool *ok)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa04aa3b9e14f6debb9131b6ef5240bf4"></a><!-- doxytag: member="ito::getParamValue" ref="aa04aa3b9e14f6debb9131b6ef5240bf4" args="(const QMap&lt; QString, Param &gt; *m_params, const QString &amp;key, ito::Param &amp;val, QString &amp;pkey, int &amp;index)" -->
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getParamValue</b> (const QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *m_params, const QString &amp;key, <a class="el" href="classito_1_1_param.html">ito::Param</a> &amp;val, QString &amp;pkey, int &amp;index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb8d82ddf3963ec68207576239e7c2f9"></a><!-- doxytag: member="ito::paramHelperSetValue" ref="adb8d82ddf3963ec68207576239e7c2f9" args="(ito::Param &amp;param, ito::ParamBase value, const int pos)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>paramHelperSetValue</b> (<a class="el" href="classito_1_1_param.html">ito::Param</a> &amp;param, <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> value, const int pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a705fb524799593c507398e9fed2f7a90"></a><!-- doxytag: member="ito::setParamValue" ref="a705fb524799593c507398e9fed2f7a90" args="(const QMap&lt; QString, Param &gt; *m_params, const QString &amp;key, const ito::ParamBase val, QString &amp;pkey, int &amp;index)" -->
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>setParamValue</b> (const QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *m_params, const QString &amp;key, const <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> val, QString &amp;pkey, int &amp;index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aea20a9bf1563f8642db8062c912b2b2c">parseParamName</a> (const QString &amp;name, QString &amp;paramName, bool &amp;hasIndex, int &amp;index, QString &amp;additionalTag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">parses parameter name with respect to regular expression, assigned for parameter-communcation with plugins  <a href="#aea20a9bf1563f8642db8062c912b2b2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a547629916973cfd68be44a11887aa45a">formatDoubleWithUnit</a> (QStringList scaleThisUnitsOnly, QString unitIn, double dVal, double &amp;dValOut, QString &amp;unitOut)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Function to convert double values with unit to scaled values with scaled units (0.01m -&gt; 10mm)  <a href="#a547629916973cfd68be44a11887aa45a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a7613132614d1cd6eb29278ceed6cdf60">generateAutoSaveParamFile</a> (QString plugInName, QFile &amp;paramFile)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">loadXML2QLIST loads parameters from an XML-File and saves them to paramList  <a href="#a7613132614d1cd6eb29278ceed6cdf60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#af3ff1acd7b8b3e2140db87852be40b77">loadXML2QLIST</a> (QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *paramList, QString id, QFile &amp;paramFile)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a1f0f29281bc5cb69fcd9759a369b09eb">saveQLIST2XML</a> (QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *paramList, QString id, QFile &amp;paramFile)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a487ae8b7490f1de2f8c400eab1859f58">mergeQLists</a> (QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *oldList, QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *newList, bool checkAutoSave, bool deleteUnchangedParams)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a09c6b2139e9995dabe2dbbabd25bab48">writeObjectHeaderToFileV1</a> (QXmlStreamWriter &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut, bool doubleAsBinary, int &amp;elementsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function writes the header of the Object to the xml stream.  This helper function writes the header (dims, sizes, type) of an object and the metaData (complete <a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a> without tagsMap) from the Object to the xml stream. The values of the header are stored as string. The values of each axis-tag / value-tag / rotation matrix are in case of string-type directly written to the stream or in case of double converted to either strings directly (15 significat digits, &gt;32Bit) or stored as lostfree binary (QByteArray::toBase64() to avoid XML-conflict). WARNING: Do not change the header (dims, sizes, type) information or the value of tags exported as binary (d2b).  <a href="#a09c6b2139e9995dabe2dbbabd25bab48"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aad6e1f7022d1f9024c771f51f01f78da">writeObjectTagsToFileV1</a> (QXmlStreamWriter &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut, bool doubleAsBinary)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function writes the tags defined in the tagMap (<a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) from the Object to the xml stream.  This helper function writes the tags defined in the tagMap (<a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) from the Object to the xml stream. Therefore the values of each tag are in case of string-type directly written to the stream or in case of double converted to either strings directly (15 significat digits, &gt;32Bit) or stored as lostfree binary (QByteArray::toBase64() to avoid XML-conflict). WARNING: Do not change information or the value of tags exported as binary (d2b).  <a href="#aad6e1f7022d1f9024c771f51f01f78da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#af96b552c35539676c8a13957de2183ad">writeObjectDataToFileV1</a> (QXmlStreamWriter &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut, int elementsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function writes the data(cv::mats) from the Object to the xml stream.  This helper function writes the data(cv::mats) from the Object to the xml stream. Therefore the data is converted using QByteArray::toBase64() to avoid XML-conflict with the binary data.  <a href="#af96b552c35539676c8a13957de2183ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a97681943d7ef8d66beeac1e332ce3a46">saveDOBJ2XML</a> (<a class="el" href="classito_1_1_data_object.html">ito::DataObject</a> *dObjOut, QString folderFileName, bool onlyHeaderObjectFile=false, bool doubleAsBinary=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Import a dataObject from harddrive, saved in the ITO-XML-Format (.ido or .idh)  <a href="#a97681943d7ef8d66beeac1e332ce3a46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#afecd6942c1876cc35f42046db0a098ea">readTillNext</a> (QXmlStreamReader &amp;stream, int &amp;times, int maxtimes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function reads the stream till the next startElement.  The Qt-Function readNextStartElement sometimes stops at the end-element (:P). So the function tries to read until it reaches the next startelement but only for maxtimes trys the Function checks if the attribute exists and than tries to convert to the value of the attribute either from binary or with string to double functions.  <a href="#afecd6942c1876cc35f42046db0a098ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae98bfefe271214ccda435c4be975f5e4">readDoubleFromXML</a> (QXmlStreamAttributes &amp;attrStream, QString &amp;Element, QString &amp;Attrib, double &amp;val, bool isBinary)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function extracts a double from the xml-Attributes of the Stream  This helper function extracts a double from the xml-Attributes of the Stream copied by the caller with the attrStream = attrStream = stream.attributes();. the Function checks if the attribute exists and than tries to convert to the value of the attribute either from binary or with string to double functions.  <a href="#ae98bfefe271214ccda435c4be975f5e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa3fb95bb073f0055c98ee99e91b9c22a">readStdStringFromXML</a> (QXmlStreamAttributes &amp;attrStream, QString &amp;Element, QString &amp;Attrib, std::string &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function extracts a std::string from the xml-Attributes of the Stream  This helper function extracts a std::string from the xml-Attributes of the Stream copied by the caller with the attrStream = attrStream = stream.attributes();. the Function checks if the attribute exists and than tries to convert to the value of the attribute from QString to std::string.  <a href="#aa3fb95bb073f0055c98ee99e91b9c22a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a49a8ffb4244dbc37882593e3ae344e74">createObjectFromXMLV1</a> (QXmlStreamReader &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObjIn, int &amp;elementsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates an dataObject from the header of the xml-file  This function creates an dataObject from the header of the xml-file by parsing the XML-stream. The first start element, already read by the calling function must contain the attributes dims, dataType and dim0..dimn-2, dimX, dimY.  <a href="#a49a8ffb4244dbc37882593e3ae344e74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a99b23c44aedc092db34847ec3d850a7c">loadObjectHeaderFromXMLV1</a> (QXmlStreamReader &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObjIn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fills the MetaData (<a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) of an allocated dataObject from the values of an xml-file  This function fills the MetaData (<a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) of an allocated dataObject from the values of an xml-file. This includes the axis-Tags (offset, scale, unit, description), value-Tags ((offset), (scale), unit, description) and the rotation matrix. It does not include the tag-Space (std::map&lt;std::string, DataObjectTagType&gt; m_tags) (e.g. protocol ...)  <a href="#a99b23c44aedc092db34847ec3d850a7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a4132d915f47775d5edcab7874885c27d">loadTagSpaceFromXMLV1</a> (QXmlStreamReader &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObjIn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fills the tagsSpace (<a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) of an allocated dataObject from the values of an xml-file  This function fills the tagsSpace (<a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) of an allocated dataObject from the values of an xml-file. This onlye includes the tag-Space (std::map&lt;std::string, DataObjectTagType&gt; m_tags) (e.g. protocol ...) and does not include the axis-Tags (offset, scale, unit, description), value-Tags ((offset), (scale), unit, description) and the rotation matrix.  <a href="#a4132d915f47775d5edcab7874885c27d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a43463b798f2244f8f380ff8af5337c20">loadDataFromXMLV1</a> (QXmlStreamReader &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObjIn, int elementsize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies the CDATA from the xml-file to the allocated dataObject.  This function copies the CDATA from the xml-file to the allocated dataObject. The data was before packed (substitution of xml-registered characters) during saving and is unpacked here. The data is stored plane-wise. The function checks if the plane-size if the object is equal to the imported size.  <a href="#a43463b798f2244f8f380ff8af5337c20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6a50711849b55cee9dfdee5224190d31">loadXML2DOBJ</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjIn, QString folderFileName, bool onlyHeaderObjectFile, bool appendEnding)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8a14cb896d5f721aab6c53ccff51c15"></a><!-- doxytag: member="ito::loadXML2QLIST" ref="ab8a14cb896d5f721aab6c53ccff51c15" args="(QMap&lt; QString, ito::Param &gt; *paramList, QString id, QFile &amp;paramFile)" -->
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab8a14cb896d5f721aab6c53ccff51c15">loadXML2QLIST</a> (QMap&lt; QString, <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramList, QString id, QFile &amp;paramFile)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">saveQLIST2XML writes parameters from paramList to an XML-File <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bbab1bb0dc4972da988584d2cb28b95"></a><!-- doxytag: member="ito::saveQLIST2XML" ref="a8bbab1bb0dc4972da988584d2cb28b95" args="(QMap&lt; QString, ito::Param &gt; *paramList, QString id, QFile &amp;paramFile)" -->
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8bbab1bb0dc4972da988584d2cb28b95">saveQLIST2XML</a> (QMap&lt; QString, <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramList, QString id, QFile &amp;paramFile)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">mergeQLists copies parameters from newList to oldList and performs some checks <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a404685e92b5b40136969bf4c6a622e82"></a><!-- doxytag: member="ito::mergeQLists" ref="a404685e92b5b40136969bf4c6a622e82" args="(QMap&lt; QString, ito::Param &gt; *oldList, QMap&lt; QString, ito::Param &gt; *newList, bool checkAutoSave, bool deleteUnchangedParams=false)" -->
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a404685e92b5b40136969bf4c6a622e82">mergeQLists</a> (QMap&lt; QString, <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *oldList, QMap&lt; QString, <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *newList, bool checkAutoSave, bool deleteUnchangedParams=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a dataObject to harddrive in a readable ITO-XML-Format (.ido or .idh) <br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af488d39d5fa87dd219cda2bf3d4ccd4f"></a><!-- doxytag: member="ito::ITOM_API_FUNCS" ref="af488d39d5fa87dd219cda2bf3d4ccd4f" args="" -->
void **&#160;</td><td class="memItemRight" valign="bottom"><b>ITOM_API_FUNCS</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><b>ITOM_API_FUNCS_ARR</b> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacfb5faee5617334d20f8ff0c2974069"></a><!-- doxytag: member="ito::ITOM_API_FUNCS_GRAPH" ref="aacfb5faee5617334d20f8ff0c2974069" args="" -->
void **&#160;</td><td class="memItemRight" valign="bottom"><b>ITOM_API_FUNCS_GRAPH</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><b>ITOM_API_FUNCS_GRAPH_ARR</b> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static tCoutFunc&#160;</td><td class="memItemRight" valign="bottom"><b>fListCout</b> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a568df211be05e76f53d2262087e4b0b6"></a><!-- doxytag: member="ito::paramFlagMask" ref="a568df211be05e76f53d2262087e4b0b6" args="" -->
const uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a568df211be05e76f53d2262087e4b0b6">paramFlagMask</a> = 0xFFFF0000</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">bits of type lying within this mask are flags (e.g. typeNoAutosave, typeReadonly...) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9158b33ef1d02a45a7d603ed6ad0906"></a><!-- doxytag: member="ito::paramTypeMask" ref="ad9158b33ef1d02a45a7d603ed6ad0906" args="" -->
const uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad9158b33ef1d02a45a7d603ed6ad0906">paramTypeMask</a> = 0x0000FFFF</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">bits of param type lying withing this mask describe the type (typeNoAutosave must be included there) <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>&lt; this is for the plugin param save / load</p>
<p>&lt; this is for the dataobject save / load </p>
</div><hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a20bda469be01178ac6cf406bcba2ee73"></a><!-- doxytag: member="ito::tAutoLoadPolicy" ref="a20bda469be01178ac6cf406bcba2ee73" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a20bda469be01178ac6cf406bcba2ee73">ito::tAutoLoadPolicy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a20bda469be01178ac6cf406bcba2ee73a8ec2058becac1ccaae65864d6f961cdf"></a><!-- doxytag: member="autoLoadAlways" ref="a20bda469be01178ac6cf406bcba2ee73a8ec2058becac1ccaae65864d6f961cdf" args="" -->autoLoadAlways</em>&nbsp;</td><td>
<p>always loads xml file by addInManager </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a20bda469be01178ac6cf406bcba2ee73ad39587830e30b302adc4421224049c28"></a><!-- doxytag: member="autoLoadNever" ref="a20bda469be01178ac6cf406bcba2ee73ad39587830e30b302adc4421224049c28" args="" -->autoLoadNever</em>&nbsp;</td><td>
<p>never automatically loads parameters from xml-file (default) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a20bda469be01178ac6cf406bcba2ee73a4c932e4379045955c6194e202c0b6b2d"></a><!-- doxytag: member="autoLoadKeywordDefined" ref="a20bda469be01178ac6cf406bcba2ee73a4c932e4379045955c6194e202c0b6b2d" args="" -->autoLoadKeywordDefined</em>&nbsp;</td><td>
<p>only loads parameters if keyword autoLoadParams=1 exists in python-constructor </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d769b26bbab936560f4c95674ff5477"></a><!-- doxytag: member="ito::tAutoSavePolicy" ref="a8d769b26bbab936560f4c95674ff5477" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a8d769b26bbab936560f4c95674ff5477">ito::tAutoSavePolicy</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a8d769b26bbab936560f4c95674ff5477a9ca1d2e8fbcc5c11e86bd24fcdec9e50"></a><!-- doxytag: member="autoSaveAlways" ref="a8d769b26bbab936560f4c95674ff5477a9ca1d2e8fbcc5c11e86bd24fcdec9e50" args="" -->autoSaveAlways</em>&nbsp;</td><td>
<p>always saves parameters to xml-file at shutdown </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a8d769b26bbab936560f4c95674ff5477a977bb0b86cfdfa0e8486241790087703"></a><!-- doxytag: member="autoSaveNever" ref="a8d769b26bbab936560f4c95674ff5477a977bb0b86cfdfa0e8486241790087703" args="" -->autoSaveNever</em>&nbsp;</td><td>
<p>never saves parameters to xml-file at shutdown (default) </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdba"></a><!-- doxytag: member="ito::tDataType" ref="acc7eee7faabd3db8463dc9b7922afdba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DataType enumeration This enum holds the possible values for <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> matrices. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa35aa1b8e08158b49ebbf6bdfb4b6a508"></a><!-- doxytag: member="tInt8" ref="acc7eee7faabd3db8463dc9b7922afdbaa35aa1b8e08158b49ebbf6bdfb4b6a508" args="" -->tInt8</em>&nbsp;</td><td>
<p>integer, 8bit </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaad21eb4541e782dc23501912f788a38bd"></a><!-- doxytag: member="tUInt8" ref="acc7eee7faabd3db8463dc9b7922afdbaad21eb4541e782dc23501912f788a38bd" args="" -->tUInt8</em>&nbsp;</td><td>
<p>unsigned integer, 8bit </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa142219f864f22d3b2e6f116f5f5cd936"></a><!-- doxytag: member="tInt16" ref="acc7eee7faabd3db8463dc9b7922afdbaa142219f864f22d3b2e6f116f5f5cd936" args="" -->tInt16</em>&nbsp;</td><td>
<p>integer, 16bit </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa68d7e991164d07a036f40379a101112b"></a><!-- doxytag: member="tUInt16" ref="acc7eee7faabd3db8463dc9b7922afdbaa68d7e991164d07a036f40379a101112b" args="" -->tUInt16</em>&nbsp;</td><td>
<p>unsigned integer, 16bit </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa47b295973c6b4b7de62599401c16df62"></a><!-- doxytag: member="tInt32" ref="acc7eee7faabd3db8463dc9b7922afdbaa47b295973c6b4b7de62599401c16df62" args="" -->tInt32</em>&nbsp;</td><td>
<p>integer, 32bit </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaaf08334798ddd5082595350b296a7a868"></a><!-- doxytag: member="tUInt32" ref="acc7eee7faabd3db8463dc9b7922afdbaaf08334798ddd5082595350b296a7a868" args="" -->tUInt32</em>&nbsp;</td><td>
<p>unsigned integer, 32bit (not fully supported) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa17ad621a0158b30fc85eb1e89b93ce3b"></a><!-- doxytag: member="tFloat32" ref="acc7eee7faabd3db8463dc9b7922afdbaa17ad621a0158b30fc85eb1e89b93ce3b" args="" -->tFloat32</em>&nbsp;</td><td>
<p>float, 32bit </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa6b9559a5cfa765160ae209ecdc258ed6"></a><!-- doxytag: member="tFloat64" ref="acc7eee7faabd3db8463dc9b7922afdbaa6b9559a5cfa765160ae209ecdc258ed6" args="" -->tFloat64</em>&nbsp;</td><td>
<p>double (64bit) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa722b93c77819223b8d630ab0fca5a0ec"></a><!-- doxytag: member="tComplex64" ref="acc7eee7faabd3db8463dc9b7922afdbaa722b93c77819223b8d630ab0fca5a0ec" args="" -->tComplex64</em>&nbsp;</td><td>
<p>complex value with real and imaginary part of type float32 </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa39fef9b8e46915c6ba232020e2fe2e7a"></a><!-- doxytag: member="tComplex128" ref="acc7eee7faabd3db8463dc9b7922afdbaa39fef9b8e46915c6ba232020e2fe2e7a" args="" -->tComplex128</em>&nbsp;</td><td>
<p>complex value with real and imaginary part of type float64 </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a43f8ec3cdde4591a8ea77f4faf569773"></a><!-- doxytag: member="ito::tLogLevel" ref="a43f8ec3cdde4591a8ea77f4faf569773" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a43f8ec3cdde4591a8ea77f4faf569773">ito::tLogLevel</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>LogLevel enumeration This enum holds all possible LogLevel values </p>

</div>
</div>
<a class="anchor" id="a8811ca8b85b70b969122b25a7c84e0ee"></a><!-- doxytag: member="ito::tMsgType" ref="a8811ca8b85b70b969122b25a7c84e0ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a8811ca8b85b70b969122b25a7c84e0ee">ito::tMsgType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>MsgType enumeration This enum holds the possible values for any message type (for qDebugStream e.g.) </p>

</div>
</div>
<a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360e"></a><!-- doxytag: member="ito::tPCLPointType" ref="a71867bc7a24c8fcb06b8cf63f5a3360e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360e">ito::tPCLPointType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>PCLPointType enumeration This enum holds the possible values for point types supported by the wrapper of the point-cloud library in itom. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360eaa2585c0961b5f357d98ed732c17b9359"></a><!-- doxytag: member="pclInvalid" ref="a71867bc7a24c8fcb06b8cf63f5a3360eaa2585c0961b5f357d98ed732c17b9359" args="" -->pclInvalid</em>&nbsp;</td><td>
<p>invalid point </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360ea6273432d3a0ca503e1a77d27ad8ab994"></a><!-- doxytag: member="pclXYZ" ref="a71867bc7a24c8fcb06b8cf63f5a3360ea6273432d3a0ca503e1a77d27ad8ab994" args="" -->pclXYZ</em>&nbsp;</td><td>
<p>point with x,y,z-value </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360ea6385e470bdc9a9e3aead145eb0ded4d8"></a><!-- doxytag: member="pclXYZI" ref="a71867bc7a24c8fcb06b8cf63f5a3360ea6385e470bdc9a9e3aead145eb0ded4d8" args="" -->pclXYZI</em>&nbsp;</td><td>
<p>point with x,y,z and intensity value </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360eaefd9ce8422846a24673536424375f223"></a><!-- doxytag: member="pclXYZRGBA" ref="a71867bc7a24c8fcb06b8cf63f5a3360eaefd9ce8422846a24673536424375f223" args="" -->pclXYZRGBA</em>&nbsp;</td><td>
<p>point with x,y,z and r,g,b,a </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360ea5f6680f5c10ff985f0be8ce06780e16a"></a><!-- doxytag: member="pclXYZNormal" ref="a71867bc7a24c8fcb06b8cf63f5a3360ea5f6680f5c10ff985f0be8ce06780e16a" args="" -->pclXYZNormal</em>&nbsp;</td><td>
<p>point with x,y,z value, its normal vector nx,ny,nz and a curvature value </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360ea9c19394acf64356ecfc0ed60bc6c8b52"></a><!-- doxytag: member="pclXYZINormal" ref="a71867bc7a24c8fcb06b8cf63f5a3360ea9c19394acf64356ecfc0ed60bc6c8b52" args="" -->pclXYZINormal</em>&nbsp;</td><td>
<p>point with the same values than pclXYZNormal and an additional intensity value </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360ea6dd64651a1b85540ac80b6efa5eeb738"></a><!-- doxytag: member="pclXYZRGBNormal" ref="a71867bc7a24c8fcb06b8cf63f5a3360ea6dd64651a1b85540ac80b6efa5eeb738" args="" -->pclXYZRGBNormal</em>&nbsp;</td><td>
<p>point with x,y,z and r,g,b and normal vector (including curvature) </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8f52a66afae16e3bb3802d701859fcf"></a><!-- doxytag: member="ito::tPluginLoadStatusFlag" ref="ae8f52a66afae16e3bb3802d701859fcf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcf">ito::tPluginLoadStatusFlag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>PluginLoadStatusFlag enumeration This enum holds the four possible return states for loaded DLLs Ok, Warning, Error and Ignored </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae8f52a66afae16e3bb3802d701859fcfa0c084ed64a1e58022675c2855494b904"></a><!-- doxytag: member="plsfOk" ref="ae8f52a66afae16e3bb3802d701859fcfa0c084ed64a1e58022675c2855494b904" args="" -->plsfOk</em>&nbsp;</td><td>
<p>ok </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae8f52a66afae16e3bb3802d701859fcfae886791877d339615c79aed5c21d35f0"></a><!-- doxytag: member="plsfWarning" ref="ae8f52a66afae16e3bb3802d701859fcfae886791877d339615c79aed5c21d35f0" args="" -->plsfWarning</em>&nbsp;</td><td>
<p>warning </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae8f52a66afae16e3bb3802d701859fcfa89928bf15c88b96936c0f981580994ba"></a><!-- doxytag: member="plsfError" ref="ae8f52a66afae16e3bb3802d701859fcfa89928bf15c88b96936c0f981580994ba" args="" -->plsfError</em>&nbsp;</td><td>
<p>error </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae8f52a66afae16e3bb3802d701859fcfa8e51ce1381d3ccf924b2b6152b554f88"></a><!-- doxytag: member="plsfIgnored" ref="ae8f52a66afae16e3bb3802d701859fcfa8e51ce1381d3ccf924b2b6152b554f88" args="" -->plsfIgnored</em>&nbsp;</td><td>
<p>ignored </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d8b8f2858876413dd8728084943ab30"></a><!-- doxytag: member="ito::tPluginType" ref="a3d8b8f2858876413dd8728084943ab30" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30">ito::tPluginType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>tPluginType enumeration used to describe the plugin type and subtype (in case of DataIO main type) e.g. typeDataIO|typeGrabber for a frame grabber </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a3d8b8f2858876413dd8728084943ab30a4cab6a4edc95b2ef6846c79aedd818cb"></a><!-- doxytag: member="typeDataIO" ref="a3d8b8f2858876413dd8728084943ab30a4cab6a4edc95b2ef6846c79aedd818cb" args="" -->typeDataIO</em>&nbsp;</td><td>
<p>base type for data input and output (cameras, AD-converter, display windows...) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3d8b8f2858876413dd8728084943ab30a67b1093d817ca4c45de9b4b1075045b1"></a><!-- doxytag: member="typeActuator" ref="a3d8b8f2858876413dd8728084943ab30a67b1093d817ca4c45de9b4b1075045b1" args="" -->typeActuator</em>&nbsp;</td><td>
<p>base type for actuators and motors </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3d8b8f2858876413dd8728084943ab30a8c028979c4b81e7eaa0a7f51e1e62d26"></a><!-- doxytag: member="typeAlgo" ref="a3d8b8f2858876413dd8728084943ab30a8c028979c4b81e7eaa0a7f51e1e62d26" args="" -->typeAlgo</em>&nbsp;</td><td>
<p>base type for algorithm plugin </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3d8b8f2858876413dd8728084943ab30af4dfe66a7744cc365947716d5bdb9f6d"></a><!-- doxytag: member="typeGrabber" ref="a3d8b8f2858876413dd8728084943ab30af4dfe66a7744cc365947716d5bdb9f6d" args="" -->typeGrabber</em>&nbsp;</td><td>
<p>subtype of dataIO for cameras (grabbers), use this type in combination with typeDataIO (OR-combination) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3d8b8f2858876413dd8728084943ab30a95ac93a74aac433a17c998c1810e3e51"></a><!-- doxytag: member="typeADDA" ref="a3d8b8f2858876413dd8728084943ab30a95ac93a74aac433a17c998c1810e3e51" args="" -->typeADDA</em>&nbsp;</td><td>
<p>subtype of dataIO for AD and DA-converters, use this type in combination with typeDataIO (OR-combination) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3d8b8f2858876413dd8728084943ab30ad2e2fbe4821bac18934a307bd89428c2"></a><!-- doxytag: member="typeRawIO" ref="a3d8b8f2858876413dd8728084943ab30ad2e2fbe4821bac18934a307bd89428c2" args="" -->typeRawIO</em>&nbsp;</td><td>
<p>subtype of dataIO for further input-output-devices (like display windows), use this type in combination with typeDataIO (OR-combination) </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="af3656645e7f004701417ecdc79b10202"></a><!-- doxytag: member="ito::tRetValue" ref="af3656645e7f004701417ecdc79b10202" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202">ito::tRetValue</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>RetValue enumeration This enum holds the three possible return states Ok, Warning and Error </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af3656645e7f004701417ecdc79b10202a2ced39cc25866a04f2fb1c9f1d6a542e"></a><!-- doxytag: member="retOk" ref="af3656645e7f004701417ecdc79b10202a2ced39cc25866a04f2fb1c9f1d6a542e" args="" -->retOk</em>&nbsp;</td><td>
<p>ok </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af3656645e7f004701417ecdc79b10202a59b8253725a061086f085758a117002b"></a><!-- doxytag: member="retWarning" ref="af3656645e7f004701417ecdc79b10202a59b8253725a061086f085758a117002b" args="" -->retWarning</em>&nbsp;</td><td>
<p>warning </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af3656645e7f004701417ecdc79b10202a199f41b7779e742e0a3cc281c42c97c0"></a><!-- doxytag: member="retError" ref="af3656645e7f004701417ecdc79b10202a199f41b7779e742e0a3cc281c42c97c0" args="" -->retError</em>&nbsp;</td><td>
<p>error </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad4074d9dd3e2267c0a869416fb138576"></a><!-- doxytag: member="ito::abs" ref="ad4074d9dd3e2267c0a869416fb138576" args="(const DataObject &amp;dObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::abs </td>
          <td>(</td>
          <td class="paramtype">const DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level value which calculates the absolute value of each element of the input source data object and returns the resulting data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new data object with absolute values </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if unknown data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#ae7089fa30e7e66b8d57438c07b7c644b" title="low-level, double templated method to save the element-wise absolute value of each element in source ...">AbsFunc</a>, <a class="el" href="namespaceito.html#a3f34b4f966d79c5eadb25216a4950620" title="low-level, templated method to save the element-wise absolute value of each element in source matrix ...">AbsFuncReal</a></dd></dl>
<p>calculates the absolute values of each element in the given data object and returns the result as new data object </p>

</div>
</div>
<a class="anchor" id="ae7089fa30e7e66b8d57438c07b7c644b"></a><!-- doxytag: member="ito::AbsFunc" ref="ae7089fa30e7e66b8d57438c07b7c644b" args="(const DataObject *dObj, DataObject *resObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CmplxTp , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::AbsFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>resObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, double templated method to save the element-wise absolute value of each element in source matrix to result matrix </p>
<p>This method takes the absolute value of a complex valued input matrix and stores it in the equivalent real typed result matrix</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is source matrix, must have complex type </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the resulting data object, which has the real data type which corresponds to the complex type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>std::abs </dd></dl>

</div>
</div>
<a class="anchor" id="a3f34b4f966d79c5eadb25216a4950620"></a><!-- doxytag: member="ito::AbsFuncReal" ref="a3f34b4f966d79c5eadb25216a4950620" args="(const DataObject *dObj, DataObject *resObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::AbsFuncReal </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>resObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method to save the element-wise absolute value of each element in source matrix to result matrix </p>
<p>This method takes the absolute value of a real typed input matrix and stores it in the equivalent real typed result matrix</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is source matrix, must have real value </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the resulting data object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>std::abs </dd></dl>

</div>
</div>
<a class="anchor" id="ae16131a91987cc5836aaf3f3918319b4"></a><!-- doxytag: member="ito::AddFunc" ref="ae16131a91987cc5836aaf3f3918319b4" args="(const DataObject *dObj1, const DataObject *dObj2, DataObject *dObjRes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::AddFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for element-wise addition of two given data objects. </p>
<p>dObjRes = dObj1 + dObj2</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj1</td><td>is the first data object </td></tr>
    <tr><td class="paramname">*dObj2</td><td>is the second data object </td></tr>
    <tr><td class="paramname">*dObjRes</td><td>is the pointer to the data object, where the values will be written to. This data object must already be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The size check for all data objects must be done before. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>operator +=, operator + </dd></dl>

</div>
</div>
<a class="anchor" id="abea3cec515d7dfc29dd5a2ac1002c7e6"></a><!-- doxytag: member="ito::AdjustROIFunc" ref="abea3cec515d7dfc29dd5a2ac1002c7e6" args="(DataObject *dObj, int dtop, int dbottom, int dleft, int dright)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::AdjustROIFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dbottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dright</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for adjusting the ROI of a data object by the given incremental values </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is the data object, whose boundaries should be adjusted </td></tr>
    <tr><td class="paramname">dtop</td><td>- The shift of the top submatrix boundary upwards (positive value means upwards) </td></tr>
    <tr><td class="paramname">dbottom</td><td>- The shift of the bottom submatrix boundary downwards (positive value means downwards) </td></tr>
    <tr><td class="paramname">dleft</td><td>- The shift of the left submatrix boundary to the left (positive value means to the left) </td></tr>
    <tr><td class="paramname">dright</td><td>- The shift of the right submatrix boundary to the right (positive value means to the right) </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>for any n-dimensional data object, the ROI of every matrix-plane is adjusted, even if any specific matrix-plane is temporarily not inside of the ROI </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a87c024c43b3d17174e8f0b14fdc09cd6"></a><!-- doxytag: member="ito::apiFCheckAndSetParamVal" ref="a87c024c43b3d17174e8f0b14fdc09cd6" args="(QVariant *tempParam, ito::ParamBase *param, int *set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::apiFCheckAndSetParamVal </td>
          <td>(</td>
          <td class="paramtype">QVariant *&#160;</td>
          <td class="paramname"><em>tempParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper function to check and set initialisation parameters in the initialisation parameter list </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tempParam</td><td>QVariant holding the value to set </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">param</td><td>the param in the parameter list, that is set </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">set</td><td>indicator whether the parameter was set or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk on success, retError otherwise</dd></dl>
<p>The function checks if the types of the passed python parameter and the parameter are compatible and sets the parameter value if it is possible. If the paramter cannot be set an error is returned. </p>

</div>
</div>
<a class="anchor" id="aba757c479378ddaa7db70850c6590f3c"></a><!-- doxytag: member="ito::apiFParseInitParams" ref="aba757c479378ddaa7db70850c6590f3c" args="(QVector&lt; ito::ParamBase &gt; *initParamListMand, QVector&lt; ito::ParamBase &gt; *initParamListOpt, QVector&lt; QVariant &gt; *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::apiFParseInitParams </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *&#160;</td>
          <td class="paramname"><em>initParamListMand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *&#160;</td>
          <td class="paramname"><em>initParamListOpt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; QVariant &gt; *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function to read mandatory and optional parameter lists from a given python parameter list according to the plugins definition </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">initParamListMand</td><td>vector holding the mandatory initialisation parameters (filled with default values), the default values are overwritten with the passed values </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">initParamListOpt</td><td>vector holding the optional initialisation parameters (filled with default values), the default values are overwritten with the passed values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>list with python arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kwds</td><td>list with named python arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns <a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a2ced39cc25866a04f2fb1c9f1d6a542e">ito::retOk</a> if the number and type of parameters was correct, <a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a199f41b7779e742e0a3cc281c42c97c0">ito::retError</a> otherwise</dd></dl>
<p>The function takes as input the vectors with the madatory and optional input parameters used for the plugin initialisation. These vectors must be previously be read using the function getInitParams. The default values of the parameters are overwritten with the values given by python. In case the number or parameters or a parameter type is incorrect the function will abort with an error. </p>

</div>
</div>
<a class="anchor" id="a1c335baddf31bc92594dc3c0694d63ff"></a><!-- doxytag: member="ito::arg" ref="a1c335baddf31bc92594dc3c0694d63ff" args="(const DataObject &amp;dObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::arg </td>
          <td>(</td>
          <td class="paramtype">const DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level value which calculates the argument value of each element of the input source data object and returns the resulting data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new data object with argument values </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if undefined data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a0e126a9e14968fd29e231b9efab55a3b" title="low-level, double templated method to save the element-wise argument of each element in source matrix...">ArgFunc</a></dd></dl>
<p>calculates the argument of each element in the given data object and returns the result as new data object </p>

</div>
</div>
<a class="anchor" id="a0e126a9e14968fd29e231b9efab55a3b"></a><!-- doxytag: member="ito::ArgFunc" ref="a0e126a9e14968fd29e231b9efab55a3b" args="(const DataObject *dObj, DataObject *resObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CmplxTp , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ArgFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>resObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, double templated method to save the element-wise argument of each element in source matrix to result matrix </p>
<p>This method takes the element-wise argument of a complex valued input matrix and stores it in the equivalent real typed result matrix</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is source matrix, must have complex type </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the resulting data object, which has the real data type which corresponds to the complex type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>std::abs </dd></dl>

</div>
</div>
<a class="anchor" id="a7a6fe8474818648fbd90616fcf518eef"></a><!-- doxytag: member="ito::AssignScalarFunc" ref="a7a6fe8474818648fbd90616fcf518eef" args="(const DataObject *src, const ito::tDataType type, const void *scalar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::AssignScalarFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated helper method to assign the given scalar to every element within its ROI in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> src. </p>
<p>The scalar value is converted to the type of the source data object</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td>is the source data object whose elements will be modified </td></tr>
    <tr><td class="paramname">type</td><td>is the data type of the scalar value </td></tr>
    <tr><td class="paramname">*scalar</td><td>is a void pointer to the scalar value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::exception</td><td>if conversion of scalar to dataObject's type is not possible </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>numberConcversion </dd></dl>

</div>
</div>
<a class="anchor" id="af958d9bca56f7971bc30feac415bdaae"></a><!-- doxytag: member="ito::BitAndFunc" ref="af958d9bca56f7971bc30feac415bdaae" args="(const DataObject *dObj1, const DataObject *dObj2, DataObject *dObjRes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitAndFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which element-wisely executes a bitwise 'and' comparison between values of two dataObjects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj1</td><td>is the first data object </td></tr>
    <tr><td class="paramname">*dObj2</td><td>is the second data object </td></tr>
    <tr><td class="paramname">*dObjRes</td><td>is the data object, where the result is stored </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>for unsupported data types (template specialization) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="afc2da43a120dd1da62b1d0dfac9ed4b1"></a><!-- doxytag: member="ito::BitAndFunc&lt; ito::complex128 &gt;" ref="afc2da43a120dd1da62b1d0dfac9ed4b1" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitAndFunc&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise and function of type complex128 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa80cc5a38859d11ae5b8b5d4f9c8c3c9"></a><!-- doxytag: member="ito::BitAndFunc&lt; ito::complex64 &gt;" ref="aa80cc5a38859d11ae5b8b5d4f9c8c3c9" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitAndFunc&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise and function of type complex64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab899e141a3847b1a7035c5e56332d6e9"></a><!-- doxytag: member="ito::BitAndFunc&lt; ito::float32 &gt;" ref="ab899e141a3847b1a7035c5e56332d6e9" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitAndFunc&lt; ito::float32 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise and function of type float32 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef3d086c4a7eed78b88a34ad1219dd06"></a><!-- doxytag: member="ito::BitAndFunc&lt; ito::float64 &gt;" ref="aef3d086c4a7eed78b88a34ad1219dd06" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitAndFunc&lt; ito::float64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise and function of type float64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f26f22cf37ce14606bd6dde853f1e8b"></a><!-- doxytag: member="ito::BitOrFunc" ref="a5f26f22cf37ce14606bd6dde853f1e8b" args="(const DataObject *dObj1, const DataObject *dObj2, DataObject *dObjRes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitOrFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which element-wisely executes a bitwise 'or' comparison between values of two dataObjects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj1</td><td>is the first data object </td></tr>
    <tr><td class="paramname">*dObj2</td><td>is the second data object </td></tr>
    <tr><td class="paramname">*dObjRes</td><td>is the data object, where the result is stored </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>for unsupported data types (template specialization) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a6bf39908f4328b8cf684b090560adb3a"></a><!-- doxytag: member="ito::BitOrFunc&lt; ito::complex128 &gt;" ref="a6bf39908f4328b8cf684b090560adb3a" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitOrFunc&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise or function of type complex128 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f4a9bac68a02e69f63828971fb69676"></a><!-- doxytag: member="ito::BitOrFunc&lt; ito::complex64 &gt;" ref="a6f4a9bac68a02e69f63828971fb69676" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitOrFunc&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise or function of type complex64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b0b5996a50ddcab865510a424d3d7a4"></a><!-- doxytag: member="ito::BitOrFunc&lt; ito::float32 &gt;" ref="a3b0b5996a50ddcab865510a424d3d7a4" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitOrFunc&lt; ito::float32 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise or function of type float32 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae82f393b489f72f5206cfe1fc7e43f93"></a><!-- doxytag: member="ito::BitOrFunc&lt; ito::float64 &gt;" ref="ae82f393b489f72f5206cfe1fc7e43f93" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitOrFunc&lt; ito::float64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise or function of type float64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e15e2fb2cba5fe01f96cc66b65c8345"></a><!-- doxytag: member="ito::BitXorFunc" ref="a7e15e2fb2cba5fe01f96cc66b65c8345" args="(const DataObject *dObj1, const DataObject *dObj2, DataObject *dObjRes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitXorFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which element-wisely executes a bitwise 'xor' comparison between values of two dataObjects. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj1</td><td>is the first data object </td></tr>
    <tr><td class="paramname">*dObj2</td><td>is the second data object </td></tr>
    <tr><td class="paramname">*dObjRes</td><td>is the data object, where the result is stored </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>for unsupported data types (template specialization) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="adf73d910b4e9d9c344b2b389f9973720"></a><!-- doxytag: member="ito::BitXorFunc&lt; ito::complex128 &gt;" ref="adf73d910b4e9d9c344b2b389f9973720" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitXorFunc&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise xor function of type complex128 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98551d38290fbe3f94b77ef58972dda8"></a><!-- doxytag: member="ito::BitXorFunc&lt; ito::complex64 &gt;" ref="a98551d38290fbe3f94b77ef58972dda8" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitXorFunc&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise xor function of type complex64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af127d3f60daba576c1b4245e96817e52"></a><!-- doxytag: member="ito::BitXorFunc&lt; ito::float32 &gt;" ref="af127d3f60daba576c1b4245e96817e52" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitXorFunc&lt; ito::float32 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise xor function of type float32 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55c68147de5f601fd5ea7b53735c5096"></a><!-- doxytag: member="ito::BitXorFunc&lt; ito::float64 &gt;" ref="a55c68147de5f601fd5ea7b53735c5096" args="(const DataObject *, const DataObject *, DataObject *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitXorFunc&lt; ito::float64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for bitwise xor function of type float64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82f12dc309c241c93ff581a406690e58"></a><!-- doxytag: member="ito::CastFunc" ref="a82f12dc309c241c93ff581a406690e58" args="(const DataObject *dObj, DataObject *resObj, double alpha, double beta)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CastFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>resObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level templated method to cast each element of source matrix to another type. </p>
<p>The result is stored in the result matrix. Optionally a scaling and offsetting is possible.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is the source data object </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the result data object </td></tr>
    <tr><td class="paramname">alpha</td><td>is the scaling factor (default 1.0) </td></tr>
    <tr><td class="paramname">beta</td><td>is the ofset value (default 0.0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if cast failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>cv::saturate_cast </dd></dl>

</div>
</div>
<a class="anchor" id="acaadeb5a84e7fa9f44207f4f6ea80a85"></a><!-- doxytag: member="ito::checkAndSetParamVal" ref="acaadeb5a84e7fa9f44207f4f6ea80a85" args="(PyObject *tempObj, ito::Param *param, int *set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::checkAndSetParamVal </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>tempObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_param.html">ito::Param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper function to check and set initialisation parameters in the initialisation parameter list </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tempObj</td><td>python object holding the value to set </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">param</td><td>the param in the parameter list, that is set </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">set</td><td>indicator whether the parameter was set or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk on success, retError otherwise</dd></dl>
<p>The function checks if the types of the passed python parameter and the parameter are compatible and sets the parameter value if it is possible. If the paramter cannot be set an error is returned. </p>

</div>
</div>
<a class="anchor" id="a90c5cf34449ff20eee13db30581826b2"></a><!-- doxytag: member="ito::checkDObjBppComp" ref="a90c5cf34449ff20eee13db30581826b2" args="(const int bpp, const int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ito::checkDObjBppComp </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>bpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper function used to check the type of a dataObject </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpp</td><td>expected bit depth of the framegrabber </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>dataObject data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if bpp and type are compatible, else -1</dd></dl>
<p>This function is used within the getVal method of the dataIO plugin. It checks if the data type of the dataObject passed and the data type of the framegrabber are "compatible". </p>

</div>
</div>
<a class="anchor" id="a6af758f942701d80f2531249158bb33d"></a><!-- doxytag: member="ito::checkParamVector" ref="a6af758f942701d80f2531249158bb33d" args="(QVector&lt; ito::Param &gt; *params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::checkParamVector </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>checks param vector </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>is a pointer to QVector&lt;ito::Param&gt;. This pointer is checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classito_1_1_ret_val.html" title="Class for error value management.">ito::RetVal</a>, that contains an error if params is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a8d4bb116538f127474d6353604b88a55"></a><!-- doxytag: member="ito::checkParamVectors" ref="a8d4bb116538f127474d6353604b88a55" args="(QVector&lt; ito::Param &gt; *paramsMand, QVector&lt; ito::Param &gt; *paramsOpt, QVector&lt; ito::Param &gt; *paramsOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::checkParamVectors </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramsMand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramsOpt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramsOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>verifies that the three param vectors are not NULL </p>
<p>If any of the given input parameters of type QVector&lt;ito::Param&gt;* are NULL, a <a class="el" href="classito_1_1_ret_val.html" title="Class for error value management.">ito::RetVal</a> is returned, that contains an error. Use this method in any algorithm-method in order to check the given input.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsMand</td><td>is the first parameter vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsOpt</td><td>is the second parameter vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsOut</td><td>is the third parameter vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classito_1_1_ret_val.html" title="Class for error value management.">ito::RetVal</a>, that contains an error if params is NULL </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a6af758f942701d80f2531249158bb33d" title="checks param vector">checkParamVector</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5dee1bec1740d52cf1ba8ff4dec6ae90"></a><!-- doxytag: member="ito::CmpFunc" ref="a5dee1bec1740d52cf1ba8ff4dec6ae90" args="(const DataObject *src1, const DataObject *src2, DataObject *dst, int cmpOp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CmpFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmpOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which compares each element in source-matrix1 with its corresponding element in source-matrix2 and saves the result in a destionation matrix </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*src1</td><td>is the first source matrix </td></tr>
    <tr><td class="paramname">*src2</td><td>is the second source matrix </td></tr>
    <tr><td class="paramname">*dst</td><td>is the destination matrix, which must have the same ROI than src1 and src2 and must be of type uint8 </td></tr>
    <tr><td class="paramname">cmpOp</td><td>is the compare operator (cv::CMP_EQ, cv::CMP_GT, cv::CMP_GE, cv::CMP_LT, cv::CMP_LE, cv::CMP_NE) </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>no comparison is possible for source matrices of type int8 (due to openCV-problems) </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if source matrix is of type int8 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="ad1f436259eb8eba0d9cbdc9fa0f375a4"></a><!-- doxytag: member="ito::CmpFunc&lt; ito::complex128 &gt;" ref="ad1f436259eb8eba0d9cbdc9fa0f375a4" args="(const DataObject *, const DataObject *, DataObject *, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CmpFunc&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for compare function of type complex128 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since comparison is not defined for complex input types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46383208b047fa54490f63567d1d1930"></a><!-- doxytag: member="ito::CmpFunc&lt; ito::complex64 &gt;" ref="a46383208b047fa54490f63567d1d1930" args="(const DataObject *, const DataObject *, DataObject *, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CmpFunc&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for compare function of type complex64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since comparison is not defined for complex input types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab29e3016de474b08d29924f0fffa7ad4"></a><!-- doxytag: member="ito::ColFunc" ref="ab29e3016de474b08d29924f0fffa7ad4" args="(DataObject *dObj, const unsigned int selCol)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ColFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>selCol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which changes the region of interest of the data object to the selected zero-based col index </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td></td></tr>
    <tr><td class="paramname">unsigned</td><td>int selCol indicates the zero-based col-index (considering any existing ROI) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="ab7900df15bdd04f8f3b229e3b03e126f"></a><!-- doxytag: member="ito::ConjFunc" ref="ab7900df15bdd04f8f3b229e3b03e126f" args="(DataObject *dObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ConjFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for calculating the conjugated value of each element within the ROI of this data object </p>
<p>This method is only valid for complex data types. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>avoid MatIterator </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if data type is not complex. This is done by template specialization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>std::conj </dd></dl>

</div>
</div>
<a class="anchor" id="a0f1e0516bec029992b462b17bf445618"></a><!-- doxytag: member="ito::convertCmplxTypeToRealType" ref="a0f1e0516bec029992b462b17bf445618" args="(ito::tDataType cmplxType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> ito::convertCmplxTypeToRealType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td>
          <td class="paramname"><em>cmplxType</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>static method which returns the real data object of any given data type </p>
<p>If the given data type is already real, the same type is returned. Else the type of the real argument of the given complex type is returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cmplxType</td><td>is the input data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>see method's description </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if the input data type is unknown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a008c12f351e9ca61ebdbb3522b94119e"></a><!-- doxytag: member="ito::ConvertToFunc" ref="a008c12f351e9ca61ebdbb3522b94119e" args="(const DataObject &amp;lhs, DataObject &amp;rhs, const int type, const double alpha, const double beta)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ConvertToFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts data in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> lhs to <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> rhs with a given type </p>
<p>Every element of the source data object is copied to the destionation data object by using this transformation<br/>
 elem_destination = static_cast&lt;newType&gt;(elem_source * alpha + beta)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;lhs</td><td>is the left-hand sided data object, whose data should be converted </td></tr>
    <tr><td class="paramname">&amp;rhs</td><td>is the destination data object, whose memory is firstly deleted, then newly allocated </td></tr>
    <tr><td class="paramname">type</td><td>is the type-number of the destination element </td></tr>
    <tr><td class="paramname">alpha</td><td>scaling factor (default: 1.0) </td></tr>
    <tr><td class="paramname">beta</td><td>offset value (default: 0.0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception(CV_StsAssert)</td><td>if conversion type is unknown </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>convertTo, <a class="el" href="namespaceito.html#a82f12dc309c241c93ff581a406690e58" title="low-level templated method to cast each element of source matrix to another type.">CastFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae443f37579ec5020b3885006d1ba3c4a"></a><!-- doxytag: member="ito::CopyMatFunc" ref="ae443f37579ec5020b3885006d1ba3c4a" args="(int **src, int **&amp;dst, bool transposed)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CopyMatFunc </td>
          <td>(</td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transposed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method that executes a shallow-copy of every matrix-plane in the source-vector and stores the copies in the destination-vector </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;src</td><td>is the source vector which contains matrix-planes of type cv::Mat_&lt;_Tp&gt; </td></tr>
    <tr><td class="paramname">&amp;dst</td><td>is the destination vector, where the shallow-copies are stored. dst should be empty at the beginning </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>operator =, <a class="el" href="classito_1_1_data_object.html#a32e74ff9c1cd0e9fc73d5f7705bce605" title="copy constructor for data object">DataObject::DataObject(const DataObject&amp; copyConstr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af336f965d8dcb64d35de938c63e18e53"></a><!-- doxytag: member="ito::copyParamVector" ref="af336f965d8dcb64d35de938c63e18e53" args="(const QVector&lt; ito::ParamBase &gt; *paramVecIn, QVector&lt; ito::ParamBase &gt; &amp;paramVecOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::copyParamVector </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramVecIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paramVecOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>makes a deep copy of a vector with values of type <a class="el" href="classito_1_1_param_base.html">ParamBase</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paramVecIn</td><td>is a pointer to a vector of ParamBase-values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">paramVecOut</td><td>is a reference to a vector which is first cleared and then filled with a deep copy of every element of paramVecIn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9596d29ad4cb556064117c73031bd0d"></a><!-- doxytag: member="ito::copyParamVector" ref="ad9596d29ad4cb556064117c73031bd0d" args="(const QVector&lt; ito::Param &gt; *paramVecIn, QVector&lt; ito::Param &gt; &amp;paramVecOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::copyParamVector </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramVecIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paramVecOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>makes a deep copy of a vector with values of type <a class="el" href="classito_1_1_param.html">Param</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paramVecIn</td><td>is a pointer to a vector of Param-values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">paramVecOut</td><td>is a reference to a vector which is first cleared and then filled with a deep copy of every element of paramVecIn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12bc247542bd015830ad21b2b6ead367"></a><!-- doxytag: member="ito::CopyToFunc" ref="a12bc247542bd015830ad21b2b6ead367" args="(const DataObject &amp;lhs, DataObject &amp;rhs, unsigned char regionOnly)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CopyToFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>regionOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for deeply copying the data of one matrix to another given matrix </p>
<p>At first, the memory of the new matrix is delete. Then the data of the lhs-matrix is deeply copied to the rhs-matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;lhs</td><td>is the matrix whose data is copied </td></tr>
    <tr><td class="paramname">&amp;rhs</td><td>is the matrix where the data is copied to. The old data of rhs is deleted first </td></tr>
    <tr><td class="paramname">regionOnly,if</td><td>true, only the data of the ROI in lhs is copied, hence, the org-size of rhs corresponds to the ROI-size of lhs, else the whole data block is copied and the ROI of rhs is set to the ROI of lhs </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>copyTo, <a class="el" href="namespaceito.html#a685ec2e9d5eecc4f7292a12aa70fc6ed" title="templated method for create">CreateFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a685ec2e9d5eecc4f7292a12aa70fc6ed"></a><!-- doxytag: member="ito::CreateFunc" ref="a685ec2e9d5eecc4f7292a12aa70fc6ed" args="(DataObject *dObj, const unsigned char dimensions, const size_t *sizes, const unsigned char continuous, const uchar *continuousDataPtr, const size_t *steps)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CreateFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>continuous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>continuousDataPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>templated method for create </p>
<p>creates or initializes matrix with given parameters</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dObj</td><td><a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a>, whose matrix is created here </td></tr>
    <tr><td class="paramname">dimensions</td><td>total number of dimensions (&gt;=1), if dimensions == 1, dimensions will be set to two and a matrix with dimension [1 x orginial dimension] is created </td></tr>
    <tr><td class="paramname">*sizes</td><td>vector with size of dimensions, each element gives the size of elements in each dimension </td></tr>
    <tr><td class="paramname">continuous,indicates</td><td>whether the data stored in this data object is stored in one continuous data block or not. if dimension &lt;= 2, matrix is always continuous be careful, continuous has not the same meaning than the continuous flag in opencv or numpy. </td></tr>
    <tr><td class="paramname">continuousDataPtr</td><td>if this pointer is NULL, new data will be allocated. Else the given data indicates data which will be used by this data object. only possible if continuous is true. m_ownflag will be set to 0 if this pointer is set </td></tr>
    <tr><td class="paramname">*steps</td><td>vector with size of dimensions, indicates how many bytes one has to move in order to get to the next element in the same dimension, the step-size for the last element must be equal to element-size (in byte) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>create </dd></dl>
<p>continuous </p>

</div>
</div>
<a class="anchor" id="a8fc8e0a61a894c95d468407a59147fec"></a><!-- doxytag: member="ito::CreateFuncWithCVPlanes" ref="a8fc8e0a61a894c95d468407a59147fec" args="(DataObject *dObj, const unsigned char dimensions, const size_t *sizes, const cv::Mat *planes, const unsigned int nrOfPlanes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CreateFuncWithCVPlanes </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat *&#160;</td>
          <td class="paramname"><em>planes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nrOfPlanes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>templated method for creation with given vector of cv::Mat-planes </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dimensions</td><td>is the total number of dimensions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*sizes</td><td>is a vector whose length is equal to dimensions. Each entry indicates the size of the specific dimension. Each matrix-plane is allocated with the size of the last two sizes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>is the desired element data type (see tDataType) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*planes</td><td>is an array of cv::Mat-planes which will be used as matrices for every single 2D-plane. Every Mat must have the same size and type. The type must correspond to the param type, the size must fit to the last two given sizes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrOfPlanes</td><td>is the length of the planes-array. This value must be the same than (sizes[0]*sizes[1]*...*sizes[dimensions-2]) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>create </dd></dl>

</div>
</div>
<a class="anchor" id="a49a8ffb4244dbc37882593e3ae344e74"></a><!-- doxytag: member="ito::createObjectFromXMLV1" ref="a49a8ffb4244dbc37882593e3ae344e74" args="(QXmlStreamReader &amp;stream, DataObject &amp;dObjIn, int &amp;elementsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::createObjectFromXMLV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamReader &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObjIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>elementsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function creates an dataObject from the header of the xml-file  This function creates an dataObject from the header of the xml-file by parsing the XML-stream. The first start element, already read by the calling function must contain the attributes dims, dataType and dim0..dimn-2, dimX, dimY. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>stream The xml-Stream from the xml-file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dObjIn</td><td>Destination dataContainter of type dataObject with size / dims / type speficied in the input xml </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elementsize</td><td>Byte-Size of the current dataObjekt</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a6a50711849b55cee9dfdee5224190d31">loadXML2DOBJ</a>, loadXML2EmptyDOBJ </dd></dl>
<p>&lt; Sizes of the new dataObject. Will be freed at end: </p>

</div>
</div>
<a class="anchor" id="a2ee6d1fc3b644438e7e45011be71540e"></a><!-- doxytag: member="ito::decRefParamPlugins" ref="a2ee6d1fc3b644438e7e45011be71540e" args="(ito::AddInBase *ai)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::decRefParamPlugins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>ai</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>decrements the reference counter of arguments passed to a plugin if necessary </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ai</td><td>AddIn to which the parameters are passed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsMand</td><td>mandatory argument parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsOpt</td><td>optional argument parameters</td></tr>
  </table>
  </dd>
</dl>
<p>This function decrements the reference counter of plugins passed to other plugins as parameters, to enable a closing of the passed plugins when they are no longer used by any other plugin. </p>

</div>
</div>
<a class="anchor" id="a22e7789c41c3399ac8d291feceb40df2"></a><!-- doxytag: member="ito::DeepCopyPartialFunc" ref="a22e7789c41c3399ac8d291feceb40df2" args="(DataObject &amp;lhs, DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DeepCopyPartialFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method to copy the values of the ROI of matrix lhs to the ROI of matrix rhs. </p>
<p>the ROI of rhs must already correspond to the ROI of lhs, hence, rhs must have allocated data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;lhs</td><td>is the original data object </td></tr>
    <tr><td class="paramname">&amp;rhs</td><td>is the data object, where the values are copied to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>deepCopyPartial </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>avoid <a class="el" href="classito_1_1_d_obj_iterator.html">DObjIterator</a> for speed-up </dd></dl>

</div>
</div>
<a class="anchor" id="a4863495020c813812170b8bdfcc46221"></a><!-- doxytag: member="ito::DivFunc" ref="a4863495020c813812170b8bdfcc46221" args="(const DataObject *src1, const DataObject *src2, DataObject *res, const double)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DivFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which does a element-wise division of elements in first source matrix by elements in second source matrix. </p>
<p>The result is stored in a result matrix, optionally the division can be scaled by a scaling factor, which is set to one by default. For fixed point numbers or complex values, a division by zero will throw an error. For floating-point values the following (matlab-like) implementation is used:</p>
<p>1.0/0.0 = Inf, 0.0/0.0 = Nan</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*src1</td><td>is the first source matrix </td></tr>
    <tr><td class="paramname">*src2</td><td>is the second source matrix </td></tr>
    <tr><td class="paramname">*res</td><td>is the result matrix, which must have the same size than the source matrices </td></tr>
    <tr><td class="paramname">double</td><td>scale is the scaling factor (default: 1.0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a8b32235878d1e9594569d92771bfcfcd"></a><!-- doxytag: member="ito::errOutInitParams" ref="a8b32235878d1e9594569d92771bfcfcd" args="(const QVector&lt; ito::Param &gt; *params, const int num, const QString reason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ito::errOutInitParams </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QString&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper function for error output </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>parameters expected by the plugin </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>parameter where the error occured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reason</td><td>the reason for the error (e.g. parameter missing, wrong type, ...)</td></tr>
  </table>
  </dd>
</dl>
<p>Function used for writing error messages occured during the parsing of the parameters passed for the initialisation of a plugin. The function uses the cerr stream to "post" the error message. If possible the parameter where the error occured is marked with an arrow. Except the error all parameters necessary and optional including their type are written to the console. </p>

</div>
</div>
<a class="anchor" id="a8dc77804bd6f6c2afa1b1cae477337ff"></a><!-- doxytag: member="ito::EyeFunc" ref="a8dc77804bd6f6c2afa1b1cae477337ff" args="(const size_t size, int **dstMat)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::EyeFunc </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for creating an eye-matrix </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>indicates the size of the square matrix </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is a pointer to which the eye-matrix is assigned to. The eye matrix is of type cv::Mat_&lt;_Tp&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a01723110515894b52457c2e3ffbb3d6f"></a><!-- doxytag: member="ito::findAndDeleteReservedInitKeyWords" ref="a01723110515894b52457c2e3ffbb3d6f" args="(PyObject *kwds, bool *enableAutoLoadParams)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::findAndDeleteReservedInitKeyWords </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>kwds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>enableAutoLoadParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>kwds list with named python arguments </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">enableAutoLoadParams</td><td>if keyword autoLoadParams is found, value of this is set to kwds-item value else false it is set to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a547629916973cfd68be44a11887aa45a"></a><!-- doxytag: member="ito::formatDoubleWithUnit" ref="a547629916973cfd68be44a11887aa45a" args="(QStringList scaleThisUnitsOnly, QString unitIn, double dVal, double &amp;dValOut, QString &amp;unitOut)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::formatDoubleWithUnit </td>
          <td>(</td>
          <td class="paramtype">QStringList&#160;</td>
          <td class="paramname"><em>scaleThisUnitsOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>unitIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>dValOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>unitOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>&lt; Function to convert double values with unit to scaled values with scaled units (0.01m -&gt; 10mm) </p>
<p>Compared the abs(dValue) with the 10^(3N) and according to the results  p M ... are added to the unit Allowed units are SI-Unit except kg and mm. It % is given as unit, values are multiplied by 100 </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scaleThisUnitsOnly</td><td>List with scaleable units (e.g. mm, m) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitIn</td><td>Old unit (e.g. mm, m, %) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dVal</td><td>Double value (e.g. mm, m, %) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dValOut</td><td>Scaled value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">unitOut</td><td>Scaled unit m -&gt; mm or m</td></tr>
  </table>
  </dd>
</dl>
<p>Function generates the auto save filename from the plugin name and the dll-folder </p>

</div>
</div>
<a class="anchor" id="a708f5dc838bfbc92c937b6e6c40df6df"></a><!-- doxytag: member="ito::FreeFunc" ref="a708f5dc838bfbc92c937b6e6c40df6df" args="(DataObject *dObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::FreeFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for freeing allocated data blocks </p>
<p>First, the header information of the corresponding data block is deleted. Then the reference counter of the data block is decremented. In the same way, the reference counter for every matrix-plane is incremented by calling the corresponding release-method. If the ref-counter is lower than zero no other instance needs this data block and it is deallocated if the m_owndata-flag is true.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>whose data block should be freed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>freeData </dd></dl>

</div>
</div>
<a class="anchor" id="aa872946454ba282dd90912cb19cce19b"></a><!-- doxytag: member="ito::freeParams" ref="aa872946454ba282dd90912cb19cce19b" args="(int length, char *&amp;cargt, char **&amp;cargs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ito::freeParams </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>cargt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&amp;&#160;</td>
          <td class="paramname"><em>cargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>frees parameter and parameter type arrays generated by the <a class="el" href="namespaceito.html#a8fe6cab8c18f8e06ec5b141d57ab1389">parseParams</a> function </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>number of parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cargt</td><td>array with parameter types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cargs</td><td>array with the parameter pointers / values </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0</dd></dl>
<p>The function frees the arrays generated by the <a class="el" href="namespaceito.html#a8fe6cab8c18f8e06ec5b141d57ab1389">parseParams</a> function, i.e. the array with the parsed parameter values and the array with their types. </p>

</div>
</div>
<a class="anchor" id="a7613132614d1cd6eb29278ceed6cdf60"></a><!-- doxytag: member="ito::generateAutoSaveParamFile" ref="a7613132614d1cd6eb29278ceed6cdf60" args="(QString plugInName, QFile &amp;paramFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::generateAutoSaveParamFile </td>
          <td>(</td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>plugInName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QFile &amp;&#160;</td>
          <td class="paramname"><em>paramFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>loadXML2QLIST loads parameters from an XML-File and saves them to paramList </p>
<p>function for generates the plugin xml file handle </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fName</td><td>filename (is needed e.g. to get filename) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">paramFile</td><td>reference to unopened parameter file</td></tr>
  </table>
  </dd>
</dl>
<p>The function generates the xml parameter file name and returns the a QFile handle. The name has the same name as the plugin in the plugins directory. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#af3ff1acd7b8b3e2140db87852be40b77">loadXML2QLIST</a>, <a class="el" href="namespaceito.html#a1f0f29281bc5cb69fcd9759a369b09eb">saveQLIST2XML</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a339187d27cca1e266efc6193653cf448"></a><!-- doxytag: member="ito::getDataType" ref="a339187d27cca1e266efc6193653cf448" args="(const _Tp *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> ito::getDataType </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>method which returns the value of enumeration <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>, which corresponds to the type of the given pointer parameter. </p>
<p>If the parameter type cannot be transformed into a value of <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>, an exception is thrown.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">any</td><td>pointer, whose type should be transformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if the input data type is unknown </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a63c174f39bf79b06c140758b074cfdd0" title="method which returns the value of enumeration ito::tDataType, which corresponds to the template param...">getDataType2</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a63c174f39bf79b06c140758b074cfdd0"></a><!-- doxytag: member="ito::getDataType2" ref="a63c174f39bf79b06c140758b074cfdd0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> ito::getDataType2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>method which returns the value of enumeration <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>, which corresponds to the template parameter (must be a pointer). </p>
<p>If the template parameter cannot be transformed into a value of <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>, an exception is thrown.</p>
<p>Call is <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> result = <a class="el" href="namespaceito.html#a63c174f39bf79b06c140758b074cfdd0" title="method which returns the value of enumeration ito::tDataType, which corresponds to the template param...">getDataType2&lt;uint8*&gt;()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if the template parameter is unknown (e.g. no pointer). </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a339187d27cca1e266efc6193653cf448" title="method which returns the value of enumeration ito::tDataType, which corresponds to the type of the gi...">getDataType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0ec801556013f5ca4f9060457ec5d912"></a><!-- doxytag: member="ito::getExecFuncsInfo" ref="a0ec801556013f5ca4f9060457ec5d912" args="(ito::AddInBase *aib, PyObject *args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::getExecFuncsInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>aib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns a list of execFunction available in a plugin similar to filterHelp </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aib</td><td>the plugin for which the execFuncs names are requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>2 Item-Vector with integer request for additional dictionary return </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>python dictionary with list of functions or specific dictionary for one execFunc with the parameters' names, min, max, current value, (infostring) </dd></dl>

</div>
</div>
<a class="anchor" id="a1d523bfed1668a22a48f33721d83768e"></a><!-- doxytag: member="ito::getName" ref="a1d523bfed1668a22a48f33721d83768e" args="(_Tp *addInObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::getName </td>
          <td>(</td>
          <td class="paramtype">_Tp *&#160;</td>
          <td class="paramname"><em>addInObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns the name of a python plugin </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addInObj</td><td>the plugin whoes name should be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the plugin name </dd></dl>

</div>
</div>
<a class="anchor" id="a969b92362da351d422ab748c7c850115"></a><!-- doxytag: member="ito::getParam" ref="a969b92362da351d422ab748c7c850115" args="(_Tp *addInObj, PyObject *args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::getParam </td>
          <td>(</td>
          <td class="paramtype">_Tp *&#160;</td>
          <td class="paramname"><em>addInObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>return a parameter value </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addInObj</td><td>the addIn whoes parameter is requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>the parameter name </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>python object with the parameter value on success (parameter exists), NULL otherwise</dd></dl>
<p>The function tries to retrieve the value of the parameter with the name given in args. If the parameter does not exist NULL is returned. To actually retrieve the value the getParam function of the plugin is invoked. </p>

</div>
</div>
<a class="anchor" id="ae5f62de950023c3db6e6f899aacc6bd3"></a><!-- doxytag: member="ito::getParamByName" ref="ae5f62de950023c3db6e6f899aacc6bd3" args="(QVector&lt; ito::Param &gt; *paramVec, const char *name, ito::RetVal *retval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_param.html">ito::Param</a> * ito::getParamByName </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> *&#160;</td>
          <td class="paramname"><em>retval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>brief returns a parameter from the parameter-vector, that fits to a specific name </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>description </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a9116ec57a2f79c788a4991e28b4617e8"></a><!-- doxytag: member="ito::getParamList" ref="a9116ec57a2f79c788a4991e28b4617e8" args="(ito::AddInBase *aib)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::getParamList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>aib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns the names of the parameters available in a plugin </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aib</td><td>the plugin for which the parameter names are requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>python object with a string list with the parameters' names </dd></dl>

</div>
</div>
<a class="anchor" id="a1abfad65cf3b738c5d98938d20b9e7fe"></a><!-- doxytag: member="ito::getParamListInfo" ref="a1abfad65cf3b738c5d98938d20b9e7fe" args="(ito::AddInBase *aib, PyObject *args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::getParamListInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>aib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns the all informations of the parameters available in a plugin </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aib</td><td>the plugin for which the parameter names are requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>1 Item-Vector with bool request for additional dictionary return </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>python list of python tuple with the parameters' names, min, max, current value, (infostring) </dd></dl>

</div>
</div>
<a class="anchor" id="a26e60a4adfd0270199d3cb0b21230c29"></a><!-- doxytag: member="ito::GetRangeFunc" ref="a26e60a4adfd0270199d3cb0b21230c29" args="(DataObject *dObj, const int dtop, const int dbottom, const int dleft, const int dright)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::GetRangeFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dtop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dbottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dright</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for saving a shallow copy of a source cv::Mat_ to a destination cv::Mat_ with respect to given row- and col-ranges </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*SrcMat</td><td>is the source matrix which is firstly cast to cv::Mat_&lt;_Tp&gt;* </td></tr>
    <tr><td class="paramname">rowRange</td><td>is the desired row-range </td></tr>
    <tr><td class="paramname">colRange</td><td>is the desired col-range </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is the pointer to a destination matrix which is also cast to cv::Mat_&lt;_Tp&gt;* </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a4c62ac398a6883ba109b6e821b6a2e6a"></a><!-- doxytag: member="ito::imag" ref="a4c62ac398a6883ba109b6e821b6a2e6a" args="(const DataObject &amp;dObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::imag </td>
          <td>(</td>
          <td class="paramtype">const DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level value which calculates the imaginary value of each element of the input source data object and returns the resulting data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new data object with imaginary values </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if undefined data type (e.g. real data types) </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a0e126a9e14968fd29e231b9efab55a3b" title="low-level, double templated method to save the element-wise argument of each element in source matrix...">ArgFunc</a></dd></dl>
<p>calculates the imaginary part of each element in the given data object and returns the result as new data object </p>

</div>
</div>
<a class="anchor" id="af94ef257b87ce7243e79b454cf1cd1f3"></a><!-- doxytag: member="ito::ImagFunc" ref="af94ef257b87ce7243e79b454cf1cd1f3" args="(const DataObject *dObj, DataObject *resObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CmplxTp , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ImagFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>resObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, double templated method to save the element-wise imaginary value of each element in source matrix to result matrix </p>
<p>This method takes the imaginary value of a complex valued input matrix and stores it in the equivalent real typed result matrix</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is source matrix, must have complex type </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the resulting data object, which has the real data type which corresponds to the complex type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>std::abs </dd></dl>

</div>
</div>
<a class="anchor" id="a9f86dfd2e4d25372a4b35066e423f4b2"></a><!-- doxytag: member="ito::incRefParamPlugins" ref="a9f86dfd2e4d25372a4b35066e423f4b2" args="(ito::AddInBase *ai, QVector&lt; ito::ParamBase &gt; *paramsMand, QVector&lt; ito::ParamBase &gt; *paramsOpt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ito::incRefParamPlugins </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>ai</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramsMand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramsOpt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>increments the reference counter of arguments passed to a plugin if necessary </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ai</td><td>AddIn to which the parameters are passed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsMand</td><td>mandatory argument parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsOpt</td><td>optional argument parameters</td></tr>
  </table>
  </dd>
</dl>
<p>This function increments the reference counter of plugins passed to other plugins as parameters, to avoid the passed plugins are closed while they are still in use by the other plugin. </p>

</div>
</div>
<a class="anchor" id="af4d3d4b43bba61b878804856808198e6"></a><!-- doxytag: member="ito::isZeroValue" ref="af4d3d4b43bba61b878804856808198e6" args="(_Tp v, _Tp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool ito::isZeroValue </td>
          <td>(</td>
          <td class="paramtype">_Tp&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Tp&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>method returns whether a given variable is equal to zero. </p>
<p>For floating point variables, this method considers a variable to be zero, if its value lie within the boundaries (-epsilon,epsilon). Epsilon can for example be obtained by std::numeric_limits&lt;_Tp&gt;::epsilon(). For floating point values only parameters of type float32, float64, complex64 or complex128 are treated in the desired way.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is value to check </td></tr>
    <tr><td class="paramname">epsilon</td><td>is epsilon boundary, for fixed-point values this value is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if value is zero or within the epsilon boundaries, else false </dd></dl>

</div>
</div>
<a class="anchor" id="a43463b798f2244f8f380ff8af5337c20"></a><!-- doxytag: member="ito::loadDataFromXMLV1" ref="a43463b798f2244f8f380ff8af5337c20" args="(QXmlStreamReader &amp;stream, DataObject &amp;dObjIn, int elementsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::loadDataFromXMLV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamReader &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObjIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function copies the CDATA from the xml-file to the allocated dataObject.  This function copies the CDATA from the xml-file to the allocated dataObject. The data was before packed (substitution of xml-registered characters) during saving and is unpacked here. The data is stored plane-wise. The function checks if the plane-size if the object is equal to the imported size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>stream The xml-Stream from the xml-file </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>dObjIn allocated dataObject </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementsize</td><td>Size of the each matrix-element</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a6a50711849b55cee9dfdee5224190d31">loadXML2DOBJ</a>, loadXML2EmptyDOBJ, <a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>, <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a99b23c44aedc092db34847ec3d850a7c"></a><!-- doxytag: member="ito::loadObjectHeaderFromXMLV1" ref="a99b23c44aedc092db34847ec3d850a7c" args="(QXmlStreamReader &amp;stream, DataObject &amp;dObjIn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::loadObjectHeaderFromXMLV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamReader &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObjIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function fills the MetaData (<a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) of an allocated dataObject from the values of an xml-file  This function fills the MetaData (<a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) of an allocated dataObject from the values of an xml-file. This includes the axis-Tags (offset, scale, unit, description), value-Tags ((offset), (scale), unit, description) and the rotation matrix. It does not include the tag-Space (std::map&lt;std::string, DataObjectTagType&gt; m_tags) (e.g. protocol ...) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">[in|out]</td><td>stream The xml-Stream from the xml-file </td></tr>
    <tr><td class="paramname">[in|out]</td><td>dObjIn allocated dataObject</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a6a50711849b55cee9dfdee5224190d31">loadXML2DOBJ</a>, loadXML2EmptyDOBJ, <a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>, <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4132d915f47775d5edcab7874885c27d"></a><!-- doxytag: member="ito::loadTagSpaceFromXMLV1" ref="a4132d915f47775d5edcab7874885c27d" args="(QXmlStreamReader &amp;stream, DataObject &amp;dObjIn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::loadTagSpaceFromXMLV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamReader &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObjIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function fills the tagsSpace (<a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) of an allocated dataObject from the values of an xml-file  This function fills the tagsSpace (<a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) of an allocated dataObject from the values of an xml-file. This onlye includes the tag-Space (std::map&lt;std::string, DataObjectTagType&gt; m_tags) (e.g. protocol ...) and does not include the axis-Tags (offset, scale, unit, description), value-Tags ((offset), (scale), unit, description) and the rotation matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">[in|out]</td><td>stream The xml-Stream from the xml-file </td></tr>
    <tr><td class="paramname">[in|out]</td><td>dObjIn allocated dataObject</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a6a50711849b55cee9dfdee5224190d31">loadXML2DOBJ</a>, loadXML2EmptyDOBJ, <a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>, <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6a50711849b55cee9dfdee5224190d31"></a><!-- doxytag: member="ito::loadXML2DOBJ" ref="a6a50711849b55cee9dfdee5224190d31" args="(DataObject *dObjIn, QString folderFileName, bool onlyHeaderObjectFile, bool appendEnding)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::loadXML2DOBJ </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>folderFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyHeaderObjectFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appendEnding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[Out]</td><td>dObjIn Destination dataContainter of type dataObject </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">folderFileName</td><td>Folder and Filename of the Sourcefile</td></tr>
  </table>
  </dd>
</dl>
<p>This function loads data from a xml-file to a dataObject. The file must be compatible to the file-format describted before. There are to possilbe import methods: 1. onlyHeaderObjectFile == false tries to import a ido file with a itoDataObject-note/startelement. 1. onlyHeaderObjectFile == true tries to import a idh file with a itoDataObjectHeader-note/startelement. The dataSpace will be ignored</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a49a8ffb4244dbc37882593e3ae344e74" title="This function creates an dataObject from the header of the xml-file  This function creates an dataObj...">createObjectFromXMLV1</a>, <a class="el" href="namespaceito.html#a99b23c44aedc092db34847ec3d850a7c" title="This function fills the MetaData (DataObjectTags) of an allocated dataObject from the values of an xm...">loadObjectHeaderFromXMLV1</a>, <a class="el" href="namespaceito.html#a4132d915f47775d5edcab7874885c27d" title="This function fills the tagsSpace (DataObjectTags) of an allocated dataObject from the values of an x...">loadTagSpaceFromXMLV1</a>, <a class="el" href="namespaceito.html#a43463b798f2244f8f380ff8af5337c20" title="This function copies the CDATA from the xml-file to the allocated dataObject.  This function copies t...">loadDataFromXMLV1</a> </dd></dl>
<p>&lt; Returnvalue for the complete function</p>
<p>&lt; Handle to the source data </p>

</div>
</div>
<a class="anchor" id="af3ff1acd7b8b3e2140db87852be40b77"></a><!-- doxytag: member="ito::loadXML2QLIST" ref="af3ff1acd7b8b3e2140db87852be40b77" args="(QMap&lt; QString, Param &gt; *paramList, QString id, QFile &amp;paramFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::loadXML2QLIST </td>
          <td>(</td>
          <td class="paramtype">QMap&lt; QString, Param &gt; *&#160;</td>
          <td class="paramname"><em>paramList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QFile &amp;&#160;</td>
          <td class="paramname"><em>paramFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">paramList</td><td>Empty List of Type QMap. If not empty this function will clear the list before reading </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Identifier of the plugin. Currently implemented as integer number only </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramFile</td><td>Filename of the file. The file will be opened/closed in this function</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads the parameters for a plugin specified with id from an XML file. During initialisation an xml file with the same name as the plugin library in the plugin directory is used to load the plugin parameters. The xml file is checked for the current plugin-file version and type when opened. The parameters have in the calling function afterwards. </p>

</div>
</div>
<a class="anchor" id="a15ebf0f0e1afe1bba069394c128372aa"></a><!-- doxytag: member="ito::makeContinuous" ref="a15ebf0f0e1afe1bba069394c128372aa" args="(const DataObject &amp;dObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::makeContinuous </td>
          <td>(</td>
          <td class="paramtype">const DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level method which copies an incontinuously organized data object to a continuously organized resulting data object, which is returned </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td>is the source data object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>resulting data object </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#aca2f517b2e6d28b2664e7939d7eb7be6" title="low-level, templated method which copies an incontinuously organized data object to a continuously or...">MakeContinuousFunc</a></dd></dl>
<p>if the given data object is not continuously organized, copies the content to a new continuous data object </p>

</div>
</div>
<a class="anchor" id="aca2f517b2e6d28b2664e7939d7eb7be6"></a><!-- doxytag: member="ito::MakeContinuousFunc" ref="aca2f517b2e6d28b2664e7939d7eb7be6" args="(const DataObject &amp;dObj, DataObject &amp;resDObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::MakeContinuousFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject &amp;&#160;</td>
          <td class="paramname"><em>resDObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which copies an incontinuously organized data object to a continuously organized resulting data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td>is the source data object </td></tr>
    <tr><td class="paramname">&amp;resDObj</td><td>is the resulting data object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a487ae8b7490f1de2f8c400eab1859f58"></a><!-- doxytag: member="ito::mergeQLists" ref="a487ae8b7490f1de2f8c400eab1859f58" args="(QMap&lt; QString, Param &gt; *oldList, QMap&lt; QString, Param &gt; *newList, bool checkAutoSave, bool deleteUnchangedParams)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::mergeQLists </td>
          <td>(</td>
          <td class="paramtype">QMap&lt; QString, Param &gt; *&#160;</td>
          <td class="paramname"><em>oldList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QMap&lt; QString, Param &gt; *&#160;</td>
          <td class="paramname"><em>newList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkAutoSave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteUnchangedParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>oldList Paramlist with all plugin-parameters, which will contain the merged parameters in the end </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>newList New parameter values to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">checkAutoSave</td><td>Flag to enable / disable autosave control to avoid obsolet parameters to overwrite exisiting parameters.</td></tr>
  </table>
  </dd>
</dl>
<p>This function compares the new list with the old list. If new list contains parameters which do not exist in the existing list, the paremeter is ignored and a warning is added to the errormessage stack. If the checkAutoSave parameter is true, parameters in oldList are not altered of the autosave is disabled. In this case a warning is returned. In case the paremters Type is not equal, a warning is returned and the paremeter is not altered. At the moment only parameters of numeric values and strings are merged. </p>

</div>
</div>
<a class="anchor" id="aa39aa15421565efbfdd04e1534c0a84f"></a><!-- doxytag: member="ito::numberConversion" ref="aa39aa15421565efbfdd04e1534c0a84f" args="(ito::tDataType fromType, void *scalar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp ito::numberConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td>
          <td class="paramname"><em>fromType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>templated method for converting a given scalar value to the data type, indicated by the template parameter </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fromType</td><td>is the data type of the given scalar </td></tr>
    <tr><td class="paramname">*scalar</td><td>is the pointer to the scalar value, casted to void* </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the converted scalar value </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if the input data type is unknown or if the conversion failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>saturate_cast </dd></dl>

</div>
</div>
<a class="anchor" id="aca6e2a03961f1f443ab7c232e501e1ab"></a><!-- doxytag: member="ito::OnesFunc" ref="aca6e2a03961f1f443ab7c232e501e1ab" args="(const size_t sizeY, const size_t sizeX, int **dstMat)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::OnesFunc </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for creation of one-valued matrix-plane </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is the pointer to the already allocated cv::Mat_&lt;type&gt;-matrix-plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>zeros </dd></dl>

</div>
</div>
<a class="anchor" id="a6e47940e1e59401ab78b8844ef709634"></a><!-- doxytag: member="ito::OpMulFunc" ref="a6e47940e1e59401ab78b8844ef709634" args="(const DataObject *dObj1, const DataObject *dObj2, DataObject *dObjRes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::OpMulFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>brief description </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>check for right definition of multiplication </dd></dl>

</div>
</div>
<a class="anchor" id="ad433fae6723437f656c2efa63b14c3f2"></a><!-- doxytag: member="ito::OpScalarMulFunc" ref="ad433fae6723437f656c2efa63b14c3f2" args="(const DataObject *src, const double factor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::OpScalarMulFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which multiplies every element of Data Object with a factor </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td></td></tr>
    <tr><td class="paramname">factor</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a8e672322a951881453fcd73de2c771ff"></a><!-- doxytag: member="ito::parseInitParams" ref="a8e672322a951881453fcd73de2c771ff" args="(QVector&lt; ito::Param &gt; *initParamListMand, QVector&lt; ito::Param &gt; *initParamListOpt, PyObject *args, PyObject *kwds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::parseInitParams </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>initParamListMand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>initParamListOpt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function to read mandatory and optional parameter lists from a given python parameter list according to the plugins definition </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">initParamListMand</td><td>vector holding the mandatory initialisation parameters (filled with default values), the default values are overwritten with the passed values </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">initParamListOpt</td><td>vector holding the optional initialisation parameters (filled with default values), the default values are overwritten with the passed values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>list with python arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kwds</td><td>list with named python arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns <a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a2ced39cc25866a04f2fb1c9f1d6a542e">ito::retOk</a> if the number and type of parameters was correct, <a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a199f41b7779e742e0a3cc281c42c97c0">ito::retError</a> otherwise</dd></dl>
<p>The function takes as input the vectors with the madatory and optional input parameters used for the plugin initialisation. These vectors must be previously be read using the function getInitParams. The default values of the parameters are overwritten with the values given by python. In case the number or parameters or a parameter type is incorrect the function will abort with an error. </p>

</div>
</div>
<a class="anchor" id="aea20a9bf1563f8642db8062c912b2b2c"></a><!-- doxytag: member="ito::parseParamName" ref="aea20a9bf1563f8642db8062c912b2b2c" args="(const QString &amp;name, QString &amp;paramName, bool &amp;hasIndex, int &amp;index, QString &amp;additionalTag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::parseParamName </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>paramName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>hasIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>additionalTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>parses parameter name with respect to regular expression, assigned for parameter-communcation with plugins </p>
<p>This method parses any parameter-name with respect to the rules defined for possible names of plugin-parameters.</p>
<p>The regular expression used for the check is "^([a-zA-Z]+\\w*)(\\[(\\d+)\\]){0,1}(:(.*)){0,1}$"</p>
<p>Then the components are:</p>
<p>[0] full string [1] PARAMNAME [2] [INDEX] or empty-string if no index is given [3] INDEX or empty-string if no index is given [4] :ADDITIONALTAG or empty-string if no tag is given [5] ADDITIONALTAG or empty-string if no tag is given</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>is the raw parameter name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">paramName</td><td>is the real parameter name (first part of name; part before the first opening bracket ('[') or if not available the first colon (':')) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hasIndex</td><td>indicates whether the name contains an index part (defined by a number within two brackets (e.g. '[NUMBER]'), which has to be appended to the paramName </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>is the fixed-point index value or -1 if hasIndex is false </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">additionalTag</td><td>is the remaining string of name which is the part after the first colon (':'). If an index part exists, the first colon after the index part is taken. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8fe6cab8c18f8e06ec5b141d57ab1389"></a><!-- doxytag: member="ito::parseParams" ref="a8fe6cab8c18f8e06ec5b141d57ab1389" args="(PyObject *args, int length, char **&amp;cargs, char *&amp;cargt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ito::parseParams </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&amp;&#160;</td>
          <td class="paramname"><em>cargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>cargt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Helper function that accepts a python parameter list and returns pointers to the parameters' values and a list with their types </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>list with python parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>number of parameters passed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cargs</td><td>pointers to the parsed parameters </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cargt</td><td>list with the parameter's types </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>return 0 if all parameters passed could be parsed to a known type, -1 otherwise</dd></dl>
<p>The function accepts a list of python parameters and tries to parse them to make them available to c/c++ functions. The found parameters pointers are given back in the cargs array ant the parameters' types in the cargt array. To free the generated lists use the <a class="el" href="namespaceito.html#aa872946454ba282dd90912cb19cce19b">freeParams</a> function. </p>

</div>
</div>
<a class="anchor" id="afb4b7505de2474537f0ff7a5e678cf94"></a><!-- doxytag: member="ito::parsePosParams" ref="afb4b7505de2474537f0ff7a5e678cf94" args="(PyObject *args, char **&amp;cargs, char *&amp;cargt, QVector&lt; int &gt; &amp;axisVec, QVector&lt; double &gt; &amp;posVec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::parsePosParams </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&amp;&#160;</td>
          <td class="paramname"><em>cargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>cargt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>axisVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>posVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>helper function to parse the positioning parameters for an actuator </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments passed to the function (in python) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>cargs parsed argument values </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>cargt parsed argument types </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">axisVec</td><td>Vector with axes numbers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">posVec</td><td>Vector with position values </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk of parameters could be parsed, retError otherwise</dd></dl>
<p>Parses the parameters passed to a setPos command in python. For each axis that should be positioned an axis number and a position value are expected. </p>

</div>
</div>
<a class="anchor" id="a273b3666f4857c488a6eca7be2ce22c0"></a><!-- doxytag: member="ito::PyDoc_STRVAR" ref="a273b3666f4857c488a6eca7be2ce22c0" args="(dataObjectInit_doc,&quot;dataObject([dims [, dtype='uint8'[, continuous = 0][, data = valueOrSequence]]]) &#45;&gt; constructor to get a new dataObject.\n\
\n\
Parameters \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
dims : {List of Integer}, optional \n\
    'dims' is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns. If not given, an empty data object is created.\n\
dtype : {str}, optional \n\
    'dtype' is the data type of each element, possible values: 'int8','uint8',...,'int32','uint32','float32','float64','complex64','complex128'\n\
continuous : {str}, optional \n\
    'continuous' [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).\n\
data : {str}, optional \n\
    'data' is a single value or a sequence with the same amount of values than the data object. The values from data will be assigned to the new data object (filled row by row).\n\
\n\
Returns \n\
&#45;&#45;&#45;&#45;&#45;&#45;&#45; \n\
dataObject {dataObject}\n\
\n\
Notes \n\
&#45;&#45;&#45;&#45;&#45;&#45; \n\
\n\
The itom.dataObject contains a n&#45;dimensional matrix and corresponding meta&#45;data.\n\
It has a direct c++&#45;representation for the python&#45;c++ interface.\n\
The n&#45;dimensional matrix can have different element types.\n\
Recently the following types are supported:\n\
\n\
* Integer&#45;type (int8, uint8, int16, uint16, int32, uint32),\n\
\n\
* Floating&#45;type (float32, float64 (=&gt; double)),\n\
\n\
* Complex&#45;type  (complex64 (2x float32), complex128 (2x float64)).\n\
\n\
\n\
Warning 'uint32' is not fully openCV&#45;compatible and hence causes instability!\n\
\n\
In order to handle huge matrices, the data object can divide one matrix into subparts in memory.\n\
Each subpart (called matrix&#45;plane) is two&#45;dimensional and covers data of the last two dimensions.\n\
In c++&#45;context each of these matrix&#45;planes is of type cv::Mat_&lt;type&gt; and can be used with every operator given by the openCV&#45;framework (version 2.3.1 or higher).\n\
\n\
The dimensions of the matrix are structured descending. So if we assume to have a n&#45;dimensional matrix A,\n\
where each dimension has its size s_i, the dimensions order is n, .., z, y, x and the corresponding sizes of A are [s_n, s_(n&#45;1),  s_(n&#45;2), ..., s_y, s_x].\n\
\n\
In order to make the data object compatible to continuously organized data structures, like numpy&#45;arrays, \n\
it is also possible to have all matrix&#45;planes in one data&#45;block in memory (not recommended for huge matrices).\n\
Nevertheless, the indicated data structure with the two&#45;dimensional sub&#45;matrix&#45;planes is still existing. \n\
The data organization is equal to the one of open&#45;cv, hence, two&#45;dimensional matrices are stored row&#45;by&#45;row (C&#45;style)...\n\
\n\
\n\
Deep Copy, Shallow Copy and ROI \n\
\n\
It is possible to set a n&#45;dimensional region of interest (ROI) to each matrix, the virtual dimensions,\n\
which will be delivered if the user asks for the matrix size.\n\
To avoid copy operations where possible a simple =_Operator will also make a shallow copy of the object.\n\
Shallow copies share the same data (elements and meta data) with the original object, hence manipulations of one object will affect the\n\
original object and all shallow copies.\n\
\n\
The opposite a deep copy of a dataObject (by sourceObject.copy()) creates a complete mew matrix with own meta data object.\n\
\n\
Example:\n\
::\n\
    #Create an object \n\
    dObj = dataObject([5, 10, 10], 'int8')\n\
    \n\
    # Make a shallow copy \n\
    dObjShallow = dObj \n\
    \n\
    # Make a shallow copy on ROI\n\
    dObjROI = dObj[1, :, :] \n\
    \n\
    # Set the value of element [1, 0, 0] to 0\n\
    dObj[1, 0, 0] = 0\n\
    \n\
    # Make a deep copy of the dObjROI\n\
    dObjROICopy = dObjROI.copy()\n\
    \n\
    # Set the value of dObjROICopy element [0, 0, 0] to 127 without effecting other objects\n\
    dObjROICopy[0, 0, 0] = 127\n\
    \n\
    \n\
**Constructor** \n\
The function dataObject([dims [, dtype='uint8'[, continuous = 0][, data = valueOrSequence]]])\n\
creates a new itom&#45;dataObject filled with undefined data.\n\
If no parameters are given, an uninitilized DataObject (dims = 0, no sizes) is created.\n\
\n\
As second possibility you can also use the copy&#45;constructor 'dataObject(AnyArray)', \n\
where AnyArray must be any array&#45;like structure which is parsable by the numpy&#45;interface.\n\
\n\
Further static methods for object construction are dataObject.zeros(..), dataObject.ones(..),\n\
dataObject.rand(..), dataObject.randN(..) and dataObject.eye(..).\n\
&quot;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ito::PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">dataObjectInit_doc&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>brief description </p>
<p>long description</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>description </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>description </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>(see also) keywords (comma-separated) </dd></dl>

</div>
</div>
<a class="anchor" id="aa42dc8403786d9a2bf7a19c41eeaee7a"></a><!-- doxytag: member="ito::PyWidgetOrFilterHelp" ref="aa42dc8403786d9a2bf7a19c41eeaee7a" args="(bool getWidgetHelp, PyObject *pArgs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::PyWidgetOrFilterHelp </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getWidgetHelp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>pArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; copy filterstring only</p>
<p>&lt; copy filterstring and toggle output</p>
<p>&lt; Valid input are filterstring, toggle output and listonlyflag</p>
<p>&lt; Valid input are filterstring, toggle output and listonlyflag only</p>
<p>first try to catch a perfect match with existing filters</p>
<p>Now get the complete filterlist </p>

</div>
</div>
<a class="anchor" id="a86d06938dd4238f988302e46a9ee9735"></a><!-- doxytag: member="ito::RandFunc" ref="a86d06938dd4238f988302e46a9ee9735" args="(const size_t sizeY, const size_t sizeX, const double value1, const double value2, const bool randMode, int **dstMat)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::RandFunc </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>randMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for creation of random-valued matrix-plane </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">type</td><td>is the desired data-element-type </td></tr>
    <tr><td class="paramname">randMode</td><td>switch mode between uniform distributed(false) and normal distributed noise(true) </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is the pointer to the already allocated cv::Mat_&lt;type&gt;-matrix-plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>zeros </dd></dl>

</div>
</div>
<a class="anchor" id="a6ac69b3f30314c1478a433ae9eabbe7a"></a><!-- doxytag: member="ito::RandFunc&lt; ito::complex128 &gt;" ref="a6ac69b3f30314c1478a433ae9eabbe7a" args="(const size_t sizeY, const size_t sizeX, const double value1, const double value2, const bool randMode, int **dstMat)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::RandFunc&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>randMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for low-level, templated method for creation of random-valued matrix-plane of type complex128 </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a86d06938dd4238f988302e46a9ee9735" title="low-level, templated method for creation of random-valued matrix-plane">RandFunc</a>, zeros, ones </dd></dl>

</div>
</div>
<a class="anchor" id="ae98bfefe271214ccda435c4be975f5e4"></a><!-- doxytag: member="ito::readDoubleFromXML" ref="ae98bfefe271214ccda435c4be975f5e4" args="(QXmlStreamAttributes &amp;attrStream, QString &amp;Element, QString &amp;Attrib, double &amp;val, bool isBinary)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::readDoubleFromXML </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>Element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>Attrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isBinary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This helper function extracts a double from the xml-Attributes of the Stream  This helper function extracts a double from the xml-Attributes of the Stream copied by the caller with the attrStream = attrStream = stream.attributes();. the Function checks if the attribute exists and than tries to convert to the value of the attribute either from binary or with string to double functions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attrStream</td><td>incomming attribute-stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Element</td><td>name of the element (only for error msg) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Attrib</td><td>name of the attribute to extract </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>val Must be filled with default value and is filled with value from the XML-Stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isBinary</td><td>Must be true if attribute value was stored as binary else false</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a6a50711849b55cee9dfdee5224190d31">loadXML2DOBJ</a>, loadXML2EmptyDOBJ, <a class="el" href="namespaceito.html#a99b23c44aedc092db34847ec3d850a7c" title="This function fills the MetaData (DataObjectTags) of an allocated dataObject from the values of an xm...">loadObjectHeaderFromXMLV1</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa3fb95bb073f0055c98ee99e91b9c22a"></a><!-- doxytag: member="ito::readStdStringFromXML" ref="aa3fb95bb073f0055c98ee99e91b9c22a" args="(QXmlStreamAttributes &amp;attrStream, QString &amp;Element, QString &amp;Attrib, std::string &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::readStdStringFromXML </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>Element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>Attrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This helper function extracts a std::string from the xml-Attributes of the Stream  This helper function extracts a std::string from the xml-Attributes of the Stream copied by the caller with the attrStream = attrStream = stream.attributes();. the Function checks if the attribute exists and than tries to convert to the value of the attribute from QString to std::string. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attrStream</td><td>incomming attribute-stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Element</td><td>name of the element (only for error msg) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Attrib</td><td>name of the attribute to extract </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>val Must be filled with default value and is filled with value from the XML-Stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a6a50711849b55cee9dfdee5224190d31">loadXML2DOBJ</a>, loadXML2EmptyDOBJ, <a class="el" href="namespaceito.html#a99b23c44aedc092db34847ec3d850a7c" title="This function fills the MetaData (DataObjectTags) of an allocated dataObject from the values of an xm...">loadObjectHeaderFromXMLV1</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afecd6942c1876cc35f42046db0a098ea"></a><!-- doxytag: member="ito::readTillNext" ref="afecd6942c1876cc35f42046db0a098ea" args="(QXmlStreamReader &amp;stream, int &amp;times, int maxtimes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ito::readTillNext </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamReader &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxtimes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This helper function reads the stream till the next startElement.  The Qt-Function readNextStartElement sometimes stops at the end-element (:P). So the function tries to read until it reaches the next startelement but only for maxtimes trys the Function checks if the attribute exists and than tries to convert to the value of the attribute either from binary or with string to double functions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>incomming xml-stream </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>times Counts of iterations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxtimes</td><td>maximal number of iterations to perform</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a6a50711849b55cee9dfdee5224190d31">loadXML2DOBJ</a>, loadXML2EmptyDOBJ </dd></dl>

</div>
</div>
<a class="anchor" id="abb7959b977b8d0f79c590380996596b8"></a><!-- doxytag: member="ito::real" ref="abb7959b977b8d0f79c590380996596b8" args="(const DataObject &amp;dObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::real </td>
          <td>(</td>
          <td class="paramtype">const DataObject &amp;&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level value which calculates the real value of each element of the input source data object and returns the resulting data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new data object with real values </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if undefined data type (e.g. real data types) </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a0e126a9e14968fd29e231b9efab55a3b" title="low-level, double templated method to save the element-wise argument of each element in source matrix...">ArgFunc</a></dd></dl>
<p>calculates the real part of each element in the given data object and returns the result as new data object </p>

</div>
</div>
<a class="anchor" id="a5756b35dfcc4d0bec5d7c69451cfaebe"></a><!-- doxytag: member="ito::RealFunc" ref="a5756b35dfcc4d0bec5d7c69451cfaebe" args="(const DataObject *dObj, DataObject *resObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CmplxTp , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::RealFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>resObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, double templated method to save the element-wise real value of each element in source matrix to result matrix </p>
<p>This method takes the real value of a complex valued input matrix and stores it in the equivalent real typed result matrix</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is source matrix, must have complex type </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the resulting data object, which has the real data type which corresponds to the complex type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>std::abs </dd></dl>

</div>
</div>
<a class="anchor" id="a8c9e2a64719008df18f75938fb711078"></a><!-- doxytag: member="ito::RowFunc" ref="a8c9e2a64719008df18f75938fb711078" args="(DataObject *dObj, const unsigned int selRow)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::RowFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>selRow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which changes the region of interest of the data object to the selected zero-based row index </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td></td></tr>
    <tr><td class="paramname">selRow</td><td>indicates the zero-based row-index (considering any existing ROI) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a97681943d7ef8d66beeac1e332ce3a46"></a><!-- doxytag: member="ito::saveDOBJ2XML" ref="a97681943d7ef8d66beeac1e332ce3a46" args="(ito::DataObject *dObjOut, QString folderFileName, bool onlyHeaderObjectFile=false, bool doubleAsBinary=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::saveDOBJ2XML </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>folderFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyHeaderObjectFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doubleAsBinary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Import a dataObject from harddrive, saved in the ITO-XML-Format (.ido or .idh) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dObjOut</td><td><a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> to save </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">folderFileName</td><td>Name of the folder and the filename e.g. c:\bla.xml or c://bla.xml </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doubleAsBinary</td><td>If true, double are exported as binary, by defaults they are saved as strings</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes data and meta data of a dataObject to the harddrive. The file format is based on xml. The data of the dataObject are converted to binary without XML-registed signs by QByteArray::toBase64()). The metaData and tagSpace are either saved as binary (QByteArray::toBase64()) or saves as strings with 15 signifiant digits (more than 32-Bit). So for most applications doubleAsBinary==false is enough.</p>
<p>Lyda </p>
<dl class="date"><dt><b>Date:</b></dt><dd>04.2012 </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a09c6b2139e9995dabe2dbbabd25bab48" title="This helper function writes the header of the Object to the xml stream.  This helper function writes ...">writeObjectHeaderToFileV1</a>, <a class="el" href="namespaceito.html#aad6e1f7022d1f9024c771f51f01f78da" title="This helper function writes the tags defined in the tagMap (DataObjectTags) from the Object to the xm...">writeObjectTagsToFileV1</a>, <a class="el" href="namespaceito.html#af96b552c35539676c8a13957de2183ad" title="This helper function writes the data(cv::mats) from the Object to the xml stream.  This helper functi...">writeObjectDataToFileV1</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1f0f29281bc5cb69fcd9759a369b09eb"></a><!-- doxytag: member="ito::saveQLIST2XML" ref="a1f0f29281bc5cb69fcd9759a369b09eb" args="(QMap&lt; QString, Param &gt; *paramList, QString id, QFile &amp;paramFile)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::saveQLIST2XML </td>
          <td>(</td>
          <td class="paramtype">QMap&lt; QString, Param &gt; *&#160;</td>
          <td class="paramname"><em>paramList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QFile &amp;&#160;</td>
          <td class="paramname"><em>paramFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>paramList List of Type QMap with the parameters to save. The parameters are deleted during writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Identifier of the plugin. Currently implemented as integer number only </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramFile</td><td>Filename of the file. The file will be opened/closed in this function</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes the parameters of a plugin to an XML file. During plugin closing this function is executed with a file name with same name as the plugin library in the plugin directory The xml file is checked for the current plugin-file version and type when opened. In case of a type conflict the parameter is currently not saved. </p>
<p>&lt; passed all elements without success, so add new one </p>

</div>
</div>
<a class="anchor" id="a121177b97c7372af887a6a01bafc0054"></a><!-- doxytag: member="ito::setParam" ref="a121177b97c7372af887a6a01bafc0054" args="(_Tp *addInObj, PyObject *args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::setParam </td>
          <td>(</td>
          <td class="paramtype">_Tp *&#160;</td>
          <td class="paramname"><em>addInObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>set a parameter value </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addInObj</td><td>the addIn whoes parameter is requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>the parameter name and value in a python object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Py_Return_None on success, NULL otherwise</dd></dl>
<p>The function tries to set the value of the parameter with the name given in args. If the parameter does not exist or is incompatible with the value passed, NULL is returned. To actually set the value the setParam function of the plugin is invoked. </p>

</div>
</div>
<a class="anchor" id="a66a9c5dc6bb068b2ce6be93f0fcf4b9f"></a><!-- doxytag: member="ito::ShiftLFunc" ref="a66a9c5dc6bb068b2ce6be93f0fcf4b9f" args="(DataObject *src, const unsigned char shiftbit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftLFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>shiftbit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which element-wisely shifts the values of the source matrix by a certain value to the left </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td></td></tr>
    <tr><td class="paramname">shiftbit</td><td>are the number bits the values are shifted </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>for unsupported data types (template specialization) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a23c24130d3ca6d2a459d5bf2a8a4b92b"></a><!-- doxytag: member="ito::ShiftLFunc&lt; ito::complex128 &gt;" ref="a23c24130d3ca6d2a459d5bf2a8a4b92b" args="(DataObject *, const unsigned char)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftLFunc&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for shift function of type complex128 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2674629cfb1e34316dd627781bfa3c0"></a><!-- doxytag: member="ito::ShiftLFunc&lt; ito::complex64 &gt;" ref="aa2674629cfb1e34316dd627781bfa3c0" args="(DataObject *, const unsigned char)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftLFunc&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for shift function of type complex64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d19fd38859c027dcf514812e987c9ee"></a><!-- doxytag: member="ito::ShiftLFunc&lt; ito::float32 &gt;" ref="a6d19fd38859c027dcf514812e987c9ee" args="(DataObject *, const unsigned char)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftLFunc&lt; ito::float32 &gt; </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for shift function of type float32 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8de5cddc9cbf637156d3acc27566e4b1"></a><!-- doxytag: member="ito::ShiftLFunc&lt; ito::float64 &gt;" ref="a8de5cddc9cbf637156d3acc27566e4b1" args="(DataObject *, const unsigned char)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftLFunc&lt; ito::float64 &gt; </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for shift function of type float64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8040457b6c031cbefb51fbdae76a3bb"></a><!-- doxytag: member="ito::ShiftRFunc" ref="ab8040457b6c031cbefb51fbdae76a3bb" args="(DataObject *src, const unsigned char shiftbit)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftRFunc </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>shiftbit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which element-wisely shifts the values of the source matrix by a certain value to the right </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td></td></tr>
    <tr><td class="paramname">shiftbit</td><td>are the number bits the values are shifted </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>for unsupported data types (template specialization) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="af06888f8baac8366f96641426371bb39"></a><!-- doxytag: member="ito::ShiftRFunc&lt; ito::complex128 &gt;" ref="af06888f8baac8366f96641426371bb39" args="(DataObject *, const unsigned char)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftRFunc&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for shift function of type complex128 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad405a0a85400adc16e1c3b1f4e1884b9"></a><!-- doxytag: member="ito::ShiftRFunc&lt; ito::complex64 &gt;" ref="ad405a0a85400adc16e1c3b1f4e1884b9" args="(DataObject *, const unsigned char)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftRFunc&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for shift function of type complex64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aabb30836cf7a7a0a3f21cf6fc35848eb"></a><!-- doxytag: member="ito::ShiftRFunc&lt; ito::float32 &gt;" ref="aabb30836cf7a7a0a3f21cf6fc35848eb" args="(DataObject *, const unsigned char)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftRFunc&lt; ito::float32 &gt; </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for shift function of type float32 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b338e54a07664315beb473504a2c8d1"></a><!-- doxytag: member="ito::ShiftRFunc&lt; ito::float64 &gt;" ref="a8b338e54a07664315beb473504a2c8d1" args="(DataObject *, const unsigned char)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftRFunc&lt; ito::float64 &gt; </td>
          <td>(</td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>template specialisation for shift function of type float64 </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1b438d0eb2715bbea3a573820950808"></a><!-- doxytag: member="ito::SubFunc" ref="af1b438d0eb2715bbea3a573820950808" args="(const DataObject *dObj1, const DataObject *dObj2, DataObject *dObjRes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::SubFunc </td>
          <td>(</td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataObject *&#160;</td>
          <td class="paramname"><em>dObj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for element-wise subtraction of values from second data object from values of first data object </p>
<p>dObjRes = dObj1 - dObj2</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj1</td><td>is the first data object </td></tr>
    <tr><td class="paramname">*dObj2</td><td>is the second data object </td></tr>
    <tr><td class="paramname">*dObjRes</td><td>is the pointer to the data object, where the values will be written to. This data object must already be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The size check for all data objects must be done before. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>operator -=, operator - </dd></dl>

</div>
</div>
<a class="anchor" id="af96b552c35539676c8a13957de2183ad"></a><!-- doxytag: member="ito::writeObjectDataToFileV1" ref="af96b552c35539676c8a13957de2183ad" args="(QXmlStreamWriter &amp;stream, DataObject *dObjOut, int elementsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::writeObjectDataToFileV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamWriter &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This helper function writes the data(cv::mats) from the Object to the xml stream.  This helper function writes the data(cv::mats) from the Object to the xml stream. Therefore the data is converted using QByteArray::toBase64() to avoid XML-conflict with the binary data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>stream outgoing xml-stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dObjOut</td><td>The allocated src-Object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementsize</td><td>Size of each matrix element in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a97681943d7ef8d66beeac1e332ce3a46" title="Import a dataObject from harddrive, saved in the ITO-XML-Format (.ido or .idh)">saveDOBJ2XML</a>, saveDOBJSpecificData2XML </dd></dl>

</div>
</div>
<a class="anchor" id="a09c6b2139e9995dabe2dbbabd25bab48"></a><!-- doxytag: member="ito::writeObjectHeaderToFileV1" ref="a09c6b2139e9995dabe2dbbabd25bab48" args="(QXmlStreamWriter &amp;stream, DataObject *dObjOut, bool doubleAsBinary, int &amp;elementsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::writeObjectHeaderToFileV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamWriter &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doubleAsBinary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>elementsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This helper function writes the header of the Object to the xml stream.  This helper function writes the header (dims, sizes, type) of an object and the metaData (complete <a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a> without tagsMap) from the Object to the xml stream. The values of the header are stored as string. The values of each axis-tag / value-tag / rotation matrix are in case of string-type directly written to the stream or in case of double converted to either strings directly (15 significat digits, &gt;32Bit) or stored as lostfree binary (QByteArray::toBase64() to avoid XML-conflict). WARNING: Do not change the header (dims, sizes, type) information or the value of tags exported as binary (d2b). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>stream outgoing xml-stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dObjOut</td><td>The allocated src-Object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doubleAsBinary</td><td>Toggle binary export for double</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a97681943d7ef8d66beeac1e332ce3a46" title="Import a dataObject from harddrive, saved in the ITO-XML-Format (.ido or .idh)">saveDOBJ2XML</a>, saveDOBJSpecificData2XML, <a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aad6e1f7022d1f9024c771f51f01f78da"></a><!-- doxytag: member="ito::writeObjectTagsToFileV1" ref="aad6e1f7022d1f9024c771f51f01f78da" args="(QXmlStreamWriter &amp;stream, DataObject *dObjOut, bool doubleAsBinary)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::writeObjectTagsToFileV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamWriter &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataObject *&#160;</td>
          <td class="paramname"><em>dObjOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doubleAsBinary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This helper function writes the tags defined in the tagMap (<a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) from the Object to the xml stream.  This helper function writes the tags defined in the tagMap (<a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a>) from the Object to the xml stream. Therefore the values of each tag are in case of string-type directly written to the stream or in case of double converted to either strings directly (15 significat digits, &gt;32Bit) or stored as lostfree binary (QByteArray::toBase64() to avoid XML-conflict). WARNING: Do not change information or the value of tags exported as binary (d2b). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>stream outgoing xml-stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dObjOut</td><td>The allocated src-Object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doubleAsBinary</td><td>Toggle binary export for double</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a97681943d7ef8d66beeac1e332ce3a46" title="Import a dataObject from harddrive, saved in the ITO-XML-Format (.ido or .idh)">saveDOBJ2XML</a>, saveDOBJSpecificData2XML, <a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a37ad10fe5e1dc2a8141837dfed93decb"></a><!-- doxytag: member="ito::ZerosFunc" ref="a37ad10fe5e1dc2a8141837dfed93decb" args="(const size_t sizeY, const size_t sizeX, int **dstMat)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ZerosFunc </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for creation of zero-valued matrix-plane </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is the pointer to the already allocated cv::Mat_&lt;type&gt;-matrix-plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>zeros </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a5f4e931b9ffb4d53504b835419bbf5d5"></a><!-- doxytag: member="ito::fListCout" ref="a5f4e931b9ffb4d53504b835419bbf5d5" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tCoutFunc ito::fListCout[]<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">
{
   coutFunc&lt;int8&gt;,
   coutFunc&lt;uint8&gt;,
   coutFunc&lt;int16&gt;,
   coutFunc&lt;uint16&gt;,
   coutFunc&lt;int32&gt;,
   coutFunc&lt;uint32&gt;,
   coutFunc&lt;ito::float32&gt;,
   coutFunc&lt;ito::float64&gt;,
   coutFunc&lt;ito::complex64&gt;,
   coutFunc&lt;ito::complex128&gt;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac3591ed94bfa2025ea35f80b6b7e1c3a"></a><!-- doxytag: member="ito::ITOM_API_FUNCS_ARR" ref="ac3591ed94bfa2025ea35f80b6b7e1c3a" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ito::ITOM_API_FUNCS_ARR[]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
                (<span class="keywordtype">void</span>*)&amp;singleApiFunctions.mfilterGetFunc,      
                (<span class="keywordtype">void</span>*)&amp;singleApiFunctions.mfilterCall,         
                (<span class="keywordtype">void</span>*)&amp;singleApiFunctions.mfilterParam,        
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctions.mfilterParamBase,    
                (<span class="keywordtype">void</span>*)&amp;singleApiFunctions.maddInGetInitParams, 
                (<span class="keywordtype">void</span>*)&amp;singleApiFunctions.maddInOpenActuator,  
                (<span class="keywordtype">void</span>*)&amp;singleApiFunctions.maddInOpenDataIO,    
        (<span class="keywordtype">void</span>*)&amp;ParamHelper::validateStringMeta,        
        (<span class="keywordtype">void</span>*)&amp;ParamHelper::validateDoubleMeta,        
        (<span class="keywordtype">void</span>*)&amp;ParamHelper::validateIntMeta,           
        (<span class="keywordtype">void</span>*)&amp;ParamHelper::validateCharMeta,          
        (<span class="keywordtype">void</span>*)&amp;ParamHelper::validateHWMeta,            
        (<span class="keywordtype">void</span>*)&amp;ParamHelper::compareParam,              
        (<span class="keywordtype">void</span>*)&amp;ParamHelper::validateParam,             
        (<span class="keywordtype">void</span>*)&amp;ParamHelper::getParamFromMapByKey,      
        (<span class="keywordtype">void</span>*)&amp;ParamHelper::parseParamName,            
        (<span class="keywordtype">void</span>*)&amp;ParamHelper::getItemFromArray,          
        (<span class="keywordtype">void</span>*)&amp;<a class="code" href="namespaceito.html#a1f0f29281bc5cb69fcd9759a369b09eb">saveQLIST2XML</a>,                          
        (<span class="keywordtype">void</span>*)&amp;loadXML2QLIST,                          
                (<span class="keywordtype">void</span>*)&amp;singleApiFunctions.mcreateFromDataObject,
                NULL
        }
</pre></div>
</div>
</div>
<a class="anchor" id="a0a87731c8a17f2acd5a5f3de4ae3f262"></a><!-- doxytag: member="ito::ITOM_API_FUNCS_GRAPH_ARR" ref="a0a87731c8a17f2acd5a5f3de4ae3f262" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ito::ITOM_API_FUNCS_GRAPH_ARR[]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mnumberOfColorBars,     
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetColorBarName,       
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetColorBarIdx,        
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetFigure,             
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetPluginList,         
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mstartLiveData,         
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mstopLiveData,          
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mconnectLiveData,       
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mdisconnectLiveData,    
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetColorBarIdxFromName,
        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetFigureSetting,      
                NULL
        }
</pre></div>
</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceito.html">ito</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Aug 22 2013 23:45:29 for itom by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
