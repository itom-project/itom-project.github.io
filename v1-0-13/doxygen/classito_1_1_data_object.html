<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>itom: ito::DataObject Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="q_itoM48.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">itom
   &#160;<span id="projectnumber">1.0.13</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.5.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classito_1_1_data_object.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">ito::DataObject Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="ito::DataObject" -->
<p>dataObject contains a n-dimensional matrix  
 <a href="classito_1_1_data_object.html#details">More...</a></p>

<p><a href="classito_1_1_data_object-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_data_object_1_1_m_r_o_i.html">MROI</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_data_object_1_1_m_size.html">MSize</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a405fb0d2cfed06ed990579e299b14309">seekMat</a> (const size_t matNum, const size_t numMats) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the index vector-index of m_data which corresponds to the given zero-based two-dimensional matrix-index  <a href="#a405fb0d2cfed06ed990579e299b14309"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#acbc98cb23e0cb28c8b8c8d7a2d05944f">seekMat</a> (const size_t matNum) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the index vector-index of m_data which corresponds to the given zero-based two-dimensional matrix-index  <a href="#acbc98cb23e0cb28c8b8c8d7a2d05944f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a7094b4f5d2dcaa975ccc6d690d23962a">calcNumMats</a> (void) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates numbers of single opencv matrices which are part of the ROI which has previously been set.  <a href="#a7094b4f5d2dcaa975ccc6d690d23962a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#aef6f5cc9ed877dff7ebf607314a1c0c0">getValueOffset</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Function return the offset of the values stored within the dataOject  <a href="#aef6f5cc9ed877dff7ebf607314a1c0c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f949cfe9c524d032ec1d04125b1bd64"></a><!-- doxytag: member="ito::DataObject::getValueScale" ref="a1f949cfe9c524d032ec1d04125b1bd64" args="() const " -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a1f949cfe9c524d032ec1d04125b1bd64">getValueScale</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function return the unit description for the values stoerd within the dataOject. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e15779be202e179813019ef50880de6"></a><!-- doxytag: member="ito::DataObject::getValueUnit" ref="a9e15779be202e179813019ef50880de6" args="() const " -->
const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a9e15779be202e179813019ef50880de6">getValueUnit</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function return the description for the values stored within the dataOject, if tagspace does not exist, NULL is returned. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13b3ece1ae4f9f44f36ac74f28367693"></a><!-- doxytag: member="ito::DataObject::getValueDescription" ref="a13b3ece1ae4f9f44f36ac74f28367693" args="() const " -->
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a13b3ece1ae4f9f44f36ac74f28367693">getValueDescription</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function return the axis-offset for the existing axis specified by axisNum. If axisNum is out of dimension range it returns NULL. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ca1ab7c61f85d6e0232773959a22d91"></a><!-- doxytag: member="ito::DataObject::getAxisOffset" ref="a9ca1ab7c61f85d6e0232773959a22d91" args="(const int axisNum) const " -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a9ca1ab7c61f85d6e0232773959a22d91">getAxisOffset</a> (const int axisNum) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function returns the axis-description for the exist axis specified by axisNum. If axisNum is out of dimension range it returns NULL. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44e554b15f9bffd8e6077fb2d61c51e5"></a><!-- doxytag: member="ito::DataObject::getAxisScale" ref="a44e554b15f9bffd8e6077fb2d61c51e5" args="(const int axisNum) const " -->
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a44e554b15f9bffd8e6077fb2d61c51e5">getAxisScale</a> (const int axisNum) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function returns the axis-unit-description for the exist axis specified by axisNum. If axisNum is out of dimension range it returns NULL. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8833ed4df6ec8987d5db5888593c38d4"></a><!-- doxytag: member="ito::DataObject::getAxisUnit" ref="a8833ed4df6ec8987d5db5888593c38d4" args="(const int axisNum, bool &amp;validOperation) const " -->
const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a8833ed4df6ec8987d5db5888593c38d4">getAxisUnit</a> (const int axisNum, bool &amp;validOperation) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function returns the axis-description for the exist specified by axisNum. If axisNum is out of dimension range it returns NULL. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70da3f5e2e7a128bb066e947ee398530"></a><!-- doxytag: member="ito::DataObject::getAxisDescription" ref="a70da3f5e2e7a128bb066e947ee398530" args="(const int axisNum, bool &amp;validOperation) const " -->
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getAxisDescription</b> (const int axisNum, bool &amp;validOperation) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05b06b04d2dc1659a816c2b404f6423d"></a><!-- doxytag: member="ito::DataObject::getTag" ref="a05b06b04d2dc1659a816c2b404f6423d" args="(const std::string key, bool &amp;validOperation) const " -->
<a class="el" href="classito_1_1_data_object_tag_type.html">DataObjectTagType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getTag</b> (const std::string key, bool &amp;validOperation) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a418f219bb93698cb411e5bd41052d65b"></a><!-- doxytag: member="ito::DataObject::getTagByIndex" ref="a418f219bb93698cb411e5bd41052d65b" args="(const int tagNumber, std::string &amp;key, DataObjectTagType &amp;value) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a418f219bb93698cb411e5bd41052d65b">getTagByIndex</a> (const int tagNumber, std::string &amp;key, <a class="el" href="classito_1_1_data_object_tag_type.html">DataObjectTagType</a> &amp;value) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function returns the string-value for 'key' identified by int tagNumber. If key in the TagMap do not exist NULL is returned. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56dac06f4679c40a9f632ac97bfd27c4"></a><!-- doxytag: member="ito::DataObject::getTagKey" ref="a56dac06f4679c40a9f632ac97bfd27c4" args="(const int tagNumber, bool &amp;validOperation) const " -->
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a56dac06f4679c40a9f632ac97bfd27c4">getTagKey</a> (const int tagNumber, bool &amp;validOperation) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function returns the number of elements in the Tags-Maps. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13f78ec1afc91c174b3e7b449b1a47bc"></a><!-- doxytag: member="ito::DataObject::getTagListSize" ref="a13f78ec1afc91c174b3e7b449b1a47bc" args="() const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>getTagListSize</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#aa58d6ed711b01b4cbd4dd282a1d574ec">setValueUnit</a> (const std::string &amp;unit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Function to set the string-value of the value unit, return 1 if values does not exist  <a href="#aa58d6ed711b01b4cbd4dd282a1d574ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac49d259247fd2f8d665287d8ac764cda"></a><!-- doxytag: member="ito::DataObject::setValueDescription" ref="ac49d259247fd2f8d665287d8ac764cda" args="(const std::string &amp;description)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>setValueDescription</b> (const std::string &amp;description)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a707f177346aed9923d84304e2c8e4b24"></a><!-- doxytag: member="ito::DataObject::setAxisOffset" ref="a707f177346aed9923d84304e2c8e4b24" args="(const unsigned int axisNum, const double offset)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a707f177346aed9923d84304e2c8e4b24">setAxisOffset</a> (const unsigned int axisNum, const double offset)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Function to set the offset of the specified axis, return 1 if axis does not exist <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a516b5ef3c2dd6ef45003951dba92bddc"></a><!-- doxytag: member="ito::DataObject::setAxisScale" ref="a516b5ef3c2dd6ef45003951dba92bddc" args="(const unsigned int axisNum, const double scale)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a516b5ef3c2dd6ef45003951dba92bddc">setAxisScale</a> (const unsigned int axisNum, const double scale)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Function to set the scale of the specified axis, return 1 if axis does not exist or scale is 0.0. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac449fa239351ce365bfdde568e15191d"></a><!-- doxytag: member="ito::DataObject::setAxisUnit" ref="ac449fa239351ce365bfdde568e15191d" args="(const unsigned int axisNum, const std::string &amp;unit)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ac449fa239351ce365bfdde568e15191d">setAxisUnit</a> (const unsigned int axisNum, const std::string &amp;unit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Function to set the unit (string value) of the specified axis, return 1 if axis does not exist <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7af580eef6b5a8ccb40a655c4a3e2ba"></a><!-- doxytag: member="ito::DataObject::setAxisDescription" ref="ad7af580eef6b5a8ccb40a655c4a3e2ba" args="(const unsigned int axisNum, const std::string &amp;description)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ad7af580eef6b5a8ccb40a655c4a3e2ba">setAxisDescription</a> (const unsigned int axisNum, const std::string &amp;description)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Function to set the description (string value) of the specified axis, return 1 if axis does not exist <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedbb349d81443ed13def258dcbff1cdf"></a><!-- doxytag: member="ito::DataObject::setTag" ref="aedbb349d81443ed13def258dcbff1cdf" args="(const std::string &amp;key, const DataObjectTagType &amp;value)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#aedbb349d81443ed13def258dcbff1cdf">setTag</a> (const std::string &amp;key, const <a class="el" href="classito_1_1_data_object_tag_type.html">DataObjectTagType</a> &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Function to set the string value of the specified tag, if the tag do not exist, it will be added automatically, return 1 if tagspace does not exist <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88944a762fdf392b6fc00d76cd92b945"></a><!-- doxytag: member="ito::DataObject::existTag" ref="a88944a762fdf392b6fc00d76cd92b945" args="(const std::string &amp;key) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a88944a762fdf392b6fc00d76cd92b945">existTag</a> (const std::string &amp;key) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Function to check whether tag exist or not <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bb74c042aba987def8d81052b722981"></a><!-- doxytag: member="ito::DataObject::deleteTag" ref="a2bb74c042aba987def8d81052b722981" args="(const std::string &amp;key)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a2bb74c042aba987def8d81052b722981">deleteTag</a> (const std::string &amp;key)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Function deletes specified tag. If tag do not exist, return value is 1 else returnvalue is 0 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca9d98ceff2cddf4c28e57b8b789c526"></a><!-- doxytag: member="ito::DataObject::deleteAllTags" ref="aca9d98ceff2cddf4c28e57b8b789c526" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>deleteAllTags</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd006f558971045d9d17021bb38de07c"></a><!-- doxytag: member="ito::DataObject::addToProtocol" ref="afd006f558971045d9d17021bb38de07c" args="(const std::string &amp;value)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#afd006f558971045d9d17021bb38de07c">addToProtocol</a> (const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Function adds value to the protocol-tag. If this object is an ROI, the ROI-coordinates are added. If string do not end with an <br/>
, <br/>
 is added. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a2391196f61281809fed015e36833c413">getPhysToPix</a> (const unsigned int dim, const double phys, bool &amp;isInsideImage) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function returns the not rounded pixel index of a physical coordinate  Function returns the not rounded pixel index of a physical coordinate (Unit-Coordinate = ( px-Coordinate - Offset)* Scale). If the pixel is outside of the image, the isInsideImage-flag is set to false else it is set to true. To avoid memory access-error, the returnvalue is clipped within the range of the image ([0...imagesize-1])  <a href="#a2391196f61281809fed015e36833c413"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c5f5878df0ece21028f06abdd3ace4c"></a><!-- doxytag: member="ito::DataObject::getPhysToPix2D" ref="a2c5f5878df0ece21028f06abdd3ace4c" args="(const double physY, double &amp;tPxY, bool &amp;isInsideImageY, const double physX, double &amp;tPxX, bool &amp;isInsideImageX) const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a2c5f5878df0ece21028f06abdd3ace4c">getPhysToPix2D</a> (const double physY, double &amp;tPxY, bool &amp;isInsideImageY, const double physX, double &amp;tPxX, bool &amp;isInsideImageX) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function returns the not rounded pixel index of a physical coordinate. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ac78de8af0bd6570e00b53ce7c1e7cac3">getPixToPhys</a> (const unsigned int dim, const double pix, bool &amp;isInsideImage) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function returns the physical coordinate of a pixel  Function returns the physical coordinate of a pixel index (Unit-Coordinate = ( px-Coordinate - Offset)* Scale). If the pixel is outside of the image, the isInsideImage-flag is set to false else it is set to true.  <a href="#ac78de8af0bd6570e00b53ce7c1e7cac3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ae336de870171cd63196843607dc05189">setXYRotationalMatrix</a> (double r11, double r12, double r13, double r21, double r22, double r23, double r31, double r32, double r33)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to access (set) the rotiational matrix by each element.  <a href="#ae336de870171cd63196843607dc05189"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ab4c8d40d3d7b5497056a6903202ffd12">getXYRotationalMatrix</a> (double &amp;r11, double &amp;r12, double &amp;r13, double &amp;r21, double &amp;r22, double &amp;r23, double &amp;r31, double &amp;r32, double &amp;r33) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to access (get) the rotiational matrix by each element.  <a href="#ab4c8d40d3d7b5497056a6903202ffd12"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#aecb43ce72bb152b72a572e584e095de7">copyTagMapTo</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a3874ac350aa5ec1fc9b14fcf551780af">copyAxisTagsTo</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a65c56fb3e99963794f1c7b854edf1aa3">getDims</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a96676055bdf8c9128c1d07f866921dcb">getType</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a06939618cad91af4c856b5489b2c463b">getContinuous</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69f02792bd3bad65a4f3acf9a4b6c9c7"></a><!-- doxytag: member="ito::DataObject::getOwnData" ref="a69f02792bd3bad65a4f3acf9a4b6c9c7" args="(void) const " -->
char&#160;</td><td class="memItemRight" valign="bottom"><b>getOwnData</b> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a31be0faf95d0a36724ee999133e12e70">getTotal</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">gets total number of elements within the data object's ROI  <a href="#a31be0faf95d0a36724ee999133e12e70"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a93f952b677c892f59943b200673c8231">getOriginalTotal</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">gets total number of elements of the whole data object  <a href="#a93f952b677c892f59943b200673c8231"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ad2bbe518c3a3e86adede7804765178e3">lockRead</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">locks this dataObject (all header information) and the underlying data block for a read operation  <a href="#ad2bbe518c3a3e86adede7804765178e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a49df9e5d334568f8cc99cfeec1cfd688">lockWrite</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">locks this dataObject (all header information) and the underlying data block for a write operation  <a href="#a49df9e5d334568f8cc99cfeec1cfd688"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a1a000f1647f44b5de4952e77aadd9cf4">unlock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">unlocks any lock. If lock is writeLock, lock is set to idle, if lock is readLock, then the number of readers is decremented and lock is freed if no more readers are available  <a href="#a1a000f1647f44b5de4952e77aadd9cf4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#affdc8a47d061562a1f7dd9a47465fea5">copyTo</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, unsigned char regionOnly=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level, non-templated method to deeply copy the data of this matrix to another matrix rhs  <a href="#affdc8a47d061562a1f7dd9a47465fea5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a8c385ca573159fd49cec4112ef92557f">convertTo</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, const int type, const double alpha=1, const double beta=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level, non-templated matrix conversion  <a href="#a8c385ca573159fd49cec4112ef92557f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ae3de7306dbaf78ea23ea96d034ca3a39">deepCopyPartial</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level, non-templated method. Deeply copies data of this data object which is within its ROI to the ROI of rhs.  <a href="#ae3de7306dbaf78ea23ea96d034ca3a39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ae3387eadb8aabb7458c2a5e2bf2e5b54">get_mdata</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to vector of cv::_Mat-matrices  <a href="#ae3387eadb8aabb7458c2a5e2bf2e5b54"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a7f1d803c480bf1c35a1b880338ccab85">get_mdata</a> (void) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constant version of get_mdata  <a href="#a7f1d803c480bf1c35a1b880338ccab85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structito_1_1_data_object_1_1_m_size.html">MSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a5bb75ea76bc186f15b41388da88d2df9">getSize</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the size-member. m_size fits to the physical organization of data in memory.  <a href="#a5bb75ea76bc186f15b41388da88d2df9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structito_1_1_data_object_1_1_m_size.html">MSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a7fa0a20b7c911588404919a2dd799fc8">getSize</a> (void) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the size-member. This member does not consider the transpose flag, hence, m_size fits to the physical organization of data in memory.  <a href="#a7fa0a20b7c911588404919a2dd799fc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a5d97eb4aa8c9c277fc7b3c038c96fa4e">getSize</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the size of the given dimension (this is the size within the ROI)  <a href="#a5d97eb4aa8c9c277fc7b3c038c96fa4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a813d34179416b7d27b3aed5622296963">getOriginalSize</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the original size of the given dimension (this is the size without considering any ROI)  <a href="#a813d34179416b7d27b3aed5622296963"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4373c50161d5ba79a9014792f9088dee"></a><!-- doxytag: member="ito::DataObject::begin" ref="a4373c50161d5ba79a9014792f9088dee" args="()" -->
<a class="el" href="classito_1_1_d_obj_iterator.html">DObjIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a4373c50161d5ba79a9014792f9088dee">begin</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns 0, this is the index of the first element in valid <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> range. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb679e37f6584c18f5a82d949ac86e2b"></a><!-- doxytag: member="ito::DataObject::end" ref="abb679e37f6584c18f5a82d949ac86e2b" args="()" -->
<a class="el" href="classito_1_1_d_obj_iterator.html">DObjIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#abb679e37f6584c18f5a82d949ac86e2b">end</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns index of last-element in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> range incremented by one. (equal to number of elements in total range) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae583be0fd89d3dcdc4ffeb70ac6e0389"></a><!-- doxytag: member="ito::DataObject::constBegin" ref="ae583be0fd89d3dcdc4ffeb70ac6e0389" args="() const " -->
<a class="el" href="classito_1_1_d_obj_const_iterator.html">DObjConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>constBegin</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedc32c887c0ff85cf96b197ac508a1c3"></a><!-- doxytag: member="ito::DataObject::constEnd" ref="aedc32c887c0ff85cf96b197ac508a1c3" args="() const " -->
<a class="el" href="classito_1_1_d_obj_const_iterator.html">DObjConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>constEnd</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ad237136b142095093e9dd3aef4fad088">DataObject</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for empty data object  <a href="#ad237136b142095093e9dd3aef4fad088"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ac26aa4e55ee83a4566c43f0407575c71">DataObject</a> (const size_t size, const int type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for one-dimensional data object. The data is newly allocated and arbitrarily filled.  <a href="#ac26aa4e55ee83a4566c43f0407575c71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a23d342956f539e2864951839ef5347c0">DataObject</a> (const size_t sizeY, const size_t sizeX, const int type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for two-dimensional data object. The data is newly allocated and arbitrarily filled.  <a href="#a23d342956f539e2864951839ef5347c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a4eabd540dbbc04253c8d8088af9df8a3">DataObject</a> (const size_t sizeZ, const size_t sizeY, const size_t sizeX, const int type, const unsigned char continuous=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for three-dimensional data object. The data is newly allocated and arbitrarily filled.  <a href="#a4eabd540dbbc04253c8d8088af9df8a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a166ee1e0965e2a6be13386c8b5c153e3">DataObject</a> (const size_t sizeZ, const size_t sizeY, const size_t sizeX, const int type, const uchar *continuousDataPtr, const size_t *steps=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for 3-dimensional data object which uses the data given by the continuousDataPtr.  <a href="#a166ee1e0965e2a6be13386c8b5c153e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a0ea80ead468229f44af3b42cb86a04fd">DataObject</a> (const unsigned char dimensions, const size_t *sizes, const int type, const unsigned char continuous=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for data object with given dimension. The data is newly allocated and arbitrarily filled.  <a href="#a0ea80ead468229f44af3b42cb86a04fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#aa10cfc9b3d42d1221f2d90c04e0d87f7">DataObject</a> (const unsigned char dimensions, const size_t *sizes, const int type, const uchar *continuousDataPtr, const size_t *steps=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for data object which uses the data given by the continuousDataPtr.  <a href="#aa10cfc9b3d42d1221f2d90c04e0d87f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0062db2e5750fafde71bfd97fbefa830"></a><!-- doxytag: member="ito::DataObject::DataObject" ref="a0062db2e5750fafde71bfd97fbefa830" args="(const unsigned char dimensions, const size_t *sizes, const int type, const cv::Mat *planes, const unsigned int nrOfPlanes)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>DataObject</b> (const unsigned char dimensions, const size_t *sizes, const int type, const cv::Mat *planes, const unsigned int nrOfPlanes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a32e74ff9c1cd0e9fc73d5f7705bce605">DataObject</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;copyConstr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor for data object  <a href="#a32e74ff9c1cd0e9fc73d5f7705bce605"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a828f90ce03f273216c9314c60ca574d1">~DataObject</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="#a828f90ce03f273216c9314c60ca574d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a04a374f5bbac7fcb0561a66cdb3e38ba">operator=</a> (const cv::Mat &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">assign-operator which creates a two-dimensional data object as a shallow copy of a two dimensional cv::Mat object.  <a href="#a04a374f5bbac7fcb0561a66cdb3e38ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#aab29e1c4f0da83365614a725293c6b40">operator=</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">assign-operator which makes a shallow-copy of the rhs data object and stores it in this data object  <a href="#aab29e1c4f0da83365614a725293c6b40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a261f0755e25c89fd87278ea17e81df10">operator=</a> (const int8 value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Every data element in this data object is set to the given value.  <a href="#a261f0755e25c89fd87278ea17e81df10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a4b5619e2c783ffcb526ddad2fd31243f">operator=</a> (const uint8 value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Every data element in this data object is set to the given value.  <a href="#a4b5619e2c783ffcb526ddad2fd31243f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a597725a7d7ff849a86b1e15115666830">operator=</a> (const int16 value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Every data element in this data object is set to the given value.  <a href="#a597725a7d7ff849a86b1e15115666830"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#aaac65ef40fdc2211f6ea7d3d6c9f984c">operator=</a> (const uint16 value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Every data element in this data object is set to the given value.  <a href="#aaac65ef40fdc2211f6ea7d3d6c9f984c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a6e7809f1696c0541e1eb8647e1269887">operator=</a> (const int32 value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Every data element in this data object is set to the given value.  <a href="#a6e7809f1696c0541e1eb8647e1269887"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a704d29e5a59e7c99ec4f7028a63957e3">operator=</a> (const uint32 value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Every data element in this data object is set to the given value.  <a href="#a704d29e5a59e7c99ec4f7028a63957e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a788f6e4313206860210a02d366902084">operator=</a> (const float32 value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Every data element in this data object is set to the given value.  <a href="#a788f6e4313206860210a02d366902084"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#abd6df3f0e743760727902c3c769864ef">operator=</a> (const float64 value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Every data element in this data object is set to the given value.  <a href="#abd6df3f0e743760727902c3c769864ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ab02ebe64c3f32b59562bf20b4fe8a543">operator=</a> (const complex64 value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Every data element in this data object is set to the given value.  <a href="#ab02ebe64c3f32b59562bf20b4fe8a543"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a836c6a8281b82e86fbaabf1e5ba76e92">operator=</a> (const complex128 value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Every data element in this data object is set to the given value.  <a href="#a836c6a8281b82e86fbaabf1e5ba76e92"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a804e80bb2cbe3e54d9b08e87ecbc0042">operator+=</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level, non-templated arithmetic operator for element-wise addition of values of given data object to this data object  <a href="#a804e80bb2cbe3e54d9b08e87ecbc0042"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43df680bb31f2245e4e3773e2a2fb026"></a><!-- doxytag: member="ito::DataObject::operator+=" ref="a43df680bb31f2245e4e3773e2a2fb026" args="(const float64 value)" -->
<a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator+=</b> (const float64 value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a423136ed813e0ced63f5c660345d5f43">operator+</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level, non-templated arithmetic operator for element-wise addition of values of two given data objects  <a href="#a423136ed813e0ced63f5c660345d5f43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac397bd705a14fe86541b3e68d44407dd"></a><!-- doxytag: member="ito::DataObject::operator+" ref="ac397bd705a14fe86541b3e68d44407dd" args="(const float64 value)" -->
<a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const float64 value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ac007b5a6c7702cf35dd9e048bd416621">operator-=</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level, non-templated arithmetic operator for element-wise subtraction of values of given data object from values of this data object  <a href="#ac007b5a6c7702cf35dd9e048bd416621"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a974b498c5f5035f6a63bfe303a4357d0"></a><!-- doxytag: member="ito::DataObject::operator&#45;=" ref="a974b498c5f5035f6a63bfe303a4357d0" args="(const float64 value)" -->
<a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator-=</b> (const float64 value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a5a7d34b662e7187dfaf222b5188264da">operator-</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level, non-templated arithmetic operator for element-wise subtraction of values of given data object from values of this data object  <a href="#a5a7d34b662e7187dfaf222b5188264da"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ae0cb35f99916f848ad68ba895b22c3"></a><!-- doxytag: member="ito::DataObject::operator&#45;" ref="a2ae0cb35f99916f848ad68ba895b22c3" args="(const float64 value)" -->
<a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const float64 value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a3dd030faaa211776b0c9ba25e63c554b">operator*=</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">brief description  <a href="#a3dd030faaa211776b0c9ba25e63c554b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a884eb37cc708d0dfb6fb1a020a126ab4">operator*=</a> (const float64 factor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level method which multiplies every element in this data object by a given floating-point factor  <a href="#a884eb37cc708d0dfb6fb1a020a126ab4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a25c0d37c69d869712782e654c5146637">operator*</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">brief description  <a href="#a25c0d37c69d869712782e654c5146637"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a67a7e9180436832562e9ded0899d9333">operator*</a> (const float64 factor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level method which multiplies every element in this data object by a given floating-point factor. The result matrix is returned as a new matrix.  <a href="#a67a7e9180436832562e9ded0899d9333"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#add5792482da07596672d94d1960be999">operator&lt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">compare operator, compares for "lower than"  <a href="#add5792482da07596672d94d1960be999"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a488459b6effcb181b020c053529699f7">operator&gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">compare operator, compares for "bigger than"  <a href="#a488459b6effcb181b020c053529699f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a46bf4171899fb1d89bdca49156ca7a55">operator&lt;=</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">compare operator, compares for "lower or equal than"  <a href="#a46bf4171899fb1d89bdca49156ca7a55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a7c850b2e6e0b7c8813f1c75d2ced4a57">operator&gt;=</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">compare operator, compares for "bigger or equal than"  <a href="#a7c850b2e6e0b7c8813f1c75d2ced4a57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a5c3366b3572da2a2ba4cd401ab198b06">operator==</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">compare operator, compares for "equal to"  <a href="#a5c3366b3572da2a2ba4cd401ab198b06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ad6a66bf5d5ba132e4fa3da9302f1dbcb">operator!=</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">compare operator, compares for "unequal to"  <a href="#ad6a66bf5d5ba132e4fa3da9302f1dbcb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a7082131ce6b72946be31ef767a9ed02a">operator&lt;&lt;</a> (const unsigned int shiftbit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level operator, which shifts the elements of this data objects by a given number of bits to the left and returns the new data object  <a href="#a7082131ce6b72946be31ef767a9ed02a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a39a98696544d8353332866673cae8725">operator&lt;&lt;=</a> (const unsigned int shiftbit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level operator, which shifts the elements of this data objects by a given number of bits to the left  <a href="#a39a98696544d8353332866673cae8725"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a4016a00323cd271ed6366bb922ac5bc5">operator&gt;&gt;</a> (const unsigned int shiftbit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level operator, which shifts the elements of this data objects by a given number of bits to the right and returns the new data object  <a href="#a4016a00323cd271ed6366bb922ac5bc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a208d1846b79c62419fed054af4250b6c">operator&gt;&gt;=</a> (const unsigned int shiftbit)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level operator, which shifts the elements of this data objects by a given number of bits to the right  <a href="#a208d1846b79c62419fed054af4250b6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a4221d0565c1df3ba6f058f41ae176fc6">operator&amp;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level operator, which executes the element-wise operation "bitwise and" between this data object and a given data object  <a href="#a4221d0565c1df3ba6f058f41ae176fc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a6d2df5af73abd286bd8b810d0585929c">operator&amp;=</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level operator, which executes the element-wise operation "bitwise and" between this data object and a given data object  <a href="#a6d2df5af73abd286bd8b810d0585929c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a2e7e0efb4bc0d347b50b28ec2b3004cb">operator|</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level operator, which executes the element-wise operation "bitwise or" between this data object and a given data object  <a href="#a2e7e0efb4bc0d347b50b28ec2b3004cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ad271054f288b123f3c1d8e88352f21ee">operator|=</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level operator, which executes the element-wise operation "bitwise or" between this data object and a given data object  <a href="#ad271054f288b123f3c1d8e88352f21ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a1537e963c49a7be1479cce8460c54294">operator^</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level operator, which executes the element-wise operation "bitwise or" between this data object and a given data object  <a href="#a1537e963c49a7be1479cce8460c54294"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a0c71ddada50985cfceeb43f32edc01b8">operator^=</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level operator, which executes the element-wise operation "bitwise xor" between this data object and a given data object  <a href="#a0c71ddada50985cfceeb43f32edc01b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a4502b8f52617660be595474cc92d7066">zeros</a> (const int type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a zero-value matrix of size 1x1 with the given type  <a href="#a4502b8f52617660be595474cc92d7066"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a613de23f31c74337e805e70f4c760f96">zeros</a> (const size_t size, const int type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a zero-value matrix of size 1 x size with the given type  <a href="#a613de23f31c74337e805e70f4c760f96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ae18e33f8cae1119a3848137108a97222">zeros</a> (const size_t sizeY, const size_t sizeX, const int type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a zero-value matrix of size sizeY x sizeX with the given type  <a href="#ae18e33f8cae1119a3848137108a97222"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ac4d5e5abd8584e2ba0e5756fd6320536">zeros</a> (const size_t sizeZ, const size_t sizeY, const size_t sizeX, const int type, const unsigned char continuous=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a zero-value, 3D- matrix of size sizeZ x sizeY x sizeX with the given type  <a href="#ac4d5e5abd8584e2ba0e5756fd6320536"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#afa41e2888cdfad842e56b702780c2846">zeros</a> (const unsigned char dimensions, const size_t *sizes, const int type, const unsigned char continuous=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level, non-templated base function for allocation of new matrix whose elements are all set to zero  <a href="#afa41e2888cdfad842e56b702780c2846"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a4ff0c10c033bde5c886468693b603817">ones</a> (const int type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a one-value matrix of size 1x1 with the given type  <a href="#a4ff0c10c033bde5c886468693b603817"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#aacd7a8ef10584c0c12de213bb351bff9">ones</a> (const size_t size, const int type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a one-value matrix of size 1 x size with the given type  <a href="#aacd7a8ef10584c0c12de213bb351bff9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a0c549fc9e13bd095c1418940f572dfe3">ones</a> (const size_t sizeY, const size_t sizeX, const int type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a one-value matrix of size sizeY x sizeX with the given type  <a href="#a0c549fc9e13bd095c1418940f572dfe3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a10122e7cd805251be2bcacafd9d071f1">ones</a> (const size_t sizeZ, const size_t sizeY, const size_t sizeX, const int type, const unsigned char continuous=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a one-valued, 3D- matrix of size sizeZ x sizeY x sizeX with the given type  <a href="#a10122e7cd805251be2bcacafd9d071f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#aa07867b126524637ccb6fc93b661b445">ones</a> (const unsigned char dimensions, const size_t *sizes, const int type, const unsigned char continuous=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level, non-templated base function for allocation of new matrix whose elements are all set to one  <a href="#aa07867b126524637ccb6fc93b661b445"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a137cff8dcc4e04b37cd3da73090f96e4">rand</a> (const int type, const bool randMode=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a random-value matrix of size 1x1 with the given type  <a href="#a137cff8dcc4e04b37cd3da73090f96e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a439cb939eaae3172d415202da83e8b24">rand</a> (const size_t size, const int type, const bool randMode=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a random-value matrix of size 1 x size with the given type  <a href="#a439cb939eaae3172d415202da83e8b24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a8f4001ccf47ee03b7b066cdc095763db">rand</a> (const size_t sizeY, const size_t sizeX, const int type, const bool randMode=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a random-value matrix of size sizeY x sizeX with the given type  <a href="#a8f4001ccf47ee03b7b066cdc095763db"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a1b2354c38eeec2687eae1131b9dc3bdf">rand</a> (const size_t sizeZ, const size_t sizeY, const size_t sizeX, const int type, const bool randMode, const unsigned char continuous=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates a random-valued, 3D- matrix of size sizeZ x sizeY x sizeX with the given type  <a href="#a1b2354c38eeec2687eae1131b9dc3bdf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ac002b0b9e459eda4df79cc0b6ead28ea">rand</a> (const unsigned char dimensions, const size_t *sizes, const int type, const bool randMode, const unsigned char continuous=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level, non-templated base function for allocation of new matrix whose elements are all set to one  <a href="#ac002b0b9e459eda4df79cc0b6ead28ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#aa2d2891a7e90fb1fc7224327d3b5895f">eye</a> (const int type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the matrix of this data object to a two-dimensional eye-matrix of size 1, hence [1]  <a href="#aa2d2891a7e90fb1fc7224327d3b5895f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a14e2ccd80603f1448a08cfb100da9138">eye</a> (const size_t size, const int type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the matrix of this data object to a two-dimensional eye-matrix of given size  <a href="#a14e2ccd80603f1448a08cfb100da9138"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a47fe6b5f8038aefcf65f30ad73d8ee2c">conj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts every element of the data object to its conjugate complex value  <a href="#a47fe6b5f8038aefcf65f30ad73d8ee2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a4cf2c2fe67b96f17fc8139036c0d4a1d">adj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts every element of the data object to its adjungate value  <a href="#a4cf2c2fe67b96f17fc8139036c0d4a1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#af834677086d1d7adeab2ae5de67f7d24">trans</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">transposes this data object  <a href="#af834677086d1d7adeab2ae5de67f7d24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70bd0816c2c3ef57295e8a905d670cae"></a><!-- doxytag: member="ito::DataObject::mul" ref="a70bd0816c2c3ef57295e8a905d670cae" args="(const DataObject &amp;mat2, const double scale=1.0)" -->
<a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mul</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;mat2, const double scale=1.0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ae26cff1f3e3efcc2d10b6062361758de">div</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;mat2, const double scale=1.0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level method which does a element-wise division of elements in this matrix by elements in second source matrix.  <a href="#ae26cff1f3e3efcc2d10b6062361758de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaacf0fc8228554652c4369a44601ef65"></a><!-- doxytag: member="ito::DataObject::squeeze" ref="aaacf0fc8228554652c4369a44601ef65" args="() const " -->
<a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><b>squeeze</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a290303624a2b04282f30325f9d20a884"></a><!-- doxytag: member="ito::DataObject::elemSize" ref="a290303624a2b04282f30325f9d20a884" args="() const " -->
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>elemSize</b> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ad8808bab69b30aa1c1421f39f7cec624">at</a> (const int x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">addressing method for one-dimensional data object or two-dimensional data object having at least one dimension with size 1.  <a href="#ad8808bab69b30aa1c1421f39f7cec624"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ab367d263f91d09171612f67c4a06369a">at</a> (const int x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">addressing method for one-dimensional data object or two-dimensional data object having at least one dimension with size 1.  <a href="#ab367d263f91d09171612f67c4a06369a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a0f61a672538ac07cfb3e7f45b185aaf0">at</a> (const unsigned int y, const unsigned int x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">addressing method for two-dimensional data object.  <a href="#a0f61a672538ac07cfb3e7f45b185aaf0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a2003f8329dcfb91aea95d9eef5feb4ef">at</a> (const unsigned int y, const unsigned int x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">addressing method for two-dimensional data object.  <a href="#a2003f8329dcfb91aea95d9eef5feb4ef"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a0aff545034bc6d6e31ac5ac507a91039">at</a> (const unsigned int z, const unsigned int y, const unsigned int x) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">addressing method for three-dimensional data object.  <a href="#a0aff545034bc6d6e31ac5ac507a91039"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a129d4a8d37cf075ec8ac75e0fdf2889d">at</a> (const unsigned int z, const unsigned int y, const unsigned int x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">addressing method for three-dimensional data object.  <a href="#a129d4a8d37cf075ec8ac75e0fdf2889d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a8c67180004a75ed2c036e151a7a83cc9">at</a> (const unsigned int *idx) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">addressing method for n-dimensional data object.  <a href="#a8c67180004a75ed2c036e151a7a83cc9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">_Tp &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ab6e695dfbde713fbd4737ca345c57d09">at</a> (const unsigned int *idx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">addressing method for n-dimensional data object.  <a href="#ab6e695dfbde713fbd4737ca345c57d09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a5f2dbbadffdbebd6bc8ae4e91e565ec3">at</a> (const <a class="el" href="classito_1_1_range.html">ito::Range</a> rowRange, const <a class="el" href="classito_1_1_range.html">ito::Range</a> colRange)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">addressing method for two-dimensional data object with two given range-values. returns shallow copy of addressed regions.  <a href="#a5f2dbbadffdbebd6bc8ae4e91e565ec3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a892e6ab94407685f44a80686411f3e79">at</a> (<a class="el" href="classito_1_1_range.html">ito::Range</a> *ranges)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#aa3beeaaa26357b24ff222ad905bd9e7e">rowPtr</a> (const size_t matNum, const int y)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the data in the y-th row in the 2d-matrix plane matNum  <a href="#aa3beeaaa26357b24ff222ad905bd9e7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uchar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a38254ce9fb22a2da7bec07884af26c5b">rowPtr</a> (const size_t matNum, const int y) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns pointer to the data in the y-th row in the 2d-matrix plane matNum  <a href="#a38254ce9fb22a2da7bec07884af26c5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a149d63105180924256f85099a73e820a">row</a> (const int selRow)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level method which makes a new header for the specified matrix row and returns it. The underlying data of the new matrix is shared with the original matrix.  <a href="#a149d63105180924256f85099a73e820a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a4f7924f210854916d5f52bb45995df8f">col</a> (const int selCol)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level method which makes a new header for the specified matrix column and returns it. The underlying data of the new matrix is shared with the original matrix.  <a href="#a4f7924f210854916d5f52bb45995df8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#adefd7b5822dc68f967ef574e9f841c71">adjustROI</a> (const int dtop, const int dbottom, const int dleft, const int dright)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">adjust submatrix size and position within the two-dimensional data-object  <a href="#adefd7b5822dc68f967ef574e9f841c71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#acff86dfa8dd2f4757ad361723718424b">adjustROI</a> (const unsigned char dims, const int *lims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">adjust submatrix size and position within the n-dimensional data-object  <a href="#acff86dfa8dd2f4757ad361723718424b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a46a1ad505f71c7081690519225bac769">locateROI</a> (int *wholeSizes, int *offsets)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">method locates ROI of this data object within its original data block  <a href="#a46a1ad505f71c7081690519225bac769"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ac6f4f76968bd4317a83a452c597db875">locateROI</a> (int *lims)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">method get ROI of this data object within its original data block  <a href="#ac6f4f76968bd4317a83a452c597db875"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a31cb9ec00d5576e764154368ebbe56f6"></a><!-- doxytag: member="ito::DataObject::copyFromData2D" ref="a31cb9ec00d5576e764154368ebbe56f6" args="(const _Tp *src, const size_t sizeX, const size_t sizeY)" -->
template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a31cb9ec00d5576e764154368ebbe56f6">copyFromData2D</a> (const _Tp *src, const size_t sizeX, const size_t sizeY)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">copies 2D continuous data into data object, data object must have correct size and type, otherwise an error is returned <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4f1485c21a0d0d526062c253ff4e083c"></a><!-- doxytag: member="ito::DataObject::copyFromData2D" ref="a4f1485c21a0d0d526062c253ff4e083c" args="(const _Tp *src, const size_t sizeX, const size_t sizeY, const int x0, const int y0, const size_t width, const size_t height)" -->
template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a4f1485c21a0d0d526062c253ff4e083c">copyFromData2D</a> (const _Tp *src, const size_t sizeX, const size_t sizeY, const int x0, const int y0, const size_t width, const size_t height)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">copies 2D continuous data into data object, data object must have correct size and type, otherwise an error is returned <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a4a43f3104ff2cdc50dbef24837a05889"></a><!-- doxytag: member="ito::DataObject::checkType" ref="a4a43f3104ff2cdc50dbef24837a05889" args="(const _Tp *src)" -->
template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a4a43f3104ff2cdc50dbef24837a05889">checkType</a> (const _Tp *src)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">verifies if the data type of elements in this data object is equal to the type of the argument. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a87f0d6cfe9dec3410b00fae4edf2fb13">operator T2</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">cast operator for data object  <a href="#a87f0d6cfe9dec3410b00fae4edf2fb13"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a85cbf8d6913c011decc6270d3f73a4ff">createHeader</a> (const unsigned char dimensions, const size_t *sizes, const size_t *steps, const size_t elemSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">helper method for creation of header information  <a href="#a85cbf8d6913c011decc6270d3f73a4ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a7f10f129370bd2d578971f2b494e987c">createHeaderWithROI</a> (const unsigned char dimensions, const size_t *sizes, const size_t *osizes=NULL, const size_t *roi=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">helper method for creation of header information considering the region of interest  <a href="#a7f10f129370bd2d578971f2b494e987c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a80c0b9752187b008d1e9114231f82d65">create</a> (const unsigned char dimensions, const size_t *sizes, const int type, const unsigned char continuous, const uchar *continuousDataPtr=NULL, const size_t *steps=NULL)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level, non-templated method for data allocation  <a href="#a80c0b9752187b008d1e9114231f82d65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a66e736e06b40c66116203efb7f56d208">create</a> (const unsigned char dimensions, const size_t *sizes, const int type, const cv::Mat *planes, const unsigned int nrOfPlanes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level, non-templated method for data allocation  <a href="#a66e736e06b40c66116203efb7f56d208"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a687861887060a1392433f4bfbfd770fc">freeData</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level, non-templated method for freeing data  <a href="#a687861887060a1392433f4bfbfd770fc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a58500432da4b3c3ac108a7930f4c91ac">secureFreeData</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level, non-templated method for securely freeing data  <a href="#a58500432da4b3c3ac108a7930f4c91ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#aa106e0f675ff44f0ef819f21c58340e1">matNumToIdx</a> (const size_t matNum, size_t *matIdx) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#acccac371f10937b61de8c3f3f0f2eeb5">matIdxToNum</a> (const unsigned int *matIdx, size_t *matNum) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">brief calculates the index of the matrix-plane in the m_data-vector for a given vector of indices, which address one element in the n-dimensional matrix  <a href="#acccac371f10937b61de8c3f3f0f2eeb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a7645ddd5b7729cba783283393ab6a961">DataObject</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj, bool transposed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad633920dcd1a5518826a97229d249e1f"></a><!-- doxytag: member="ito::DataObject::mdata_realloc" ref="ad633920dcd1a5518826a97229d249e1f" args="(const size_t size)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mdata_realloc</b> (const size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4625cde8ab99bc30bdf0263d41dfd1a"></a><!-- doxytag: member="ito::DataObject::mdata_size" ref="af4625cde8ab99bc30bdf0263d41dfd1a" args="(void) const " -->
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>mdata_size</b> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc88b7f477982b1fedc21179280c3e0d"></a><!-- doxytag: member="ito::DataObject::mdata_free" ref="afc88b7f477982b1fedc21179280c3e0d" args="()" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>mdata_free</b> ()</td></tr>
<tr><td colspan="2"><h2><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a34d66a7e0f3f92bbd81e07bc231106ad">m_continuous</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a69dd85ae0c340c46abfcd4ea1343d2ba">m_owndata</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ac8a8870999f48e135c58177c07bc6c4a">m_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a099eaedf12393d3ccd9b3d18a2cae997">m_pRefCount</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ad0cd7504bf6c6c275e544e8da295150d">m_dims</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structito_1_1_data_object_1_1_m_size.html">MSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a8055dbc01e3085b80ce13467d34b0e6d">m_osize</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structito_1_1_data_object_1_1_m_r_o_i.html">MROI</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a268102dd4108170c941490c5ee0aa6ee">m_roi</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structito_1_1_data_object_1_1_m_size.html">MSize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a38d829331990b70cfd803b279d697eed">m_size</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae546c890bc84b63b2912310f41db9755"></a><!-- doxytag: member="ito::DataObject::m_data" ref="ae546c890bc84b63b2912310f41db9755" args="" -->
int **&#160;</td><td class="memItemRight" valign="bottom"><b>m_data</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_read_write_lock.html">ReadWriteLock</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ab07e3eada8fcc050b4acc8ea0cb4a9e8">m_objSharedDataLock</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object_tags.html">DataObjectTags</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a91976d657e3ded04efa44cf60705395c">m_pDataObjectTags</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_read_write_lock.html">ReadWriteLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ad904fb92e5eb77b6ade0d771f10731ff">m_objHeaderLock</a></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#afbcaf0f37a720fa194d6a8c095850979">CreateFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned char dimensions, const size_t *sizes, const unsigned char continuous, const uchar *continuousDataPtr, const size_t *steps)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">templated method for create  <a href="#afbcaf0f37a720fa194d6a8c095850979"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ab1a6c3bf0a6850c25027bca65c338587">CreateFuncWithCVPlanes</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned char dimensions, const size_t *sizes, const cv::Mat *planes, const unsigned int nrOfPlanes)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">templated method for creation with given vector of cv::Mat-planes  <a href="#ab1a6c3bf0a6850c25027bca65c338587"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ac132a32c9e9b2ca544bbec584cfdcadf">FreeFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for freeing allocated data blocks  <a href="#ac132a32c9e9b2ca544bbec584cfdcadf"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6a6e048afcd50dcadee8bedfa50f92c0"></a><!-- doxytag: member="ito::DataObject::SecureFreeFunc" ref="a6a6e048afcd50dcadee8bedfa50f92c0" args="(DataObject *dObj)" -->
template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SecureFreeFunc</b> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a52cb1bc366f5596fbe70133067856d66">CopyToFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, unsigned char regionOnly)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for deeply copying the data of one matrix to another given matrix  <a href="#a52cb1bc366f5596fbe70133067856d66"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a75d31ff52c62d22f8cf85a9ad709b81e">ConvertToFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, const int type, const double alpha, const double beta)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">converts data in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> lhs to <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> rhs with a given type  <a href="#a75d31ff52c62d22f8cf85a9ad709b81e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8707848d3cfaa9b5c8db31707b4f3894"></a><!-- doxytag: member="ito::DataObject::AdjustROIFunc" ref="a8707848d3cfaa9b5c8db31707b4f3894" args="(DataObject *dObj, const int *lims)" -->
template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AdjustROIFunc</b> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const int *lims)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a6975ad19e3a5f1082ddeb0b46443bd84"></a><!-- doxytag: member="ito::DataObject::MinMaxLocFunc" ref="a6975ad19e3a5f1082ddeb0b46443bd84" args="(const DataObject &amp;dObj, double *minVal, double *maxVal, size_t *minPos, size_t *maxPos)" -->
template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinMaxLocFunc</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj, double *minVal, double *maxVal, size_t *minPos, size_t *maxPos)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a4462aaa3d1eaed52f49dde2a6c33441e">AssignScalarFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> type, const void *scalar)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated helper method to assign the given scalar to every element within its ROI in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> src.  <a href="#a4462aaa3d1eaed52f49dde2a6c33441e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#ab7597f06c9c0867be7c54ee48412ee21">MakeContinuousFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;resDObj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which copies an incontinuously organized data object to a continuously organized resulting data object  <a href="#ab7597f06c9c0867be7c54ee48412ee21"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a066ad7861d7c35054ff042708e547b71"></a><!-- doxytag: member="ito::DataObject::EvaluateTransposeFlagFunc" ref="a066ad7861d7c35054ff042708e547b71" args="(DataObject *dObj)" -->
template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EvaluateTransposeFlagFunc</b> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a893026c6c5031a537892050480d52c5b"></a><!-- doxytag: member="ito::DataObject::CalcMinMaxValues" ref="a893026c6c5031a537892050480d52c5b" args="(DataObject *lhs, double &amp;result_min, double &amp;result_max, const int cmplxSel=0)" -->
template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CalcMinMaxValues</b> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *lhs, double &amp;result_min, double &amp;result_max, const int cmplxSel=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a6c93d41178959c112bd49bfe5d165d24">GetRangeFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const int dtop, const int dbottom, const int dleft, const int dright)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for saving a shallow copy of a source cv::Mat_ to a destination cv::Mat_ with respect to given row- and col-ranges  <a href="#a6c93d41178959c112bd49bfe5d165d24"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html#a31cf6d028cf22453faf4cacdf26131fb">AdjustROIFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, int dtop, int dbottom, int dleft, int dright)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for adjusting the ROI of a data object by the given incremental values  <a href="#a31cf6d028cf22453faf4cacdf26131fb"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>dataObject contains a n-dimensional matrix </p>
<p>The n-dimensional matrix can have different element types. Recently the following types are supported: int8, uint8, int16, uint16, int32, uint32, float32, float64 (=&gt; double), complex64 (2x float32), complex128 (2x float64)</p>
<p>In order to handle huge matrices, the data object can divide one matrix into subparts in memory. Each subpart (called matrix-plane) is two-dimensional and covers data of the last two dimensions. Each of these matrix-planes is of type cv::Mat_&lt;type&gt; and can be used with every operator given by the openCV-framework (version 2.3.1 or higher).</p>
<p>We assume to have a n-dimensional matrix A, where each dimension has its size s_i, hence A=[s_1, s_2, ..., s_(n-2), s_(n-1), s_n]</p>
<p>Hence, in total there are s_1 * s_2 * ... * s_(n-2) different matrix-planes, which are all accessible by the member m_data, which is a std::vector of the general type int*. This type has to be casted to the specific cv::Mat_&lt;...&gt; when one matrix-plane has to be accessed. Sometimes it is also possible to simply cast to cv::Mat.</p>
<p>In order to make the data object compatible to continuously organized data structures, like numpy-arrays, it is also possible to have all matrix-planes in one data-block in memory. Then the continuous-flag will be set and the whole data block can be accessed by taking the pointer given by m_data[0]. Nevertheless, the indicated data structure with the two-dimensional sub-matrix-planes is still existing, hence, the pointer to each matrix-planes points to the entry point of its matrix-planes lying withing the huge data block.</p>
<p>The data organization is equal to the one of open-cv, hence, two-dimensional matrices are stored row-by-row (C-style)...</p>
<p>The real size of each dimension is stored in the vector m_osize. Since it is possible to set a n-dimensional region of interest (ROI) to each matrix, the virtual dimensions, which will be delivered if the user asks for the matrix size, are stored in the member vector m_size.</p>
<p>Concept to handle templated and non-templated methods<br/>
 -----------------------------------------------------</p>
<p>According to openCV, the class dataObject is not templated, because there are some structures in the entire itom-framework which does not support any templating concept, like the plugin-handling or communication with external dll-functions. Additionally the signal-slot-design of the Qt-framework does not accept templated parameters beside some standard-objects. Therefore the element-data-type is set by the integer-member m_type. The transformation between the real data type and the integer number is coded several times within the whole framework and can be accessed by the enumeration tDataType in <a class="el" href="type_defs_8h_source.html">typeDefs.h</a>. Since templating has got many advantages concerning low-level calculation, we adapted the transformation-process which is used by openCV:</p>
<p>1. define a templated helper-method in the following form:</p>
<p>template&lt;typename _Tp&gt; returnType 'MethodName'Func(Parameters1)</p>
<p>2. define the following two lines of code: typedef returnType (*t'MethodName'Func)(Parameters1); MAKEFUNCLIST('MethodName'Func);</p>
<p>3. define the method, accessed for example as public-method of dataObject <a class="el" href="classito_1_1_ret_val.html" title="Class for error value management.">RetVal</a> <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a>::'PublicMethodName'(Parameters2) { ... fList'MethodName'Func[<a class="el" href="classito_1_1_data_object.html#a96676055bdf8c9128c1d07f866921dcb">getType()</a>](Parameters1); ... return ... }</p>
<p>--- By the macro MAKEFUNCLIST a list fList'MethodName'Func is generated with each entry being a function pointer to the specific templated version of 'MethodName'Func. The specific method is accessed by using <a class="el" href="classito_1_1_data_object.html#a96676055bdf8c9128c1d07f866921dcb">getType()</a> of dataObject. Hence it is important to keep the element-data-types and their order consistent for the whole itom-project. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7645ddd5b7729cba783283393ab6a961"></a><!-- doxytag: member="ito::DataObject::DataObject" ref="a7645ddd5b7729cba783283393ab6a961" args="(const DataObject &amp;dObj, bool transposed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ito::DataObject::DataObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transposed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>copy constructor for transposed creation </p>

</div>
</div>
<a class="anchor" id="ad237136b142095093e9dd3aef4fad088"></a><!-- doxytag: member="ito::DataObject::DataObject" ref="ad237136b142095093e9dd3aef4fad088" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ito::DataObject::DataObject </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructor for empty data object </p>
<p>no data will be allocated, the number of elements and dimensions is set to zero </p>

</div>
</div>
<a class="anchor" id="ac26aa4e55ee83a4566c43f0407575c71"></a><!-- doxytag: member="ito::DataObject::DataObject" ref="ac26aa4e55ee83a4566c43f0407575c71" args="(const size_t size, const int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ito::DataObject::DataObject </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructor for one-dimensional data object. The data is newly allocated and arbitrarily filled. </p>
<p>In fact, by this constructor a two-dimensional matrix with dimension 1 x size will be created. the owndata-flag is set to true, the continuously-flag, too (since only one matrix-plane will be created)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>is the number of elements </td></tr>
    <tr><td class="paramname">type</td><td>is the data-type of each element (use type of enumeration tDataType) </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a80c0b9752187b008d1e9114231f82d65" title="high-level, non-templated method for data allocation">create</a>, <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">tDataType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a23d342956f539e2864951839ef5347c0"></a><!-- doxytag: member="ito::DataObject::DataObject" ref="a23d342956f539e2864951839ef5347c0" args="(const size_t sizeY, const size_t sizeX, const int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ito::DataObject::DataObject </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructor for two-dimensional data object. The data is newly allocated and arbitrarily filled. </p>
<p>the owndata-flag is set to true, the continuously-flag, too (since only one matrix-plane will be created)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeY</td><td>is the number of rows in each matrix-plane </td></tr>
    <tr><td class="paramname">sizeX</td><td>is the number of columns in each matrix-plane </td></tr>
    <tr><td class="paramname">type</td><td>is the data-type of each element (use type of enumeration tDataType) </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a80c0b9752187b008d1e9114231f82d65" title="high-level, non-templated method for data allocation">create</a>, <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">tDataType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4eabd540dbbc04253c8d8088af9df8a3"></a><!-- doxytag: member="ito::DataObject::DataObject" ref="a4eabd540dbbc04253c8d8088af9df8a3" args="(const size_t sizeZ, const size_t sizeY, const size_t sizeX, const int type, const unsigned char continuous=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ito::DataObject::DataObject </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>continuous</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructor for three-dimensional data object. The data is newly allocated and arbitrarily filled. </p>
<p>the owndata-flag is set to true</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeZ</td><td>is the number of images in the z-direction </td></tr>
    <tr><td class="paramname">sizeY</td><td>is the number of rows in each matrix-plane </td></tr>
    <tr><td class="paramname">sizeX</td><td>is the number of columns in each matrix-plane </td></tr>
    <tr><td class="paramname">type</td><td>is the data-type of each element (use type of enumeration tDataType) </td></tr>
    <tr><td class="paramname">continuous</td><td>indicates whether all matrix-planes should continuously lie in memory (1) or not (0) (default: 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a80c0b9752187b008d1e9114231f82d65" title="high-level, non-templated method for data allocation">create</a>, <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">tDataType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a166ee1e0965e2a6be13386c8b5c153e3"></a><!-- doxytag: member="ito::DataObject::DataObject" ref="a166ee1e0965e2a6be13386c8b5c153e3" args="(const size_t sizeZ, const size_t sizeY, const size_t sizeX, const int type, const uchar *continuousDataPtr, const size_t *steps=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ito::DataObject::DataObject </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>continuousDataPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>steps</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructor for 3-dimensional data object which uses the data given by the continuousDataPtr. </p>
<p>In case of the continuousDataPtr, the owndata-flag is set to false, hence this dataObj will not delete the data. Additionally the continuous-flag is set to true.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeZ</td><td>is the number of images in the z-direction </td></tr>
    <tr><td class="paramname">sizeY</td><td>is the number of rows in each matrix-plane </td></tr>
    <tr><td class="paramname">sizeX</td><td>is the number of columns in each matrix-plane </td></tr>
    <tr><td class="paramname">type</td><td>is the data-type of each element (use type of enumeration tDataType) </td></tr>
    <tr><td class="paramname">*continuousDataPtr</td><td>points to the first element of a continuous data block of the specific data type </td></tr>
    <tr><td class="paramname">*steps</td><td>may be NULL, if the data in continuousDataPtr should be taken continuously, hence the ROI is the whole matrix, else this is a vector with three elements, where each elements indicates the number of bytes one has to move in order to get from one element to the next one in the same dimension. Hence, the last element in this vector is equal to the size of one single element (in bytes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a80c0b9752187b008d1e9114231f82d65" title="high-level, non-templated method for data allocation">create</a>, <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">tDataType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0ea80ead468229f44af3b42cb86a04fd"></a><!-- doxytag: member="ito::DataObject::DataObject" ref="a0ea80ead468229f44af3b42cb86a04fd" args="(const unsigned char dimensions, const size_t *sizes, const int type, const unsigned char continuous=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ito::DataObject::DataObject </td>
          <td>(</td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>continuous</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructor for data object with given dimension. The data is newly allocated and arbitrarily filled. </p>
<p>the owndata-flag is set to true</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>indicates the total number of dimensions </td></tr>
    <tr><td class="paramname">*sizes</td><td>is a vector of size 'dimensions', where each element gives the size (not osize) of the specific dimension </td></tr>
    <tr><td class="paramname">type</td><td>is the data-type of each element (use type of enumeration tDataType) </td></tr>
    <tr><td class="paramname">continuous</td><td>indicates whether all matrix-planes should continuously lie in memory (1) or not (0) (default: 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a80c0b9752187b008d1e9114231f82d65" title="high-level, non-templated method for data allocation">create</a>, <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">tDataType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa10cfc9b3d42d1221f2d90c04e0d87f7"></a><!-- doxytag: member="ito::DataObject::DataObject" ref="aa10cfc9b3d42d1221f2d90c04e0d87f7" args="(const unsigned char dimensions, const size_t *sizes, const int type, const uchar *continuousDataPtr, const size_t *steps=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ito::DataObject::DataObject </td>
          <td>(</td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>continuousDataPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>steps</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructor for data object which uses the data given by the continuousDataPtr. </p>
<p>In case of the continuousDataPtr, the owndata-flag is set to false, hence this dataObj will not delete the data. Additionally the continuous-flag is set to true.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>indicates the total number of dimensions </td></tr>
    <tr><td class="paramname">*sizes</td><td>is a vector of size 'dimensions', where each element gives the size (not osize) of the specific dimension </td></tr>
    <tr><td class="paramname">type</td><td>is the data-type of each element (use type of enumeration tDataType) </td></tr>
    <tr><td class="paramname">*continuousDataPtr</td><td>points to the first element of a continuous data block of the specific data type </td></tr>
    <tr><td class="paramname">*steps</td><td>may be NULL, if the data in continuousDataPtr should be taken continuously, hence the ROI is the whole matrix, else this is a vector of size 'dimensions', where each elements indicates the number of bytes one has to move in order to get from one element to the next one in the same dimension. Hence, the last element in this vector is equal to the size of one single element (in bytes) </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a80c0b9752187b008d1e9114231f82d65" title="high-level, non-templated method for data allocation">create</a>, <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a32e74ff9c1cd0e9fc73d5f7705bce605"></a><!-- doxytag: member="ito::DataObject::DataObject" ref="a32e74ff9c1cd0e9fc73d5f7705bce605" args="(const DataObject &amp;copyConstr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ito::DataObject::DataObject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>copyConstr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>copy constructor for data object </p>
<p>copy constructor</p>
<p>creates a data object with respect to the given data object. The header information is completely copied, while the data is a shallow copy. The lock of the new data object is unlocked while the lock for the common data block is taken from the current lock status of the given data object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;copyConstr</td><td>is the data object, which will be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a828f90ce03f273216c9314c60ca574d1"></a><!-- doxytag: member="ito::DataObject::~DataObject" ref="a828f90ce03f273216c9314c60ca574d1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ito::DataObject::~DataObject </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>destructor </p>
<p>reference pointer of data is decremented and if &lt;0, data will be deleted if owndata-flag is true. Additionally the allocated memory for header information will be deleted, too.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a687861887060a1392433f4bfbfd770fc" title="high-level, non-templated method for freeing data">freeData</a> </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4cf2c2fe67b96f17fc8139036c0d4a1d"></a><!-- doxytag: member="ito::DataObject::adj" ref="a4cf2c2fe67b96f17fc8139036c0d4a1d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::adj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts every element of the data object to its adjungate value </p>
<p>The adjungate is the transposed matrix, where each element is complex conjugated. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if data type is not complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a47fe6b5f8038aefcf65f30ad73d8ee2c" title="converts every element of the data object to its conjugate complex value">conj</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adefd7b5822dc68f967ef574e9f841c71"></a><!-- doxytag: member="ito::DataObject::adjustROI" ref="adefd7b5822dc68f967ef574e9f841c71" args="(const int dtop, const int dbottom, const int dleft, const int dright)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::adjustROI </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dtop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dbottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dright</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>adjust submatrix size and position within the two-dimensional data-object </p>
<p>changes the boundaries of the ROI of a two-dimensional data object by the given incremental values</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dtop</td><td>The shift of the top submatrix boundary upwards (positive value means upwards) </td></tr>
    <tr><td class="paramname">dbottom</td><td>The shift of the bottom submatrix boundary downwards (positive value means downwards) </td></tr>
    <tr><td class="paramname">dleft</td><td>The shift of the left submatrix boundary to the left (positive value means to the left) </td></tr>
    <tr><td class="paramname">dright</td><td>The shift of the right submatrix boundary to the right (positive value means to the right) </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>the parameters indicates the shift with respect to the virtual order of the matrix, hence, the transpose flag is considered in this method </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to this data object </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if data object is not two-dimensional </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#adefd7b5822dc68f967ef574e9f841c71" title="adjust submatrix size and position within the two-dimensional data-object">adjustROI</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acff86dfa8dd2f4757ad361723718424b"></a><!-- doxytag: member="ito::DataObject::adjustROI" ref="acff86dfa8dd2f4757ad361723718424b" args="(const unsigned char dims, const int *lims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::adjustROI </td>
          <td>(</td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>lims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>adjust submatrix size and position within the n-dimensional data-object </p>
<p>changes the boundaries of the ROI of a n-dimensional data object by the given incremental values</p>
<p>dims is the number of dimensions </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*lims</td><td>is a integer array whose length is 2*dims. For every dimension, two adjacent values indicates the shift of the ROI. The first of both values indicates the shift of the ROI towards the first element in the matrix (positive direction). The second value indicates the shift of the ROI towards the last element in the matrix (positive direction). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to this data object </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>lims indicates the shift with respect to the virtual order of the matrix, hence, the transpose flag is considered in this method </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#adefd7b5822dc68f967ef574e9f841c71" title="adjust submatrix size and position within the two-dimensional data-object">adjustROI</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad8808bab69b30aa1c1421f39f7cec624"></a><!-- doxytag: member="ito::DataObject::at" ref="ad8808bab69b30aa1c1421f39f7cec624" args="(const int x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp&amp; ito::DataObject::at </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>addressing method for one-dimensional data object or two-dimensional data object having at least one dimension with size 1. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the zero-based index to the element which is requested (considering any ROI) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to specific element </dd></dl>

</div>
</div>
<a class="anchor" id="ab367d263f91d09171612f67c4a06369a"></a><!-- doxytag: member="ito::DataObject::at" ref="ab367d263f91d09171612f67c4a06369a" args="(const int x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp&amp; ito::DataObject::at </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>addressing method for one-dimensional data object or two-dimensional data object having at least one dimension with size 1. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the zero-based index to the element which is requested (considering any ROI) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>const reference to specific element </dd></dl>

</div>
</div>
<a class="anchor" id="a0f61a672538ac07cfb3e7f45b185aaf0"></a><!-- doxytag: member="ito::DataObject::at" ref="a0f61a672538ac07cfb3e7f45b185aaf0" args="(const unsigned int y, const unsigned int x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp&amp; ito::DataObject::at </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>addressing method for two-dimensional data object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>is the zero-based row-index to the element which is requested (considering any ROI) </td></tr>
    <tr><td class="paramname">x</td><td>is the zero-based column-index to the element which is requested (considering any ROI) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>const reference to specific element </dd></dl>

</div>
</div>
<a class="anchor" id="a2003f8329dcfb91aea95d9eef5feb4ef"></a><!-- doxytag: member="ito::DataObject::at" ref="a2003f8329dcfb91aea95d9eef5feb4ef" args="(const unsigned int y, const unsigned int x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp&amp; ito::DataObject::at </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>addressing method for two-dimensional data object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>is the zero-based row-index to the element which is requested (considering any ROI) </td></tr>
    <tr><td class="paramname">x</td><td>is the zero-based column-index to the element which is requested (considering any ROI) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to specific element </dd></dl>

</div>
</div>
<a class="anchor" id="a0aff545034bc6d6e31ac5ac507a91039"></a><!-- doxytag: member="ito::DataObject::at" ref="a0aff545034bc6d6e31ac5ac507a91039" args="(const unsigned int z, const unsigned int y, const unsigned int x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp&amp; ito::DataObject::at </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>addressing method for three-dimensional data object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>is the zero-based z-index to the element which is requested (considering any ROI) </td></tr>
    <tr><td class="paramname">y</td><td>is the zero-based row-index to the element which is requested (considering any ROI) </td></tr>
    <tr><td class="paramname">x</td><td>is the zero-based column-index to the element which is requested (considering any ROI) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>const reference to specific element </dd></dl>

</div>
</div>
<a class="anchor" id="a129d4a8d37cf075ec8ac75e0fdf2889d"></a><!-- doxytag: member="ito::DataObject::at" ref="a129d4a8d37cf075ec8ac75e0fdf2889d" args="(const unsigned int z, const unsigned int y, const unsigned int x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp&amp; ito::DataObject::at </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>addressing method for three-dimensional data object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>is the zero-based z-index to the element which is requested (considering any ROI) </td></tr>
    <tr><td class="paramname">y</td><td>is the zero-based row-index to the element which is requested (considering any ROI) </td></tr>
    <tr><td class="paramname">x</td><td>is the zero-based column-index to the element which is requested (considering any ROI) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to specific element </dd></dl>

</div>
</div>
<a class="anchor" id="a8c67180004a75ed2c036e151a7a83cc9"></a><!-- doxytag: member="ito::DataObject::at" ref="a8c67180004a75ed2c036e151a7a83cc9" args="(const unsigned int *idx) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp&amp; ito::DataObject::at </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>addressing method for n-dimensional data object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*idx</td><td>is vector whose size is equal to the data object's dimensions. Each entry indicates the zero-based index of its specific dimension considering any ROI </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The idx vector must indicate the indizes in "virtual"-order (user-friendly order) </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>const reference to specific element </dd></dl>

</div>
</div>
<a class="anchor" id="ab6e695dfbde713fbd4737ca345c57d09"></a><!-- doxytag: member="ito::DataObject::at" ref="ab6e695dfbde713fbd4737ca345c57d09" args="(const unsigned int *idx)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_Tp&amp; ito::DataObject::at </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>addressing method for n-dimensional data object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*idx</td><td>is vector whose size is equal to the data object's dimensions. Each entry indicates the zero-based index of its specific dimension considering any ROI </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The idx vector must indicate the indizes in "virtual"-order (user-friendly order) </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to specific element </dd></dl>

</div>
</div>
<a class="anchor" id="a5f2dbbadffdbebd6bc8ae4e91e565ec3"></a><!-- doxytag: member="ito::DataObject::at" ref="a5f2dbbadffdbebd6bc8ae4e91e565ec3" args="(const ito::Range rowRange, const ito::Range colRange)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_range.html">ito::Range</a>&#160;</td>
          <td class="paramname"><em>rowRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_range.html">ito::Range</a>&#160;</td>
          <td class="paramname"><em>colRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>addressing method for two-dimensional data object with two given range-values. returns shallow copy of addressed regions. </p>
<p>addressing method for two-dimensional data object with two given range-values. returns shallow copy of addressed regions</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rowRange</td><td>is the desired rowRange which should be in the new ROI (considers any existing ROI, too) </td></tr>
    <tr><td class="paramname">colRange</td><td>is the desired colRange which should be in the new ROI (considers any existing ROI, too) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new data object which is a shallow copy of this data object and whose ROI is set to the given row- and col-ranges </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if number of dimensions is unequal to two. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a892e6ab94407685f44a80686411f3e79"></a><!-- doxytag: member="ito::DataObject::at" ref="a892e6ab94407685f44a80686411f3e79" args="(ito::Range *ranges)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_range.html">ito::Range</a> *&#160;</td>
          <td class="paramname"><em>ranges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>addressing method for n-dimensional data object with n given range-values. returns shallow copy of addressed regions</p>
<p>If any of the given ranges exceed the boundaries of its corresponding dimension, the range will be set to the boundaries. ranges will be given in "virtual" order, hence, the transpose-flag is considered by this method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*ranges</td><td>is vector of desired ranges for each dimension </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new data object with shallow copy of this data object and adjusted ROI with respect to the given ranges </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a6c93d41178959c112bd49bfe5d165d24" title="low-level, templated method for saving a shallow copy of a source cv::Mat_ to a destination cv::Mat_ ...">GetRangeFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7094b4f5d2dcaa975ccc6d690d23962a"></a><!-- doxytag: member="ito::DataObject::calcNumMats" ref="a7094b4f5d2dcaa975ccc6d690d23962a" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ito::DataObject::calcNumMats </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>calculates numbers of single opencv matrices which are part of the ROI which has previously been set. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if empty range or empty matrix, 1 if two dimensional, else product of sizes of all dimensions besides the last two ones. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f7924f210854916d5f52bb45995df8f"></a><!-- doxytag: member="ito::DataObject::col" ref="a4f7924f210854916d5f52bb45995df8f" args="(const int selCol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::col </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>selCol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level method which makes a new header for the specified matrix column and returns it. The underlying data of the new matrix is shared with the original matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">selCol</td><td>is the specific zero-based row index </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new data object </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if dimension is unequal to two. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#ab29e3016de474b08d29924f0fffa7ad4" title="low-level, templated method which changes the region of interest of the data object to the selected z...">ColFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a47fe6b5f8038aefcf65f30ad73d8ee2c"></a><!-- doxytag: member="ito::DataObject::conj" ref="a47fe6b5f8038aefcf65f30ad73d8ee2c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::conj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts every element of the data object to its conjugate complex value </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if data type is not complex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#ab7900df15bdd04f8f3b229e3b03e126f" title="low-level, templated method for calculating the conjugated value of each element within the ROI of th...">ConjFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8c385ca573159fd49cec4112ef92557f"></a><!-- doxytag: member="ito::DataObject::convertTo" ref="a8c385ca573159fd49cec4112ef92557f" args="(DataObject &amp;rhs, const int type, const double alpha=1, const double beta=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::convertTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>beta</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level, non-templated matrix conversion </p>
<p>Every element of the source matrix is converted to a new, given type. Additionally a floating-point scaling and offset parameter is possible.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the destination data object, whose memory is firstly deleted, then newly allocated </td></tr>
    <tr><td class="paramname">type</td><td>is the type-number of the destination element </td></tr>
    <tr><td class="paramname">alpha</td><td>scaling factor (default: 1.0) </td></tr>
    <tr><td class="paramname">beta</td><td>offset value (default: 0.0) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if cast failed, e.g. if cast not possible or types unknown </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>fListConvertToFunc </dd></dl>

</div>
</div>
<a class="anchor" id="a3874ac350aa5ec1fc9b14fcf551780af"></a><!-- doxytag: member="ito::DataObject::copyAxisTagsTo" ref="a3874ac350aa5ec1fc9b14fcf551780af" args="(DataObject &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::copyAxisTagsTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deep copies the axistags to rhs object</p>
<p>this function makes a deepcopy of the axis and value metadata from this object to rhs object. It copies </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the matrix where the map is copied from. The old map of this object is cleared first </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aecb43ce72bb152b72a572e584e095de7"></a><!-- doxytag: member="ito::DataObject::copyTagMapTo" ref="aecb43ce72bb152b72a572e584e095de7" args="(DataObject &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::copyTagMapTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deep copies the tagmap with all entries to rhs object</p>
<p>this function makes a deepcopy of the tags map to rhs object from this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the matrix where the map is copied to. The old map of ths object is cleared first </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object_tags.html" title="class for handling tags for class DataObject  This class contains meta-information for the dataObject...">DataObjectTags</a> </dd></dl>

</div>
</div>
<a class="anchor" id="affdc8a47d061562a1f7dd9a47465fea5"></a><!-- doxytag: member="ito::DataObject::copyTo" ref="affdc8a47d061562a1f7dd9a47465fea5" args="(DataObject &amp;rhs, unsigned char regionOnly=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::copyTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>regionOnly</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level, non-templated method to deeply copy the data of this matrix to another matrix rhs </p>
<p>deeply copies the data of this data object to the given rhs-dataObject, whose existing data will be deleted first.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the matrix where the data is copied to. The old data of rhs is deleted first </td></tr>
    <tr><td class="paramname">regionOnly,if</td><td>true, only the data of the ROI in lhs is copied, hence, the org-size of rhs corresponds to the ROI-size of lhs, else the whole data block is copied and the ROI of rhs is set to the ROI of lhs </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a52cb1bc366f5596fbe70133067856d66" title="low-level, templated method for deeply copying the data of one matrix to another given matrix...">CopyToFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a80c0b9752187b008d1e9114231f82d65"></a><!-- doxytag: member="ito::DataObject::create" ref="a80c0b9752187b008d1e9114231f82d65" args="(const unsigned char dimensions, const size_t *sizes, const int type, const unsigned char continuous, const uchar *continuousDataPtr=NULL, const size_t *steps=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ito::DataObject::create </td>
          <td>(</td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>continuous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>continuousDataPtr</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>steps</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level, non-templated method for data allocation </p>
<p>allocates new data</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>is the total number of dimensions </td></tr>
    <tr><td class="paramname">*sizes</td><td>is a vector whose length is equal to dimensions. Each entry indicates the size of the specific dimension. Each matrix-plane is allocated with the size of the last two sizes </td></tr>
    <tr><td class="paramname">type</td><td>is the desired element data type (see tDataType) </td></tr>
    <tr><td class="paramname">continuous</td><td>indicates wether the entire array should be allocated in one connected data block in memory (true) or not (default, better for huge matrices) </td></tr>
    <tr><td class="paramname">*continuousDataPtr</td><td>is NULL if new data storage should be allocated (then m_owndata is true). Otherwise this pointer points to the starting point of a continuous data block, where this data-object should be refer to (then m_owndata is false) </td></tr>
    <tr><td class="paramname">*steps</td><td>vector with size of dimensions, indicates how many bytes one has to move in order to get to the next element in the same dimension, the step-size for the last element must be set to element-size </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">open-cv</td><td>error in case of error </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#afbcaf0f37a720fa194d6a8c095850979" title="templated method for create">CreateFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a66e736e06b40c66116203efb7f56d208"></a><!-- doxytag: member="ito::DataObject::create" ref="a66e736e06b40c66116203efb7f56d208" args="(const unsigned char dimensions, const size_t *sizes, const int type, const cv::Mat *planes, const unsigned int nrOfPlanes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ito::DataObject::create </td>
          <td>(</td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat *&#160;</td>
          <td class="paramname"><em>planes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nrOfPlanes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level, non-templated method for data allocation </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dimensions</td><td>is the total number of dimensions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*sizes</td><td>is a vector whose length is equal to dimensions. Each entry indicates the size of the specific dimension. Each matrix-plane is allocated with the size of the last two sizes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>is the desired element data type (see tDataType) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*planes</td><td>is an array of cv::Mat-planes which will be used as matrices for every single 2D-plane. Every Mat must have the same size and type. The type must correspond to the param type, the size must fit to the last two given sizes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrOfPlanes</td><td>is the length of the planes-array. This value must be the same than (sizes[0]*sizes[1]*...*sizes[dimensions-2]) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">open-cv</td><td>error in case of error </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#ab1a6c3bf0a6850c25027bca65c338587" title="templated method for creation with given vector of cv::Mat-planes">CreateFuncWithCVPlanes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a85cbf8d6913c011decc6270d3f73a4ff"></a><!-- doxytag: member="ito::DataObject::createHeader" ref="a85cbf8d6913c011decc6270d3f73a4ff" args="(const unsigned char dimensions, const size_t *sizes, const size_t *steps, const size_t elemSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ito::DataObject::createHeader </td>
          <td>(</td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>elemSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>helper method for creation of header information </p>
<p>This method allocates memory for the member variables m_roi, m_osize and m_size. Therefore one memory-block is continuously allocated with length 3*(dims+1):</p>
<p>[dimensions, roi1, ..., roiN, dimensions, osize1,..., osizeN, dimensions, size1,...,sizeN] m_roi.m_p points to roi1, m_osize.m_p points to osize1 and m_size.m_p points to size1</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>indicates the number of dimensions </td></tr>
    <tr><td class="paramname">*sizes</td><td>is an array with length of 'dimensions'. Each element gives the size of the corresponding dimension </td></tr>
    <tr><td class="paramname">*steps</td><td>This parameter makes the data object compatible to numpy and opencv and is only used if a continuousDataPtr has been given to the data object. Else set steps = NULL. Each element if steps indicates by how many bytes one has to go in order to get from one element in this dimension to the next one. Hence, the last element is equal to elemSize </td></tr>
    <tr><td class="paramname">elemSize</td><td>number of bytes each element requires </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if dimensions is &lt;= 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#afbcaf0f37a720fa194d6a8c095850979" title="templated method for create">CreateFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7f10f129370bd2d578971f2b494e987c"></a><!-- doxytag: member="ito::DataObject::createHeaderWithROI" ref="a7f10f129370bd2d578971f2b494e987c" args="(const unsigned char dimensions, const size_t *sizes, const size_t *osizes=NULL, const size_t *roi=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ito::DataObject::createHeaderWithROI </td>
          <td>(</td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>osizes</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>roi</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>helper method for creation of header information considering the region of interest </p>
<p>This method allocates memory for the member variables m_roi, m_osize and m_size. Therefore one memory-block is continuously allocated with length 3*(dims+1):</p>
<p>[dimensions, roi1, ..., roiN, dimensions, osize1,..., osizeN, dimensions, size1,...,sizeN] m_roi.m_p points to roi1, m_osize.m_p points to osize1 and m_size.m_p points to size1</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>indicates the number of dimensions </td></tr>
    <tr><td class="paramname">*sizes</td><td>is an array with length of 'dimensions'. Each element gives the size of the corresponding dimension </td></tr>
    <tr><td class="paramname">*osizes</td><td>gives a vector with the original size of each dimension, which corresponds to the physical data in memory, if NULL, a full size ROI is assumed, hence osize is equal to size (default : NULL) </td></tr>
    <tr><td class="paramname">*roi</td><td>gives a vector with the offset from the starting point of the allocated data block to the first element in the region of interest, must be NULL if osizes is NULL too (default : NULL) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if dimensions is &lt;= 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#afbcaf0f37a720fa194d6a8c095850979" title="templated method for create">CreateFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae3de7306dbaf78ea23ea96d034ca3a39"></a><!-- doxytag: member="ito::DataObject::deepCopyPartial" ref="ae3de7306dbaf78ea23ea96d034ca3a39" args="(DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::deepCopyPartial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level, non-templated method. Deeply copies data of this data object which is within its ROI to the ROI of rhs. </p>
<p>copies the values of each element from this data object to the ROI of the given rhs-dataObject. The rhs-dataObject must be allocated yet and its ROI must be the same size than this ROI</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the right-handed data object, where data is copied to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception(CV_StsAssert)</td><td>if sizes or type of both matrices are not equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a22e7789c41c3399ac8d291feceb40df2" title="low-level, templated method to copy the values of the ROI of matrix lhs to the ROI of matrix rhs...">DeepCopyPartialFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae26cff1f3e3efcc2d10b6062361758de"></a><!-- doxytag: member="ito::DataObject::div" ref="ae26cff1f3e3efcc2d10b6062361758de" args="(const DataObject &amp;mat2, const double scale=1.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::div </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>mat2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level method which does a element-wise division of elements in this matrix by elements in second source matrix. </p>
<p>The result is stored in a result matrix which is returned. Optionally the division can be scaled by a scaling factor, which is set to one by default.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;mat2</td><td>is the second source matrix </td></tr>
    <tr><td class="paramname">scale</td><td>is the scaling factor (default: 1.0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>result matrix </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a4863495020c813812170b8bdfcc46221" title="low-level, templated method which does a element-wise division of elements in first source matrix by ...">DivFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa2d2891a7e90fb1fc7224327d3b5895f"></a><!-- doxytag: member="ito::DataObject::eye" ref="aa2d2891a7e90fb1fc7224327d3b5895f" args="(const int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::eye </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>sets the matrix of this data object to a two-dimensional eye-matrix of size 1, hence [1] </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>is the desired element data-type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a4ff0c10c033bde5c886468693b603817" title="allocates a one-value matrix of size 1x1 with the given type">ones</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a14e2ccd80603f1448a08cfb100da9138"></a><!-- doxytag: member="ito::DataObject::eye" ref="a14e2ccd80603f1448a08cfb100da9138" args="(const size_t size, const int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::eye </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>sets the matrix of this data object to a two-dimensional eye-matrix of given size </p>
<p>At first, a preexisting matrix is freed, before creating the eye-matrix</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>is the desired size of the squared eye-matrix </td></tr>
    <tr><td class="paramname">type</td><td>is the desired element data-type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a687861887060a1392433f4bfbfd770fc" title="high-level, non-templated method for freeing data">freeData</a>, <a class="el" href="classito_1_1_data_object.html#a80c0b9752187b008d1e9114231f82d65" title="high-level, non-templated method for data allocation">create</a>, <a class="el" href="namespaceito.html#a8dc77804bd6f6c2afa1b1cae477337ff" title="low-level, templated method for creating an eye-matrix">EyeFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a687861887060a1392433f4bfbfd770fc"></a><!-- doxytag: member="ito::DataObject::freeData" ref="a687861887060a1392433f4bfbfd770fc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ito::DataObject::freeData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level, non-templated method for freeing data </p>
<p>decrements reference counter and deletes data, if no other instance is using them (ref counter &lt; 0)</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#ac132a32c9e9b2ca544bbec584cfdcadf" title="low-level, templated method for freeing allocated data blocks">FreeFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae3387eadb8aabb7458c2a5e2bf2e5b54"></a><!-- doxytag: member="ito::DataObject::get_mdata" ref="ae3387eadb8aabb7458c2a5e2bf2e5b54" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ** ito::DataObject::get_mdata </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to vector of cv::_Mat-matrices </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to vector of matrices </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>the returned type of std::vector is int*, you should cast it to the appropriate type (e.g. cv::_Mat&lt;int8&gt;) </dd></dl>

</div>
</div>
<a class="anchor" id="a7f1d803c480bf1c35a1b880338ccab85"></a><!-- doxytag: member="ito::DataObject::get_mdata" ref="a7f1d803c480bf1c35a1b880338ccab85" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ** ito::DataObject::get_mdata </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constant version of get_mdata </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#ae3387eadb8aabb7458c2a5e2bf2e5b54" title="returns pointer to vector of cv::_Mat-matrices">get_mdata</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a06939618cad91af4c856b5489b2c463b"></a><!-- doxytag: member="ito::DataObject::getContinuous" ref="a06939618cad91af4c856b5489b2c463b" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char ito::DataObject::getContinuous </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns if the data object is owner of the data, hence, the data will be deleted by this data object, if nobody else is using the data any more </p>

</div>
</div>
<a class="anchor" id="a65c56fb3e99963794f1c7b854edf1aa3"></a><!-- doxytag: member="ito::DataObject::getDims" ref="a65c56fb3e99963794f1c7b854edf1aa3" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ito::DataObject::getDims </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>&lt; returns the number of dimensions returns the element data type in form of its type-number </p>

</div>
</div>
<a class="anchor" id="a813d34179416b7d27b3aed5622296963"></a><!-- doxytag: member="ito::DataObject::getOriginalSize" ref="a813d34179416b7d27b3aed5622296963" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ito::DataObject::getOriginalSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>gets the original size of the given dimension (this is the size without considering any ROI) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>is the specific zero-based dimension-index whose size is requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>size or -1 if index is out of boundaries </dd></dl>

</div>
</div>
<a class="anchor" id="a93f952b677c892f59943b200673c8231"></a><!-- doxytag: member="ito::DataObject::getOriginalTotal" ref="a93f952b677c892f59943b200673c8231" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ito::DataObject::getOriginalTotal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>gets total number of elements of the whole data object </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of elements </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a65c56fb3e99963794f1c7b854edf1aa3">getDims</a>, <a class="el" href="classito_1_1_data_object.html#a5bb75ea76bc186f15b41388da88d2df9" title="returns the size-member. m_size fits to the physical organization of data in memory.">getSize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2391196f61281809fed015e36833c413"></a><!-- doxytag: member="ito::DataObject::getPhysToPix" ref="a2391196f61281809fed015e36833c413" args="(const unsigned int dim, const double phys, bool &amp;isInsideImage) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ito::DataObject::getPhysToPix </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>phys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isInsideImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function returns the not rounded pixel index of a physical coordinate  Function returns the not rounded pixel index of a physical coordinate (Unit-Coordinate = ( px-Coordinate - Offset)* Scale). If the pixel is outside of the image, the isInsideImage-flag is set to false else it is set to true. To avoid memory access-error, the returnvalue is clipped within the range of the image ([0...imagesize-1]) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Axis-dimension for which the physical coordinate is calculated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pix</td><td>Pixel-index as double </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isInsideImage</td><td>flag which is set to true if coordinate is within range of the image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(double)( pix / AxisScale + AxisOffset) &amp; [0..imagesize-1] </dd></dl>

</div>
</div>
<a class="anchor" id="ac78de8af0bd6570e00b53ce7c1e7cac3"></a><!-- doxytag: member="ito::DataObject::getPixToPhys" ref="ac78de8af0bd6570e00b53ce7c1e7cac3" args="(const unsigned int dim, const double pix, bool &amp;isInsideImage) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ito::DataObject::getPixToPhys </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>pix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isInsideImage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function returns the physical coordinate of a pixel  Function returns the physical coordinate of a pixel index (Unit-Coordinate = ( px-Coordinate - Offset)* Scale). If the pixel is outside of the image, the isInsideImage-flag is set to false else it is set to true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Axis-dimension for which the physical coordinate is calculated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pix</td><td>Pixel-index as double </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isInsideImage</td><td>flag which is set to true if coordinate is within range of the image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(double)( pix - AxisOffset)* AxisScale) </dd></dl>

</div>
</div>
<a class="anchor" id="a5bb75ea76bc186f15b41388da88d2df9"></a><!-- doxytag: member="ito::DataObject::getSize" ref="a5bb75ea76bc186f15b41388da88d2df9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structito_1_1_data_object_1_1_m_size.html">MSize</a> ito::DataObject::getSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the size-member. m_size fits to the physical organization of data in memory. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>size-member of type <a class="el" href="structito_1_1_data_object_1_1_m_size.html">MSize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7fa0a20b7c911588404919a2dd799fc8"></a><!-- doxytag: member="ito::DataObject::getSize" ref="a7fa0a20b7c911588404919a2dd799fc8" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structito_1_1_data_object_1_1_m_size.html">MSize</a> ito::DataObject::getSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the size-member. This member does not consider the transpose flag, hence, m_size fits to the physical organization of data in memory. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>size-member of type <a class="el" href="structito_1_1_data_object_1_1_m_size.html">MSize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5d97eb4aa8c9c277fc7b3c038c96fa4e"></a><!-- doxytag: member="ito::DataObject::getSize" ref="a5d97eb4aa8c9c277fc7b3c038c96fa4e" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ito::DataObject::getSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>gets the size of the given dimension (this is the size within the ROI) </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>is the specific zero-based dimension-index whose size is requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>size or -1 if index is out of boundaries </dd></dl>

</div>
</div>
<a class="anchor" id="a31be0faf95d0a36724ee999133e12e70"></a><!-- doxytag: member="ito::DataObject::getTotal" ref="a31be0faf95d0a36724ee999133e12e70" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ito::DataObject::getTotal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>gets total number of elements within the data object's ROI </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of elements </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a65c56fb3e99963794f1c7b854edf1aa3">getDims</a>, <a class="el" href="classito_1_1_data_object.html#a5bb75ea76bc186f15b41388da88d2df9" title="returns the size-member. m_size fits to the physical organization of data in memory.">getSize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a96676055bdf8c9128c1d07f866921dcb"></a><!-- doxytag: member="ito::DataObject::getType" ref="a96676055bdf8c9128c1d07f866921dcb" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ito::DataObject::getType </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>returns if the data in the first n-2 dimensions is stored within one entire block in memory (true), else (false) </p>

</div>
</div>
<a class="anchor" id="aef6f5cc9ed877dff7ebf607314a1c0c0"></a><!-- doxytag: member="ito::DataObject::getValueOffset" ref="aef6f5cc9ed877dff7ebf607314a1c0c0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ito::DataObject::getValueOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>&lt; Function return the offset of the values stored within the dataOject </p>
<p>Function return the scaling of values stored within the dataOject </p>

</div>
</div>
<a class="anchor" id="ab4c8d40d3d7b5497056a6903202ffd12"></a><!-- doxytag: member="ito::DataObject::getXYRotationalMatrix" ref="ab4c8d40d3d7b5497056a6903202ffd12" args="(double &amp;r11, double &amp;r12, double &amp;r13, double &amp;r21, double &amp;r22, double &amp;r23, double &amp;r31, double &amp;r32, double &amp;r33) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::getXYRotationalMatrix </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>r11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>r12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>r13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>r21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>r22</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>r23</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>r31</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>r32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>r33</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to access (get) the rotiational matrix by each element. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">r11</td><td>Upper left element </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r12</td><td>Upper middle element </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r13</td><td>Upper rigth element </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r21</td><td>Middle left element </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r22</td><td>Middle middle element </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r23</td><td>Middle rigth element </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r31</td><td>Lower left element </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r32</td><td>Lower middle element </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">r33</td><td>Lower rigth element </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a2ced39cc25866a04f2fb1c9f1d6a542e">ito::retOk</a> || <a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a199f41b7779e742e0a3cc281c42c97c0">ito::retError</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a46a1ad505f71c7081690519225bac769"></a><!-- doxytag: member="ito::DataObject::locateROI" ref="a46a1ad505f71c7081690519225bac769" args="(int *wholeSizes, int *offsets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::locateROI </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>wholeSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>method locates ROI of this data object within its original data block </p>
<p>locates the boundaries of the ROI of a n-dimensional data object and returns the original size and the distances to the physical borders</p>
<p>long description</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*wholeSizes</td><td>is an allocated array of size m_dims, which is filled with the original matrix-sizes (considering the transpose-flag, hence, the output is in user-friendly form) </td></tr>
    <tr><td class="paramname">*offsets</td><td>is dimension-wise offset in order to get from the original first element of the matrix to the subpart within the region of interest, array must be pre-allocated, too. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="ac6f4f76968bd4317a83a452c597db875"></a><!-- doxytag: member="ito::DataObject::locateROI" ref="ac6f4f76968bd4317a83a452c597db875" args="(int *lims)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::locateROI </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>lims</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>method get ROI of this data object within its original data block </p>
<p>locates the boundaries of the ROI of a n-dimensional data object the distances to the physical borders</p>
<p>dims is the number of dimensions </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*lims</td><td>is a integer array whose length is 2*dims. For every dimension, two adjacent values indicates the shift of the ROI. The first of both values indicates the shift of the ROI towards the first element in the matrix (positive direction). The second value indicates the shift of the ROI towards the last element in the matrix (positive direction). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="ad2bbe518c3a3e86adede7804765178e3"></a><!-- doxytag: member="ito::DataObject::lockRead" ref="ad2bbe518c3a3e86adede7804765178e3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ito::DataObject::lockRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>locks this dataObject (all header information) and the underlying data block for a read operation </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>During the copy-constructor, operator=, eye, zero and ones method, the readWriteLock for the data block will be set to writeLock if any of the participating dataObjects are in writeLock mode. Then the number of readers will be decremented first. The lock of the dataObject, hence the lock for all header information, which are not shared, remains at its level.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_read_write_lock.html" title="objects of this class organize a read-write-lock mechanism. This class is mainly used by dataObject...">ReadWriteLock</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a49df9e5d334568f8cc99cfeec1cfd688"></a><!-- doxytag: member="ito::DataObject::lockWrite" ref="a49df9e5d334568f8cc99cfeec1cfd688" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ito::DataObject::lockWrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>locks this dataObject (all header information) and the underlying data block for a write operation </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_read_write_lock.html" title="objects of this class organize a read-write-lock mechanism. This class is mainly used by dataObject...">ReadWriteLock</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acccac371f10937b61de8c3f3f0f2eeb5"></a><!-- doxytag: member="ito::DataObject::matIdxToNum" ref="acccac371f10937b61de8c3f3f0f2eeb5" args="(const unsigned int *matIdx, size_t *matNum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::DataObject::matIdxToNum </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>matIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>matNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>brief calculates the index of the matrix-plane in the m_data-vector for a given vector of indices, which address one element in the n-dimensional matrix </p>
<p>The matrix indices are zero-based and consider the ROI of this data object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*matIdx</td><td>is a vector containing indices which address one element in the n-dimensional matrix </td></tr>
    <tr><td class="paramname">*matNum</td><td>is a pointer, where the resulting matrix-plane-index is written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if the given indices are out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa106e0f675ff44f0ef819f21c58340e1"></a><!-- doxytag: member="ito::DataObject::matNumToIdx" ref="aa106e0f675ff44f0ef819f21c58340e1" args="(const size_t matNum, size_t *matIdx) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::matNumToIdx </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>matNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>matIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>documentation is missing </dd></dl>

</div>
</div>
<a class="anchor" id="a4ff0c10c033bde5c886468693b603817"></a><!-- doxytag: member="ito::DataObject::ones" ref="a4ff0c10c033bde5c886468693b603817" args="(const int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::ones </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>allocates a one-value matrix of size 1x1 with the given type </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>is the desired type-number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a4502b8f52617660be595474cc92d7066" title="allocates a zero-value matrix of size 1x1 with the given type">zeros</a>, <a class="el" href="namespaceito.html#a37ad10fe5e1dc2a8141837dfed93decb" title="low-level, templated method for creation of zero-valued matrix-plane">ZerosFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aacd7a8ef10584c0c12de213bb351bff9"></a><!-- doxytag: member="ito::DataObject::ones" ref="aacd7a8ef10584c0c12de213bb351bff9" args="(const size_t size, const int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::ones </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>allocates a one-value matrix of size 1 x size with the given type </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>is the desired length of the vector </td></tr>
    <tr><td class="paramname">type</td><td>is the desired type-number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a4502b8f52617660be595474cc92d7066" title="allocates a zero-value matrix of size 1x1 with the given type">zeros</a>, <a class="el" href="namespaceito.html#a37ad10fe5e1dc2a8141837dfed93decb" title="low-level, templated method for creation of zero-valued matrix-plane">ZerosFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0c549fc9e13bd095c1418940f572dfe3"></a><!-- doxytag: member="ito::DataObject::ones" ref="a0c549fc9e13bd095c1418940f572dfe3" args="(const size_t sizeY, const size_t sizeX, const int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::ones </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>allocates a one-value matrix of size sizeY x sizeX with the given type </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">type</td><td>is the desired type-number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a4502b8f52617660be595474cc92d7066" title="allocates a zero-value matrix of size 1x1 with the given type">zeros</a>, <a class="el" href="namespaceito.html#a37ad10fe5e1dc2a8141837dfed93decb" title="low-level, templated method for creation of zero-valued matrix-plane">ZerosFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a10122e7cd805251be2bcacafd9d071f1"></a><!-- doxytag: member="ito::DataObject::ones" ref="a10122e7cd805251be2bcacafd9d071f1" args="(const size_t sizeZ, const size_t sizeY, const size_t sizeX, const int type, const unsigned char continuous=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::ones </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>continuous</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>allocates a one-valued, 3D- matrix of size sizeZ x sizeY x sizeX with the given type </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeZ</td><td>are the number of matrix-planes </td></tr>
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">type</td><td>is the desired type-number </td></tr>
    <tr><td class="paramname">unsigned</td><td>char continuous indicates wether the data should be in one continuous block (true) or not (false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a4502b8f52617660be595474cc92d7066" title="allocates a zero-value matrix of size 1x1 with the given type">zeros</a>, <a class="el" href="namespaceito.html#a37ad10fe5e1dc2a8141837dfed93decb" title="low-level, templated method for creation of zero-valued matrix-plane">ZerosFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa07867b126524637ccb6fc93b661b445"></a><!-- doxytag: member="ito::DataObject::ones" ref="aa07867b126524637ccb6fc93b661b445" args="(const unsigned char dimensions, const size_t *sizes, const int type, const unsigned char continuous=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::ones </td>
          <td>(</td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>continuous</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level, non-templated base function for allocation of new matrix whose elements are all set to one </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>indicates the number of dimensions </td></tr>
    <tr><td class="paramname">*sizes</td><td>is a vector with the same length than dimensions. Every element indicates the size of the specific dimension </td></tr>
    <tr><td class="paramname">type</td><td>is the desired data-element-type </td></tr>
    <tr><td class="paramname">continuous</td><td>indicates wether the data should be in one continuous block (true) or not (false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#aca6e2a03961f1f443ab7c232e501e1ab" title="low-level, templated method for creation of one-valued matrix-plane">OnesFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a87f0d6cfe9dec3410b00fae4edf2fb13"></a><!-- doxytag: member="ito::DataObject::operator T2" ref="a87f0d6cfe9dec3410b00fae4edf2fb13" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ito::DataObject::operator T2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>cast operator for data object </p>
<p>cast operator, tries to cast this data object to another element type</p>
<p>usage: res = static_cast&lt;ito::float32&gt;(sourceDataObject)</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if cast failed, e.g. if cast not possible or types unknown </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>cast data object </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a8c385ca573159fd49cec4112ef92557f" title="high-level, non-templated matrix conversion">convertTo</a>, <a class="el" href="namespaceito.html#a82f12dc309c241c93ff581a406690e58" title="low-level templated method to cast each element of source matrix to another type.">CastFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad6a66bf5d5ba132e4fa3da9302f1dbcb"></a><!-- doxytag: member="ito::DataObject::operator!=" ref="ad6a66bf5d5ba132e4fa3da9302f1dbcb" args="(DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>compare operator, compares for "unequal to" </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the data object with which this data object should element-wisely be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>compare matrix of type uint8, which contains 0 or 1, depending on the result of the element-wise comparison </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if both data objects doesn't have the same size or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a5dee1bec1740d52cf1ba8ff4dec6ae90" title="low-level, templated method which compares each element in source-matrix1 with its corresponding elem...">CmpFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4221d0565c1df3ba6f058f41ae176fc6"></a><!-- doxytag: member="ito::DataObject::operator&amp;" ref="a4221d0565c1df3ba6f058f41ae176fc6" args="(const DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level operator, which executes the element-wise operation "bitwise and" between this data object and a given data object </p>
<p>the result is returned as a newly allocated data object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the matrix which is used for the operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new data object, where the result of the operation is stored </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if data type is not supported or both data objects differs either in their size or data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>operator &amp;=, <a class="el" href="namespaceito.html#af958d9bca56f7971bc30feac415bdaae" title="low-level, templated method which element-wisely executes a bitwise &#39;and&#39; comparison between values o...">BitAndFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6d2df5af73abd286bd8b810d0585929c"></a><!-- doxytag: member="ito::DataObject::operator&amp;=" ref="a6d2df5af73abd286bd8b810d0585929c" args="(const DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator&amp;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level operator, which executes the element-wise operation "bitwise and" between this data object and a given data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the matrix which is used for the operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to this data object, where the result of the operation is stored </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if data type is not supported or both data objects differs either in their size or data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#af958d9bca56f7971bc30feac415bdaae" title="low-level, templated method which element-wisely executes a bitwise &#39;and&#39; comparison between values o...">BitAndFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a25c0d37c69d869712782e654c5146637"></a><!-- doxytag: member="ito::DataObject::operator*" ref="a25c0d37c69d869712782e654c5146637" args="(const DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>brief description </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>think about definition for this operator </dd></dl>

</div>
</div>
<a class="anchor" id="a67a7e9180436832562e9ded0899d9333"></a><!-- doxytag: member="ito::DataObject::operator*" ref="a67a7e9180436832562e9ded0899d9333" args="(const float64 factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::operator* </td>
          <td>(</td>
          <td class="paramtype">const float64&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level method which multiplies every element in this data object by a given floating-point factor. The result matrix is returned as a new matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>operator *, <a class="el" href="namespaceito.html#ad433fae6723437f656c2efa63b14c3f2" title="low-level, templated method which multiplies every element of Data Object with a factor">OpScalarMulFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3dd030faaa211776b0c9ba25e63c554b"></a><!-- doxytag: member="ito::DataObject::operator*=" ref="a3dd030faaa211776b0c9ba25e63c554b" args="(const DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>brief description </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>think about definition for this operator </dd></dl>

</div>
</div>
<a class="anchor" id="a884eb37cc708d0dfb6fb1a020a126ab4"></a><!-- doxytag: member="ito::DataObject::operator*=" ref="a884eb37cc708d0dfb6fb1a020a126ab4" args="(const float64 factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator*= </td>
          <td>(</td>
          <td class="paramtype">const float64&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level method which multiplies every element in this data object by a given floating-point factor </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#ad433fae6723437f656c2efa63b14c3f2" title="low-level, templated method which multiplies every element of Data Object with a factor">OpScalarMulFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a423136ed813e0ced63f5c660345d5f43"></a><!-- doxytag: member="ito::DataObject::operator+" ref="a423136ed813e0ced63f5c660345d5f43" args="(const DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level, non-templated arithmetic operator for element-wise addition of values of two given data objects </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the data object whose elements will be added to this data object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new resulting data object </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if both data objects don't have the same size or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#ae16131a91987cc5836aaf3f3918319b4" title="low-level, templated method for element-wise addition of two given data objects.">AddFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a804e80bb2cbe3e54d9b08e87ecbc0042"></a><!-- doxytag: member="ito::DataObject::operator+=" ref="a804e80bb2cbe3e54d9b08e87ecbc0042" args="(const DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level, non-templated arithmetic operator for element-wise addition of values of given data object to this data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the data object whose elements will be added to this data object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>this data object </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if both data objects don't have the same size or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#ae16131a91987cc5836aaf3f3918319b4" title="low-level, templated method for element-wise addition of two given data objects.">AddFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5a7d34b662e7187dfaf222b5188264da"></a><!-- doxytag: member="ito::DataObject::operator&#45;" ref="a5a7d34b662e7187dfaf222b5188264da" args="(const DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level, non-templated arithmetic operator for element-wise subtraction of values of given data object from values of this data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the data object whose elements will be subtracted from this data object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new resulting data object </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if both data objects don't have the same size or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#af1b438d0eb2715bbea3a573820950808" title="low-level, templated method for element-wise subtraction of values from second data object from value...">SubFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac007b5a6c7702cf35dd9e048bd416621"></a><!-- doxytag: member="ito::DataObject::operator&#45;=" ref="ac007b5a6c7702cf35dd9e048bd416621" args="(const DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level, non-templated arithmetic operator for element-wise subtraction of values of given data object from values of this data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the data object whose elements will be subtracted from this data object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>this data object </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if both data objects don't have the same size or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#af1b438d0eb2715bbea3a573820950808" title="low-level, templated method for element-wise subtraction of values from second data object from value...">SubFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="add5792482da07596672d94d1960be999"></a><!-- doxytag: member="ito::DataObject::operator&lt;" ref="add5792482da07596672d94d1960be999" args="(DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>compare operator, compares for "lower than" </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the data object with which this data object should element-wisely be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>compare matrix of type uint8, which contains 0 or 1, depending on the result of the element-wise comparison </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if both data objects doesn't have the same size or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a5dee1bec1740d52cf1ba8ff4dec6ae90" title="low-level, templated method which compares each element in source-matrix1 with its corresponding elem...">CmpFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7082131ce6b72946be31ef767a9ed02a"></a><!-- doxytag: member="ito::DataObject::operator&lt;&lt;" ref="a7082131ce6b72946be31ef767a9ed02a" args="(const unsigned int shiftbit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shiftbit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level operator, which shifts the elements of this data objects by a given number of bits to the left and returns the new data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">shiftbit</td><td>defines the number of bits to shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new data object with shifted values </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>operator &lt;&lt;=, <a class="el" href="namespaceito.html#a66a9c5dc6bb068b2ce6be93f0fcf4b9f" title="low-level, templated method which element-wisely shifts the values of the source matrix by a certain ...">ShiftLFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a39a98696544d8353332866673cae8725"></a><!-- doxytag: member="ito::DataObject::operator&lt;&lt;=" ref="a39a98696544d8353332866673cae8725" args="(const unsigned int shiftbit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator&lt;&lt;= </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shiftbit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level operator, which shifts the elements of this data objects by a given number of bits to the left </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">shiftbit</td><td>defines the number of bits to shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to this data object </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a66a9c5dc6bb068b2ce6be93f0fcf4b9f" title="low-level, templated method which element-wisely shifts the values of the source matrix by a certain ...">ShiftLFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a46bf4171899fb1d89bdca49156ca7a55"></a><!-- doxytag: member="ito::DataObject::operator&lt;=" ref="a46bf4171899fb1d89bdca49156ca7a55" args="(DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>compare operator, compares for "lower or equal than" </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the data object with which this data object should element-wisely be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>compare matrix of type uint8, which contains 0 or 1, depending on the result of the element-wise comparison </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if both data objects doesn't have the same size or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a5dee1bec1740d52cf1ba8ff4dec6ae90" title="low-level, templated method which compares each element in source-matrix1 with its corresponding elem...">CmpFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a04a374f5bbac7fcb0561a66cdb3e38ba"></a><!-- doxytag: member="ito::DataObject::operator=" ref="a04a374f5bbac7fcb0561a66cdb3e38ba" args="(const cv::Mat &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator= </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>assign-operator which creates a two-dimensional data object as a shallow copy of a two dimensional cv::Mat object. </p>
<p>shallow-copy means, that the header information of this data-object is physically created at the hard disk, while the data is shared with the original cv::Mat.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the cv::Mat where the shallow copy is taken from. At first, the existing data of this object is freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>this data object </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if rhs is not two-dimensional or data type has no compatible data type of dataObject. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a80c0b9752187b008d1e9114231f82d65" title="high-level, non-templated method for data allocation">create</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aab29e1c4f0da83365614a725293c6b40"></a><!-- doxytag: member="ito::DataObject::operator=" ref="aab29e1c4f0da83365614a725293c6b40" args="(const DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>assign-operator which makes a shallow-copy of the rhs data object and stores it in this data object </p>
<p>shallow-copy means, that the header information of the rhs data-object is physically copied to this-dataObject while the data is shared, hence, only its reference counter is incremented</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the data object where the shallow copy is taken from. At first, the existing data of this object is freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>this data object </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if lock state of both objects is not equal. Please make sure, that both lock states are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#ae443f37579ec5020b3885006d1ba3c4a" title="low-level, templated method that executes a shallow-copy of every matrix-plane in the source-vector a...">CopyMatFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a261f0755e25c89fd87278ea17e81df10"></a><!-- doxytag: member="ito::DataObject::operator=" ref="a261f0755e25c89fd87278ea17e81df10" args="(const int8 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator= </td>
          <td>(</td>
          <td class="paramtype">const int8&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Every data element in this data object is set to the given value. </p>
<p>sets all elements of the data object to the given value. Value is cast to the data object's type</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is the scalar assignment value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>modified data object </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>AssignScalarValue </dd></dl>

</div>
</div>
<a class="anchor" id="a4b5619e2c783ffcb526ddad2fd31243f"></a><!-- doxytag: member="ito::DataObject::operator=" ref="a4b5619e2c783ffcb526ddad2fd31243f" args="(const uint8 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator= </td>
          <td>(</td>
          <td class="paramtype">const uint8&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Every data element in this data object is set to the given value. </p>
<p>sets all elements of the data object to the given value. Value is cast to the data object's type</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is the scalar assignment value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>modified data object </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>AssignScalarValue </dd></dl>

</div>
</div>
<a class="anchor" id="a597725a7d7ff849a86b1e15115666830"></a><!-- doxytag: member="ito::DataObject::operator=" ref="a597725a7d7ff849a86b1e15115666830" args="(const int16 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator= </td>
          <td>(</td>
          <td class="paramtype">const int16&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Every data element in this data object is set to the given value. </p>
<p>sets all elements of the data object to the given value. Value is cast to the data object's type</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is the scalar assignment value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>modified data object </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>AssignScalarValue </dd></dl>

</div>
</div>
<a class="anchor" id="aaac65ef40fdc2211f6ea7d3d6c9f984c"></a><!-- doxytag: member="ito::DataObject::operator=" ref="aaac65ef40fdc2211f6ea7d3d6c9f984c" args="(const uint16 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator= </td>
          <td>(</td>
          <td class="paramtype">const uint16&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Every data element in this data object is set to the given value. </p>
<p>sets all elements of the data object to the given value. Value is cast to the data object's type</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is the scalar assignment value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>modified data object </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>AssignScalarValue </dd></dl>

</div>
</div>
<a class="anchor" id="a6e7809f1696c0541e1eb8647e1269887"></a><!-- doxytag: member="ito::DataObject::operator=" ref="a6e7809f1696c0541e1eb8647e1269887" args="(const int32 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator= </td>
          <td>(</td>
          <td class="paramtype">const int32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Every data element in this data object is set to the given value. </p>
<p>sets all elements of the data object to the given value. Value is cast to the data object's type</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is the scalar assignment value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>modified data object </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>AssignScalarValue </dd></dl>

</div>
</div>
<a class="anchor" id="a704d29e5a59e7c99ec4f7028a63957e3"></a><!-- doxytag: member="ito::DataObject::operator=" ref="a704d29e5a59e7c99ec4f7028a63957e3" args="(const uint32 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator= </td>
          <td>(</td>
          <td class="paramtype">const uint32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Every data element in this data object is set to the given value. </p>
<p>sets all elements of the data object to the given value. Value is cast to the data object's type</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is the scalar assignment value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>modified data object </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>AssignScalarValue </dd></dl>

</div>
</div>
<a class="anchor" id="a788f6e4313206860210a02d366902084"></a><!-- doxytag: member="ito::DataObject::operator=" ref="a788f6e4313206860210a02d366902084" args="(const float32 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator= </td>
          <td>(</td>
          <td class="paramtype">const float32&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Every data element in this data object is set to the given value. </p>
<p>sets all elements of the data object to the given value. Value is cast to the data object's type</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is the scalar assignment value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>modified data object </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>AssignScalarValue </dd></dl>

</div>
</div>
<a class="anchor" id="abd6df3f0e743760727902c3c769864ef"></a><!-- doxytag: member="ito::DataObject::operator=" ref="abd6df3f0e743760727902c3c769864ef" args="(const float64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator= </td>
          <td>(</td>
          <td class="paramtype">const float64&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Every data element in this data object is set to the given value. </p>
<p>sets all elements of the data object to the given value. Value is cast to the data object's type</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is the scalar assignment value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>modified data object </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>AssignScalarValue </dd></dl>

</div>
</div>
<a class="anchor" id="ab02ebe64c3f32b59562bf20b4fe8a543"></a><!-- doxytag: member="ito::DataObject::operator=" ref="ab02ebe64c3f32b59562bf20b4fe8a543" args="(const complex64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator= </td>
          <td>(</td>
          <td class="paramtype">const complex64&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Every data element in this data object is set to the given value. </p>
<p>sets all elements of the data object to the given value. Value is cast to the data object's type</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is the scalar assignment value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>modified data object </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>AssignScalarValue </dd></dl>

</div>
</div>
<a class="anchor" id="a836c6a8281b82e86fbaabf1e5ba76e92"></a><!-- doxytag: member="ito::DataObject::operator=" ref="a836c6a8281b82e86fbaabf1e5ba76e92" args="(const complex128 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator= </td>
          <td>(</td>
          <td class="paramtype">const complex128&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Every data element in this data object is set to the given value. </p>
<p>sets all elements of the data object to the given value. Value is cast to the data object's type</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is the scalar assignment value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>modified data object </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>AssignScalarValue </dd></dl>

</div>
</div>
<a class="anchor" id="a5c3366b3572da2a2ba4cd401ab198b06"></a><!-- doxytag: member="ito::DataObject::operator==" ref="a5c3366b3572da2a2ba4cd401ab198b06" args="(DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>compare operator, compares for "equal to" </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the data object with which this data object should element-wisely be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>compare matrix of type uint8, which contains 0 or 1, depending on the result of the element-wise comparison </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if both data objects doesn't have the same size or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a5dee1bec1740d52cf1ba8ff4dec6ae90" title="low-level, templated method which compares each element in source-matrix1 with its corresponding elem...">CmpFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a488459b6effcb181b020c053529699f7"></a><!-- doxytag: member="ito::DataObject::operator&gt;" ref="a488459b6effcb181b020c053529699f7" args="(DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>compare operator, compares for "bigger than" </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the data object with which this data object should element-wisely be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>compare matrix of type uint8, which contains 0 or 1, depending on the result of the element-wise comparison </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if both data objects doesn't have the same size or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a5dee1bec1740d52cf1ba8ff4dec6ae90" title="low-level, templated method which compares each element in source-matrix1 with its corresponding elem...">CmpFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7c850b2e6e0b7c8813f1c75d2ced4a57"></a><!-- doxytag: member="ito::DataObject::operator&gt;=" ref="a7c850b2e6e0b7c8813f1c75d2ced4a57" args="(DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>compare operator, compares for "bigger or equal than" </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the data object with which this data object should element-wisely be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>compare matrix of type uint8, which contains 0 or 1, depending on the result of the element-wise comparison </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if both data objects doesn't have the same size or type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a5dee1bec1740d52cf1ba8ff4dec6ae90" title="low-level, templated method which compares each element in source-matrix1 with its corresponding elem...">CmpFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4016a00323cd271ed6366bb922ac5bc5"></a><!-- doxytag: member="ito::DataObject::operator&gt;&gt;" ref="a4016a00323cd271ed6366bb922ac5bc5" args="(const unsigned int shiftbit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shiftbit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level operator, which shifts the elements of this data objects by a given number of bits to the right and returns the new data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">shiftbit</td><td>defines the number of bits to shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new data object with shifted values </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>operator &gt;&gt;=, <a class="el" href="namespaceito.html#ab8040457b6c031cbefb51fbdae76a3bb" title="low-level, templated method which element-wisely shifts the values of the source matrix by a certain ...">ShiftRFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a208d1846b79c62419fed054af4250b6c"></a><!-- doxytag: member="ito::DataObject::operator&gt;&gt;=" ref="a208d1846b79c62419fed054af4250b6c" args="(const unsigned int shiftbit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator&gt;&gt;= </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>shiftbit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level operator, which shifts the elements of this data objects by a given number of bits to the right </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">shiftbit</td><td>defines the number of bits to shift </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to this data object </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#ab8040457b6c031cbefb51fbdae76a3bb" title="low-level, templated method which element-wisely shifts the values of the source matrix by a certain ...">ShiftRFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1537e963c49a7be1479cce8460c54294"></a><!-- doxytag: member="ito::DataObject::operator^" ref="a1537e963c49a7be1479cce8460c54294" args="(const DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::operator^ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level operator, which executes the element-wise operation "bitwise or" between this data object and a given data object </p>
<p>the result is returned as a newly allocated data object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the matrix which is used for the operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new data object, where the result of the operation is stored </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if data type is not supported or both data objects differs either in their size or data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>operator ^=, <a class="el" href="namespaceito.html#a7e15e2fb2cba5fe01f96cc66b65c8345" title="low-level, templated method which element-wisely executes a bitwise &#39;xor&#39; comparison between values o...">BitXorFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0c71ddada50985cfceeb43f32edc01b8"></a><!-- doxytag: member="ito::DataObject::operator^=" ref="a0c71ddada50985cfceeb43f32edc01b8" args="(const DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator^= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level operator, which executes the element-wise operation "bitwise xor" between this data object and a given data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the matrix which is used for the operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to this data object, where the result of the operation is stored </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if data type is not supported or both data objects differs either in their size or data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a7e15e2fb2cba5fe01f96cc66b65c8345" title="low-level, templated method which element-wisely executes a bitwise &#39;xor&#39; comparison between values o...">BitXorFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2e7e0efb4bc0d347b50b28ec2b3004cb"></a><!-- doxytag: member="ito::DataObject::operator|" ref="a2e7e0efb4bc0d347b50b28ec2b3004cb" args="(const DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::operator| </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level operator, which executes the element-wise operation "bitwise or" between this data object and a given data object </p>
<p>the result is returned as a newly allocated data object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the matrix which is used for the operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new data object, where the result of the operation is stored </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if data type is not supported or both data objects differs either in their size or data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>operator |=, <a class="el" href="namespaceito.html#a5f26f22cf37ce14606bd6dde853f1e8b" title="low-level, templated method which element-wisely executes a bitwise &#39;or&#39; comparison between values of...">BitOrFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad271054f288b123f3c1d8e88352f21ee"></a><!-- doxytag: member="ito::DataObject::operator|=" ref="ad271054f288b123f3c1d8e88352f21ee" args="(const DataObject &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp; ito::DataObject::operator|= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level operator, which executes the element-wise operation "bitwise or" between this data object and a given data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;rhs</td><td>is the matrix which is used for the operator </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to this data object, where the result of the operation is stored </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if data type is not supported or both data objects differs either in their size or data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a5f26f22cf37ce14606bd6dde853f1e8b" title="low-level, templated method which element-wisely executes a bitwise &#39;or&#39; comparison between values of...">BitOrFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a137cff8dcc4e04b37cd3da73090f96e4"></a><!-- doxytag: member="ito::DataObject::rand" ref="a137cff8dcc4e04b37cd3da73090f96e4" args="(const int type, const bool randMode=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::rand </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>randMode</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>allocates a random-value matrix of size 1x1 with the given type </p>
<p>this function allocates an random value matrix using cv::randu for uniform (randMode = false) or gausion noise (randMode = true). In case of an integer type, the uniform noise is from min(inclusiv) to max(inclusiv). For floating point types, the noise is between 0(inclusiv) and 1(exclusiv). In case of an integer type, the gausian noise mean value is (max+min)/2.0 and the standard deviation is (max-min/)6.0 to max. For floating point types, the noise mean value is 0 and the standard deviation is 1.0/3.0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>is the desired type-number </td></tr>
    <tr><td class="paramname">randMode</td><td>switch mode between uniform distributed(false) and normal distributed noise(true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a4502b8f52617660be595474cc92d7066" title="allocates a zero-value matrix of size 1x1 with the given type">zeros</a>, <a class="el" href="namespaceito.html#a37ad10fe5e1dc2a8141837dfed93decb" title="low-level, templated method for creation of zero-valued matrix-plane">ZerosFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a439cb939eaae3172d415202da83e8b24"></a><!-- doxytag: member="ito::DataObject::rand" ref="a439cb939eaae3172d415202da83e8b24" args="(const size_t size, const int type, const bool randMode=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::rand </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>randMode</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>allocates a random-value matrix of size 1 x size with the given type </p>
<p>this function allocates an random value matrix using cv::randu for uniform (randMode = false) or gausion noise (randMode = true). In case of an integer type, the uniform noise is from min(inclusiv) to max(inclusiv). For floating point types, the noise is between 0(inclusiv) and 1(exclusiv). In case of an integer type, the gausian noise mean value is (max+min)/2.0 and the standard deviation is (max-min/)6.0 to max. For floating point types, the noise mean value is 0 and the standard deviation is 1.0/3.0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>is the desired length of the vector </td></tr>
    <tr><td class="paramname">type</td><td>is the desired type-number </td></tr>
    <tr><td class="paramname">randMode</td><td>switch mode between uniform distributed(false) and normal distributed noise(true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a4502b8f52617660be595474cc92d7066" title="allocates a zero-value matrix of size 1x1 with the given type">zeros</a>, <a class="el" href="namespaceito.html#a37ad10fe5e1dc2a8141837dfed93decb" title="low-level, templated method for creation of zero-valued matrix-plane">ZerosFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8f4001ccf47ee03b7b066cdc095763db"></a><!-- doxytag: member="ito::DataObject::rand" ref="a8f4001ccf47ee03b7b066cdc095763db" args="(const size_t sizeY, const size_t sizeX, const int type, const bool randMode=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::rand </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>randMode</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>allocates a random-value matrix of size sizeY x sizeX with the given type </p>
<p>this function allocates an random value matrix using cv::randu for uniform (randMode = false) or gausion noise (randMode = true). In case of an integer type, the uniform noise is from min(inclusiv) to max(inclusiv). For floating point types, the noise is between 0(inclusiv) and 1(exclusiv). In case of an integer type, the gausian noise mean value is (max+min)/2.0 and the standard deviation is (max-min/)6.0 to max. For floating point types, the noise mean value is 0 and the standard deviation is 1.0/3.0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">type</td><td>is the desired type-number </td></tr>
    <tr><td class="paramname">randMode</td><td>switch mode between uniform distributed(false) and normal distributed noise(true) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a4502b8f52617660be595474cc92d7066" title="allocates a zero-value matrix of size 1x1 with the given type">zeros</a>, <a class="el" href="namespaceito.html#a37ad10fe5e1dc2a8141837dfed93decb" title="low-level, templated method for creation of zero-valued matrix-plane">ZerosFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1b2354c38eeec2687eae1131b9dc3bdf"></a><!-- doxytag: member="ito::DataObject::rand" ref="a1b2354c38eeec2687eae1131b9dc3bdf" args="(const size_t sizeZ, const size_t sizeY, const size_t sizeX, const int type, const bool randMode, const unsigned char continuous=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::rand </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>randMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>continuous</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>allocates a random-valued, 3D- matrix of size sizeZ x sizeY x sizeX with the given type </p>
<p>this function allocates an random value matrix using cv::randu for uniform (randMode = false) or gausion noise (randMode = true). In case of an integer type, the uniform noise is from min(inclusiv) to max(inclusiv). For floating point types, the noise is between 0(inclusiv) and 1(exclusiv). In case of an integer type, the gausian noise mean value is (max+min)/2.0 and the standard deviation is (max-min/)6.0 to max. For floating point types, the noise mean value is 0 and the standard deviation is 1.0/3.0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeZ</td><td>are the number of matrix-planes </td></tr>
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">type</td><td>is the desired type-number </td></tr>
    <tr><td class="paramname">randMode</td><td>switch mode between uniform distributed(false) and normal distributed noise(true) </td></tr>
    <tr><td class="paramname">unsigned</td><td>char continuous indicates wether the data should be in one continuous block (true) or not (false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a4502b8f52617660be595474cc92d7066" title="allocates a zero-value matrix of size 1x1 with the given type">zeros</a>, <a class="el" href="namespaceito.html#a37ad10fe5e1dc2a8141837dfed93decb" title="low-level, templated method for creation of zero-valued matrix-plane">ZerosFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac002b0b9e459eda4df79cc0b6ead28ea"></a><!-- doxytag: member="ito::DataObject::rand" ref="ac002b0b9e459eda4df79cc0b6ead28ea" args="(const unsigned char dimensions, const size_t *sizes, const int type, const bool randMode, const unsigned char continuous=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::rand </td>
          <td>(</td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>randMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>continuous</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level, non-templated base function for allocation of new matrix whose elements are all set to one </p>
<p>this function allocates an random value matrix using cv::randu for uniform (randMode = false) or gausion noise (randMode = true). In case of an integer type, the uniform noise is from min(inclusiv) to max(inclusiv). For floating point types, the noise is between 0(inclusiv) and 1(exclusiv). In case of an integer type, the gausian noise mean value is (max+min)/2.0 and the standard deviation is (max-min/)6.0 to max. For floating point types, the noise mean value is 0 and the standard deviation is 1.0/3.0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>indicates the number of dimensions </td></tr>
    <tr><td class="paramname">*sizes</td><td>is a vector with the same length than dimensions. Every element indicates the size of the specific dimension </td></tr>
    <tr><td class="paramname">type</td><td>is the desired data-element-type </td></tr>
    <tr><td class="paramname">randMode</td><td>switch mode between uniform distributed(false) and normal distributed noise(true) </td></tr>
    <tr><td class="paramname">continuous</td><td>indicates wether the data should be in one continuous block (true) or not (false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#aca6e2a03961f1f443ab7c232e501e1ab" title="low-level, templated method for creation of one-valued matrix-plane">OnesFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a149d63105180924256f85099a73e820a"></a><!-- doxytag: member="ito::DataObject::row" ref="a149d63105180924256f85099a73e820a" args="(const int selRow)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::row </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>selRow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level method which makes a new header for the specified matrix row and returns it. The underlying data of the new matrix is shared with the original matrix. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">selRow</td><td>is the specific zero-based row index </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new data object </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if dimension is unequal to two. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a8c9e2a64719008df18f75938fb711078" title="low-level, templated method which changes the region of interest of the data object to the selected z...">RowFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa3beeaaa26357b24ff222ad905bd9e7e"></a><!-- doxytag: member="ito::DataObject::rowPtr" ref="aa3beeaaa26357b24ff222ad905bd9e7e" args="(const size_t matNum, const int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uchar* ito::DataObject::rowPtr </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>matNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to the data in the y-th row in the 2d-matrix plane matNum </p>
<p>cast this pointer to the data type of the matrix elements (as pointer).</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>No further error checking (e.g. boundaries) </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>data-pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a38254ce9fb22a2da7bec07884af26c5b"></a><!-- doxytag: member="ito::DataObject::rowPtr" ref="a38254ce9fb22a2da7bec07884af26c5b" args="(const size_t matNum, const int y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uchar* ito::DataObject::rowPtr </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>matNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns pointer to the data in the y-th row in the 2d-matrix plane matNum </p>
<p>cast this pointer to the data type of the matrix elements (as pointer).</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>No further error checking (e.g. boundaries) </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>data-pointer </dd></dl>

</div>
</div>
<a class="anchor" id="a58500432da4b3c3ac108a7930f4c91ac"></a><!-- doxytag: member="ito::DataObject::secureFreeData" ref="a58500432da4b3c3ac108a7930f4c91ac" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ito::DataObject::secureFreeData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level, non-templated method for securely freeing data </p>
<p>decrements reference counter and deletes data, if no other instance is using them (ref counter &lt; 0). This method makes a lot of security checks instead of freeFunc.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>SecureFreeFunc </dd></dl>

</div>
</div>
<a class="anchor" id="a405fb0d2cfed06ed990579e299b14309"></a><!-- doxytag: member="ito::DataObject::seekMat" ref="a405fb0d2cfed06ed990579e299b14309" args="(const size_t matNum, const size_t numMats) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ito::DataObject::seekMat </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>matNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>numMats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the index vector-index of m_data which corresponds to the given zero-based two-dimensional matrix-index </p>
<p>Since there might be a difference between the "real" matrix size in memory and the virtual size which is set by subslicing a matrix and hence setting any ROI, this method transforms a desired matrix-plane index to the real index in memory of the data-vector m_data</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matNum</td><td>zero-based matrix-plane-index, considering the virtual matrix size (ROI), 0&lt;=matNum&lt;calcNumMats </td></tr>
    <tr><td class="paramname">numMats</td><td>total number of matrix-planes, lying within the ROI </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>real vector-index for the desired matrix-plane or 0 if matNum &gt;= numMats. </dd></dl>

</div>
</div>
<a class="anchor" id="acbc98cb23e0cb28c8b8c8d7a2d05944f"></a><!-- doxytag: member="ito::DataObject::seekMat" ref="acbc98cb23e0cb28c8b8c8d7a2d05944f" args="(const size_t matNum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ito::DataObject::seekMat </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>matNum</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns the index vector-index of m_data which corresponds to the given zero-based two-dimensional matrix-index </p>
<p>Since there might be a difference between the "real" matrix size in memory and the virtual size which is set by subslicing a matrix and hence setting any ROI, this method transforms a desired matrix-plane index to the real index in memory of the data-vector m_data</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">matNum</td><td>zero-based matrix-plane considering the virtual matrix size (ROI), 0&lt;=matNum&lt;calcNumMats </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>real vector-index for the desired matrix-plane </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a405fb0d2cfed06ed990579e299b14309" title="returns the index vector-index of m_data which corresponds to the given zero-based two-dimensional ma...">seekMat</a> </dd>
<dd>
<a class="el" href="classito_1_1_data_object.html#a7094b4f5d2dcaa975ccc6d690d23962a" title="calculates numbers of single opencv matrices which are part of the ROI which has previously been set...">calcNumMats</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa58d6ed711b01b4cbd4dd282a1d574ec"></a><!-- doxytag: member="ito::DataObject::setValueUnit" ref="aa58d6ed711b01b4cbd4dd282a1d574ec" args="(const std::string &amp;unit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ito::DataObject::setValueUnit </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>unit</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>&lt; Function to set the string-value of the value unit, return 1 if values does not exist </p>
<p>Function to set the string-value of the value description, return 1 if values does not exist </p>

</div>
</div>
<a class="anchor" id="ae336de870171cd63196843607dc05189"></a><!-- doxytag: member="ito::DataObject::setXYRotationalMatrix" ref="ae336de870171cd63196843607dc05189" args="(double r11, double r12, double r13, double r21, double r22, double r23, double r31, double r32, double r33)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::setXYRotationalMatrix </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r13</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r22</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r23</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r31</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r32</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r33</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function to access (set) the rotiational matrix by each element. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">r11</td><td>Upper left element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r12</td><td>Upper middle element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r13</td><td>Upper rigth element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r21</td><td>Middle left element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r22</td><td>Middle middle element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r23</td><td>Middle rigth element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r31</td><td>Lower left element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r32</td><td>Lower middle element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r33</td><td>Lower rigth element </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a2ced39cc25866a04f2fb1c9f1d6a542e">ito::retOk</a> || <a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a199f41b7779e742e0a3cc281c42c97c0">ito::retError</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af834677086d1d7adeab2ae5de67f7d24"></a><!-- doxytag: member="ito::DataObject::trans" ref="af834677086d1d7adeab2ae5de67f7d24" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::DataObject::trans </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>transposes this data object </p>
<p>simply toggles the transpose flag </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to this data object </dd></dl>

</div>
</div>
<a class="anchor" id="a1a000f1647f44b5de4952e77aadd9cf4"></a><!-- doxytag: member="ito::DataObject::unlock" ref="a1a000f1647f44b5de4952e77aadd9cf4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ito::DataObject::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>unlocks any lock. If lock is writeLock, lock is set to idle, if lock is readLock, then the number of readers is decremented and lock is freed if no more readers are available </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_read_write_lock.html" title="objects of this class organize a read-write-lock mechanism. This class is mainly used by dataObject...">ReadWriteLock</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4502b8f52617660be595474cc92d7066"></a><!-- doxytag: member="ito::DataObject::zeros" ref="a4502b8f52617660be595474cc92d7066" args="(const int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::zeros </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>allocates a zero-value matrix of size 1x1 with the given type </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>is the desired type-number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a4502b8f52617660be595474cc92d7066" title="allocates a zero-value matrix of size 1x1 with the given type">zeros</a>, <a class="el" href="namespaceito.html#a37ad10fe5e1dc2a8141837dfed93decb" title="low-level, templated method for creation of zero-valued matrix-plane">ZerosFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a613de23f31c74337e805e70f4c760f96"></a><!-- doxytag: member="ito::DataObject::zeros" ref="a613de23f31c74337e805e70f4c760f96" args="(const size_t size, const int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::zeros </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>allocates a zero-value matrix of size 1 x size with the given type </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>is the desired length of the vector </td></tr>
    <tr><td class="paramname">type</td><td>is the desired type-number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a4502b8f52617660be595474cc92d7066" title="allocates a zero-value matrix of size 1x1 with the given type">zeros</a>, <a class="el" href="namespaceito.html#a37ad10fe5e1dc2a8141837dfed93decb" title="low-level, templated method for creation of zero-valued matrix-plane">ZerosFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae18e33f8cae1119a3848137108a97222"></a><!-- doxytag: member="ito::DataObject::zeros" ref="ae18e33f8cae1119a3848137108a97222" args="(const size_t sizeY, const size_t sizeX, const int type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::zeros </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>allocates a zero-value matrix of size sizeY x sizeX with the given type </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">type</td><td>is the desired type-number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a4502b8f52617660be595474cc92d7066" title="allocates a zero-value matrix of size 1x1 with the given type">zeros</a>, <a class="el" href="namespaceito.html#a37ad10fe5e1dc2a8141837dfed93decb" title="low-level, templated method for creation of zero-valued matrix-plane">ZerosFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac4d5e5abd8584e2ba0e5756fd6320536"></a><!-- doxytag: member="ito::DataObject::zeros" ref="ac4d5e5abd8584e2ba0e5756fd6320536" args="(const size_t sizeZ, const size_t sizeY, const size_t sizeX, const int type, const unsigned char continuous=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::zeros </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>continuous</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>allocates a zero-value, 3D- matrix of size sizeZ x sizeY x sizeX with the given type </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeZ</td><td>are the number of matrix-planes </td></tr>
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">type</td><td>is the desired type-number </td></tr>
    <tr><td class="paramname">continuous</td><td>indicates wether the data should be in one continuous block (true) or not (false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a4502b8f52617660be595474cc92d7066" title="allocates a zero-value matrix of size 1x1 with the given type">zeros</a>, <a class="el" href="namespaceito.html#a37ad10fe5e1dc2a8141837dfed93decb" title="low-level, templated method for creation of zero-valued matrix-plane">ZerosFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afa41e2888cdfad842e56b702780c2846"></a><!-- doxytag: member="ito::DataObject::zeros" ref="afa41e2888cdfad842e56b702780c2846" args="(const unsigned char dimensions, const size_t *sizes, const int type, const unsigned char continuous=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DataObject::zeros </td>
          <td>(</td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>continuous</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>high-level, non-templated base function for allocation of new matrix whose elements are all set to zero </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>indicates the number of dimensions </td></tr>
    <tr><td class="paramname">*sizes</td><td>is a vector with the same length than dimensions. Every element indicates the size of the specific dimension </td></tr>
    <tr><td class="paramname">type</td><td>is the desired data-element-type </td></tr>
    <tr><td class="paramname">continuous</td><td>indicates wether the data should be in one continuous block (true) or not (false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespaceito.html#a37ad10fe5e1dc2a8141837dfed93decb" title="low-level, templated method for creation of zero-valued matrix-plane">ZerosFunc</a> </dd></dl>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a31cf6d028cf22453faf4cacdf26131fb"></a><!-- doxytag: member="ito::DataObject::AdjustROIFunc" ref="a31cf6d028cf22453faf4cacdf26131fb" args="(DataObject *dObj, int dtop, int dbottom, int dleft, int dright)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> AdjustROIFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dbottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dright</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for adjusting the ROI of a data object by the given incremental values </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is the data object, whose boundaries should be adjusted </td></tr>
    <tr><td class="paramname">dtop</td><td>- The shift of the top submatrix boundary upwards (positive value means upwards) </td></tr>
    <tr><td class="paramname">dbottom</td><td>- The shift of the bottom submatrix boundary downwards (positive value means downwards) </td></tr>
    <tr><td class="paramname">dleft</td><td>- The shift of the left submatrix boundary to the left (positive value means to the left) </td></tr>
    <tr><td class="paramname">dright</td><td>- The shift of the right submatrix boundary to the right (positive value means to the right) </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>for any n-dimensional data object, the ROI of every matrix-plane is adjusted, even if any specific matrix-plane is temporarily not inside of the ROI </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a4462aaa3d1eaed52f49dde2a6c33441e"></a><!-- doxytag: member="ito::DataObject::AssignScalarFunc" ref="a4462aaa3d1eaed52f49dde2a6c33441e" args="(const DataObject *src, const ito::tDataType type, const void *scalar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> AssignScalarFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated helper method to assign the given scalar to every element within its ROI in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> src. </p>
<p>The scalar value is converted to the type of the source data object</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td>is the source data object whose elements will be modified </td></tr>
    <tr><td class="paramname">type</td><td>is the data type of the scalar value </td></tr>
    <tr><td class="paramname">*scalar</td><td>is a void pointer to the scalar value </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::exception</td><td>if conversion of scalar to dataObject's type is not possible </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>numberConcversion </dd></dl>

</div>
</div>
<a class="anchor" id="a75d31ff52c62d22f8cf85a9ad709b81e"></a><!-- doxytag: member="ito::DataObject::ConvertToFunc" ref="a75d31ff52c62d22f8cf85a9ad709b81e" args="(const DataObject &amp;lhs, DataObject &amp;rhs, const int type, const double alpha, const double beta)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ConvertToFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>converts data in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> lhs to <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a> rhs with a given type </p>
<p>Every element of the source data object is copied to the destionation data object by using this transformation<br/>
 elem_destination = static_cast&lt;newType&gt;(elem_source * alpha + beta)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;lhs</td><td>is the left-hand sided data object, whose data should be converted </td></tr>
    <tr><td class="paramname">&amp;rhs</td><td>is the destination data object, whose memory is firstly deleted, then newly allocated </td></tr>
    <tr><td class="paramname">type</td><td>is the type-number of the destination element </td></tr>
    <tr><td class="paramname">alpha</td><td>scaling factor (default: 1.0) </td></tr>
    <tr><td class="paramname">beta</td><td>offset value (default: 0.0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception(CV_StsAssert)</td><td>if conversion type is unknown </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a8c385ca573159fd49cec4112ef92557f" title="high-level, non-templated matrix conversion">convertTo</a>, <a class="el" href="namespaceito.html#a82f12dc309c241c93ff581a406690e58" title="low-level templated method to cast each element of source matrix to another type.">CastFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a52cb1bc366f5596fbe70133067856d66"></a><!-- doxytag: member="ito::DataObject::CopyToFunc" ref="a52cb1bc366f5596fbe70133067856d66" args="(const DataObject &amp;lhs, DataObject &amp;rhs, unsigned char regionOnly)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> CopyToFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>regionOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for deeply copying the data of one matrix to another given matrix </p>
<p>At first, the memory of the new matrix is delete. Then the data of the lhs-matrix is deeply copied to the rhs-matrix.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;lhs</td><td>is the matrix whose data is copied </td></tr>
    <tr><td class="paramname">&amp;rhs</td><td>is the matrix where the data is copied to. The old data of rhs is deleted first </td></tr>
    <tr><td class="paramname">regionOnly,if</td><td>true, only the data of the ROI in lhs is copied, hence, the org-size of rhs corresponds to the ROI-size of lhs, else the whole data block is copied and the ROI of rhs is set to the ROI of lhs </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#affdc8a47d061562a1f7dd9a47465fea5" title="high-level, non-templated method to deeply copy the data of this matrix to another matrix rhs...">copyTo</a>, <a class="el" href="classito_1_1_data_object.html#afbcaf0f37a720fa194d6a8c095850979" title="templated method for create">CreateFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afbcaf0f37a720fa194d6a8c095850979"></a><!-- doxytag: member="ito::DataObject::CreateFunc" ref="afbcaf0f37a720fa194d6a8c095850979" args="(DataObject *dObj, const unsigned char dimensions, const size_t *sizes, const unsigned char continuous, const uchar *continuousDataPtr, const size_t *steps)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> CreateFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>continuous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>continuousDataPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>templated method for create </p>
<p>creates or initializes matrix with given parameters</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dObj</td><td><a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix">DataObject</a>, whose matrix is created here </td></tr>
    <tr><td class="paramname">dimensions</td><td>total number of dimensions (&gt;=1), if dimensions == 1, dimensions will be set to two and a matrix with dimension [1 x orginial dimension] is created </td></tr>
    <tr><td class="paramname">*sizes</td><td>vector with size of dimensions, each element gives the size of elements in each dimension </td></tr>
    <tr><td class="paramname">continuous,indicates</td><td>whether the data stored in this data object is stored in one continuous data block or not. if dimension &lt;= 2, matrix is always continuous be careful, continuous has not the same meaning than the continuous flag in opencv or numpy. </td></tr>
    <tr><td class="paramname">continuousDataPtr</td><td>if this pointer is NULL, new data will be allocated. Else the given data indicates data which will be used by this data object. only possible if continuous is true. m_ownflag will be set to 0 if this pointer is set </td></tr>
    <tr><td class="paramname">*steps</td><td>vector with size of dimensions, indicates how many bytes one has to move in order to get to the next element in the same dimension, the step-size for the last element must be equal to element-size (in byte) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a80c0b9752187b008d1e9114231f82d65" title="high-level, non-templated method for data allocation">create</a> </dd></dl>
<p>continuous </p>

</div>
</div>
<a class="anchor" id="ab1a6c3bf0a6850c25027bca65c338587"></a><!-- doxytag: member="ito::DataObject::CreateFuncWithCVPlanes" ref="ab1a6c3bf0a6850c25027bca65c338587" args="(DataObject *dObj, const unsigned char dimensions, const size_t *sizes, const cv::Mat *planes, const unsigned int nrOfPlanes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> CreateFuncWithCVPlanes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat *&#160;</td>
          <td class="paramname"><em>planes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nrOfPlanes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>templated method for creation with given vector of cv::Mat-planes </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dimensions</td><td>is the total number of dimensions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*sizes</td><td>is a vector whose length is equal to dimensions. Each entry indicates the size of the specific dimension. Each matrix-plane is allocated with the size of the last two sizes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>is the desired element data type (see tDataType) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*planes</td><td>is an array of cv::Mat-planes which will be used as matrices for every single 2D-plane. Every Mat must have the same size and type. The type must correspond to the param type, the size must fit to the last two given sizes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrOfPlanes</td><td>is the length of the planes-array. This value must be the same than (sizes[0]*sizes[1]*...*sizes[dimensions-2]) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a80c0b9752187b008d1e9114231f82d65" title="high-level, non-templated method for data allocation">create</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac132a32c9e9b2ca544bbec584cfdcadf"></a><!-- doxytag: member="ito::DataObject::FreeFunc" ref="ac132a32c9e9b2ca544bbec584cfdcadf" args="(DataObject *dObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> FreeFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for freeing allocated data blocks </p>
<p>First, the header information of the corresponding data block is deleted. Then the reference counter of the data block is decremented. In the same way, the reference counter for every matrix-plane is incremented by calling the corresponding release-method. If the ref-counter is lower than zero no other instance needs this data block and it is deallocated if the m_owndata-flag is true.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>whose data block should be freed </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classito_1_1_data_object.html#a687861887060a1392433f4bfbfd770fc" title="high-level, non-templated method for freeing data">freeData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6c93d41178959c112bd49bfe5d165d24"></a><!-- doxytag: member="ito::DataObject::GetRangeFunc" ref="a6c93d41178959c112bd49bfe5d165d24" args="(DataObject *dObj, const int dtop, const int dbottom, const int dleft, const int dright)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> GetRangeFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dtop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dbottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dright</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method for saving a shallow copy of a source cv::Mat_ to a destination cv::Mat_ with respect to given row- and col-ranges </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">*SrcMat</td><td>is the source matrix which is firstly cast to cv::Mat_&lt;_Tp&gt;* </td></tr>
    <tr><td class="paramname">rowRange</td><td>is the desired row-range </td></tr>
    <tr><td class="paramname">colRange</td><td>is the desired col-range </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is the pointer to a destination matrix which is also cast to cv::Mat_&lt;_Tp&gt;* </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="ab7597f06c9c0867be7c54ee48412ee21"></a><!-- doxytag: member="ito::DataObject::MakeContinuousFunc" ref="ab7597f06c9c0867be7c54ee48412ee21" args="(const DataObject &amp;dObj, DataObject &amp;resDObj)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> MakeContinuousFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>resDObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>low-level, templated method which copies an incontinuously organized data object to a continuously organized resulting data object </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td>is the source data object </td></tr>
    <tr><td class="paramname">&amp;resDObj</td><td>is the resulting data object </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>retOk </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a34d66a7e0f3f92bbd81e07bc231106ad"></a><!-- doxytag: member="ito::DataObject::m_continuous" ref="a34d66a7e0f3f92bbd81e07bc231106ad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="classito_1_1_data_object.html#a34d66a7e0f3f92bbd81e07bc231106ad">ito::DataObject::m_continuous</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>continuous flag </p>

</div>
</div>
<a class="anchor" id="ad0cd7504bf6c6c275e544e8da295150d"></a><!-- doxytag: member="ito::DataObject::m_dims" ref="ad0cd7504bf6c6c275e544e8da295150d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classito_1_1_data_object.html#ad0cd7504bf6c6c275e544e8da295150d">ito::DataObject::m_dims</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>number of dimensions </p>

</div>
</div>
<a class="anchor" id="ad904fb92e5eb77b6ade0d771f10731ff"></a><!-- doxytag: member="ito::DataObject::m_objHeaderLock" ref="ad904fb92e5eb77b6ade0d771f10731ff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_read_write_lock.html">ReadWriteLock</a> <a class="el" href="classito_1_1_data_object.html#ad904fb92e5eb77b6ade0d771f10731ff">ito::DataObject::m_objHeaderLock</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>readWriteLock for this instance of dataObject. </p>

</div>
</div>
<a class="anchor" id="ab07e3eada8fcc050b4acc8ea0cb4a9e8"></a><!-- doxytag: member="ito::DataObject::m_objSharedDataLock" ref="ab07e3eada8fcc050b4acc8ea0cb4a9e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_read_write_lock.html">ReadWriteLock</a>* <a class="el" href="classito_1_1_data_object.html#ab07e3eada8fcc050b4acc8ea0cb4a9e8">ito::DataObject::m_objSharedDataLock</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>readWriteLock for data block, this lock is shared within every instance which is using the same data. </p>

</div>
</div>
<a class="anchor" id="a8055dbc01e3085b80ce13467d34b0e6d"></a><!-- doxytag: member="ito::DataObject::m_osize" ref="a8055dbc01e3085b80ce13467d34b0e6d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structito_1_1_data_object_1_1_m_size.html">MSize</a> <a class="el" href="classito_1_1_data_object.html#a8055dbc01e3085b80ce13467d34b0e6d">ito::DataObject::m_osize</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>vector containing the original size of each dimension. The allocated data block corresponds to these sizes </p>

</div>
</div>
<a class="anchor" id="a69dd85ae0c340c46abfcd4ea1343d2ba"></a><!-- doxytag: member="ito::DataObject::m_owndata" ref="a69dd85ae0c340c46abfcd4ea1343d2ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char <a class="el" href="classito_1_1_data_object.html#a69dd85ae0c340c46abfcd4ea1343d2ba">ito::DataObject::m_owndata</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>owndata flag (false if the data object is constructed with a given continuousDataPointer, else true) </p>

</div>
</div>
<a class="anchor" id="a91976d657e3ded04efa44cf60705395c"></a><!-- doxytag: member="ito::DataObject::m_pDataObjectTags" ref="a91976d657e3ded04efa44cf60705395c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_data_object_tags.html">DataObjectTags</a>* <a class="el" href="classito_1_1_data_object.html#a91976d657e3ded04efa44cf60705395c">ito::DataObject::m_pDataObjectTags</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>class containing the object metadata </p>

</div>
</div>
<a class="anchor" id="a099eaedf12393d3ccd9b3d18a2cae997"></a><!-- doxytag: member="ito::DataObject::m_pRefCount" ref="a099eaedf12393d3ccd9b3d18a2cae997" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* <a class="el" href="classito_1_1_data_object.html#a099eaedf12393d3ccd9b3d18a2cae997">ito::DataObject::m_pRefCount</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>pointer to the reference counter, the integer variable will be allocated once the data block is allocated. If only one data object has access to the data, the reference counter is 0. </p>

</div>
</div>
<a class="anchor" id="a268102dd4108170c941490c5ee0aa6ee"></a><!-- doxytag: member="ito::DataObject::m_roi" ref="a268102dd4108170c941490c5ee0aa6ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structito_1_1_data_object_1_1_m_r_o_i.html">MROI</a> <a class="el" href="classito_1_1_data_object.html#a268102dd4108170c941490c5ee0aa6ee">ito::DataObject::m_roi</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>vector containing the offset to the starting point of the ROI for each dimension, is used for detecting and adjusting the ROI </p>

</div>
</div>
<a class="anchor" id="a38d829331990b70cfd803b279d697eed"></a><!-- doxytag: member="ito::DataObject::m_size" ref="a38d829331990b70cfd803b279d697eed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structito_1_1_data_object_1_1_m_size.html">MSize</a> <a class="el" href="classito_1_1_data_object.html#a38d829331990b70cfd803b279d697eed">ito::DataObject::m_size</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>vector containing the "virtual" size of each dimension considering the ROI </p>

</div>
</div>
<a class="anchor" id="ac8a8870999f48e135c58177c07bc6c4a"></a><!-- doxytag: member="ito::DataObject::m_type" ref="ac8a8870999f48e135c58177c07bc6c4a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classito_1_1_data_object.html#ac8a8870999f48e135c58177c07bc6c4a">ito::DataObject::m_type</a><code> [private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>element data type </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/itom-git/sources/itom/DataObject/<a class="el" href="dataobj_8h_source.html">dataobj.h</a></li>
<li>D:/itom-git/sources/itom/DataObject/dataobj.cpp</li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceito.html">ito</a>      </li>
      <li class="navelem"><a class="el" href="classito_1_1_data_object.html">DataObject</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">Generated on Thu Aug 22 2013 23:45:36 for itom by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.5.1 </li>
   </ul>
 </div>


</body>
</html>
