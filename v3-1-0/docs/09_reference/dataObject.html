

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>10.6. dataObject &mdash; itom Documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../_static/breathe.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="itom Documentation" href="../index.html"/>
        <link rel="up" title="10. itom Script Reference" href="reference.html"/>
        <link rel="next" title="10.7. figure" href="figure.html"/>
        <link rel="prev" title="10.5. dataIO" href="dataIO.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> itom Documentation
          

          
          </a>

          
            
            
              <div class="version">
                3.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../00_releaseNotes/whats-new.html">1. Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../01_introduction/introduction.html">2. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_installation/install.html">3. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_gettingStarted/getting-started.html">4. Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_itom_gui/gui.html">5. The itom User Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_plots/plots.html">6. Plots and Figures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_extended_gui/extended_gui.html">7. Extending the user interface of <strong>itom</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_plugins/plugins.html">8. Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_scriptLanguage/script-language.html">9. Python scripting language</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="reference.html">10. itom Script Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="itom_general.html">10.1. itom methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="actuator.html">10.2. actuator</a></li>
<li class="toctree-l2"><a class="reference internal" href="algo.html">10.3. Algorithms, Widgets and Filters</a></li>
<li class="toctree-l2"><a class="reference internal" href="autoInterval.html">10.4. autoInterval</a></li>
<li class="toctree-l2"><a class="reference internal" href="dataIO.html">10.5. dataIO</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">10.6. dataObject</a></li>
<li class="toctree-l2"><a class="reference internal" href="figure.html">10.7. figure</a></li>
<li class="toctree-l2"><a class="reference internal" href="font.html">10.8. font</a></li>
<li class="toctree-l2"><a class="reference internal" href="plotItem.html">10.9. plotItem</a></li>
<li class="toctree-l2"><a class="reference internal" href="point.html">10.10. point</a></li>
<li class="toctree-l2"><a class="reference internal" href="pointCloud.html">10.11. pointCloud</a></li>
<li class="toctree-l2"><a class="reference internal" href="polygonMesh.html">10.12. polygonMesh</a></li>
<li class="toctree-l2"><a class="reference internal" href="region.html">10.13. region</a></li>
<li class="toctree-l2"><a class="reference internal" href="rgba.html">10.14. rgba</a></li>
<li class="toctree-l2"><a class="reference internal" href="shape.html">10.15. shape</a></li>
<li class="toctree-l2"><a class="reference internal" href="timer.html">10.16. timer</a></li>
<li class="toctree-l2"><a class="reference internal" href="itom_GUI.html">10.17. ui-elements (ui, uiItem)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../10_miscellaneous/miscellaneous.html">11. Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_test-scripts/test-scripts.html">12. Demo scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_tutorials/tutorials.html">13. Python tutorials</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">itom Documentation</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="reference.html">10. itom Script Reference</a> &raquo;</li>
        
      <li>10.6. dataObject</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/09_reference/dataObject.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="dataobject">
<h1>10.6. dataObject<a class="headerlink" href="#dataobject" title="Permalink to this headline">¶</a></h1>
<p>This section contains the script reference to the main array class <em>dataObject</em> of <strong>itom</strong>. Read the <a class="reference internal" href="../08_scriptLanguage/pymod-dataObject.html#itomdataobject"><span class="std std-ref">overview document</span></a> for more
details about the Python interface of the class <em>dataObject</em>.</p>
<dl class="class">
<dt id="itom.dataObject">
<em class="property">class </em><code class="descclassname">itom.</code><code class="descname">dataObject</code><span class="sig-paren">(</span><em>[dims [, dtype='uint8'[, continuous = 0][, data = valueOrSequence]]]</em><span class="sig-paren">)</span> &#x2192; constructor to get a new dataObject.<a class="headerlink" href="#itom.dataObject" title="Permalink to this definition">¶</a></dt>
<dd><p>The itom.dataObject represents a multidimensional array of fixed-size items with corresponding meta information (units, axes descriptions, scalings, tags, protocol…). 
Recently the following data types (dtype) are supported:</p>
<ul class="simple">
<li>Integer-type (int8, uint8, int16, uint16, int32, uint32),</li>
<li>Floating-type (float32, float64 (=&gt; double)),</li>
<li>Complex-type  (complex64 (2x float32), complex128 (2x float64)).</li>
<li>Color-type  (rgba32 (uint32 or uint[4] containing the four 8bit values [R, G, B, Alpha])).</li>
</ul>
<p>Arrays can also be constructed using some of the static pre-initialization methods ‘zeros’, ‘ones’, ‘rand’ or ‘randN’ (refer to the See Also section below).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : {sequence of integers}, optional</p>
<blockquote>
<div><p>‘dims’ is a list or tuple indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns. If not given, an empty data object is created.</p>
</div></blockquote>
<p><strong>dtype</strong> : {str}, optional</p>
<blockquote>
<div><p>‘dtype’ is the data type of each element, possible values: ‘int8’,’uint8’,…,’int32’,’uint32’,’float32’,’float64’,’complex64’,’complex128’, ‘rgba32’</p>
</div></blockquote>
<p><strong>continuous</strong> : {int}, optional</p>
<blockquote>
<div><p>‘continuous’ [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).</p>
</div></blockquote>
<p><strong>data</strong> : {str}, optional</p>
<blockquote class="last">
<div><p>‘data’ is a single value or a sequence with the same amount of values than the data object. The values from data will be assigned to the new data object (filled row by row).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataObject.ones" title="itom.dataObject.ones"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code></a>, <a class="reference internal" href="#itom.dataObject.zeros" title="itom.dataObject.zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></a>, <a class="reference internal" href="#itom.dataObject.rand" title="itom.dataObject.rand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rand</span></code></a>, <a class="reference internal" href="#itom.dataObject.randN" title="itom.dataObject.randN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">randN</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>The itom.dataObject is a direct wrapper for the underlying C++ class <em>dataObject</em>. This array class mainly is based on the class <em>Mat</em> of the computer vision library (OpenCV).</p>
<p>In order to handle huge matrices, the data object can divide one array into chunks in memory.
Each subpart (called matrix-plane) is two-dimensional and covers data of the last two dimensions.
In c++-context each of these matrix-planes is of type cv::Mat_&lt;type&gt; and can be used with every operator given by the openCV-framework (version 2.3.1 or higher).</p>
<p>The dimensions of the matrix are structured descending. So if we assume to have a n-dimensional matrix A,
where each dimension has its size s_i, the dimensions order is n, .., z, y, x and the corresponding sizes of A are [s_n, s_(n-1),  s_(n-2), …, s_y, s_x].</p>
<p>In order to make the data object compatible to continuously organized data structures, like numpy-arrays, 
it is also possible to have all matrix-planes in one data-block in memory (not recommended for huge matrices).
Nevertheless, the indicated data structure with the two-dimensional sub-matrix-planes is still existing. 
The data organization is equal to the one of openCV, hence, two-dimensional matrices are stored row-by-row (C-style)…</p>
<p>In addition to OpenCV, itom.dataObject supports complex valued data types for all operators and methods.</p>
<p>Warning ‘uint32’ is not fully openCV-compatible and hence causes instability!</p>
<p><strong>Deep Copy, Shallow Copy and ROI</strong></p>
<p>It is possible to set a n-dimensional region of interest (ROI) to each matrix, the virtual dimensions,
which will be delivered if the user asks for the matrix size.
To avoid copy operations where possible a simple =_Operator will also make a shallow copy of the object.
Shallow copies share the same data (elements and meta data) with the original object, hence manipulations of one object will affect the
original object and all shallow copies.</p>
<p>The opposite a deep copy of a dataObject (by sourceObject.copy()) creates a complete mew matrix with own meta data object.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#Create an object </span>
<span class="n">dObj</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="s1">&#39;int8&#39;</span><span class="p">)</span>

<span class="c1"># Make a shallow copy </span>
<span class="n">dObjShallow</span> <span class="o">=</span> <span class="n">dObj</span> 

<span class="c1"># Make a shallow copy on ROI</span>
<span class="n">dObjROI</span> <span class="o">=</span> <span class="n">dObj</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> 

<span class="c1"># Set the value of element [1, 0, 0] to 0</span>
<span class="n">dObj</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># Make a deep copy of the dObjROI</span>
<span class="n">dObjROICopy</span> <span class="o">=</span> <span class="n">dObjROI</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<span class="c1"># Set the value of dObjROICopy element [0, 0, 0] to 127 without effecting other objects</span>
<span class="n">dObjROICopy</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">127</span>
</pre></div>
</div>
<p><strong>Constructor</strong></p>
<p>The function dataObject([dims [, dtype=’uint8’[, continuous = 0][, data = valueOrSequence]]])
creates a new itom-dataObject filled with undefined data.
If no parameters are given, an uninitilized DataObject (dims = 0, no sizes) is created.</p>
<p>As second possibility you can also use the copy-constructor ‘dataObject(AnyArray)’, 
where AnyArray must be any array-like structure which is parsable by the numpy-interface.</p>
<dl class="method">
<dt id="itom.dataObject.abs">
<code class="descname">abs</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; return a new data object with the absolute values of the source<a class="headerlink" href="#itom.dataObject.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>This method calculates the abs value of each element in source and writes the result to the output object.In case of floating point or real object, the type of the output will not change. For complex valuesthe type is changes to the corresponding floating type value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>res</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>output dataObject of same shape but the type may be changed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.addToProtocol">
<code class="descname">addToProtocol</code><span class="sig-paren">(</span><em>newLine</em><span class="sig-paren">)</span> &#x2192; Appends a protocol line to the protocol.<a class="headerlink" href="#itom.dataObject.addToProtocol" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends a line of text to the protocol string of this data object. If this data object has got a region of interest defined, the rectangle of the ROI is automatically appended to newLine. The protocol string ends with a newline character.</p>
<p>Address the content of the protocol by obj.tags[“protocol”]. The protocol is contained in the ordinary tag dictionary of this data object under the key ‘protocol’.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>newLine</strong> : {str}</p>
<blockquote class="last">
<div><p>The text to be added to the protocol.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.adj">
<code class="descname">adj</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; Adjugate all elements<a class="headerlink" href="#itom.dataObject.adj" title="Permalink to this definition">¶</a></dt>
<dd><p>Every plane (spanned by the last two axes) is transposed and every element is replaced by its complex conjugate value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>TypeError :</strong> :</p>
<blockquote class="last">
<div><p>if data type of this data object is not complex.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataObject.adjugate" title="itom.dataObject.adjugate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjugate</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.adjugate">
<code class="descname">adjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; returns the plane-wise adjugated array of this dataObject.<a class="headerlink" href="#itom.dataObject.adjugate" title="Permalink to this definition">¶</a></dt>
<dd><p>If this data object has a complex type, the tranposed data object is returned where every element is complex conjugated. For data objects with more than two dimensions the tranposition is done plane-wise, hence, only the last two dimensions are permutated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : {dataObject}</p>
<blockquote>
<div><p>adjugate of this dataObject</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>TypeError :</strong> :</p>
<blockquote class="last">
<div><p>if data type of this data object is not complex.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataObject.adj" title="itom.dataObject.adj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adj</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.adjustROI">
<code class="descname">adjustROI</code><span class="sig-paren">(</span><em>offsetList</em><span class="sig-paren">)</span> &#x2192; adjust the size and position of the region of interest of this data object<a class="headerlink" href="#itom.dataObject.adjustROI" title="Permalink to this definition">¶</a></dt>
<dd><p>For every data object, it is possible to define a region of interest such that subsequent commands only refer to this subpart. However, if values within 
the region of interest (ROI) are changed, this also affects the original data object due to the shallow copy principal of python. 
Use this command to adjust the current size and position of this region of interest by passing an offset list, that contains integer numbers with twice the size than the number of dimensions.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span> 
<span class="n">droi</span> <span class="o">=</span> <span class="n">d</span> 
<span class="n">droi</span><span class="o">.</span><span class="n">adjustROI</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> 
</pre></div>
</div>
<p>Now <em>droi</em> is a region of interest of the original data object whose first value is equal to d[2,1] and its size is (3,2)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>offsetList</strong> : {list of integers}</p>
<blockquote class="last">
<div><p>This list must have twice as many values than the number of dimensions of this data object. A pair of numbers indicates the shift of the     current boundaries of the region of interest in every dimension. The first value of each pair is the offset of the ‘left’ boundary, the     second the shift of the right boundary. A positive value means a growth of the region of interest, a negative one let the region of interest     shrink towards the center.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataObject.locateROI" title="itom.dataObject.locateROI"><code class="xref py py-obj docutils literal notranslate"><span class="pre">locateROI</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.arg">
<code class="descname">arg</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; return a new data object with the argument values of the source<a class="headerlink" href="#itom.dataObject.arg" title="Permalink to this definition">¶</a></dt>
<dd><p>This method calculates the argument value of each element in source and writes the result to the output object.This object must be of complex type (complex128 or complex64). The output value will be float type (float64 or float32).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>res</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>output dataObject of same shape but the type is changed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.astype">
<code class="descname">astype</code><span class="sig-paren">(</span><em>typestring</em><span class="sig-paren">)</span> &#x2192; converts this data object to another type<a class="headerlink" href="#itom.dataObject.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts this data object to a new data object with another type, given by the string newTypestring (e.g. ‘uint8’). The converted data object is a deep copy of this object if the new type does not correspond to the current type, else a shallow copy of this object is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>typestring</strong> : {str}</p>
<blockquote>
<div><p>Type string indicating the new type (‘uint8’,…’float32’,..,’complex64’)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>c</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>type-converted data object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This method mainly uses the method convertTo of OpenCV.</p>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.conj">
<code class="descname">conj</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; complex-conjugates all elements of this dataObject (inline).<a class="headerlink" href="#itom.dataObject.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Every value of this dataObject is replaced by its complex-conjugate value.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>TypeError :</strong> :</p>
<blockquote class="last">
<div><p>if data type of this data object is not complex.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataObject.conjugate" title="itom.dataObject.conjugate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conjugate</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.conjugate">
<code class="descname">conjugate</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; return a copy of this dataObject where every element is complex-conjugated.<a class="headerlink" href="#itom.dataObject.conjugate" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : {dataObject}</p>
<blockquote>
<div><p>element-wise complex conjugate of this data object</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>TypeError :</strong> :</p>
<blockquote class="last">
<div><p>if data type of this data object is not complex.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataObject.conj" title="itom.dataObject.conj"><code class="xref py py-obj docutils literal notranslate"><span class="pre">conj</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><em>regionOnly=0</em><span class="sig-paren">)</span> &#x2192; return a deep copy of this dataObject<a class="headerlink" href="#itom.dataObject.copy" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>regionOnly</strong> : {bool}, optional</p>
<blockquote>
<div><p>If regionOnly is 1, only the current region of interest of this dataObject is copied, else the entire dataObject     including the current settings concerning the region of interest are deeply copied [default].</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cpy</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>Deep copy of this dataObject</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.copyMetaInfo">
<code class="descname">copyMetaInfo</code><span class="sig-paren">(</span><em>sourceObj</em><span class="optional">[</span>, <em>copyAxisInfo = True</em>, <em>copyTags = False</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; Copy the meta information of sourceObj.<a class="headerlink" href="#itom.dataObject.copyMetaInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>All meta information(axis scales, offsets, descriptions, units, tags…) of the sourceObj are copied to the dataObject.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>sourceObj</strong> : {dataObject}</p>
<blockquote>
<div><p>whose meta information is copied in this dataObject.</p>
</div></blockquote>
<p><strong>copyAxisInfo</strong> : {bool}, optional</p>
<blockquote>
<div><p>If ‘copyAxisInfo’ is True, the ‘axis scales’, ‘offsets’, ‘descriptions’, ‘units’ are copied.</p>
</div></blockquote>
<p><strong>copyTags</strong> : {bool}, optional</p>
<blockquote>
<div><p>If ‘copyTags’ is True, the ‘tags’ are copied.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError :</strong> :</p>
<blockquote class="last">
<div><p>if the given sourceObj is not a dataObject</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#itom.dataObject.metaDict" title="itom.dataObject.metaDict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">metaDict</span></code></a></dt>
<dd>this attribute can directly be used to print the meta information of a dataobject.</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.createMask">
<code class="descname">createMask</code><span class="sig-paren">(</span><em>shapes</em><span class="optional">[</span>, <em>inverse = False</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; return a uint8 data object of the same size where all pixels belonging to any shape are masked.<a class="headerlink" href="#itom.dataObject.createMask" title="Permalink to this definition">¶</a></dt>
<dd><p>The destination data object has the same size than this data object and the real type given by destinationType. The pixel - wise conversion is done using the formula : gray = 0.299 * red + 0.587 * green + 0.114 * blue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>shapes</strong> : {shape or seq. of shapes}</p>
<blockquote>
<div><p>The union of all shapes (polygons, rectangles, squares, circles and ellipes are considered, only) are marked within the mask</p>
</div></blockquote>
<p><strong>inverse</strong> : {bool}</p>
<blockquote>
<div><p>If False (default) the shape areas are marked with 255 and the outer areas with 0, if True the behaviour is vice-versa.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dataObj</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>uint8 data object as mask with the same size, scales and offsets than this object. The mask is applied to all planes.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.data">
<code class="descname">data</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; prints the content of the dataObject to the command line in a readable form.<a class="headerlink" href="#itom.dataObject.data" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="itom.dataObject.deleteTag">
<code class="descname">deleteTag</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span> &#x2192; Delete a tag specified by key from the tag dictionary.<a class="headerlink" href="#itom.dataObject.deleteTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a tag with the given key exists in the tag dictionary and if so deletes it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : {str}</p>
<blockquote>
<div><p>the name of the tag to be deleted</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>success</strong> : {bool}:</p>
<blockquote class="last">
<div><p>True if tag with given key existed and could be deleted, else False</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.div">
<code class="descname">div</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span> &#x2192; a.div(b) return result of element wise division of a./b<a class="headerlink" href="#itom.dataObject.div" title="Permalink to this definition">¶</a></dt>
<dd><p>All meta information (axis scales, offsets, descriptions, units, tags…) of the resulting object are copied from this data object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>obj</strong> : {dataObject}</p>
<blockquote>
<div><p>Every value in this data object is divided by the corresponding value in obj.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>c</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>Resulting divided data object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="itom.dataObject.dstack">
<em class="property">static </em><code class="descname">dstack</code><span class="sig-paren">(</span><em>objects</em><span class="sig-paren">)</span> &#x2192; returns a stacked data object containing a stack of all planes given by this and obj.<a class="headerlink" href="#itom.dataObject.dstack" title="Permalink to this definition">¶</a></dt>
<dd><p>The returned dataObject contains layers of the same shape and type like the given ones. The different layers will be located along the first axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>obj</strong> : {sequence of dataObjects}</p>
<blockquote>
<div><p>Sequence (list) of dataObjects containig planes that will be stacked together. All dataObjects must be of the same type and have the same shape of planes (last two dimesnions).                Only one of the (n-2) dimensions of each input dataObject is allowed to have a size greater one.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dataObj</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>dataObject of the same type. The different planes are located along the first axis.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.existTag">
<code class="descname">existTag</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span> &#x2192; return True if tag with given key exists, else False<a class="headerlink" href="#itom.dataObject.existTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a tag with the given key exists in tag dictionary of this data object and returns True if such a tag exists, else False.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : {str}</p>
<blockquote>
<div><p>the key of the tag</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>result</strong> : {bool}</p>
<blockquote class="last">
<div><p>True if tag exists, else False</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="itom.dataObject.eye">
<em class="property">static </em><code class="descname">eye</code><span class="sig-paren">(</span><em>size</em><span class="optional">[</span>, <em>dtype='uint8'</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; creates a 2D, square, eye-matrix.<a class="headerlink" href="#itom.dataObject.eye" title="Permalink to this definition">¶</a></dt>
<dd><p>Static method for creating a two-dimensional, square, eye-matrix of type itom.dataObject.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>size</strong> : {int},</p>
<blockquote>
<div><p>the size of the square matrix (single value)</p>
</div></blockquote>
<p><strong>dtype</strong> : {str}, optional</p>
<blockquote>
<div><p>‘dtype’ is the data type of each element, possible values: ‘int8’, ‘uint8’, …, ‘int32’, ‘uint32’, ‘float32’, ‘float64’, ‘complex64’, ‘complex128’, ‘rgba32’</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>I</strong> : {dataObject} of shape (size,size)</p>
<blockquote class="last">
<div><p>An array where all elements are equal to zero, except for the ‘k-th diagonal, whose values are equal to one.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#itom.dataObject.ones" title="itom.dataObject.ones"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code></a></dt>
<dd>method for creating a matrix filled with ones</dd>
<dt><a class="reference internal" href="#itom.dataObject.zeros" title="itom.dataObject.zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></a></dt>
<dd>method for creating a matrix filled with zeros</dd>
</dl>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="itom.dataObject.fromNumpyColor">
<em class="property">static </em><code class="descname">fromNumpyColor</code><span class="sig-paren">(</span><em>array</em><span class="sig-paren">)</span> &#x2192; creates a rgba32 dataObject from a three-dimensional numpy array whose liast dimension has the size 3 or 4.<a class="headerlink" href="#itom.dataObject.fromNumpyColor" title="Permalink to this definition">¶</a></dt>
<dd><p>Static method for creating a two-dimensional dataObject of type ‘rgba32’ from a three-dimensional numpy.array (uint8 only). 
The size of the dataObject corresponds to the first two dimensions of the numpy.array. The last dimension of 
the numpy.array must have a size of 3 (blue, green, red and alpha = 255) or 4 (blue, green, red, alpha).</p>
<p>This method can especially be used to convert numpy.arrays that are obtained by methods from packages like OpenCV (cv2) 
or PIL to dataObjects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>array</strong> : {numpy.array},</p>
<blockquote>
<div><p>[MxNx3] or [MxNx4], uint8 numpy.array</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>I</strong> : {dataObject} of shape (M,N) and type ‘rgba32’</p>
<blockquote class="last">
<div><p>The last dimension of the numpy.array corresponds to blue, green, red and optional alpha of the rgba32 value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.getTagListSize">
<code class="descname">getTagListSize</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; returns the number of tags in the tag dictionary<a class="headerlink" href="#itom.dataObject.getTagListSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Every data object can have an arbitrary number of tags stored in the tag dictionary. This method returns the number of different tags, where the protocol is also one tag with the key ‘protocol’.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>length</strong> : {int}:</p>
<blockquote class="last">
<div><p>size of the tag dictionary. The optional protocol also counts as one item.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.imag">
<code class="descname">imag</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; return a new data object with the imaginary part of the source<a class="headerlink" href="#itom.dataObject.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>This method extracts the imaginary part of each element in source and writes the result to the output object.This object must be of complex type (complex128 or complex64). The output value will be float type (float64 or float32).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>res</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>output dataObject of same shape but the type is changed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.lineCut">
<code class="descname">lineCut</code><span class="sig-paren">(</span><em>coordinates</em><span class="sig-paren">)</span> &#x2192; returns a data object of the same type containing a lineCut calculated by the use of a Bresenham algorithm.<a class="headerlink" href="#itom.dataObject.lineCut" title="Permalink to this definition">¶</a></dt>
<dd><p>The returned dataObject contains a lineCut across the 2d source dataObject.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>obj</strong> : {sequence of double}</p>
<blockquote>
<div><p>Sequence (list) containing four floating-point values representing the physical coordinates of the start- and endpoint. The values are interpreted as followed: [x0,y0,x1,y1]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dataObj</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>one dimensional dataObject of the same type.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.locateROI">
<code class="descname">locateROI</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; returns information about the current region of interest of this data object<a class="headerlink" href="#itom.dataObject.locateROI" title="Permalink to this definition">¶</a></dt>
<dd><p>A region of interest (ROI) of a data object is defined by the two values per axis. The first element always indicates the size between the 
real border of the data object and the region of interest on the left / top … side and the second value the margin of the right / bottom … side.</p>
<p>This method returns a tuple with two elements: The first is a list with the original sizes of this data object, the second is a list with the offsets from the original data object to the first value in the current region of interest</p>
<p>If no region of interest is set (hence: full region of interest), the first list corresponds to the one returned by size(), the second list is a zero-vector.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataObject.adjustROI" title="itom.dataObject.adjustROI"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjustROI</span></code></a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.makeContinuous">
<code class="descname">makeContinuous</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; return continuous representation of dataObject<a class="headerlink" href="#itom.dataObject.makeContinuous" title="Permalink to this definition">¶</a></dt>
<dd><p>Per default a dataObject with more than two dimensions allocates separated chunks of memory for every plane, where a plane is always the matrix given by the last two dimensions. This separated storage usually allows allocating more memory for huge for instance three dimensional matrices. However, in order to generate a dataObject that is directly compatible to Numpy or other C-style matrix structures, the entire allocated memory must be in one block, that is called continuous. If you create a Numpy array from a dataObject that is not continuous, this function is implicitely called in order to firstly make the dataObject continuous before passing to Numpy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>obj</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>continuous dataObject</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>if this dataObject already is continuous, a simple shallow copy is returned</p>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.mul">
<code class="descname">mul</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span> &#x2192; a.mul(b) returns element wise multiplication of a*b<a class="headerlink" href="#itom.dataObject.mul" title="Permalink to this definition">¶</a></dt>
<dd><p>All meta information (axis scales, offsets, descriptions, units, tags…) of the resulting object are copied from this data object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>obj</strong> : {dataObject}</p>
<blockquote>
<div><p>dataObject whose values are element-wisely multiplied with the values in this dataObject.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>c</strong> : {dataObject}</p>
<blockquote>
<div><p>Resulting multiplied data object.</p>
</div></blockquote>
<p class="last"><strong>For a mathematical multiplication see the *-operator.</strong> :</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>) -&gt; returns the name of this object (dataObject</em><span class="sig-paren">)</span><a class="headerlink" href="#itom.dataObject.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="itom.dataObject.normalize">
<code class="descname">normalize</code><span class="sig-paren">(</span><span class="optional">[</span><em>minValue=0.0</em>, <em>maxValue=1.0</em>, <em>typestring=''</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; returns the normalization of this dataObject<a class="headerlink" href="#itom.dataObject.normalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the normalized version of this data object, where the values lie in the range [minValue,maxValue]. Additionally it is also 
possible to convert the resulting data object to another type (given by the parameter typestring). As default no type conversion is executed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>minValue</strong> : {double}</p>
<blockquote>
<div><p>minimum value of the normalized range</p>
</div></blockquote>
<p><strong>maxValue</strong> : {double}</p>
<blockquote>
<div><p>maximum value of the normalized range</p>
</div></blockquote>
<p><strong>typestring</strong> : {String}</p>
<blockquote>
<div><p>Type string indicating the new type (‘uint8’,…’float32’,..,’complex64’), default: ‘’ (no type conversion)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>normalized</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>normalized data object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="itom.dataObject.ones">
<em class="property">static </em><code class="descname">ones</code><span class="sig-paren">(</span><em>dims</em><span class="optional">[</span>, <em>dtype='uint8'</em><span class="optional">[</span>, <em>continuous = 0</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; creates new dataObject filled with ones.<a class="headerlink" href="#itom.dataObject.ones" title="Permalink to this definition">¶</a></dt>
<dd><p>Static method for creating a new n-dimensional itom.dataObject with given number of dimensions and dtype, filled with ones.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : {integer list}</p>
<blockquote>
<div><p>‘dims’ is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns</p>
</div></blockquote>
<p><strong>dtype</strong> : {str}, optional</p>
<blockquote>
<div><p>‘dtype’ is the data type of each element, possible values: ‘int8’, ‘uint8’, …, ‘int32’, ‘uint32’, ‘float32’, ‘float64’, ‘complex64’, ‘complex128’, ‘rgba32’</p>
</div></blockquote>
<p><strong>continuous</strong> : {int}, optional</p>
<blockquote>
<div><p>‘continuous’ [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>I</strong> : {dataObject} of shape (size,size)</p>
<blockquote class="last">
<div><p>An array where all elements are equal to one.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#itom.dataObject.eye" title="itom.dataObject.eye"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eye</span></code></a></dt>
<dd>method for creating an eye matrix</dd>
<dt><a class="reference internal" href="#itom.dataObject.zeros" title="itom.dataObject.zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zeros</span></code></a></dt>
<dd>method for creating a matrix filled with zeros</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For color-types (rgba32) every item / cell will be white: [r=255 g=255 b=255 a=255].</p>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.physToPix">
<code class="descname">physToPix</code><span class="sig-paren">(</span><em>values</em><span class="optional">[</span>, <em>axes</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; returns the pixel coordinates for the given physical coordinates.<a class="headerlink" href="#itom.dataObject.physToPix" title="Permalink to this definition">¶</a></dt>
<dd><p>This method transforms a physical axis coordinate into its corresponding pixel coordinate. The transformation is influenced 
by the offset and scaling of each axis:</p>
<p>phys = (pix - offset) * scaling</p>
<p>If no axes parameter is given, the values are assumed to belong the the ascending axis list (0,1,2,3…). 
The returned pixel value is clipped by the real size of the data object in the requested dimension [0, shape[axis]-1].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>values</strong> : {float, float-tuple}</p>
<blockquote>
<div><p>One single physical coordinate or a tuple of physical coordinates.</p>
</div></blockquote>
<p><strong>axes</strong> : {int, int-tuple}, optional</p>
<blockquote>
<div><p>If this is given, the values are mapped to the axis indices given by this value or tuple. Else, an ascending list starting with index 0 is assumed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Float or float-tuple with the pixel coordinates for each physical coordinate at the given axis index.</strong> :</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>Value error :</strong> :</p>
<blockquote>
<div><p>if the given axes is invalid (out of range)</p>
</div></blockquote>
<p><strong>Runtime warning :</strong> :</p>
<blockquote class="last">
<div><p>if requested physical unit is outside of the range of the requested axis. The returned pixel value is clipped to the closest boundary value.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.pixToPhys">
<code class="descname">pixToPhys</code><span class="sig-paren">(</span><em>values</em><span class="optional">[</span>, <em>axes</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; returns the physical coordinates for the given pixel coordinates.<a class="headerlink" href="#itom.dataObject.pixToPhys" title="Permalink to this definition">¶</a></dt>
<dd><p>This method transforms a pixel coordinate into its corresponding physical coordinate. The transformation is influenced 
by the offset and scaling of each axis:</p>
<p>pix = (phys / scaling) + offset</p>
<p>If no axes parameter is given, the values are assumed to belong the the ascending axis list (0,1,2,3…).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>values</strong> : {float, float-tuple}</p>
<blockquote>
<div><p>One single pixel coordinate or a tuple of pixel coordinates.</p>
</div></blockquote>
<p><strong>axes</strong> : {int, int-tuple}, optional</p>
<blockquote>
<div><p>If this is given, the values are mapped to the axis indices given by this value or tuple. Else, an ascending list starting with index 0 is assumed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>Float or float-tuple with the physical coordinates for each pixel coordinate at the given axis index.</strong> :</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>Value error :</strong> :</p>
<blockquote class="last">
<div><p>if the given axes is invalid (out of range)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="itom.dataObject.rand">
<em class="property">static </em><code class="descname">rand</code><span class="sig-paren">(</span><span class="optional">[</span><em>dims</em><span class="optional">[</span>, <em>dtype='uint8'</em><span class="optional">[</span>, <em>continuous = 0</em><span class="optional">]</span><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; creates new dataObject filled with uniformly distributed random values.<a class="headerlink" href="#itom.dataObject.rand" title="Permalink to this definition">¶</a></dt>
<dd><p>Static method to create a new itom.dataObject filled with uniformly distributed random numbers.
In case of an integer type, the uniform noise is from min&lt;ObjectType&gt;(inclusiv) to max&lt;ObjectType&gt;(inclusiv).
For floating point types, the noise is between 0(inclusiv) and 1(exclusiv).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : {integer list}</p>
<blockquote>
<div><p>‘dims’ is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns.</p>
</div></blockquote>
<p><strong>dtype</strong> : {str}, optional</p>
<blockquote>
<div><p>‘dtype’ is the data type of each element, possible values: ‘int8’, ‘uint8’, …, ‘int32’, ‘uint32’, ‘float32’, ‘float64’, ‘complex64’, ‘complex128’, ‘rgba32’</p>
</div></blockquote>
<p><strong>continuous</strong> : {int}, optional</p>
<blockquote>
<div><p>‘continuous’ [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>Array of random numbers with the given dimensions, dtype.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#itom.dataObject.randN" title="itom.dataObject.randN"><code class="xref py py-obj docutils literal notranslate"><span class="pre">randN</span></code></a></dt>
<dd>method for creating a matrix filled with gaussian distributed values</dd>
</dl>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="itom.dataObject.randN">
<em class="property">static </em><code class="descname">randN</code><span class="sig-paren">(</span><em>dims</em><span class="optional">[</span>, <em>dtype='uint8'</em><span class="optional">[</span>, <em>continuous = 0</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; creates dataObject filled with gaussian distributed random values.<a class="headerlink" href="#itom.dataObject.randN" title="Permalink to this definition">¶</a></dt>
<dd><p>Static method to create a new itom.dataObject filled with gaussian distributed random numbers. 
In case of an integer type, the gausian noise mean value is (max+min)/2.0 and the standard deviation is (max-min/)6.0 to max. 
For floating point types, the noise mean value is 0 and the standard deviation is 1.0/3.0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : {integer list}</p>
<blockquote>
<div><p>‘dims’ is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns.</p>
</div></blockquote>
<p><strong>dtype</strong> : {str}, optional</p>
<blockquote>
<div><p>‘dtype’ is the data type of each element, possible values: ‘int8’, ‘uint8’, …, ‘int32’, ‘uint32’, ‘float32’, ‘float64’, ‘complex64’, ‘complex128’, ‘rgba32’</p>
</div></blockquote>
<p><strong>continuous</strong> : {int}, optional</p>
<blockquote>
<div><p>‘continuous’ [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>Array of random numbers with the given dimensions, dtype.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#itom.dataObject.rand" title="itom.dataObject.rand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rand</span></code></a></dt>
<dd>method for creating a matrix filled with unformly distributed values</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.real">
<code class="descname">real</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; return a new data object with the real part of the source<a class="headerlink" href="#itom.dataObject.real" title="Permalink to this definition">¶</a></dt>
<dd><p>This method extracts the real part of each element in source and writes the result to the output object.This object must be of complex type (complex128 or complex64). The output value will be float type (float64 or float32).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>res</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>output dataObject of same shape but the type is changed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.reshape">
<code class="descname">reshape</code><span class="sig-paren">(</span><em>newShape</em><span class="sig-paren">)</span> &#x2192; return a reshaped shallow copy (if possible) of this dataObject.<a class="headerlink" href="#itom.dataObject.reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>This method returns a shallow or deep copy if this data object where the type and data is unchanged. The shape 
of the returned object corresponds to the parameter ‘newShape’. The number of values must therefore not be changed. 
If the last two dimensions of ‘newShape’ and this object are the same and if the data is not continously organized, 
a shallow copy can be returned, else a deep 
copy has to be created. Tags and the rotation matrix are copied, the axis tags are only copied for all axes whose 
size will not change beginning from the last axis (‘x’). This axis copying is stopped after the first axis with a different 
new size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>newShape</strong> : {seq. of int}</p>
<blockquote>
<div><p>New shape of the returned object. A minimal size of this list or tuple is two.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>reshaped</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>The reshaped data object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This method is similar to numpy.reshape</p>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.setAxisDescription">
<code class="descname">setAxisDescription</code><span class="sig-paren">(</span><em>axisNum</em>, <em>axisDescription</em><span class="sig-paren">)</span> &#x2192; Set the description of the specified axis.<a class="headerlink" href="#itom.dataObject.setAxisDescription" title="Permalink to this definition">¶</a></dt>
<dd><p>Each axis in the data object can get a specific axisDescription string (e.g. mm). Use this method to set the axisDescription of one specific axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axisNum</strong> : {int}</p>
<blockquote>
<div><p>The addressed axis index</p>
</div></blockquote>
<p><strong>axisDescription</strong> : {str}</p>
<blockquote>
<div><p>New axis description</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError :</strong> :</p>
<blockquote class="last">
<div><p>if the given axisNum is invalid (out of range)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#itom.dataObject.axisDescriptions" title="itom.dataObject.axisDescriptions"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axisDescriptions</span></code></a></dt>
<dd>this attribute can directly be used to read/write the axis description(s) of single or all axes</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.setAxisOffset">
<code class="descname">setAxisOffset</code><span class="sig-paren">(</span><em>axisNum</em>, <em>axisOffset</em><span class="sig-paren">)</span> &#x2192; Set the offset of the specified axis.<a class="headerlink" href="#itom.dataObject.setAxisOffset" title="Permalink to this definition">¶</a></dt>
<dd><p>Each axis in the data object can get a specific scale value, described in axisUnits per pixel. Use this method to set the scale of one specific axis. 
The value of each pixel in its physical unit is the (px-Coordinate - axisOffset) * axisScale</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axisNum</strong> : {int}</p>
<blockquote>
<div><p>The addressed axis index</p>
</div></blockquote>
<p><strong>axisOffset</strong> : {double}</p>
<blockquote>
<div><p>New axis offset in [px]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError :</strong> :</p>
<blockquote class="last">
<div><p>if the given axisNum is invalid (out of range)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#itom.dataObject.axisOffsets" title="itom.dataObject.axisOffsets"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axisOffsets</span></code></a></dt>
<dd>this attribute can directly be used to read/write the axis offset(s) of single or all axes</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.setAxisScale">
<code class="descname">setAxisScale</code><span class="sig-paren">(</span><em>axisNum</em>, <em>axisScale</em><span class="sig-paren">)</span> &#x2192; Set the scale value of the specified axis.<a class="headerlink" href="#itom.dataObject.setAxisScale" title="Permalink to this definition">¶</a></dt>
<dd><p>Each axis in the data object can get a specific scale value, described in axisUnits per pixel. Use this method to set the scale of one specific axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axisNum</strong> : {int}</p>
<blockquote>
<div><p>The addressed axis index</p>
</div></blockquote>
<p><strong>axisScale</strong> : {double}</p>
<blockquote>
<div><p>New axis scale in axisUnit/px</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError :</strong> :</p>
<blockquote class="last">
<div><p>if the given axisNum is invalid (out of range)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#itom.dataObject.axisScales" title="itom.dataObject.axisScales"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axisScales</span></code></a></dt>
<dd>this attribute can directly be used to read/write the axis scale(s) of single or all axes</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.setAxisUnit">
<code class="descname">setAxisUnit</code><span class="sig-paren">(</span><em>axisNum</em>, <em>axisUnit</em><span class="sig-paren">)</span> &#x2192; Set the unit of the specified axis.<a class="headerlink" href="#itom.dataObject.setAxisUnit" title="Permalink to this definition">¶</a></dt>
<dd><p>Each axis in the data object can get a specific unit string (e.g. mm). Use this method to set the unit of one specific axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>axisNum</strong> : {int}</p>
<blockquote>
<div><p>The addressed axis index</p>
</div></blockquote>
<p><strong>axisUnit</strong> : {str}</p>
<blockquote>
<div><p>New axis unit</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>RuntimeError :</strong> :</p>
<blockquote class="last">
<div><p>if the given axisNum is invalid (out of range)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#itom.dataObject.axisUnits" title="itom.dataObject.axisUnits"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axisUnits</span></code></a></dt>
<dd>this attribute can directly be used to read/write the axis unit(s) of single or all axes</dd>
</dl>
</div>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.setTag">
<code class="descname">setTag</code><span class="sig-paren">(</span><em>key</em>, <em>tagvalue</em><span class="sig-paren">)</span> &#x2192; Set the value of tag specified by key.<a class="headerlink" href="#itom.dataObject.setTag" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the value of an existing tag (defined by key) in the tag dictionary to the string or double tagvalue or adds a new item with key.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : {str}</p>
<blockquote>
<div><p>the name of the tag to set</p>
</div></blockquote>
<p><strong>tagvalue</strong> : {str or double}</p>
<blockquote class="last">
<div><p>the new value of the tag, either string or double value</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Do NOT use ‘special character’ within the tag key because they are not XML-save.</p>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.size">
<code class="descname">size</code><span class="sig-paren">(</span><span class="optional">[</span><em>index</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; returns the size of this dataObject (tuple of the sizes in all dimensions or size in dimension indicated by optional axis index).<a class="headerlink" href="#itom.dataObject.size" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>index</strong> : {int}, optional</p>
<blockquote>
<div><p>If index is given, only the size of the indicated dimension is returned as single number (0 &lt;= index &lt; number of dimensions)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>A tuple containing the sizes of all dimensions or one single size value if ‘index’ is indicated.</strong> :</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="shape.html#itom.shape" title="itom.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></dt>
<dd>the read-only attribute shape is equal to size()</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For a more consistent syntax with respect to numpy arrays, the same result is obtained by the attribute shape. Please use the attribute shape for future implementations since this method is marked as deprecated.</p>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.splitColor">
<code class="descname">splitColor</code><span class="sig-paren">(</span><em>color</em><span class="optional">[</span>, <em>destinationType='uint8'</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; returns a seperated color channel of a rgba32 color data object<a class="headerlink" href="#itom.dataObject.splitColor" title="Permalink to this definition">¶</a></dt>
<dd><p>The destination data object has the same size than this data object if only one color is extracted. The output will have one dimension more if there are more than one colors extracted.Each element of the new dimension corrspomnds to one color. DestinationType defines the type of the output object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>color</strong> : {str}</p>
<blockquote>
<div><p>Color string indicating the color(s) to be extracted (‘b’,’r’,’g’,’a’). It is possible to combine the colors for ex. ‘rgb’,</p>
</div></blockquote>
<p><strong>so that each color corresponds to one elemnt of the first dimension of the output dataObject</strong> :</p>
<p><strong>destinationType</strong> : {str}</p>
<blockquote>
<div><p>Type string indicating the new real type (‘int8’,…’float32’,’float64’ - no complex)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dataObj</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>containing the selected channel values</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.squeeze">
<code class="descname">squeeze</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; return a squeezed shallow copy (if possible) of this dataObject.<a class="headerlink" href="#itom.dataObject.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>This method removes every dimension with size equal to 1. A shallow copy is only returned, if the last two dimensions 
(called plane) are not affected by the squeeze operation and if the data block in the dataObject is not continuous. 
Else a deep-copy has to be returned due to a overall re-
aligment of the matrix. The returned object can never have less then two dimensions. If this is the case, the 
last or second to last dimensions with a size of 1 is not deleted. If squeeze() returns a shallow copy, a change in a 
value will change the same value in the original object, too.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>squeezed</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>The squeezed data object.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This method is similar to numpy.squeeze</p>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.toGray">
<code class="descname">toGray</code><span class="sig-paren">(</span><span class="optional">[</span><em>destinationType='uint8'</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; returns the rgba32 color data object as a gray-scale object<a class="headerlink" href="#itom.dataObject.toGray" title="Permalink to this definition">¶</a></dt>
<dd><p>The destination data object has the same size than this data object and the real type given by destinationType. The pixel-wise conversion is done using the formula: gray = 0.299 * red + 0.587 * green + 0.114 * blue.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>destinationType</strong> : {str}</p>
<blockquote>
<div><p>Type string indicating the new real type (‘uint8’,…’float32’,’float64’ - no complex)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>dataObj</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>converted gray-scale data object of desired type</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.toNumpyColor">
<code class="descname">toNumpyColor</code><span class="sig-paren">(</span><span class="optional">[</span><em>addAlphaChannel = 0</em><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; convert a 2D dataObject of type 'rgba32' to a 3D 'uint8' numpy.array whose last dimension is 3 (no alpha channel) or 4.<a class="headerlink" href="#itom.dataObject.toNumpyColor" title="Permalink to this definition">¶</a></dt>
<dd><p>Whereas the class ‘dataObject’ has a specific type ‘rgba32’ for colour values (which is internally a uint32 value with 4 times 8bit values for blue, green, red and alpha), 
numpy.arrays don’t have this. Therefore, several python packages like cv2 (OpenCV) or PIL store colour values in 3D numpy.arrays whereas the last dimension has a size of 3 
(without alpha value) or 4. This method returns the coloured version of a numpy.array from the rgba32 dataObject.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>addAlphaChannel</strong> : {int}</p>
<blockquote>
<div><p>If 0, the last dimension of the returned numpy.array has a size of 3 and contains the blue, green and red value, whereas 1 adds the alpha value as fourth value.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>arr</strong> : {numpy.array}</p>
<blockquote class="last">
<div><p>converted 2D numpy.array of type ‘uint8’ that can for instance be used in methods of packages like cv2 (OpenCV) or PIL.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.tolist">
<code class="descname">tolist</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; return the data object as a (possibly nested) list<a class="headerlink" href="#itom.dataObject.tolist" title="Permalink to this definition">¶</a></dt>
<dd><p>This method returns a nested list with all values of this data object. The recursion level of this nested list corresponds to the number of dimensions. The outer list corresponds to the first dimension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>y</strong> : {list}</p>
<blockquote class="last">
<div><p>Nested list with values of data object (int, float or complex depending on type of data object)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="itom.dataObject.trans">
<code class="descname">trans</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; return a plane-wise transposed dataObject<a class="headerlink" href="#itom.dataObject.trans" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new data object with the same data type than this object and where every plane (data spanned by the last two dimensions) is transposed respectively such that the last two axes are permuted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : {dataObject}</p>
<blockquote class="last">
<div><p>A copy of this dataObject is returned where every plane is its transposed plane.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="itom.dataObject.zeros">
<em class="property">static </em><code class="descname">zeros</code><span class="sig-paren">(</span><em>dims</em><span class="optional">[</span>, <em>dtype='uint8'</em><span class="optional">[</span>, <em>continuous = 0</em><span class="optional">]</span><span class="optional">]</span><span class="sig-paren">)</span> &#x2192; creates new dataObject filled with zeros.<a class="headerlink" href="#itom.dataObject.zeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Static method for creating a new n-dimensional itom.dataObject with given number of dimensions and dtype, filled with zeros.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>dims</strong> : {integer list}</p>
<blockquote>
<div><p>‘dims’ is list indicating the size of each dimension, e.g. [2,3] is a matrix with 2 rows and 3 columns</p>
</div></blockquote>
<p><strong>dtype</strong> : {str}, optional</p>
<blockquote>
<div><p>‘dtype’ is the data type of each element, possible values: ‘int8’, ‘uint8’, …, ‘int32’, ‘uint32’, ‘float32’, ‘float64’, ‘complex64’, ‘complex128’, ‘rgba32’</p>
</div></blockquote>
<p><strong>continuous</strong> : {int}, optional</p>
<blockquote>
<div><p>‘continuous’ [0|1] defines whether the data block should be continuously allocated in memory [1] or in different smaller blocks [0] (recommended for huge matrices).</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>I</strong> : {dataObject} of shape (size,size)</p>
<blockquote class="last">
<div><p>An array where all elements are equal to zero.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#itom.dataObject.eye" title="itom.dataObject.eye"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eye</span></code></a></dt>
<dd>method for creating an eye matrix</dd>
<dt><a class="reference internal" href="#itom.dataObject.ones" title="itom.dataObject.ones"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ones</span></code></a></dt>
<dd>method for creating a matrix filled with ones</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For color-types (rgba32) every item / cell will be black and transparent: [r=0 g=0 b=0 a=0].</p>
</dd></dl>

<dl class="attribute">
<dt id="itom.dataObject.axisDescriptions">
<code class="descname">axisDescriptions</code><a class="headerlink" href="#itom.dataObject.axisDescriptions" title="Permalink to this definition">¶</a></dt>
<dd><p>tuple containing the axis descriptions {str}.</p>
<p>This attribute gives access to the internal axis descriptions expressed as 
a tuple of strings. The tuple has the same length than the number of dimensions of this data object.</p>
<p>You can either assign a new tuple with the same length or change single values using tuple indexing.</p>
<p>The axis descriptions are considered if the data object is plotted.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">setAxisDescriptions</span></code></dt>
<dd>alternative method to change the description string of one single axis</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>read / write</p>
</dd></dl>

<dl class="attribute">
<dt id="itom.dataObject.axisOffsets">
<code class="descname">axisOffsets</code><a class="headerlink" href="#itom.dataObject.axisOffsets" title="Permalink to this definition">¶</a></dt>
<dd><p>tuple containing the axis offsets [px].</p>
<p>This attribute gives access to the internal axis offsets [px] expressed as 
a tuple of double values. The i-th value in the tuple corresponds to the pixel-offset of the i-th 
axis. Either assign a new tuple with the same length than the number of dimensions or change single values 
using tuple indexing.</p>
<p>Definition: Physical unit = (px-Coordinate - offset)* scale</p>
<p>If the data object is plot with offsets != 0, the scaled (physical) units are displayed in the plot.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataObject.setAxisOffset" title="itom.dataObject.setAxisOffset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setAxisOffset</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>read / write</p>
</dd></dl>

<dl class="attribute">
<dt id="itom.dataObject.axisScales">
<code class="descname">axisScales</code><a class="headerlink" href="#itom.dataObject.axisScales" title="Permalink to this definition">¶</a></dt>
<dd><p>tuple containing the axis scales [unit/px].</p>
<p>This attribute gives access to the internal axis scales [unit/px] expressed as 
a tuple of double values. The i-th value in the tuple corresponds to the scaling factor of the i-th 
axis. Either assign a new tuple with the same length than the number of dimensions or change single values 
using tuple indexing.</p>
<p>Definition: Physical unit = (px-Coordinate - offset)* scale</p>
<p>If the data object is plot with scalings != 1, the scaled (physical) units are displayed in the plot.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataObject.setAxisScale" title="itom.dataObject.setAxisScale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setAxisScale</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>read / write</p>
</dd></dl>

<dl class="attribute">
<dt id="itom.dataObject.axisUnits">
<code class="descname">axisUnits</code><a class="headerlink" href="#itom.dataObject.axisUnits" title="Permalink to this definition">¶</a></dt>
<dd><p>tuple containing the axis units {str}.</p>
<p>This attribute gives access to the internal axis units expressed as 
a tuple of strings. The tuple has the same length than the number of dimensions of this data object.</p>
<p>You can either assign a new tuple with the same length or change single values using tuple indexing.</p>
<p>The axis units are considered if the data object is plotted.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#itom.dataObject.setAxisUnit" title="itom.dataObject.setAxisUnit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">setAxisUnit</span></code></a></dt>
<dd>alternative method to change the unit string of one single axis</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>read / write</p>
</dd></dl>

<dl class="attribute">
<dt id="itom.dataObject.base">
<code class="descname">base</code><a class="headerlink" href="#itom.dataObject.base" title="Permalink to this definition">¶</a></dt>
<dd><p>base object</p>
</dd></dl>

<dl class="attribute">
<dt id="itom.dataObject.continuous">
<code class="descname">continuous</code><a class="headerlink" href="#itom.dataObject.continuous" title="Permalink to this definition">¶</a></dt>
<dd><p>true if matrix is continuously organized, else false.</p>
<p>If true, the whole matrix is allocated in one huge block in memory, hence, 
this data object can be transformed into a numpy representation 
without reallocating memory.</p>
<p class="rubric">Notes</p>
<p>read-only</p>
</dd></dl>

<dl class="attribute">
<dt id="itom.dataObject.dims">
<code class="descname">dims</code><a class="headerlink" href="#itom.dataObject.dims" title="Permalink to this definition">¶</a></dt>
<dd><p>number of dimensions of this data object</p>
<p class="rubric">Notes</p>
<p>read-only property, this property is readable both by the attributes ndim and dims.</p>
</dd></dl>

<dl class="attribute">
<dt id="itom.dataObject.dtype">
<code class="descname">dtype</code><a class="headerlink" href="#itom.dataObject.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>get type string of data in this data object</p>
<p>This type string has one of these values: ‘uint8’, ‘int8’, ‘uint16’, ‘int16’, ‘uint32’, ‘int32’, 
‘float32’, ‘float64’, ‘complex64’, ‘complex128’, ‘rgba32’</p>
<p class="rubric">Notes</p>
<p>This attribute is read-only</p>
</dd></dl>

<dl class="attribute">
<dt id="itom.dataObject.metaDict">
<code class="descname">metaDict</code><a class="headerlink" href="#itom.dataObject.metaDict" title="Permalink to this definition">¶</a></dt>
<dd><p>return dictionary with all meta information of this dataObject</p>
<p>Returns a new dictionary with the following meta information:</p>
<ul class="simple">
<li>axisOffsets : List with offsets of each axis</li>
<li>axisScales : List with the scales of each axis</li>
<li>axisUnits : List with the unit strings of each axis</li>
<li>axisDescriptions : List with the description strings of each axis</li>
<li>tags : Dictionary with all tags including the tag ‘protocol’ if at least one protocol entry has been added using addToProtocol</li>
<li>valueOffset : Offset of each value (0.0)</li>
<li>valueScale : Scale of each value (1.0)</li>
<li>valueDescription : Description of the values</li>
<li>valueUnit : The unit string of the values</li>
</ul>
<p class="rubric">Notes</p>
<p>Adding or changing values to / in the dictionary does not change the meta information of the dataObject. Use the corresponding setters like setTag… instead.</p>
</dd></dl>

<dl class="attribute">
<dt id="itom.dataObject.ndim">
<code class="descname">ndim</code><a class="headerlink" href="#itom.dataObject.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>number of dimensions of this data object</p>
<p class="rubric">Notes</p>
<p>read-only property, this property is readable both by the attributes ndim and dims.</p>
</dd></dl>

<dl class="attribute">
<dt id="itom.dataObject.shape">
<code class="descname">shape</code><a class="headerlink" href="#itom.dataObject.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>tuple with the sizes of each dimension / axis of this data object.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#itom.dataObject.size" title="itom.dataObject.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></a></p>
</div>
<p class="rubric">Notes</p>
<p>In difference to the shape attribute of numpy arrays, no new shape tuple can be assigned to this value (used to ‘reshape’ the array). Read-only.</p>
</dd></dl>

<dl class="attribute">
<dt id="itom.dataObject.tags">
<code class="descname">tags</code><a class="headerlink" href="#itom.dataObject.tags" title="Permalink to this definition">¶</a></dt>
<dd><p>tag dictionary of this data object.</p>
<p>This attribute returns a dict_proxy object of the tag dictionary of this data object. This object is read-only. 
However you can assign an entire new dictionary to this attribute that fully replaces the old tag dictionary. 
The tag dictionary can contain arbitrary pairs of key -&gt; value where value is either a string or a double value.</p>
<p>Special tags are the key ‘protocol’ that contains the newline-separated protocol string of the data object (see: addToProtocol()) 
or the key ‘title’ that can for instance be used as title in any plots.</p>
<p>You can add single elements using the method setTag(key,value) or you can delete tags using deleteTag(key).</p>
<p>Do NOT use ‘special character’ within the tag key because they are not XML-save.</p>
<p class="rubric">Notes</p>
<p>read-only / write only for fully new dictionary</p>
</dd></dl>

<dl class="attribute">
<dt id="itom.dataObject.value">
<code class="descname">value</code><a class="headerlink" href="#itom.dataObject.value" title="Permalink to this definition">¶</a></dt>
<dd><p>get/set the values within the ROI as a one-dimensional tuple.</p>
<p>This method gets or sets the values within the ROI. If this attribute is called by means of a getter, 
a tuple is returned which is created by iterating through the values of the data object (row-wise). 
In the same way of iterating, the values are set to the data object if you provide a tuple of the size of the data object 
or its ROI, respectively.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
<span class="c1"># or for the first value </span>
<span class="n">b</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1"># The elements of the tuple are adressed with b[idx].</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="itom.dataObject.valueDescription">
<code class="descname">valueDescription</code><a class="headerlink" href="#itom.dataObject.valueDescription" title="Permalink to this definition">¶</a></dt>
<dd><p>value unit description.</p>
<p>Attribute to read or write the unit description string of the values in this data object.</p>
<p>The value description is considered if the data object is plotted.</p>
<p class="rubric">Notes</p>
<p>read / write</p>
</dd></dl>

<dl class="attribute">
<dt id="itom.dataObject.valueOffset">
<code class="descname">valueOffset</code><a class="headerlink" href="#itom.dataObject.valueOffset" title="Permalink to this definition">¶</a></dt>
<dd><p>value offset.</p>
<p>This attribute gives the offset of each value in the data object. This value is always 0.0.</p>
<p class="rubric">Notes</p>
<p>This attribute is read only</p>
</dd></dl>

<dl class="attribute">
<dt id="itom.dataObject.valueScale">
<code class="descname">valueScale</code><a class="headerlink" href="#itom.dataObject.valueScale" title="Permalink to this definition">¶</a></dt>
<dd><p>value scale.</p>
<p>This attribute gives the scaling factor of each value in the data object. This value is always 1.0.</p>
<p class="rubric">Notes</p>
<p>This attribute is read only</p>
</dd></dl>

<dl class="attribute">
<dt id="itom.dataObject.valueUnit">
<code class="descname">valueUnit</code><a class="headerlink" href="#itom.dataObject.valueUnit" title="Permalink to this definition">¶</a></dt>
<dd><p>value unit.</p>
<p>Attribute to read or write the unit string of the values in this data object.</p>
<p>The value unit is considered if the data object is plotted.</p>
<p class="rubric">Notes</p>
<p>read / write</p>
</dd></dl>

<dl class="attribute">
<dt id="itom.dataObject.xyRotationalMatrix">
<code class="descname">xyRotationalMatrix</code><a class="headerlink" href="#itom.dataObject.xyRotationalMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Access the 3x3 rotational matrix in the dataObject tagspace</p>
<p>This attribute gives access to the xyRotationalMatrix in the metaData-Tagspace.
The getter method retuns a 3x3-Array deep copied from the internal matrix,
Implemented to offer compability to x3p format.</p>
<p class="rubric">Notes</p>
<p>{3x3 array of doubles} : ReadWrite</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="figure.html" class="btn btn-neutral float-right" title="10.7. figure" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="dataIO.html" class="btn btn-neutral" title="10.5. dataIO" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2011-2016, Institut fuer Technische Optik (ITO), University Stuttgart. Bug report: https://bitbucket.org/itom/itom/issues.
      Last updated on Mar 05, 2018.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'35c0898d',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>