

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>6.3. Creating advanced dialogs and windows &mdash; itom Documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.4. Custom Designer Widgets" href="list_custom_widgets.html" />
    <link rel="prev" title="6.2. Show messages, input boxes and default dialogs" href="method-itom.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> itom Documentation
          

          
          </a>

          
            
            
              <div class="version">
                4.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../00_releaseNotes/whats-new.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../01_introduction/introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_installation/install.html">2. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_gettingStarted/getting-started.html">3. Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_itom_gui/gui.html">4. The itom User Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_plots/plots.html">5. Plots and Figures</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="extended_gui.html">6. Extending the user interface of <strong>itom</strong></a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="toolbar.html">6.1. Customize the menu and toolbars of <strong>itom</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="method-itom.html">6.2. Show messages, input boxes and default dialogs</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">6.3. Creating advanced dialogs and windows</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#qt-designer">6.3.1. Qt Designer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#widget-library">6.3.1.1. Widget Library</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#loading-user-interface-in-itom">6.3.2. Loading user interface in <strong>itom</strong></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#widget-embedded-in-itom-dialog-typedialog">6.3.2.1. Widget embedded in <strong>itom</strong>-dialog (TYPEDIALOG)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#main-window-or-dialog-typewindow">6.3.2.2. Main window or dialog (TYPEWINDOW)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#main-window-or-widget-as-dockable-toolbox-typedockwidget">6.3.2.3. Main window or widget as dockable toolbox (TYPEDOCKWIDGET)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#main-window-or-widget-as-part-of-the-central-widget-area-of-itom-typecentralwidget">6.3.2.4. Main window or widget as part of the central widget area of itom (TYPECENTRALWIDGET)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#accessing-control-elements">6.3.3. Accessing control elements</a></li>
<li class="toctree-l3"><a class="reference internal" href="#getting-and-setting-properties">6.3.4. Getting and setting properties</a></li>
<li class="toctree-l3"><a class="reference internal" href="#supported-datatypes">6.3.5. Supported datatypes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#connecting-signals">6.3.6. Connecting signals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#calling-slots">6.3.7. Calling slots</a></li>
<li class="toctree-l3"><a class="reference internal" href="#connecting-internal-signals-and-slots-in-qt-designer">6.3.8. Connecting internal signals and slots in <strong>Qt Designer</strong></a></li>
<li class="toctree-l3"><a class="reference internal" href="#auto-connecting-signals-using-python-decorators">6.3.9. Auto-connecting signals using python decorators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#debugging-user-interfaces-and-slot-methods">6.3.10. Debugging user interfaces and slot-methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#access-the-status-bar-of-a-main-window">6.3.11. Access the status bar of a main window</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hints-and-limitations">6.3.12. Hints and limitations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="list_custom_widgets.html">6.4. Custom Designer Widgets</a></li>
<li class="toctree-l2"><a class="reference internal" href="algo-plugin.html">6.5. Implement a  more complex GUI in a plugin (C/C++)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../07_plugins/plugins.html">7. Plugins</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_scriptLanguage/script-language.html">8. Python scripting language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_reference/reference.html">9. itom Script Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_miscellaneous/miscellaneous.html">10. Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_test-scripts/test-scripts.html">11. Demo scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_tutorials/tutorials.html">12. Python tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_contributing/contributing.html">13. Contributing</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">itom Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="extended_gui.html"><span class="section-number">6. </span>Extending the user interface of <strong>itom</strong></a> &raquo;</li>
        
      <li><span class="section-number">6.3. </span>Creating advanced dialogs and windows</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/06_extended_gui/qtdesigner.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="creating-advanced-dialogs-and-windows">
<span id="qtdesigner"></span><h1><span class="section-number">6.3. </span>Creating advanced dialogs and windows<a class="headerlink" href="#creating-advanced-dialogs-and-windows" title="Permalink to this headline">¶</a></h1>
<p>With <strong>itom</strong> it is not only possible to add menus and toolbar elements to the main GUI of <strong>itom</strong> or to use the default set of input and message boxes, but
it is also possible to create own user interfaces. These interfaces are designed by help of a WYSIWYG (“what you see is what you get”) design tool (Qt Designer).
The logic behind the surfaces is then scripted using <strong>Python</strong>. Therefore it is possible to change the appearance of control elements at runtime or to connect
a signal, emitted when for instance clicking on a button, with a user-defined python method.</p>
<p>In this chapter, the creation of such user interfaces is explained.</p>
<div class="section" id="qt-designer">
<h2><span class="section-number">6.3.1. </span>Qt Designer<a class="headerlink" href="#qt-designer" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">The Qt Designer can be used to create a GUI for interaction with the <strong>itom</strong> software.</div>
<div class="line">For details see the Qt Designer documentation under <a class="reference external" href="http://doc.qt.io/qt-5/qtdesigner-manual.html">http://doc.qt.io/qt-5/qtdesigner-manual.html</a></div>
</div>
<p>In order to start the <strong>Qt Designer</strong>, click on the corresponding icon in the toolbar of <strong>itom</strong>:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/mainsymbols2.png"><img alt="../_images/mainsymbols2.png" src="../_images/mainsymbols2.png" style="width: 206.0px; height: 82.0px;" /></a>
</div>
<p>or double-click on a corresponding <strong>ui</strong>-file in the file system widget of <strong>itom</strong>. In the first case, <strong>Qt Designer</strong> shows an initialization dialog, where you
can choose the base type of the user interface you want to create.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/designerNew.png"><img alt="../_images/designerNew.png" src="../_images/designerNew.png" style="width: 523.0px; height: 474.0px;" /></a>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is a known issue in the setup 1.4.0 (or earlier) concerning an unsuccessful startup of the external Qt designer. If you want to open
the designer using the button in the toolbox of the itom main window, the startup may fail. This bug is known and will be fixed
in future releases. Until then, please open the designer either by starting the <strong>designer.exe</strong> in the application folder of itom
or open an existing ui-file (e.g. in the demo folder of itom). This issue only affects setup versions (32bit and 64bit) for Windows.</p>
</div>
<p>In principle you have the possibility to choose between three different base layouts:</p>
<p>1. <strong>Dialog</strong>. A Dialog is usually displayed on top of the main window and only has got one close-button in its title bar. Often, dialogs are used for configuration dialogs where the
user finally closes the dialog using one of the standard buttons (OK, Cancel, Apply…) in order to confirm or reject the current changes in the dialog. A dialog cannot have its
own toolbar, menu or status bar.
2. <strong>Main Window</strong>. A main window is a fully equipped main window, which can be minimized, maximized, can have toolbars, menus and a status bar. Therefore it is recommended to use this
type of user interface for the main window of your measurement system. Like a dialog, it is possible to show the main window on top of <strong>itom</strong> (as sub-window of <strong>itom</strong>) or as independent
window, which has its own icon in the windows tray.
3. <strong>Widget</strong>. A widget is the base class for all control elements provided by <strong>Qt</strong>. Therefore a widget does not have any title bar or windows frame. Nevertheless you can choose a widget
for your user interface, since <strong>itom</strong> provides the possibility to stack this widget into a default dialog which can optionally show some default buttons on the right side or at the
bottom of the dialog. This is the easiest way the generate a configuration dialog in <strong>itom</strong>, since you do not need to script the necessary methods handling clicks on one of these buttons.
In this case, <strong>itom</strong> automatically gets full information about the close status and type of closing of the dialog (accepted, rejected…).</p>
<p>After having chosen one of these base layouts (types), your surface is displayed in the middle of the <strong>Qt Designer</strong> and you can start to drag elements from the widget library
on your surface. If the <strong>Qt Designer</strong> is started from <strong>itom</strong> you will even find a section <strong>ITOM Plugins</strong> in the library list, which contains all loadable designer plugins that are
provided by <strong>itom</strong> and can also be placed on your surface. The choice of these plugins depend on the designer plugins that are currently available in your installation of <strong>itom</strong>.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/qtdesigner1.png"><img alt="../_images/qtdesigner1.png" src="../_images/qtdesigner1.png" style="width: 859.0px; height: 555.0px;" /></a>
</div>
<p>After having placed one widget on the canvas, you will see its properties in the property toolbox of <strong>Qt Designer</strong>. Every widget has the common property <strong>objectName</strong>. If you assign
a unique object name to any of your control elements, it is possible to access and manipulate this widget from a <strong>Python</strong> script in <strong>itom</strong> using this name, too. In general many of the
properties that are visible in the property toolbox can afterwards be read or changed by an appropriate script (depending on the data type of the property).</p>
<p>The alignment of control elements on the surface is mainly controlled by so-called layout elements. These layouts together with size policies that can be assigned to every widget
control the appearance of the entire user interface and provide the feature that the dialog can be changed in size whereas all widgets are dynamically repositioned. For more information
about layouting your user interface, see <a class="reference external" href="http://qt-project.org/doc/qt-5/designer-layouts.html">http://qt-project.org/doc/qt-5/designer-layouts.html</a>.</p>
<p>Finally, save your user interface under a convenient filename with the suffix <strong>.ui</strong>.</p>
<div class="section" id="widget-library">
<h3><span class="section-number">6.3.1.1. </span>Widget Library<a class="headerlink" href="#widget-library" title="Permalink to this headline">¶</a></h3>
<p>In principle, you are allowed to place every widget on your user interface that is available in the widget library (widget box) of <strong>Qt Designer</strong>. Later, you will learn how you can
access properties of any widget (read and/or write) and how you can call specific functions provided by any widget. However, you will also learn that you do not have access using <strong>Python</strong>
to all functions a widget has and you are not able to sub-class any widget, like you can it using a native <strong>C++</strong> program. Therefore, it is not recommended to place any widget from the
group <strong>Item Views (Model-based)</strong> on your user interface since only few functions of these widgets are accessible by a <strong>Python</strong> script. If you need a list box, use the item-based list
widget. <strong>itom</strong> also provides some widgets (section <strong>ITOM widgets</strong>) that can be placed on your user interfaces, for instance some plot widgets or the widget for plotting the result of
the python module matplotlib (see <a class="reference internal" href="../08_scriptLanguage/pymod-matplotlib.html#pymod-matplotlib"><span class="std std-ref">Python-Module matplotlib</span></a>).</p>
</div>
</div>
<div class="section" id="loading-user-interface-in-itom">
<h2><span class="section-number">6.3.2. </span>Loading user interface in <strong>itom</strong><a class="headerlink" href="#loading-user-interface-in-itom" title="Permalink to this headline">¶</a></h2>
<p>In this section, an introduction is given how to create and load user interfaces in <strong>itom</strong> depending on different type-attributes.</p>
<div class="section" id="widget-embedded-in-itom-dialog-typedialog">
<h3><span class="section-number">6.3.2.1. </span>Widget embedded in <strong>itom</strong>-dialog (TYPEDIALOG)<a class="headerlink" href="#widget-embedded-in-itom-dialog-typedialog" title="Permalink to this headline">¶</a></h3>
<p>Like described above, the easiest and most comfortable way to load user interfaces in <strong>itom</strong> is to use the type <strong>TYPEDIALOG</strong>. In <strong>Qt Creator</strong> you design a widget with your
individual content and then when loading this GUI in <strong>itom</strong>, the widget is embedded in a dialog provided by <strong>itom</strong>, which optionally adds a horizontal or vertical button bar
at the right side or at the bottom of the dialog.</p>
<p>Let us create an exemplary user interface. In <strong>Qt Creator</strong> the following widget has been created:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/testWidget.png"><img alt="../_images/testWidget.png" src="../_images/testWidget.png" style="width: 603.0px; height: 212.0px;" /></a>
</div>
<p>On the right side of the widget <em>testWidget</em> you see the hierarchical organization of objects that are put on the widget. At first, a group box has been placed on the widget. Inside of
this group box two radio buttons have been placed using a simple drag&amp;drop from the widget library. Both radio buttons are aligned inside of the group box with a vertical layout. This
is reached by a right-click on the group box and choosing <em>vertical layout</em> from the <em>layout</em> menu. Below the group box, a widget of type <em>lineedit</em> and a push button (type <em>pushbutton</em>)
have been placed. Finally the three main elements are also aligned in a vertical layout with respect to the overall widget. This can be achieved by a right click on an empty space of
the widget or directly in the <em>object inspector</em>. If you increase now the size of the overall widget, you will see that all sub-elements are resized according to their layout. Since
we don’t want sub-widgets to be vertically stretched and distributed, a vertical spacer element has been placed at the bottom of the vertical layout stack.</p>
<p>The following properties have been directly set in <strong>Qt Creator</strong>:</p>
<ul class="simple">
<li><p>group box: <em>objectName</em>: groupOption, <em>title</em>: ‘Please make your choice’</p></li>
<li><p>push button: <em>objectName</em>: btnClickMe, <em>text</em>: ‘click me’</p></li>
<li><p>line edit: <em>objectName</em>: txtInput, <em>text</em>: ‘put here your text…’</p></li>
<li><p>radio buttons: <em>objectName</em>: radioOpt1 and radioOpt2, <em>text</em>: ‘Option 1’ and ‘Option 2’</p></li>
</ul>
<p>The entire widget is saved under the filename <em>testWidget.ui</em> in an arbitrary directory.</p>
<p>Then you can load and show the widget in <strong>itom</strong> by creating a python-script in the same directory with the following content. You can also directly type these lines into the command line of <strong>itom</strong>, however, you should then assure that the current directory is equal to the directory where the user interface has been stored.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dialog</span> <span class="o">=</span> <span class="n">ui</span><span class="p">(</span><span class="s2">&quot;testWidget.ui&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">.</span><span class="n">TYPEDIALOG</span><span class="p">)</span> <span class="c1">#loading dialog</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">dialog</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#modally show, wait until the dialog has been closed</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The dialog has been closed with code&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>At first, an instance of class <a class="reference internal" href="../09_reference/itom_GUI.html#itom.ui" title="itom.ui"><code class="xref py py-class docutils literal notranslate"><span class="pre">itom.ui</span></code></a> is created that is given the name of the user interface file. This instance can then be accessed by the name <em>dialog</em>.
By calling the method <a class="reference internal" href="../09_reference/itom_GUI.html#itom.ui.show" title="itom.ui.show"><code class="xref py py-meth docutils literal notranslate"><span class="pre">show()</span></code></a>, the dialog is shown. Since the parameter has been set to <strong>1</strong>, the dialog is shown in a modal style, such that python waits
until the dialog has been closed again and <strong>itom</strong> is entirely blocked during that time. However, then it is possible to get informed about the way the dialog is closed, such
that the variable <em>result</em> will be set to <em>0</em> if the user closed the dialog using a cancel button (not available here) or the close button in the title bar or <em>1</em> if the user
clicked an <strong>OK</strong>-button.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/testWidgetItom.png"><img alt="../_images/testWidgetItom.png" src="../_images/testWidgetItom.png" style="width: 448.0px; height: 319.0px;" /></a>
</div>
<p>It is also possible to open the dialog in a non-modal version or to open it in a modal style however to immediately force python to continue the script execution. This depends
on the parameters of <a class="reference internal" href="../09_reference/itom_GUI.html#itom.ui.show" title="itom.ui.show"><code class="xref py py-meth docutils literal notranslate"><span class="pre">show()</span></code></a>. However only in the modal case above, the closing result can be tracked by <strong>Python</strong>. Additionally, this is also only possible if
a widget is embedded in a dialog, given by <strong>itom</strong>, like it is always the case if you create an instance of <a class="reference internal" href="../09_reference/itom_GUI.html#itom.ui" title="itom.ui"><code class="xref py py-class docutils literal notranslate"><span class="pre">itom.ui</span></code></a> with the second parameter set to <strong>ui.TYPEDIALOG</strong>.</p>
<p>Right now, you don’t have the possibility to quit the dialog using any button (<strong>OK</strong>, <strong>Cancel</strong>…). In order to obtain a button bar with these buttons, the call to the class
<a class="reference internal" href="../09_reference/itom_GUI.html#itom.ui" title="itom.ui"><code class="xref py py-class docutils literal notranslate"><span class="pre">itom.ui</span></code></a> needs to be changed. There is the choice between two different appearances of a button bar, which can be automatically added to your widget:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/testWidgetButtonBar.png"><img alt="../_images/testWidgetButtonBar.png" src="../_images/testWidgetButtonBar.png" style="width: 679.0px; height: 318.0px;" /></a>
</div>
<p>Next, you need to select which buttons should be included in the button bar. This is done by creating a python dictionary, where each elements corresponds to one button. The
key-word of the item corresponds to the role of the button (see enumeration <em>QDialogButtonBox::ButtonRole*</em> of the <strong>Qt</strong>-library documentation) and the value is the text of the
button. Common roles are:</p>
<ul class="simple">
<li><p>“AcceptRole”: Use this role for an <strong>OK</strong>-button. The dialog is closed and the return value in modal style is 1.</p></li>
<li><p>“RejectRole”: Use this role for a <strong>Cancel</strong>-button. The dialog is also closed but the return value is 0.</p></li>
</ul>
<p>Finally, the call to <a class="reference internal" href="../09_reference/itom_GUI.html#itom.ui" title="itom.ui"><code class="xref py py-class docutils literal notranslate"><span class="pre">itom.ui</span></code></a> must be in the following way, in order to get an auto-generated button bar:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dialog</span> <span class="o">=</span> <span class="n">ui</span><span class="p">(</span><span class="s2">&quot;testWidget.ui&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">.</span><span class="n">TYPEDIALOG</span><span class="p">,</span> <span class="n">ui</span><span class="o">.</span><span class="n">BUTTONBAR_VERTICAL</span><span class="p">,</span> \
    <span class="p">{</span><span class="s2">&quot;AcceptRole&quot;</span><span class="p">:</span><span class="s2">&quot;OK&quot;</span><span class="p">,</span> <span class="s2">&quot;RejectRole&quot;</span><span class="p">:</span><span class="s2">&quot;Cancel&quot;</span><span class="p">})</span>
<span class="c1">#or</span>
<span class="n">dialog</span> <span class="o">=</span> <span class="n">ui</span><span class="p">(</span><span class="s2">&quot;testWidget.ui&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">.</span><span class="n">TYPEDIALOG</span><span class="p">,</span> <span class="n">ui</span><span class="o">.</span><span class="n">BUTTONBAR_HORIZONTAL</span><span class="p">,</span> \
    <span class="p">{</span><span class="s2">&quot;AcceptRole&quot;</span><span class="p">:</span><span class="s2">&quot;Yes&quot;</span><span class="p">,</span> <span class="s2">&quot;RejectRole&quot;</span><span class="p">:</span><span class="s2">&quot;No&quot;</span><span class="p">})</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can also use a keyword-based call to <strong>ui</strong> since every parameter has its default value such that you can omit parameters beside the first one.
For more details about all parameters, keywords and its default values see <a class="reference internal" href="../09_reference/itom_GUI.html#itom.ui" title="itom.ui"><code class="xref py py-class docutils literal notranslate"><span class="pre">itom.ui</span></code></a>.</p>
</div>
<p>The dialog is closed and deleted if the variable <strong>dialog</strong> is deleted using the command <strong>del</strong>.</p>
</div>
<div class="section" id="main-window-or-dialog-typewindow">
<h3><span class="section-number">6.3.2.2. </span>Main window or dialog (TYPEWINDOW)<a class="headerlink" href="#main-window-or-dialog-typewindow" title="Permalink to this headline">¶</a></h3>
<p>If you are not interested in the exact return value of the dialog but you want to have full control and all available functionalities of any dialog or main window,
create an user interface based on a <strong>dialog</strong> or <strong>main window</strong> in <strong>Qt Designer</strong>.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/testWindow.png"><img alt="../_images/testWindow.png" src="../_images/testWindow.png" style="width: 763.0px; height: 359.0px;" /></a>
</div>
<p>The figure shows an exemplary user interface (<strong>testWindow.ui</strong>) that is based on a main window. On the right side, there have been added three buttons, nested in a vertical layout.
On the left side, there is a list widget (objectName: <strong>listWidget</strong>, type: <strong>List Widget</strong>). Additionally a menu has been added that consists of three items.</p>
<p>This main window can now be shown using the following code snippet:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">win</span> <span class="o">=</span> <span class="n">ui</span><span class="p">(</span><span class="s2">&quot;testWindow.ui&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">.</span><span class="n">TYPEWINDOW</span><span class="p">)</span>
<span class="n">win</span><span class="o">.</span><span class="n">show</span><span class="p">()</span> <span class="c1">#this is equal to win.show(0) -&gt; non-modal</span>
</pre></div>
</div>
<p>Then, the window is shown on top of the main window of <strong>itom</strong>, since it is considered to be a child of <strong>itom</strong>. If you don’t want this, you can also add the keyword-parameter
<em>childOfMainWindow=False</em> to the call of <a class="reference internal" href="../09_reference/itom_GUI.html#itom.ui" title="itom.ui"><code class="xref py py-class docutils literal notranslate"><span class="pre">itom.ui</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">win</span> <span class="o">=</span> <span class="n">ui</span><span class="p">(</span><span class="s2">&quot;testWindow.ui&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">.</span><span class="n">TYPEWINDOW</span><span class="p">,</span> <span class="n">childOfMainWindow</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, you need to use the keyword, since the parameters <em>dialogButtonBar</em> and <em>dialogButtons</em> (used for TYPEDIALOG) are not given in this case, since they are useless in case of
<em>TYPEWINDOW</em>. If your window is no child of <strong>itom</strong>, it gets its own icon in the Windows tray bar and does not stay on top of <strong>itom</strong>.</p>
</div>
<div class="section" id="main-window-or-widget-as-dockable-toolbox-typedockwidget">
<h3><span class="section-number">6.3.2.3. </span>Main window or widget as dockable toolbox (TYPEDOCKWIDGET)<a class="headerlink" href="#main-window-or-widget-as-dockable-toolbox-typedockwidget" title="Permalink to this headline">¶</a></h3>
<p>It is also possible to integrate user-defined main windows or widgets as dockable toolbox in the main window of <strong>itom</strong>. This is done using the type value <strong>ui.TYPEDOCKWIDGET</strong>. Then the
widget is registered as dockwidget in the main window of <strong>itom</strong> and once it becomes visible, its startup position is at the top-center position. You can define the initial dock area using
the optional argument <em>dockWidgetArea</em> of the class <a class="reference internal" href="../09_reference/itom_GUI.html#itom.ui" title="itom.ui"><code class="xref py py-class docutils literal notranslate"><span class="pre">itom.ui</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">win</span> <span class="o">=</span> <span class="n">ui</span><span class="p">(</span><span class="s2">&quot;testWindow.ui&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">.</span><span class="n">TYPEDOCKWIDGET</span><span class="p">,</span> <span class="n">dockWidgetArea</span> <span class="o">=</span> <span class="n">ui</span><span class="o">.</span><span class="n">RIGHTDOCKWIDGETAREA</span><span class="p">)</span>
</pre></div>
</div>
<p>Possible values for <em>dockWidgetArea</em> are:</p>
<blockquote>
<div><ul class="simple">
<li><p>ui.LEFTDOCKWIDGETAREA = 1</p></li>
<li><p>ui.RIGHTDOCKWIDGETAREA = 2</p></li>
<li><p>ui.TOPDOCKWIDGETAREA = 4</p></li>
<li><p>ui.BOTTOMDOCKWIDGETAREA = 8</p></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="main-window-or-widget-as-part-of-the-central-widget-area-of-itom-typecentralwidget">
<h3><span class="section-number">6.3.2.4. </span>Main window or widget as part of the central widget area of itom (TYPECENTRALWIDGET)<a class="headerlink" href="#main-window-or-widget-as-part-of-the-central-widget-area-of-itom-typecentralwidget" title="Permalink to this headline">¶</a></h3>
<p>It is also possible to integrate user-defined main windows or widgets as part of the central widget area of the main window of <strong>itom</strong>. This is done using the type value <strong>ui.TYPECENTRALWIDGET</strong>.
The central widget area can contain several widgets which are vertically stacked and whose size can be vertically changed by a splitter layout.
Per default, this central area only contains the command line. Every new widget that is added to this area is prepended to the top.</p>
<p>The current size of all widgets in the central area (including the command) line, can be changed via <code class="xref py py-obj docutils literal notranslate"><span class="pre">itom.setCentralWidgetsSizes</span></code>. This method
expects a list of integers as argument which correspond to the desired height of every widget in pixels (0: the widget is collapsed and can be
made visible again with the mouse). If the sum of all sizes does not correspond to the current height of the central area, the sizes are distributed
based on their relative weights.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">itom</span>
<span class="n">win</span> <span class="o">=</span> <span class="n">itom</span><span class="o">.</span><span class="n">ui</span><span class="p">(</span><span class="s2">&quot;testWindow.ui&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">.</span><span class="n">TYPECENTRALWIDGET</span><span class="p">)</span>
<span class="n">itom</span><span class="o">.</span><span class="n">setCentralWidgetsSizes</span><span class="p">([</span><span class="mi">400</span><span class="p">,</span><span class="mi">300</span><span class="p">])</span> <span class="c1">#desired height of 400px for the new widget &#39;win&#39; and 300px for the command line of itom.</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="accessing-control-elements">
<h2><span class="section-number">6.3.3. </span>Accessing control elements<a class="headerlink" href="#accessing-control-elements" title="Permalink to this headline">¶</a></h2>
<p>Until now, you know how to design an interface and how to show it using <strong>itom</strong>. This and the following sections explain how you dynamically interact with the user interface and
its elements. One elementary tool for this is to access any desired element of the GUI. For instance, if you want to change properties of a button or the text of a lineedit-widget,
you first need to access these elements.</p>
<p>The accessing is simply done by the unique and specific <strong>objectName</strong> of each element and the dot-operator (<strong>.</strong>). Let’s take the first example <strong>testWidget.ui</strong> again. The
dialog has been assigned the variable <strong>dialog</strong>. Then have the following possibilities to access its elements:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">elemGroup</span> <span class="o">=</span> <span class="n">dialog</span><span class="o">.</span><span class="n">groupOption</span> <span class="c1"># access the group box by its objectName</span>

<span class="n">elemRadioOpt1</span> <span class="o">=</span> <span class="n">dialog</span><span class="o">.</span><span class="n">radioOpt1</span> <span class="c1"># OR</span>
<span class="n">elemRadioOpt1</span> <span class="o">=</span> <span class="n">elemGroup</span><span class="o">.</span><span class="n">radioOpt1</span>

<span class="n">textfield</span> <span class="o">=</span> <span class="n">dialog</span><span class="o">.</span><span class="n">txtInput</span>
</pre></div>
</div>
<p>Each variable created by the code block above is an instance of <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">itom.uiItem</span></code></a>. It is this class that defines the dot-operator. Looking at the example of accessing the first radio
button, which is a child of the group-box, it is both possible to access the group button by its objectName as child of the entire dialog or as child of the groupbox. This is feasible
since the class <a class="reference internal" href="../09_reference/itom_GUI.html#itom.ui" title="itom.ui"><code class="xref py py-class docutils literal notranslate"><span class="pre">ui</span></code></a> is derived from <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">uiItem</span></code></a>, such that the dot-operator not only works for entire dialog references but also for accessing sub-elements
of other widgets. However, since each objectName is unique among all elements of the entire dialog, is doesn’t matter how to access any element.</p>
<p>An alternative access to child widgets is provided by the method <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem.getChild" title="itom.uiItem.getChild"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getChild()</span></code></a> which has the desired objectName as argument:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">elemGroup</span> <span class="o">=</span> <span class="n">dialog</span><span class="o">.</span><span class="n">getChild</span><span class="p">(</span><span class="s2">&quot;groupOption&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This method can for instance be used if the widgetName is created from a formatted string.</p>
<p>But why do we need to access these elements? Why do they returns its own instance of class <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">uiItem</span></code></a>. These questions are answered in the following sections…</p>
</div>
<div class="section" id="getting-and-setting-properties">
<span id="qtdesigner-getsetprops"></span><h2><span class="section-number">6.3.4. </span>Getting and setting properties<a class="headerlink" href="#getting-and-setting-properties" title="Permalink to this headline">¶</a></h2>
<p>As already mentioned, you can read or write most properties of any element that are also listed in the property toolbox of <strong>Qt Designer</strong>. Properties are also separately listed in the
corresponding <strong>Qt</strong> documentation. In general it makes sense to set properties - when offline possible - in the <strong>Qt Designer</strong>. This is a little bit more efficient and keeps your
script tiny. Getting and setting properties is possible if you have an object of type <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">uiItem</span></code></a>. Therefore you need to get this object like described in the section above.</p>
<p>Getting the property value can either be done by using the mapping-operator <strong>[]</strong> or by using the method <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem.getProperty" title="itom.uiItem.getProperty"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getProperty()</span></code></a>. For instance, if you want to get the current text
and the enabled status of the textfield in dialog <em>testWidget.ui</em> from the first example, you can use one of the following possibilities:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#1. possibility</span>
<span class="n">text</span> <span class="o">=</span> <span class="n">dialog</span><span class="o">.</span><span class="n">txtInput</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">]</span>
<span class="n">enabled</span> <span class="o">=</span> <span class="n">dialog</span><span class="o">.</span><span class="n">txtInput</span><span class="p">[</span><span class="s2">&quot;enabled&quot;</span><span class="p">]</span>

<span class="c1">#2. possibility</span>
<span class="p">[</span><span class="n">text</span><span class="p">,</span><span class="n">enabled</span><span class="p">]</span> <span class="o">=</span> <span class="n">dialog</span><span class="o">.</span><span class="n">txtInput</span><span class="o">.</span><span class="n">getProperty</span><span class="p">([</span><span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="s2">&quot;enabled&quot;</span><span class="p">])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For accessing single properties, it is shorter and easier to use the mapping-operator <strong>[]</strong>. However, due to the interal thread-structure of <strong>itom</strong>, it is a little bit faster to
access multiple properties of the same widget using the method <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem.getProperty" title="itom.uiItem.getProperty"><code class="xref py py-meth docutils literal notranslate"><span class="pre">getProperty()</span></code></a>.</p>
</div>
<p>In order to set one or multiple properties, you can use similar methods. Simply assign a value to the mapping-operator <strong>[]</strong> or use the method <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem.setProperty" title="itom.uiItem.setProperty"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setProperty()</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#1. possibility</span>
<span class="n">dialog</span><span class="o">.</span><span class="n">txtInput</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;new text for this textfield&quot;</span>
<span class="n">dialog</span><span class="o">.</span><span class="n">txtInput</span><span class="p">[</span><span class="s2">&quot;enabled&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

<span class="c1">#2. possibility</span>
<span class="n">dialog</span><span class="o">.</span><span class="n">txtInput</span><span class="o">.</span><span class="n">setProperty</span><span class="p">(</span> <span class="p">{</span><span class="s2">&quot;text&quot;</span><span class="p">:</span><span class="s2">&quot;new text for this textfield&quot;</span><span class="p">,</span> \
    <span class="s2">&quot;enabled&quot;</span><span class="p">:</span><span class="kc">False</span><span class="p">}</span> <span class="p">)</span>
</pre></div>
</div>
<p>If you use <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem.setProperty" title="itom.uiItem.setProperty"><code class="xref py py-meth docutils literal notranslate"><span class="pre">setProperty()</span></code></a>, you always need to pass a dictionary as argument. This dictionary can contain one or multiple properties, where the keyword
always is the property-name (string) and the value is the corresponding new value (type depends on corresponding C++ type).
For more information about supported datatypes, that can be accessed by python in <strong>itom</strong> see <a class="reference internal" href="#qtdesigner-datatypes"><span class="std std-ref">Supported datatypes</span></a>.</p>
<p>If the property is an enumeration or a bitmask (or-combination of enumeration values), you can either pass the integer value or a string with the enumeration key name.
In case of a flag, pass a semicolon-separated string with all values. The return value is always the integer number.</p>
</div>
<div class="section" id="supported-datatypes">
<span id="qtdesigner-datatypes"></span><h2><span class="section-number">6.3.5. </span>Supported datatypes<a class="headerlink" href="#supported-datatypes" title="Permalink to this headline">¶</a></h2>
<p>The classes <a class="reference internal" href="../09_reference/itom_GUI.html#itom.ui" title="itom.ui"><code class="xref py py-class docutils literal notranslate"><span class="pre">itom.ui</span></code></a> and <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">itom.uiItem</span></code></a> are the connection between any python-script in <strong>itom</strong> and GUI-elements, written in C++ and provided by <strong>Qt</strong>.
Therefore, it is necessary to transform types from python to corresponding C++-structures and vice-versa. The following table lists some convenient type casts. In general,
it is always tried to convert the input type to the desired destination type, such that a number can also be transformed to a string, if it is always known, that the destination
requires a string.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>C++/Qt-Type</p></th>
<th class="head"><p>Python-Type</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>QString</p></td>
<td><p>str or any type, that has a string representation</p></td>
</tr>
<tr class="row-odd"><td><p>QByteArray</p></td>
<td><p>unicode or byte type</p></td>
</tr>
<tr class="row-even"><td><p>QUrl</p></td>
<td><p>any string that can be interpreted as Url</p></td>
</tr>
<tr class="row-odd"><td><p>bool</p></td>
<td><p>any type that can be casted to a boolean value (1,0,True,False…)</p></td>
</tr>
<tr class="row-even"><td><p>QStringList</p></td>
<td><p>any sequence that only contains values castable to QString</p></td>
</tr>
<tr class="row-odd"><td><p>int, short, long</p></td>
<td><p>integer, floats are rounded to integer, True=1, False=0</p></td>
</tr>
<tr class="row-even"><td><p>unsigned int …</p></td>
<td><p>integer, floats are rounded to integer, True=1, False=0</p></td>
</tr>
<tr class="row-odd"><td><p>float, double</p></td>
<td><p>integer, floats, True=1.0, False=0.0</p></td>
</tr>
<tr class="row-even"><td><p>QVector&lt;int&gt;</p></td>
<td><p>any sequence whose values are castable to int</p></td>
</tr>
<tr class="row-odd"><td><p>QVector&lt;double&gt;</p></td>
<td><p>any sequence whose values are castable to float</p></td>
</tr>
<tr class="row-even"><td><p>QList&lt;int&gt;</p></td>
<td><p>any sequence whose values are castable to int</p></td>
</tr>
<tr class="row-odd"><td><p>QList&lt;double&gt;</p></td>
<td><p>any sequence whose values are castable to float</p></td>
</tr>
<tr class="row-even"><td><p>QVector2D</p></td>
<td><p>any sequence with two values castable to float (x,y)</p></td>
</tr>
<tr class="row-odd"><td><p>QVector3D</p></td>
<td><p>any sequence with three values castable to float (x,y,z)</p></td>
</tr>
<tr class="row-even"><td><p>QVector4D</p></td>
<td><p>any sequence with four values castable to float (x,y,z,w)</p></td>
</tr>
<tr class="row-odd"><td><p>PCLPointCloud</p></td>
<td><p><a class="reference internal" href="../09_reference/pointCloud.html#itom.pointCloud" title="itom.pointCloud"><code class="xref py py-class docutils literal notranslate"><span class="pre">pointCloud</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>PCLPoint</p></td>
<td><p><a class="reference internal" href="../09_reference/point.html#itom.point" title="itom.point"><code class="xref py py-class docutils literal notranslate"><span class="pre">point</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>PCLPolygonMesh</p></td>
<td><p><a class="reference internal" href="../09_reference/polygonMesh.html#itom.polygonMesh" title="itom.polygonMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">polygonMesh</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>DataObject*</p></td>
<td><p><a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">dataObject</span></code></a> or any type convertable to an array (see numpy)</p></td>
</tr>
<tr class="row-odd"><td><p>AddInDataIO*</p></td>
<td><p><a class="reference internal" href="../09_reference/dataIO.html#itom.dataIO" title="itom.dataIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">dataIO</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>AddInActuator*</p></td>
<td><p><a class="reference internal" href="../09_reference/actuator.html#itom.actuator" title="itom.actuator"><code class="xref py py-class docutils literal notranslate"><span class="pre">actuator</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>QVariant</p></td>
<td><p>any of the types above can be transformed to QVariant</p></td>
</tr>
<tr class="row-even"><td><p>QVariantMap</p></td>
<td><p>a dictionary where keys are strings and values are generally convertable.</p></td>
</tr>
<tr class="row-odd"><td><p>QVariantList</p></td>
<td><p>any sequence whose items can be convertable.</p></td>
</tr>
<tr class="row-even"><td><p>QRegion</p></td>
<td><p><a class="reference internal" href="../09_reference/region.html#itom.region" title="itom.region"><code class="xref py py-class docutils literal notranslate"><span class="pre">region</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>QColor</p></td>
<td><p>string with color name or hex-value or <a class="reference internal" href="../09_reference/rgba.html#itom.rgba" title="itom.rgba"><code class="xref py py-class docutils literal notranslate"><span class="pre">rgba</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p>Enumeration</p></td>
<td><p>integer with value or string with key (setter only)</p></td>
</tr>
<tr class="row-odd"><td><p>QTime</p></td>
<td><p>datetime.time object</p></td>
</tr>
<tr class="row-even"><td><p>QDate</p></td>
<td><p>datetime.date object</p></td>
</tr>
<tr class="row-odd"><td><p>QDateTime</p></td>
<td><p>datetime.datetime object</p></td>
</tr>
<tr class="row-even"><td><p>QFont</p></td>
<td><p><a class="reference internal" href="../09_reference/font.html#itom.font" title="itom.font"><code class="xref py py-class docutils literal notranslate"><span class="pre">font</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p>Qt::CheckState</p></td>
<td><p>int (0: unchecked, 1: partially checked, 2: checked)</p></td>
</tr>
<tr class="row-even"><td><p>Qt::ItemFlags</p></td>
<td><p>int, bitmask (see Qt::ItemFlags for definitions)</p></td>
</tr>
</tbody>
</table>
<p>If a property or other arguments in <strong>Qt</strong> require other datatypes, it is possibly to implement a converter for them. It only becomes a little bit more difficult for pointers to
extended C++ or <strong>Qt</strong> classes. The conversion is mainly done in the <strong>itom</strong> class <strong>PythonQtConversion</strong>.</p>
</div>
<div class="section" id="connecting-signals">
<h2><span class="section-number">6.3.6. </span>Connecting signals<a class="headerlink" href="#connecting-signals" title="Permalink to this headline">¶</a></h2>
<p>Now, you know how to change properties of dialogs at runtime of <strong>itom</strong> using a small python script snippet. In this section, you will learn how you can let <strong>itom</strong> a specific python-method
for instance if a button on the user interface is clicked. Whenever something is changed in a user interface or the user starts to interact with the interface, any type of event is emitted.
In <strong>Qt</strong> many of these events are specially handled and called signals. For instance, if an user clicks a button, toggles a checkbox, triggers an item in a menu or selects an item in a list
widget, a signal is emitted or sent.</p>
<p>The counterpart to a signal is called slot. <strong>Qt</strong> provides the possibility to <strong>connect</strong> a signal with a slot, under the only condition, that both have exactly the same order and type
of arguments. It is even possible to connect the same signal to various slots. Whenever a signal is emitted, all connected slots are executed. <strong>itom</strong> provides you the possibility to
define slots in form of ordinary python methods or functions and to also connect them to signals of widgets on your user interface.</p>
<p>For establishing the connection, you need again a reference to the specific widget on the user interface. This reference is any variable of type <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">uiItem</span></code></a>. Next, you need the
name and the arguments of the <strong>Qt</strong> signal, you want to connec to. This information can be obtained by the <strong>Qt</strong> documentation. For instance, if you need any signal that a widget of type
<strong>QPushButton</strong> (the type of our push button, placed in the user interface in file <strong>testWidget.ui</strong>), go to <a class="reference external" href="https://doc.qt.io/qt-5/qpushbutton.html">https://doc.qt.io/qt-5/qpushbutton.html</a>. Unfortunately, you won’t find
a headline called <strong>Signals</strong> at this page, since <strong>QPushButton</strong> does not directly declare any signal. However, you can see under <strong>Additional Inherited Members</strong>, that <strong>QPushButton</strong>
inherits signals from its base classes. The most important signals are inherited from <strong>QAbstractButton</strong>. Click on its link and you will see the available signals for a push button:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">clicked</span> <span class="p">(</span> <span class="kt">bool</span> <span class="n">checked</span> <span class="o">=</span> <span class="nb">false</span> <span class="p">)</span>
<span class="kt">void</span> <span class="n">pressed</span> <span class="p">()</span>
<span class="kt">void</span> <span class="n">released</span> <span class="p">()</span>
<span class="kt">void</span> <span class="n">toggled</span> <span class="p">(</span> <span class="kt">bool</span> <span class="n">checked</span> <span class="p">)</span>
</pre></div>
</div>
<p>If any argument provides a default value, you can also omit the specific argument. Select the signal that is convenient for you and create its string-signature. The signature always
contains the following structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">signature</span> <span class="o">=</span> <span class="s2">&quot;signalName(typeName1,typeName2,...)&quot;</span>
</pre></div>
</div>
<p>For instance, the signatures for the signals above are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;clicked()&quot;</span> <span class="ow">or</span> <span class="s2">&quot;clicked(bool)&quot;</span>
<span class="s2">&quot;pressed()&quot;</span>
<span class="s2">&quot;released()&quot;</span>
<span class="s2">&quot;toggled(bool)&quot;</span>
</pre></div>
</div>
<p>Then, create a python method in your script, which you want to consider to be a slot and that should be connected with the signal. This method always requires the same number of
arguments than given in the signature. If you want to connect a signal to a method that is a bounded method of a class in python, the first argument <strong>self</strong> does not count to the
number of total arguments, hence, you always need to define the first parameter <strong>self</strong>, like it is the case for bounded methods.</p>
<p>Finally, use the method <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem.connect" title="itom.uiItem.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> in order to establish the connection. For instance let us create a method, that should show a message when the push button “click me”
on the first exemplary dialog (<em>testWidget.ui</em>) has been clicked:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dialog</span> <span class="o">=</span> <span class="n">ui</span><span class="p">(</span><span class="s2">&quot;testWidget.ui&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">.</span><span class="n">TYPEDIALOG</span><span class="p">,</span> <span class="n">ui</span><span class="o">.</span><span class="n">BUTTONBAR_VERTICAL</span><span class="p">,</span> \
    <span class="p">{</span><span class="s2">&quot;AcceptRole&quot;</span><span class="p">:</span><span class="s2">&quot;OK&quot;</span><span class="p">,</span> <span class="s2">&quot;RejectRole&quot;</span><span class="p">:</span><span class="s2">&quot;Cancel&quot;</span><span class="p">})</span>

<span class="k">def</span> <span class="nf">showMsg</span><span class="p">():</span>
    <span class="c1">#slot executed in button &#39;click me&#39; is clicked</span>
    <span class="n">ui</span><span class="o">.</span><span class="n">msgInformation</span><span class="p">(</span><span class="s2">&quot;itom&quot;</span><span class="p">,</span><span class="s2">&quot;you pressed the button click me&quot;</span><span class="p">)</span>

<span class="c1">#connect(signature, method)</span>
<span class="n">dialog</span><span class="o">.</span><span class="n">btnClickMe</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span> <span class="s2">&quot;clicked()&quot;</span><span class="p">,</span> <span class="n">showMsg</span> <span class="p">)</span>

<span class="c1">#show dialog</span>
<span class="n">dialog</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>You have seen that the method <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem.connect" title="itom.uiItem.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> of the element <em>dialog.btnClickMe</em> (the push button) has been called. Its first argument is
the signature of the signal, as second argument the reference to the slot-methods is given. If you integrate the dialog within a class and the slot is a member of this class, too,
the exemplary code can look as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyDialog</span><span class="p">():</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dialog</span> <span class="o">=</span> <span class="n">ui</span><span class="p">(</span><span class="s2">&quot;testWidget.ui&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">.</span><span class="n">TYPEDIALOG</span><span class="p">,</span> <span class="n">ui</span><span class="o">.</span><span class="n">BUTTONBAR_VERTICAL</span><span class="p">,</span> \
            <span class="p">{</span><span class="s2">&quot;AcceptRole&quot;</span><span class="p">:</span><span class="s2">&quot;OK&quot;</span><span class="p">,</span> <span class="s2">&quot;RejectRole&quot;</span><span class="p">:</span><span class="s2">&quot;Cancel&quot;</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dialog</span><span class="o">.</span><span class="n">btnClickMe</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;clicked()&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">showMsg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dialog</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">showMsg</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ui</span><span class="o">.</span><span class="n">msgInformation</span><span class="p">(</span><span class="s2">&quot;itom&quot;</span><span class="p">,</span><span class="s2">&quot;you pressed the button click me&quot;</span><span class="p">)</span>

<span class="c1">#instance of class MyDialog</span>
<span class="n">test</span> <span class="o">=</span> <span class="n">MyDialog</span><span class="p">()</span>
</pre></div>
</div>
<p>Let us use the second example <strong>testWindow.ui</strong>. If you want a python method to be executed if the user clicks an action in the menu of the main window, you should connect
the signal <strong>triggered()</strong> of every item in the menu with your method. In <strong>Qt</strong> such an item is an instance of <em>QAction</em> and is also accessed by its <em>objectName</em>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">win</span> <span class="o">=</span> <span class="n">ui</span><span class="p">(</span><span class="s2">&quot;testWindow.ui&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">.</span><span class="n">TYPEWINDOW</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">addItem</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;action addItem clicked&quot;</span><span class="p">)</span>

<span class="n">win</span><span class="o">.</span><span class="n">actionAddItem</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;triggered()&quot;</span><span class="p">,</span> <span class="n">addItem</span><span class="p">)</span>
<span class="c1">#actionAddItem is the objectName of the action</span>
<span class="n">win</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>New in itom 3.2</strong></p>
<p>The method <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem.connect" title="itom.uiItem.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> now has the additional optional argument <strong>minRepeatInterval</strong>. If this is given with a value &gt; 0,
the connected slot will only be called, if the last call from the same signal happened at least <strong>minRepeatInterval</strong> ms ago. Else, the new
call is ignored. This can be used, to avoid that signals, that are fired very often, will jam the incoming event queue of the corresponding Python method.</p>
<p>It is further possible to not only connect signals from widgets to Python slots, but also signals from <strong>dataIO</strong> or <strong>actuator</strong> instances. For this, see
the methods <a class="reference internal" href="../09_reference/dataIO.html#itom.dataIO.connect" title="itom.dataIO.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">connect()</span></code></a> and <a class="reference internal" href="../09_reference/actuator.html#itom.actuator.connect" title="itom.actuator.connect"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itom.actuator.connect()</span></code></a>.</p>
</div>
</div>
<div class="section" id="calling-slots">
<span id="qtdesigner-slots"></span><h2><span class="section-number">6.3.7. </span>Calling slots<a class="headerlink" href="#calling-slots" title="Permalink to this headline">¶</a></h2>
<p>Widgets on user interfaces not only emit signals but they also have slots defined, such that you can connect other signals (e.g. from other widgets) to these slots. Using a python
script in <strong>itom</strong> you can also call (<em>or:</em> invoke) these slots.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With respect to the documentation of <strong>Qt</strong> it is only possible to invoke slots of widgets from python, but it is not possible
to call public, protected or private member methods. This is a limitation of <strong>itom</strong>. Other python packages like <em>pySide</em> or <em>PyQt</em> offer this possibility, however their use is not
possible in <strong>itom</strong>, since they require the python interpreter to be executed in the main thread, which is not the case in <strong>itom</strong>, where <strong>Python</strong> runs in its own secondary thread.</p>
</div>
<p>In order to invoke a slot, call the method <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem.call" title="itom.uiItem.call"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call()</span></code></a> of any element on your user interface. For instance, in order to clear the list widget (<em>objectName</em>: <em>listWidget</em>)
of <strong>uiWindow.ui</strong>, you can invoke its public slot <strong>clear()</strong>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">win</span> <span class="o">=</span> <span class="n">ui</span><span class="p">(</span><span class="s2">&quot;testWindow.ui&quot;</span><span class="p">,</span> <span class="n">ui</span><span class="o">.</span><span class="n">TYPEWINDOW</span><span class="p">)</span>
<span class="n">listWidget</span> <span class="o">=</span> <span class="n">win</span><span class="o">.</span><span class="n">listWidget</span>
<span class="n">listWidget</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s2">&quot;clear&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here, the method <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem.call" title="itom.uiItem.call"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call()</span></code></a> is only called with one argument, the name of the slot in <strong>Qt</strong>. If this slot would have any arguments that can be converted from <strong>Python</strong> (see
<a class="reference internal" href="#qtdesigner-datatypes"><span class="std std-ref">Supported datatypes</span></a>), add these arguments as further parameters to the call.</p>
<p>Unfortunately, there are some methods of important widgets in <strong>Qt</strong>, which are not defined to be a <em>public slot</em>. For instance, the methods to add item(s) to a list widget are no slots.
However, there are some exceptions defined in <strong>itom</strong> such that some <em>public methods</em> of widgets can also be called with the method <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem.call" title="itom.uiItem.call"><code class="xref py py-meth docutils literal notranslate"><span class="pre">call()</span></code></a>. These exceptions are
contained in the following table:</p>
<dl class="py function">
<dt>
<code class="sig-name descname">QWidget::resize(int width, int height) -&gt; None</code></dt>
<dd><p>resizes the widget to width / height.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QWidget::setGeometry(int x, int y, int width, int height) -&gt; None</code></dt>
<dd><p>changes the geometry of the widget.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QWidget::setCursor(int index) -&gt; None</code></dt>
<dd><p>sets the given cursor for this uiItem. The number is a value of the enumeration <a class="reference external" href="https://doc.qt.io/qt-5/qt.html#CursorShape-enum/">Qt::CursorShape</a>. A number &lt; 0 will unset the current cursor.</p>
<p><em>New in **itom*</em> 3.2*</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QWidget::devicePixelRatioF() -&gt; float</code></dt>
<dd><p>Returns the device pixel ratio for the device as a floating point number. Only if <strong>itom</strong> is compiled against Qt &gt;= 5.6, else 1.0 is returned always.</p>
<p><em>New in **itom*</em> 3.2*</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QListWidget::addItem(str item) -&gt; None</code></dt>
<dd><p>adds the item to the list</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QListWidget::addItems(Sequence[str] items) -&gt; None</code></dt>
<dd><p>adds the given items in the given order to the list.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QListWidget::selectedRows() -&gt; Tuple[int]</code></dt>
<dd><p>returns a tuple of all selected row indices</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QListWidget::selectedTexts() -&gt; Tuple[str]</code></dt>
<dd><p>returns a tuple of all selected values</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QListWidget::selectRows(Sequence[int] indices) -&gt; None</code></dt>
<dd><p>select the rows with the given indices (ListWidget must be in multi-selection mode)</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QListWidget::takeItem(int row) -&gt; str</code></dt>
<dd><p>removes and returns the text of the item from the given row in the list widget. Raises an exception if the item does not exist.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QListWidget::item(int row) -&gt; str</code></dt>
<dd><p>returns the text of the item from the given row or raises an exception if the item does not exist</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QListWidget::setItemText(int row, str text) -&gt; None</code></dt>
<dd><p>sets the text of the item from the given row or raises an exception if the item does not exist</p>
<p><em>New in **itom*</em> &gt; 3.2.1*</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QListWidget::checkState(int row) -&gt; int (Qt::CheckState)</code></dt>
<dd><p>returns the check state of the item from the given row (0: unchecked, 1: partially checked, 2: checked) or raises an exception if the item does not exist.
For possible values of flags, see the enumeration <a class="reference external" href="https://doc.qt.io/qt-5/qt.html#CheckFlag-enum/">Qt::ItemFlags</a>.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QListWidget::setCheckState(int row, Qt::CheckState state) -&gt; None</code></dt>
<dd><p>set the check state of the item in the given row (0: unchecked, 1: partially checked, 2: checked) - set the flags properly before changing the state.
For possible values of flags, see the enumeration <a class="reference external" href="https://doc.qt.io/qt-5/qt.html#CheckFlag-enum/">Qt::ItemFlags</a>.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QListWidget::flags(int row) -&gt; int (Qt::ItemFlags)</code></dt>
<dd><p>returns the flags used to describe this item (e.g. checkable, tristate, editable, selectable…).
For possible values of flags, see the enumeration <a class="reference external" href="https://doc.qt.io/qt-5/qt.html#ItemFlag-enum/">Qt::ItemFlags</a>.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QListWidget::setFlags(int row, Qt::ItemFlags flags) -&gt; None</code></dt>
<dd><p>set the flags of the item in the given row based on the flags bitmask (use an integer). You have to set the flags properly before changing the state.
For possible values of flags, see the enumeration <a class="reference external" href="https://doc.qt.io/qt-5/qt.html#ItemFlag-enum/">Qt::ItemFlags</a>.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QComboBox::addItem(str item) -&gt; None</code></dt>
<dd><p>appends the given item to the combo box</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QComboBox::addItems(Sequence[str] items) -&gt; None</code></dt>
<dd><p>appends the given items to the combo box</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QComboBox::removeItem(int index) -&gt; None</code></dt>
<dd><p>remove the item in the combo box given by index</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QComboBox::setItemData(int index, variant value) -&gt; None</code></dt>
<dd><p>sets the displayed text of the item given by index to the given value.
<em>value</em> can be of any type, that can be converted to a string representation (originally: QVariant).</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QComboBox::insertItem(int index , str item) -&gt; None</code></dt>
<dd><p>Inserts the item at the position in the list given by index.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QComboBox::itemText(int index) -&gt; str</code></dt>
<dd><p>returns the text of the item in the combo box given by index.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QTabWidget::isTabEnabled(int index) -&gt; bool</code></dt>
<dd><p>returns True, if the tab, given by index, is enabled; else False</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QTabWidget::setTabEnabled(int index, bool enabled) -&gt; None</code></dt>
<dd><p>sets the enable state of the tab, given by index.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QMainWindow::statusBar() -&gt; uiItem</code></dt>
<dd><p>returns a reference to the statusbar widget as <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">uiItem</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QMainWindow::centralWidget() -&gt; uiItem</code></dt>
<dd><p>returns a reference to the central widget of the mainWindow as <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">uiItem</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QMainWindow::addToolBar(str name, str objectName) -&gt; uiItem</code></dt>
<dd><p>adds a new toolbar with the given name to the main window and returns its reference as <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">uiItem</span></code></a>.
If objectName is a nonempty string, it is used as internal object name of the new toolbar.</p>
<p><em>New in **itom*</em> 3.2*</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QTableWidget::setHorizontalHeaderLabels(Sequence[str] labels) -&gt; None</code></dt>
<dd><p>sets the labels of the horizontal header labels</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QTableWidget::setVerticalHeaderLabels(Sequence[str] labels) -&gt; None</code></dt>
<dd><p>sets the labels of the vertical header labels</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QTableWidget::getItem(int row, int column) -&gt; variant (QVariant)</code></dt>
<dd><p>returns the value of the item, given by row and column</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QTableWidget::setItem(int row, int column, variant value) -&gt; None</code></dt>
<dd><p>sets the value of the item, given by row and column, to the given value (any type, castable to QVariant).</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QTableWidget::currentColumn() -&gt; int</code></dt>
<dd><p>returns the index of the currently selected column</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QTableWidget::currentRow() -&gt; int</code></dt>
<dd><p>returns the index of the currently selected row</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QTableWidget::checkState(int row, int column) -&gt; int (Qt::CheckState)</code></dt>
<dd><p>returns the check state of the item from the given row and column (0: unchecked, 1: partially checked, 2: checked) or raises an exception if the item does not exist.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QTableWidget::setCheckState(int row, int column,Qt::CheckState state) -&gt; None</code></dt>
<dd><p>set the check state of the item in the given row and column (0: unchecked, 1: partially checked, 2: checked) - set the flags properly before changing the state.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QTableWidget::flags(int row, int column) -&gt; int (Qt::ItemFlags)</code></dt>
<dd><p>returns the flags used to describe this item (e.g. checkable, tristate, editable, selectable…).
For possible values of flags, see the enumeration <a class="reference external" href="https://doc.qt.io/qt-5/qt.html#ItemFlag-enum/">Qt::ItemFlags</a>.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QTableWidget::setFlags(int row, int column, Qt::ItemFlags flags) -&gt; None</code></dt>
<dd><p>set the flags of the item in the given row and column based on the flags bitmask (use an integer). You have to set the flags properly before changing the state.
For possible values of flags, see the enumeration <a class="reference external" href="https://doc.qt.io/qt-5/qt.html#ItemFlag-enum/">Qt::ItemFlags</a>.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QTableView::horizontalHeader() -&gt; uiItem</code></dt>
<dd><p>returns a reference to the horizontal header widget as <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">uiItem</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QTableView::verticalHeader() -&gt; uiItem</code></dt>
<dd><p>returns a reference to the vertical header widget as <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">uiItem</span></code></a>.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QSplitter::setStretchFactor(int section, int factor) -&gt; None</code></dt>
<dd><p>sets the stretch factor (size policy) for the given section.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QSplitter::sizes() -&gt; Tuple[int]</code></dt>
<dd><p>returns the sizes (in pixel) of each section as tuple.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QSplitter::setSizes(Sequence[int] sizes) -&gt; None</code></dt>
<dd><p>sets the sizes of all sections (in pixels). Pass sizes as tuple or list of integers.</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QSplitter::isCollapsible(int section) -&gt; bool</code></dt>
<dd><p>returns True if the given section is collapsible, else False</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QSplitter::setCollapsible(int section, bool value) -&gt; None</code></dt>
<dd><p>set if the given section should be collapsible (True) or not (False)</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QStatusBar::addLabelWidget(str objectName) -&gt; uiItem</code></dt>
<dd><p>adds an empty label (class: QLabel) to the status bar with the given object name and returns its reference as <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">uiItem</span></code></a>.</p>
<p><em>New in **itom*</em> 3.2*</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QStatusBar::currentText() -&gt; str</code></dt>
<dd><p>Returns the temporary message currently shown, or an empty string if there is no such message.</p>
<p><em>New in **itom*</em> 3.2*</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QToolBar::addSeparator() -&gt; uiItem</code></dt>
<dd><p>adds a new separator to the toolbar and returns its reference as <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">uiItem</span></code></a>.</p>
<p><em>New in **itom*</em> 3.2*</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QToolBar::addAction(str label, str objectName) -&gt; uiItem</code></dt>
<dd><p>adds a new action to the toolbar and returns its reference (QAction) as <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">uiItem</span></code></a>.
The action has a label text, as well as an optional objectName. No objectName is assigned if it is an empty string.</p>
<p>You can assign an icon to this action, by the following sample code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">#given is the uiItem of the toolbar as &#39;myToolbar&#39;</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">myToolbar</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s2">&quot;addAction&quot;</span><span class="p">,</span> <span class="s2">&quot;do it&quot;</span><span class="p">,</span> <span class="s2">&quot;do_it&quot;</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s2">&quot;setIcon&quot;</span><span class="p">,</span> <span class="s2">&quot;C:/temp/icon.png&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p><em>New in **itom*</em> 3.2*</p>
</dd></dl>

<dl class="py function">
<dt>
<code class="sig-name descname">QAction::setIcon(str filename, float scaleFactor) -&gt; None</code></dt>
<dd><p>sets the icon of the action to the given filename and optionally defines a certain scaling factor, which
is the pixel ratio that is applied to the icon (usually: 1.0).</p>
<p><em>New in **itom*</em> 3.2*</p>
</dd></dl>

<p>Please notice, that every method listed above is also valid for a widget, that is derived from the specific class (derived in C++). Therefore the additional slots of <em>QWidget</em>
hold for every other widget, since every widget is derived from <em>QWidget</em>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Whenever the return value is of type <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">uiItem</span></code></a>, the original C++ datatype is a pointer to <strong>QWidget</strong>. This pointer is specially wrapped in a thread-safe process to the
corresponding instance of <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">uiItem</span></code></a>, that represents the specific widget.</p>
<p>The special slots defined in the table above are given in the class <strong>WidgetWrapper</strong> of <strong>itom</strong>.</p>
</div>
</div>
<div class="section" id="connecting-internal-signals-and-slots-in-qt-designer">
<h2><span class="section-number">6.3.8. </span>Connecting internal signals and slots in <strong>Qt Designer</strong><a class="headerlink" href="#connecting-internal-signals-and-slots-in-qt-designer" title="Permalink to this headline">¶</a></h2>
<p>If you want to connect the signal, emitted by any widget, with a slot from another widget, you will learn in this section how to do this. This type of connection can for instance
be useful if you want to enable or disable certain widgets depending on the status of other ones, like the check-status of a checkbox. The following figure shows an user interface
with a checkbox and a textfield. Let us define a signal-slot-connection, such that the textfield gets disabled if the checkbox is unchecked.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/uiSignalSlot1.png"><img alt="../_images/uiSignalSlot1.png" src="../_images/uiSignalSlot1.png" style="width: 393.0px; height: 76.0px;" /></a>
</div>
<p>This type of gui-internal connections are completely done in <strong>Qt Creator</strong>. Therefore chose the “Signal and Slots” editing mode, that is obtained by clicking the symbol <img alt="qtsignalslotmode" src="../_images/designer-connection-tool.png" />
in the toolbar or by pressing <em>F4</em>. Then you can make a drag&amp;drop connection between the emitting widget and the receiver-widget. After releasing the mouse button, the connection dialog,
depicted in the following figure becomes visible:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/uiSignalSlot2.png"><img alt="../_images/uiSignalSlot2.png" src="../_images/uiSignalSlot2.png" style="width: 582.0px; height: 410.0px;" /></a>
</div>
<p>Here you can choose which signal of the emitting widget should be connected with which slot of the destination. At the beginning, only slots and signals of the specific widget classes are
visible. However, you can check the checkbox below, in order to also show the signals and slots of the inherited classes. Please make sure, that you only choose pairs of signals and
slots which have the same parameter types. In our case, we connect the signal <em>toggled(bool)</em> with the slot <em>setEnabled(bool)</em>, which is the setter-method of the property <em>enabled</em>.</p>
<p>This example has also shown, that not only slots defined in the slot-section can be called as slots, but also every setter-method of any property can be called like every slot. However,
in this case it is more convenient the property like described in section <a class="reference internal" href="#qtdesigner-getsetprops"><span class="std std-ref">Getting and setting properties</span></a>.</p>
</div>
<div class="section" id="auto-connecting-signals-using-python-decorators">
<h2><span class="section-number">6.3.9. </span>Auto-connecting signals using python decorators<a class="headerlink" href="#auto-connecting-signals-using-python-decorators" title="Permalink to this headline">¶</a></h2>
<p><strong>itom</strong> provides an optional approach to directly connect methods with a specific signal of a widget. An example for this approach is for instance given in the demo script <strong>autoConnectDemo.py</strong>
in the <strong>demo/ui</strong> subfolder of the itom installation.</p>
<p>The concept is as follows:</p>
<ol class="arabic">
<li><p>import the class <strong>ItomUi</strong> from the module <strong>itomUi</strong> (located in the subfolder <strong>itom_packages</strong> that is part of the Python search path:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">itomUi</span> <span class="kn">import</span> <span class="n">ItomUi</span>
</pre></div>
</div>
</li>
<li><p>Create a class that is derived from <strong>ItomUi</strong></p></li>
<li><p>In the constructor (method __init__) of your class call the constructor of the base class <strong>ItomUi</strong>. This constructor has the same arguments than the class <a class="reference internal" href="../09_reference/itom_GUI.html#itom.ui" title="itom.ui"><code class="xref py py-class docutils literal notranslate"><span class="pre">itom.ui</span></code></a>. This is where you create the GUI from the ui file.</p></li>
<li><p>The <a class="reference internal" href="../09_reference/itom_GUI.html#itom.ui" title="itom.ui"><code class="xref py py-class docutils literal notranslate"><span class="pre">ui</span></code></a> is accessible via the member variable <strong>gui</strong> of your class, hence, within a member method write <strong>self.gui</strong> to access the user interface and its widgets.</p></li>
<li><p>You can now connect one or multiple signals from one widget to one member method of your class.</p></li>
<li><p>The name of the member method must be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">on_ObjectNameOfWidget_SignalName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="o">...</span><span class="p">]):</span>
    <span class="k">pass</span>
</pre></div>
</div>
</li>
<li><p>The argument is <strong>self</strong> (like it is always the case in object-oriented Python programming) followed by a series of arguments. The number of these arguments must correspond to the number of arguments the signal has.</p></li>
<li><p>Write one or multiple decorators above the method signature, to establish the connection. The decorator looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@ItomUi</span><span class="o">.</span><span class="n">autoslot</span><span class="p">(</span><span class="s2">&quot;args&quot;</span><span class="p">)</span>

<span class="n">Hereby</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="o">*</span> <span class="n">corresponds</span> <span class="n">to</span> <span class="n">a</span> <span class="n">comma</span> <span class="n">separated</span> <span class="nb">list</span> <span class="n">of</span> <span class="nb">all</span> <span class="nb">type</span> <span class="n">names</span> <span class="p">(</span><span class="ow">in</span> <span class="n">C</span><span class="o">++</span><span class="p">)</span> <span class="n">the</span> <span class="n">Qt</span> <span class="n">signal</span> <span class="ow">is</span> <span class="n">emitting</span><span class="o">.</span>
</pre></div>
</div>
</li>
</ol>
<p>As an example, we want to connect the <strong>valueChanged</strong> signal of a spin box (object-name: spinTestBox, argument obtained from Qt  help: one <strong>int</strong>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@ItomUi</span><span class="o">.</span><span class="n">autoslot</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">on_spinTestBox_valueChanged</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The value of the spin box changed to&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="debugging-user-interfaces-and-slot-methods">
<h2><span class="section-number">6.3.10. </span>Debugging user interfaces and slot-methods<a class="headerlink" href="#debugging-user-interfaces-and-slot-methods" title="Permalink to this headline">¶</a></h2>
<p>If you established a signal-slot-connection between an element of the GUI and a <strong>Python</strong>-method, you probably want to debug this method once the signal has been emitted. This
is obtained by setting any breakpoint into the specific line and toggling the button <em>Run python code in debug mode</em> in the menu <strong>Script</strong> of <strong>itom</strong>.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/runPyCodeInDebug.png"><img alt="../_images/runPyCodeInDebug.png" src="../_images/runPyCodeInDebug.png" style="width: 579.0px; height: 112.0px;" /></a>
</div>
</div>
<div class="section" id="access-the-status-bar-of-a-main-window">
<h2><span class="section-number">6.3.11. </span>Access the status bar of a main window<a class="headerlink" href="#access-the-status-bar-of-a-main-window" title="Permalink to this headline">¶</a></h2>
<p>If one wants to access and modify the content of the status bar of a main window, the following steps need to be done:</p>
<p>Let’s assume the main window is accessible via Python by the variable name <strong>gui</strong>, then</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">statusbar</span> <span class="o">=</span> <span class="n">gui</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="s2">&quot;statusBar&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>returns an instance of <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">uiItem</span></code></a> representing the status bar widget (Qt class QStatusBar). Check the Qt help to see that QStatusBar has the following slots (among others):</p>
<ul class="simple">
<li><p><strong>clearMessage()</strong> clears the current text of the status bar</p></li>
<li><p><strong>showMessage(const QString &amp;message)</strong> displays <em>message</em> in the status bar</p></li>
<li><p><strong>showMessage(const QString &amp;message, int timeout)</strong> displays <em>message</em> in the status bar and hides it after the <em>timeout</em> given in milliseconds.</p></li>
</ul>
</div>
<div class="section" id="hints-and-limitations">
<h2><span class="section-number">6.3.12. </span>Hints and limitations<a class="headerlink" href="#hints-and-limitations" title="Permalink to this headline">¶</a></h2>
<p>All methods described in this chapter explain how to create and use user-defined dialogs and windows using <strong>Python</strong> scripts in <strong>itom</strong>. Finally, all dialogs are created using the
<strong>Qt</strong>-framework. The classes <a class="reference internal" href="../09_reference/itom_GUI.html#itom.ui" title="itom.ui"><code class="xref py py-class docutils literal notranslate"><span class="pre">itom.ui</span></code></a> and <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">itom.uiItem</span></code></a> finally are wrappers for the underlying <strong>Qt</strong>-system. Using pure python, similar things can also be
obtained with the famous packages <strong>PyQt</strong> or <strong>PySide</strong>. However, in <strong>itom</strong> you must not use these packages. The reason is, that create a new main instance of the <strong>Qt</strong>-engine, that
needs to be created in the main thread. This is the case, if <strong>PyQt</strong> or <strong>PySide</strong> is executed directly in <strong>Python</strong>. However using <strong>itom</strong> <strong>Python</strong> is embedded as scripting language, such
that <strong>itom</strong> is executed in the main thread while <strong>Python</strong> is moved to its own additional thread. The reason is to enable the execution of longer scripts, while the main application <strong>itom</strong>
still keeps reactive. Therefore, <strong>Python</strong> does not have access to the real main thread and it is forbidden to explicitly execute some GUI-related stuff in secondary threads. Therefore
all methods in <a class="reference internal" href="../09_reference/itom_GUI.html#itom.ui" title="itom.ui"><code class="xref py py-class docutils literal notranslate"><span class="pre">itom.ui</span></code></a> and <a class="reference internal" href="../09_reference/itom_GUI.html#itom.uiItem" title="itom.uiItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">itom.uiItem</span></code></a> have thread-safe implementations and communicate with an organization structure, that runs in the main thread of <strong>itom</strong>, in
order to interact with all dialogs.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="list_custom_widgets.html" class="btn btn-neutral float-right" title="6.4. Custom Designer Widgets" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="method-itom.html" class="btn btn-neutral float-left" title="6.2. Show messages, input boxes and default dialogs" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2011-2016, Institut fuer Technische Optik (ITO), University Stuttgart. Bug report: https://bitbucket.org/itom/itom/issues
      <span class="lastupdated">
        Last updated on Jul 03, 2020.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>