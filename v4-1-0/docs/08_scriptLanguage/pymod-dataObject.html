

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>8.2. Array class DataObject &mdash; itom Documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="8.3. Save and load images and other files" href="pymod-load-save-files.html" />
    <link rel="prev" title="8.1. Python-Module itom" href="pymod-itom.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> itom Documentation
          

          
          </a>

          
            
            
              <div class="version">
                4.1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../00_releaseNotes/whats-new.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../01_introduction/introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_installation/install.html">2. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_gettingStarted/getting-started.html">3. Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_itom_gui/gui.html">4. The itom User Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_plots/plots.html">5. Plots and Figures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_extended_gui/extended_gui.html">6. Extending the user interface of <strong>itom</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_plugins/plugins.html">7. Plugins</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="script-language.html">8. Python scripting language</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pymod-itom.html">8.1. Python-Module <strong>itom</strong></a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">8.2. Array class DataObject</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">8.2.1. Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#creating-a-dataobject">8.2.2. Creating a dataObject</a></li>
<li class="toctree-l3"><a class="reference internal" href="#static-constructors-for-dataobjects">8.2.3. Static constructors for dataObjects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#print-content-of-dataobject">8.2.4. Print content of dataObject</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accessing-values-in-a-dataobject">8.2.5. Accessing values in a dataObject</a></li>
<li class="toctree-l3"><a class="reference internal" href="#basic-attributes-of-a-dataobject">8.2.6. Basic attributes of a dataObject</a></li>
<li class="toctree-l3"><a class="reference internal" href="#value-and-axes-descriptions-units-scaling-and-offset">8.2.7. Value and axes descriptions, units, scaling and offset</a></li>
<li class="toctree-l3"><a class="reference internal" href="#meta-tags-and-protocol">8.2.8. Meta tags and protocol</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dataobject-vs-numpy-array">8.2.9. DataObject vs. Numpy.array</a></li>
<li class="toctree-l3"><a class="reference internal" href="#main-operations-on-numpy-arrays-and-itom-dataobjects">8.2.10. Main operations on numpy.arrays and itom.dataObjects</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="pymod-load-save-files.html">8.3. Save and load images and other files</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymod-popular-python-packages.html">8.4. Popular Python packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymod-matplotlib.html">8.5. Python-Module matplotlib</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymod-matlab.html">8.6. Python-Module matlab</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymod-reload-modules.html">8.7. Reload modified modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="pymod-limitations.html">8.8. Python Limitations in <strong>itom</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="pymod-problems-and-solutions.html">8.9. Python - common problems and solutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="pytutorial.html">8.10. Python tutorial</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../09_reference/reference.html">9. itom Script Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_miscellaneous/miscellaneous.html">10. Miscellaneous</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_test-scripts/test-scripts.html">11. Demo scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_tutorials/tutorials.html">12. Python tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_contributing/contributing.html">13. Contributing</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">itom Documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="script-language.html"><span class="section-number">8. </span>Python scripting language</a> &raquo;</li>
        
      <li><span class="section-number">8.2. </span>Array class DataObject</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/08_scriptLanguage/pymod-dataObject.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="array-class-dataobject">
<span id="itomdataobject"></span><h1><span class="section-number">8.2. </span>Array class DataObject<a class="headerlink" href="#array-class-dataobject" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2><span class="section-number">8.2.1. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>In <strong>itom</strong>, the class <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">dataObject</span></code></a> is the main array object. Arrays in <strong>itom</strong> can have the following properties:</p>
<ul>
<li><p>unlimited number of dimensions</p></li>
<li><p>each dimension can have an arbitrary size</p></li>
<li><dl>
<dt>possible data types:</dt><dd><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;uint8&quot;</span>      <span class="c1">#unsigned integer, 8 bit [0,255]</span>
<span class="s2">&quot;int8&quot;</span>       <span class="c1">#signed integer, 8 bit [-128,127]</span>
<span class="s2">&quot;uint16&quot;</span>     <span class="c1">#unsigned integer, 16 bit [0,65536]</span>
<span class="s2">&quot;int16&quot;</span>      <span class="c1">#signed integer, 16 bit [-32768,32767]</span>
<span class="s2">&quot;uint32&quot;</span>     <span class="c1">#unsigned integer, 32 bit</span>
<span class="s2">&quot;int32&quot;</span>      <span class="c1">#signed integer, 32 bit</span>
<span class="s2">&quot;float32&quot;</span>    <span class="c1">#floating point, 32 bit single precision</span>
<span class="s2">&quot;float64&quot;</span>    <span class="c1">#floating point, 64 bit double precision</span>
<span class="s2">&quot;complex64&quot;</span>  <span class="c1">#complex number with two float32 components</span>
<span class="s2">&quot;complex128&quot;</span> <span class="c1">#complex number with two float64 components</span>
<span class="s2">&quot;rgba32&quot;</span>     <span class="c1">#color format, 4x uint8 values (alpha,r,g,b)</span>
</pre></div>
</div>
</dd>
</dl>
</li>
</ul>
<p>Before giving a short tutorial about how to use the class <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">dataObject</span></code></a>, the base idea and concept of the array structure should be explained. If you already now the huge <strong>Python</strong> module <strong>Numpy</strong> with its base array class <strong>numpy.array</strong>, one will ask why another similar array class is provided by <strong>itom</strong>. The reasons for this are as follows:</p>
<ul class="simple">
<li><p>The python class <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">dataObject</span></code></a> is just a wrapper for the <strong>itom</strong> internal class <strong>DataObject</strong>, written in C++. This array structure is used all over <strong>itom</strong> and also passed to any plugin instances of <strong>itom</strong>. Internally, the C++ class <strong>DataObject</strong> is based on OpenCV-matrices, such that functionalities provided by the open-source Computer-Vision Library (OpenCV) can be used by <strong>itom</strong>.</p></li>
<li><p>The class <strong>dataObject</strong> should also be used to store real measurement data. Therefore it is possible to add tags and other meta information to every dataObject (like axis descriptions, scale and offset values, protocol entries…).</p></li>
<li><p>Usually, array classes (like the class <strong>Numpy.array</strong>) store the whole matrix in one continuous block in memory. Due to the working principle of every operating system, it is sometimes difficult to allocate a huge block in memory. Therefore, <strong>dataObject</strong> only stores the sub-matrices of the last two-dimensions in single blocks in memory, while the first <strong>n-2</strong> dimensions of the array are represented by one vector in memory, where every cell is pointing to the corresponding sub-matrix (called plane). Using this concept, huger arrays can be allocated without causing a memory error.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In order to realize a compatible version with respect to <em>numpy</em>, <em>matlab</em>… data in a <strong>DataObject</strong> can also be stored <em>continuously</em>. The basic structure for
the data object is the same than in the <em>non-continuous</em> (default) version, but the data of each 2dim-matrix lies continuously in memory and each data-pointer
of each matrix just points to the first element of the corresponding matrix in this big data block in memory.</p>
<p>The non-continuous representation has advantages especially in the case of huge data sets, since it is more difficult to obtain a free, big continuous block in memory without
reorganizing it than multiple smaller blocks of memory, which can be distributed randomly in memory.</p>
<p>Matrixes with only one or two dimension are automatically stored continuously.</p>
</div>
</div>
<div class="section" id="creating-a-dataobject">
<h2><span class="section-number">8.2.2. </span>Creating a dataObject<a class="headerlink" href="#creating-a-dataobject" title="Permalink to this headline">¶</a></h2>
<p>In general, a <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">dataObject</span></code></a> is created like any other class instance in <strong>Python</strong>, hence the constructor of class <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">dataObject</span></code></a> is called. For a full reference of the constructor of class <strong>dataObject</strong>, type</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="n">dataObject</span><span class="p">)</span>
</pre></div>
</div>
<p>In the following example, some dataObjects of different size and types are created. Using these constructors, the content of the created array is arbitrary at initialization:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">#1. empty dataObject, dimensions: 0, size: []</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">()</span>

<span class="c1">#2. one dimensional dataObject</span>
<span class="c1">#  a one dimensional dataObject already is</span>
<span class="c1">#  allocated as an array of size [1 x n]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">([</span><span class="mi">5</span><span class="p">],</span> <span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="c1">#size [1x5]</span>

<span class="c1">#3. 5 x 3 array, type: int8</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="s2">&quot;int8&quot;</span><span class="p">)</span>

<span class="c1">#4. 2 x 5 x 10 array, type: complex128</span>
<span class="c1">#  here two planes of size [5x10] are created and a vector with two items points to them</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="s2">&quot;complex128&quot;</span><span class="p">)</span>

<span class="c1">#5. 2 x 5 x 10 array, type: complex128, continuous</span>
<span class="c1">#  This matrix has the same size and type than matrix</span>
<span class="c1">#  &#39;d&#39; above. However, the continuous keyword indicates,</span>
<span class="c1">#  that python should already allocate all planes in</span>
<span class="c1">#  one block. Then the data object can be converted in</span>
<span class="c1">#  a numpy.array without the need of copying the data block</span>
<span class="c1">#  in memory. It is useful to use this keyword, if you</span>
<span class="c1">#  often want to switch between dataObject and numpy.arrays.</span>
<span class="c1">#  However consider that this is not recommended for huge</span>
<span class="c1">#  matrices.</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="s2">&quot;complex128&quot;</span><span class="p">,</span> <span class="n">continuous</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

<span class="c1">#6. create a 2x3, uint16 dataObject filled with [[1,2,3],[4,5,6]]</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="s2">&quot;uint16&quot;</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>You can also use the copy constructor of class <strong>dataObject</strong> in order to create
a dataObject from another array-like object or a sequence of numbers (tuple, list…).
In <strong>Python</strong> it is usual, that different objects share their memory (for arrays the memory
is mainly the data block(s)) as long as possible, such that memory and execution time is saved. This is also the case when using the copy constructor. See the <strong>Numpy</strong> documentation for more information about this. The main thing you should know is, that if you change the value of any cell of an array, the corresponding value is also changed in all arrays, that share their memory with the dataObject.</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="c1">#1. create dataObject from any array-like object (e.g. Numpy array)</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1">#b has the continuous flag set</span>

<span class="c1">#2. create dataObject from a tuple of values</span>
<span class="c1">#  any object, that python can interpret as sequence can be used</span>
<span class="c1">#  in order to initialize the data object. The dataObject can have</span>
<span class="c1">#  an arbitrary size or number of dimensions, if the total number</span>
<span class="c1">#  of elements fits to the length of the given input sequence.</span>
<span class="c1">#  In this case, the sequence is totally copied into the data object.</span>
<span class="c1">#  The values are filled row-by-row into the array, also called as</span>
<span class="c1">#  c-continuous creation.</span>
<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#8 values</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">data</span> <span class="o">=</span> <span class="n">c</span><span class="p">)</span>

<span class="c1">#3. create a dataObject as shallow copy of another dataObject</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="static-constructors-for-dataobjects">
<h2><span class="section-number">8.2.3. </span>Static constructors for dataObjects<a class="headerlink" href="#static-constructors-for-dataobjects" title="Permalink to this headline">¶</a></h2>
<p>If a <strong>dataObject</strong> is created using one of the default constructors (without keyword <em>data</em>), the matrix is allocated to the right
side but the values usually have no defined content. The values are even not randomly distributed. In order to generate a pre-filled
<strong>dataObject</strong>, there exist some special static methods. These are:</p>
<ul class="simple">
<li><p>Use <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject.eye" title="itom.dataObject.eye"><code class="xref py py-meth docutils literal notranslate"><span class="pre">eye()</span></code></a> to create a 2D, square, eye matrix.</p></li>
<li><p><a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject.ones" title="itom.dataObject.ones"><code class="xref py py-meth docutils literal notranslate"><span class="pre">ones()</span></code></a> is used to created a n-dimensional dataObject filled with ones.</p></li>
<li><p><a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject.zeros" title="itom.dataObject.zeros"><code class="xref py py-meth docutils literal notranslate"><span class="pre">zeros()</span></code></a> is used to created a n-dimensional dataObject filled with zeros.</p></li>
<li><p><a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject.rand" title="itom.dataObject.rand"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rand()</span></code></a> is used to created a n-dimensional dataObject filled with uniformly distributed random values: range [0,1) for floating point values, else the values are taken from the entire value range of the data type.</p></li>
<li><p><a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject.randN" title="itom.dataObject.randN"><code class="xref py py-meth docutils literal notranslate"><span class="pre">randN()</span></code></a> is used to created a n-dimensional dataObject filled with gaussian distributed random values.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">data</span><span class="p">()</span>
<span class="c1">#returns:</span>
<span class="c1">#dataObject(size=[3x4], dtype=&#39;uint8&#39;</span>
<span class="c1">#    [[  1,   1,   1,   1],</span>
<span class="c1">#     [  1,   1,   1,   1],</span>
<span class="c1">#     [  1,   1,   1,   1]])</span>
</pre></div>
</div>
</div>
<div class="section" id="print-content-of-dataobject">
<h2><span class="section-number">8.2.4. </span>Print content of dataObject<a class="headerlink" href="#print-content-of-dataobject" title="Permalink to this headline">¶</a></h2>
<p>If you type the variable name of a <strong>dataObject</strong> into the command line of <strong>itom</strong> and press return, the short string representation with all important
facts of the dataObject are printed in one line. This is the same result than using the <code class="xref py py-meth docutils literal notranslate"><span class="pre">print()</span></code> command of Python. If you want to obtain
the full content of a <strong>dataObject</strong> in the command line, use the method <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject.data" title="itom.dataObject.data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">data()</span></code></a>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="c1">#returns:</span>
<span class="c1">#dataObject(&#39;uint8&#39;, [3 x 4], continuous: 1, owndata: 1)</span>

<span class="n">a</span><span class="o">.</span><span class="n">data</span><span class="p">()</span>
<span class="c1">#returns:</span>
<span class="c1">#dataObject(size=[3x4], dtype=&#39;uint8&#39;</span>
<span class="c1">#    [[  1,   1,   1,   1],</span>
<span class="c1">#     [  1,   1,   1,   1],</span>
<span class="c1">#     [  1,   1,   1,   1]])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The string representation (using the <code class="xref py py-meth docutils literal notranslate"><span class="pre">print()</span></code> method) of a numpy array will print the full or cropped content of the numpy array
to the command line (cropped if it is too big). For <strong>dataObjects</strong>, the content is only print using the <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject.data" title="itom.dataObject.data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">data()</span></code></a> method.</p>
</div>
</div>
<div class="section" id="accessing-values-in-a-dataobject">
<h2><span class="section-number">8.2.5. </span>Accessing values in a dataObject<a class="headerlink" href="#accessing-values-in-a-dataobject" title="Permalink to this headline">¶</a></h2>
<p>In order to read or write single values of a dataObject, use the indexing operator:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;first element&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;last line:&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="c1">#write 5 to the first value:</span>
<span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
<p>The index operator obtains <em>n</em> comma separated arguments, one for each axis. Each index starts with <em>0</em>, the order of axes is <em>y,x</em>, <em>z,y,x</em>, …</p>
<p>A dataObject is an iteratible object in Python, like lists, tuples, numpy.arrays, … Therefore, it is possible to iterate through all values of
a dataObject, whereas the iterator at first goes along the last axis (x), then along the second axis (y) and so on:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;uint8&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">))</span>
<span class="n">a</span><span class="o">.</span><span class="n">data</span><span class="p">()</span>

<span class="sd">&#39;&#39;&#39;returns:</span>
<span class="sd">dataObject(size=[2x3x2], dtype=&#39;uint8&#39;</span>
<span class="sd">[0,:,:]-&gt;([[  1,   2],</span>
<span class="sd">       [  3,   4],</span>
<span class="sd">       [  5,   6]])</span>
<span class="sd">[1,:,:]-&gt;([[  7,   8],</span>
<span class="sd">       [  9,  10],</span>
<span class="sd">       [ 11,  12]])</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="sd">&#39;&#39;&#39;returns:</span>
<span class="sd">1,2,3,4,5,6,7,8,9,10,11,12</span>
<span class="sd">&#39;&#39;&#39;</span>
</pre></div>
</div>
<p>All fixed-point data types are represented by the python type <em>int</em>, all real floating point data types by <em>float</em>, the complex data types by <em>complex</em> and
the color type by <a class="reference internal" href="../09_reference/rgba.html#itom.rgba" title="itom.rgba"><code class="xref py py-class docutils literal notranslate"><span class="pre">rgba</span></code></a>.</p>
<p>It is not only possible to address single values within a dataObject, but the index (or mapping) operator also allows the usage of slices. Then, sub-regions
of dataObjects can be returned in terms of another dataObject instance. However, it is very important to mention, that a slice or sub-region shares its data memory
with the original object. Once you change one value in the original or sliced object, the corresponding value is also changed in all related objects. This is the
main philosophy of Python and also holds for numpy.arrays.</p>
<p>Considering slices, the index of any axis in the indexing or mapping operator can then have the following forms:</p>
<ul class="simple">
<li><p>single, zero-based integer value: Only the one value in the corresponding axis is addressed</p></li>
<li><p>start:end: A range of values in the corresponding axis is addressed, where start is the first, zero-based index that is included in the range and end is the last value that is NOT part of the range (excluded).</p></li>
<li><p>colon operator (:): All values in this axis are addressed.</p></li>
</ul>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">15</span><span class="p">])</span>

<span class="c1">#get subpart</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="c1">#b then has the size [5,20,1]</span>

<span class="c1">#set all values in b to 0:</span>
<span class="n">b</span><span class="p">[:,:,:]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="c1">#-&gt; 1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="c1">#-&gt; 0</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="c1">#-&gt; 0</span>
</pre></div>
</div>
</div>
<div class="section" id="basic-attributes-of-a-dataobject">
<h2><span class="section-number">8.2.6. </span>Basic attributes of a dataObject<a class="headerlink" href="#basic-attributes-of-a-dataobject" title="Permalink to this headline">¶</a></h2>
<p>Any created <strong>dataObject</strong> provides some basic attributes that describe the corresponding array:</p>
<ul class="simple">
<li><p>The attribute <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject.ndim" title="itom.dataObject.ndim"><code class="xref py py-attr docutils literal notranslate"><span class="pre">ndim</span></code></a> or <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject.dims" title="itom.dataObject.dims"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dims</span></code></a> return the number of dimensions of the  <strong>dataObject</strong>.</p></li>
<li><p>The attribute <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject.shape" title="itom.dataObject.shape"><code class="xref py py-attr docutils literal notranslate"><span class="pre">shape</span></code></a> returns a tuple with the size for every axis. The size of the tuple corresponds to the number of dimensions. Remember, that the order is always (y,x), (z,y,x)…</p></li>
<li><p>The attribute <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject.dtype" title="itom.dataObject.dtype"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dtype</span></code></a> returns a string with the type of the <strong>dataObject</strong> (e.g. uint8, float32 or complex64).</p></li>
<li><p>The attribute <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject.continuous" title="itom.dataObject.continuous"><code class="xref py py-attr docutils literal notranslate"><span class="pre">continuous</span></code></a> returns True if the data block lies continuously in memory or not (False). False is only possible for 3 or higher dimensional dataObjects. Then, the memory of the single planes lies distributed at different locations in the memory allowing to save bigger matrices in the available memory. While a continuous dataObject can share its memory with a numpy array, a non-continuous dataObject has to be converted in the continuous version before being transmitted to a numpy array (this is implicitely done).</p></li>
</ul>
<p>Examples:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="s1">&#39;uint16&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;dims:&quot;</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="s2">&quot;shape:&quot;</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;type:&quot;</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="c1">#returns:</span>
<span class="c1">#dims: 4 shape: (5, 4, 3, 2) type: uint16</span>
</pre></div>
</div>
</div>
<div class="section" id="value-and-axes-descriptions-units-scaling-and-offset">
<h2><span class="section-number">8.2.7. </span>Value and axes descriptions, units, scaling and offset<a class="headerlink" href="#value-and-axes-descriptions-units-scaling-and-offset" title="Permalink to this headline">¶</a></h2>
<p>Usually, <strong>dataObjects</strong> and numpy arrays are quite similar and very compatible to each other. They can even share memory (if continuous) and dataObjects can usually be
used whenever a function requires an <strong>array-like</strong> input type (the class <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">dataObject</span></code></a> implements the <strong>array-like</strong> interface definitions). However, the
<strong>dataObject</strong> has been made in order to also save protocol information, meta information as well as the physical meaning of the matrix. As one powerful feature, it is possible
to set an arbitrary description, unit, scaling and offset to all axes as well as a description and unit to the values. If a <strong>dataObject</strong> is plot (e.g. by <a class="reference internal" href="../09_reference/itom_general.html#itom.plot" title="itom.plot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itom.plot()</span></code></a>),
these properties are read and considered in the plot.</p>
<p>In detail:</p>
<ul class="simple">
<li><p>Every axis as well as the value axis can have a description (e.g. ‘length’)</p></li>
<li><p>Every axis as well as the value axis can have a unit (e.g. ‘mm’, ‘m’, ‘nm’…). Some algorithms consider these units for special calculations.</p></li>
<li><p>Every axis (but not the value axis) can have a scaling (default: 1.0)</p></li>
<li><p>Every axis (but not the value axis) can have an offset (default: 0.0)</p></li>
</ul>
<p>Scaling and offset transform the pixel coordinate in the matrix (beginning with 0 in all axes) into a physical coordinate. While the values in a matrix are always addressed
by their pixel coordinate (in integer values), the physical units are displayed in the plots (e.g. designer widget type <em>itom1dqwtplot</em> or <em>itom2dqwtplot</em>). The following
example should explain the advantage of the scaling and offset values:</p>
<p>Lets assume that a white-light interferometer records a 2.5D topography of an object. The distance between two adjacent pixels in 2.5 µm in both directions. Additionally, the
start position of the x-y-stage is (20.5 mm and 47.7 mm in x and y direction, respectively). These values can then be considered in the obtained <strong>dataObject</strong> by the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># coding=iso-8859-15</span>
<span class="c1"># the coding is important due to the micron sign below</span>

<span class="n">record</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">randN</span><span class="p">([</span><span class="mi">768</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="c1">#record is assumed to be a dataObject</span>
<span class="n">record</span><span class="o">.</span><span class="n">axisScales</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0025</span><span class="p">,</span> <span class="mf">0.0025</span><span class="p">)</span>
<span class="n">record</span><span class="o">.</span><span class="n">axisOffsets</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">47.7</span> <span class="o">/</span> <span class="mf">0.0025</span><span class="p">,</span> <span class="o">-</span><span class="mf">20.5</span> <span class="o">/</span> <span class="mf">0.0025</span><span class="p">)</span> <span class="c1">#offset is given in pixel</span>
<span class="n">record</span><span class="o">.</span><span class="n">axisUnits</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;mm&#39;</span><span class="p">,</span> <span class="s1">&#39;mm&#39;</span><span class="p">)</span>
<span class="n">record</span><span class="o">.</span><span class="n">axisDescriptions</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">record</span><span class="o">.</span><span class="n">valueUnit</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;µm&#39;</span><span class="p">)</span>
<span class="n">record</span><span class="o">.</span><span class="n">valueDescription</span> <span class="o">=</span> <span class="s1">&#39;height&#39;</span>
<span class="n">plot</span><span class="p">(</span><span class="n">record</span><span class="p">)</span>
</pre></div>
</div>
<p>The output is then:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/plotDataObjectScaleOffset.png"><img alt="../_images/plotDataObjectScaleOffset.png" src="../_images/plotDataObjectScaleOffset.png" style="width: 591.0px; height: 295.0px;" /></a>
</div>
<p>The relation between pixel coordinates and the physical coordinates is:</p>
<p>phys = (pix - offset) * scaling</p>
<p>pix = phys / scaling + offset</p>
<p>These transformations can be done using the methods <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject.physToPix" title="itom.dataObject.physToPix"><code class="xref py py-meth docutils literal notranslate"><span class="pre">physToPix()</span></code></a> and <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject.pixToPhys" title="itom.dataObject.pixToPhys"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pixToPhys()</span></code></a>.</p>
</div>
<div class="section" id="meta-tags-and-protocol">
<h2><span class="section-number">8.2.8. </span>Meta tags and protocol<a class="headerlink" href="#meta-tags-and-protocol" title="Permalink to this headline">¶</a></h2>
<p>It is often required to store further meta information together with a dataObject. For this purpose, the dataObject provides arbitrary meta tags (either string or double values) or a
string based protocol list. While the first can be used to store timestamps, system configurations, calibration states, … the latter can be used to document filter chains that have
already be executed.</p>
<p>Tags are always a mapping between a string-keyword and either a double or string value. The class <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">itom.dataObject</span></code></a> provides several functions and attributes in order
to set or read tags:</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">obj</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="s1">&#39;float32&#39;</span><span class="p">)</span>
<span class="c1">#add new tags:</span>
<span class="n">obj</span><span class="o">.</span><span class="n">setTag</span><span class="p">(</span><span class="s2">&quot;sensor&quot;</span><span class="p">,</span> <span class="s2">&quot;confocal sensor v1.0&quot;</span><span class="p">)</span>
<span class="n">obj</span><span class="o">.</span><span class="n">setTag</span><span class="p">(</span><span class="s2">&quot;aperture&quot;</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)</span>

<span class="c1">#get tags:</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;aperture:&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s2">&quot;aperture&quot;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sensor:&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s2">&quot;sensor&quot;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;num tags:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">tags</span><span class="p">))</span>

<span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">existTag</span><span class="p">(</span><span class="s2">&quot;manufacturer&quot;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The tag &#39;manufacturer&#39; exists&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The tag &#39;manufacturer&#39; does not exist&quot;</span><span class="p">)</span>

<span class="c1">#delete tag</span>
<span class="n">success</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">deleteTag</span><span class="p">(</span><span class="s2">&quot;aperture&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;success:&quot;</span><span class="p">,</span> <span class="n">success</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>The output will be:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">aperture</span><span class="p">:</span> <span class="mf">0.6</span>
<span class="n">sensor</span><span class="p">:</span> <span class="n">confocal</span> <span class="n">sensor</span> <span class="n">v1</span><span class="o">.</span><span class="mi">0</span>
<span class="n">num</span> <span class="n">tags</span><span class="p">:</span> <span class="mi">2</span>
<span class="n">success</span><span class="p">:</span> <span class="kc">True</span>
</pre></div>
</div>
<p>One special tag is the ‘title’-tag. If you plot a dataObject with a string-based ‘title’-tag (e.g. with <em>itom1dqwtplot</em> or <em>itom2dqwtplot</em>), the title tag
will be used as title for the plot (if the property <em>title</em> of the plot is set to <strong>&lt;auto&gt;</strong>):</p>
<div class="highlight-python notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="n">obj</span><span class="o">.</span><span class="n">setTag</span><span class="p">(</span><span class="s2">&quot;title&quot;</span><span class="p">,</span> <span class="s2">&quot;User-defined title&quot;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;2D&quot;</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>This code will lead to the following plot (under the assumption, that the designer plugin <strong>itom2dqwtplot</strong> is set as default 2D plot in the <a class="reference internal" href="../04_itom_gui/propertyDialog.html#gui-default-plots"><span class="std std-ref">properties dialog</span></a>
of <strong>itom</strong>):</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/plotDataObjectTitle.png"><img alt="../_images/plotDataObjectTitle.png" src="../_images/plotDataObjectTitle.png" style="width: 712.0px; height: 266.0px;" /></a>
</div>
<p>Another special tag is only important for 1D-plots (using the designer plugin <strong>itom1dqwtplot</strong>). You can then set the legend titles for every single curve.
This is done by the tag <strong>legendTitleX</strong> where X is a continuous line index starting with 0. The following example shows how to create a 2D dataObject
with two rows and 100 columns. In the first line (row 0), a sine with an amplitude of 127 is created, in the second line (row 1), a sine with an amplitude of 60.
Then, the dataObject is plot as 1D plot (indicated by “1D”) and the property <strong>legendPosition</strong> is set to <strong>Right</strong> (per default, no legend is shown):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">dataObject</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">],</span><span class="s1">&#39;int8&#39;</span><span class="p">)</span>
<span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">127</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">)]</span>
<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">60</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">15</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">)]</span>
<span class="n">a</span><span class="o">.</span><span class="n">setTag</span><span class="p">(</span><span class="s2">&quot;legendTitle0&quot;</span><span class="p">,</span> <span class="s2">&quot;first line&quot;</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">setTag</span><span class="p">(</span><span class="s2">&quot;legendTitle1&quot;</span><span class="p">,</span> <span class="s2">&quot;second line&quot;</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;1D&quot;</span><span class="p">,</span> <span class="n">properties</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;legendPosition&quot;</span><span class="p">:</span><span class="s2">&quot;Right&quot;</span><span class="p">})</span>
</pre></div>
</div>
<p>The result looks like this:</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="../_images/plotDataObjectLegend.png"><img alt="../_images/plotDataObjectLegend.png" src="../_images/plotDataObjectLegend.png" style="width: 605.0px; height: 351.0px;" /></a>
</div>
<p>The attribute <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject.tags" title="itom.dataObject.tags"><code class="xref py py-attr docutils literal notranslate"><span class="pre">tags</span></code></a> returns a mapping object to a dictionary. This has to be considered to be a read-only dictionary, where no item can be deleted, appended
or changed. However, it is possible to assign a new dictionary to this attribute. Then, all current tags are deleted and the new dictionary items are considered to be the new tags.</p>
<p>The protocol of a dataObject is a list of strings. Use the method <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject.addToProtocol" title="itom.dataObject.addToProtocol"><code class="xref py py-meth docutils literal notranslate"><span class="pre">addToProtocol()</span></code></a> in order to add a new entry to the protocol. If the dataObject is
a slice of another object, the string <strong>ROI[…]</strong> with the current slice parameters is prepended to each new protocol entry. Finally, the protocol is stored as tag <strong>protocol</strong>
and can be requested and deleted using the methods described above.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is not possible to set tags or protocol entries for empty dataObjects. Tags and the protocol is shared between two shallow copies, hence, if two dataObjects share the same
data, they also share their tags and protocol.</p>
</div>
</div>
<div class="section" id="dataobject-vs-numpy-array">
<span id="itomdataobjectvsnumpyarray"></span><h2><span class="section-number">8.2.9. </span>DataObject vs. Numpy.array<a class="headerlink" href="#dataobject-vs-numpy-array" title="Permalink to this headline">¶</a></h2>
<p>The most common Python package that is used for numeric calculations is <strong>Numpy</strong>. <strong>Numpy</strong> is one of the most famous and used Python packages and is the basis
for other packages, like Scipy, Matplotlib, Scikit-image, … Numpy is directly included in <strong>itom</strong> and also connected to some features of the GUI. Nevertheless,
the main array structure of <strong>itom</strong> is the class <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">dataObject</span></code></a> and not <code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.array</span></code>. The main reason for this is, that the basis of <strong>dataObject</strong>
is a C++ class with the same name that can be used in all plugins. Further points for the class <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">dataObject</span></code></a> are:</p>
<ul class="simple">
<li><p>Numpy arrays are always stored in one continuous block in memory. This is a compact and fast structure, however huge matrices can easily run into memory errors, since the computer may have free memory, however probably not in one single block in memory. Therefore, a dataObject usually stores every plane (this is every 2d array of the last two dimensions (x-y-plane)) in one block, whereas all planes lie at arbitrary positions in memory. This is only the case, if the dataObject is created as non-continuous object (see constructor of <a class="reference internal" href="../09_reference/dataObject.html#itom.dataObject" title="itom.dataObject"><code class="xref py py-class docutils literal notranslate"><span class="pre">dataObject</span></code></a>). 2D dataObjects are always continuous.</p></li>
<li><p>DataObjects are also created with respect to measurement data. Therefore, dataObjects have further meta information, like stated in the sections above.</p></li>
<li><p>Internally, every plane in a DataObject is based on OpenCV matrices (in the C++ code). Therefore, it is directly possible to apply OpenCV methods to DataObjects. Furthermore, a direct</p></li>
</ul>
<p>use of dataObjects, created in Python, in algorithms or hardware plugins is possible.</p>
<p>Despite the stated differences, the good is, that the classes <em>dataObject</em> and <em>numpy.array</em> are compatible to each other. This is especially the case for continuous dataObjects.
They can directly be converted to and from <em>numpy.arrays</em> even as shallow copy, such that both objects share the same matrix memory. If a 3- or higher dimensional dataObject is converted to a numpy-array, it is implicitly converted to a continuous form (such that all planes lie in adjacent blocks in the memory).</p>
<p>Examples for these conversions are:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">dobj2d</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
<span class="n">np2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dobj2d</span><span class="p">)</span> <span class="c1">#deep copy</span>
<span class="n">np2d_v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dobj2d</span><span class="p">,</span> <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="c1">#shallow copy</span>
<span class="n">dobj2d_v2</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">(</span><span class="n">np2d</span><span class="p">)</span> <span class="c1">#shallow copy</span>

<span class="n">dobj3d</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">],</span> <span class="s1">&#39;uint8&#39;</span><span class="p">)</span> <span class="c1">#non-continuous</span>
<span class="n">np3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dobj3d</span><span class="p">,</span> <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="c1">#deep copy, since implicit continuous conversion</span>
<span class="n">dobj3d_v2</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">(</span><span class="n">np3d</span><span class="p">)</span> <span class="c1">#shallow copy of np3d</span>

<span class="n">dobj3d2</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">],</span> <span class="s1">&#39;uint8&#39;</span><span class="p">,</span> <span class="n">continuous</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">np3d2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dobj3d2</span><span class="p">,</span> <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="c1">#shallow copy</span>
<span class="n">dobj3d2_v2</span> <span class="o">=</span> <span class="n">dataObject</span><span class="p">(</span><span class="n">np3d2</span><span class="p">)</span>
</pre></div>
</div>
<p>In order to understand these examples, the following things have to be mentioned or repeated: Per default, a <em>dataObject</em> with more than two dimensions is created as non-continuous
dataObject, hence various planes (the 2d matrix spanned by the last two axes) are distributed at different locations in memory. If passing a dataObject to the constructor of a numpy.array
a deep copy is created per default. Deep copy means, that the array data is entirely copied to another location in memory, such that both arrays are completely de-coupled. This is
not the case if the optional parameter <em>copy</em> of the <em>np.array</em> constructor is set to <em>False</em>. If possible, a so called shallow copy is then created such that as little as
memory has to be copied. This is the default for most python operations! If both objects are a shallow copy of each other, a change of one value in the one object also changes the other object. However, only values are changed, never types or sizes. A shallow copy is therefore only possible if no change in type or memory structure is required. If a sub-region of an object
is copied, a shallow copy is possible. However, this is not the case if the type is changed or if a non-continuous dataObject has to be converted to a numpy.array.</p>
<p>While the copy constructor of a <em>np.array</em> usually creates a deep copy (default setting), the copy constructor of a dataObject always tries to make a shallow copy if possible.</p>
<p>Usually, all methods of Numpy not only work with <em>np.arrays</em> but also with <strong>array-like</strong> objects. These are python objects that provide a specific interface such that Numpy
can implicitely obtain a Numpy array out of them. This is also what <em>dataObject</em> provides. Therefore you can pass every dataObject to a numpy function without a previous conversion to
a numpy array.</p>
<p>On the other side, <strong>itom</strong> often supports numpy arrays without conversion to dataObject. This is for instance the case for the method <a class="reference internal" href="../09_reference/itom_general.html#itom.plot" title="itom.plot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">itom.plot()</span></code></a>. Only, when passing arrays
to algorithm or hardware plugins (classes <a class="reference internal" href="../09_reference/dataIO.html#itom.dataIO" title="itom.dataIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">dataIO</span></code></a> or <a class="reference internal" href="../09_reference/actuator.html#itom.actuator" title="itom.actuator"><code class="xref py py-class docutils literal notranslate"><span class="pre">actuator</span></code></a>, method <a class="reference internal" href="../09_reference/itom_general.html#itom.filter" title="itom.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">filter()</span></code></a>), usually numpy.arrays have to be converted to
dataObjects:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="n">a</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">itom</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="n">itom</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1">#works</span>
<span class="n">itom</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="s2">&quot;minValue&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="c1">#raises an error</span>
<span class="n">itom</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="s2">&quot;minValue&quot;</span><span class="p">,</span> <span class="n">itom</span><span class="o">.</span><span class="n">dataObject</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="c1">#works</span>
</pre></div>
</div>
</div>
<div class="section" id="main-operations-on-numpy-arrays-and-itom-dataobjects">
<h2><span class="section-number">8.2.10. </span>Main operations on numpy.arrays and itom.dataObjects<a class="headerlink" href="#main-operations-on-numpy-arrays-and-itom-dataobjects" title="Permalink to this headline">¶</a></h2>
<p>The following list in an extract of the itom cheatsheet (<a class="reference external" href="http://itom.bitbucket.io/media.html">http://itom.bitbucket.io/media.html</a>) and shows major operations on numpy.arrays and itom.dataObjects:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 22%" />
<col style="width: 26%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>np.array (import numpy as np)</p></th>
<th class="head"><p>itom.dataObject (import itom)</p></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>arr=np.ndarray([2,3],’uint8’)</p></td>
<td><p>dObj = dataObject([2,3],’uint8’)</p></td>
<td><p>create a randomly filled 2x3 array with type uint8</p></td>
</tr>
<tr class="row-odd"><td><p>arr=np.array([[1,2,3],[4,5,6]])</p></td>
<td><p>dObj =dataObject([2,3],data=(1,2,3,4,5,6))</p></td>
<td><p>create the 2x3 array [1,2,3 ; 4,5,6]</p></td>
</tr>
<tr class="row-even"><td><p>arr=np.array(dObj, copy = False)</p></td>
<td><p>dObj =dataObject(arr)</p></td>
<td><p>convert np.array &lt;-&gt; dataObject (shallow copy if possible)</p></td>
</tr>
<tr class="row-odd"><td><p>arr.ndim</p></td>
<td><p>dObj.ndim</p></td>
<td><p>Returns number of dimensions (here: 2)</p></td>
</tr>
<tr class="row-even"><td><p>arr.shape</p></td>
<td><p>dObj.shape</p></td>
<td><p>Returns size tuple (here: [2,3])</p></td>
</tr>
<tr class="row-odd"><td><p>arr.shape[0]</p></td>
<td><p>dObj.shape[0]</p></td>
<td><p>Returns size of first dimensions (here: y-axis)</p></td>
</tr>
<tr class="row-even"><td><p>c=arr[0,1]; arr[0,1]=7</p></td>
<td><p>dObj[0,1]; b[0,1]=7</p></td>
<td><p>Gets or sets the element in the 1st row, 2nd col</p></td>
</tr>
<tr class="row-odd"><td><p>c=arr[:,1:3] or</p></td>
<td><p>c=dObj[:,1:3] or</p></td>
<td><p>Returns shallow copy of array containing the 2nd and 3rd columns</p></td>
</tr>
<tr class="row-even"><td><p>c=arr[0:2,1:3]</p></td>
<td><p>c= dObj [0:2,1:3]</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p>arr[:,:]=7</p></td>
<td><p>dObj[:,:]=7</p></td>
<td><p>sets all values of array to value 7</p></td>
</tr>
<tr class="row-even"><td><p>arr.transpose() (shallow copy)</p></td>
<td><p>dObj.trans() (deep copy)</p></td>
<td><p>transpose of array</p></td>
</tr>
<tr class="row-odd"><td><p>np.dot(arr1,arr2)</p></td>
<td><p>dObj1 * dObj2 (float only)</p></td>
<td><p>matrix multiplication</p></td>
</tr>
<tr class="row-even"><td><p>arr1 * arr2</p></td>
<td><p>dObj1.mul(dObj2)</p></td>
<td><p>element-wise multiply</p></td>
</tr>
<tr class="row-odd"><td><p>arr1 / arr2</p></td>
<td><p>dObj1.div(dObj2)</p></td>
<td><p>element-wise divide</p></td>
</tr>
<tr class="row-even"><td><p>arr1 +,- arr2</p></td>
<td><p>dObj1 +,- dObj2</p></td>
<td><p>sum/difference of elements</p></td>
</tr>
<tr class="row-odd"><td><p>arr1 +,- scalar</p></td>
<td><p>dObj1 +,- scalar</p></td>
<td><p>adds/subtracts scalar from every element in array</p></td>
</tr>
<tr class="row-even"><td><p>arr1 &amp;,| arr2</p></td>
<td><p>dObj1 &amp;,| dObj2</p></td>
<td><p>element-wise, bitwise AND/OR operator</p></td>
</tr>
<tr class="row-odd"><td><p>arr2 = arr1</p></td>
<td><p>dObj2 = dObj1</p></td>
<td><p>referencing (both still point to the same array)</p></td>
</tr>
<tr class="row-even"><td><p>arr2 = arr1.copy()</p></td>
<td><p>dObj2 = dObj1.copy()</p></td>
<td><p>deep copy (entire data is copied)</p></td>
</tr>
<tr class="row-odd"><td><p>arr2 = arr1.astype(newtype)</p></td>
<td><p>dObj2 = dObj1.astype(‘newtypestring’)</p></td>
<td><p>type conversion</p></td>
</tr>
<tr class="row-even"><td><p>arr = np.zeros([3,4],’float32’)</p></td>
<td><p>dObj = dataObject.zeros([3,4], ‘float32’)</p></td>
<td><p>3x4 array filled with zeros of type float32</p></td>
</tr>
<tr class="row-odd"><td><p>arr = np.ones([3,4],’float32’)</p></td>
<td><p>dObj = dataObject.ones([3,4], ‘float32’)</p></td>
<td><p>3x4 array filled with ones of type float32</p></td>
</tr>
<tr class="row-even"><td><p>arr = np.eye(3,dtype=’float32’)</p></td>
<td><p>dObj = dataObject.eye(3, ‘float32’)</p></td>
<td><p>3x3 identity matrix (type: float32)</p></td>
</tr>
<tr class="row-odd"><td><p>arr2 = arr1.squeeze()</p></td>
<td><p>dObj2 = dObj1.squeeze()</p></td>
<td><p>converts array to an array where dims of size 1 are eliminated (deep copy if necessary)</p></td>
</tr>
<tr class="row-even"><td><p>np.linspace(1,3,4)</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>4 equally spaced samples between 1 and 3, inclusive</p></td>
</tr>
<tr class="row-odd"><td><p>[x,y] = np.meshgrid(0:2,1:5)</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>two 2D arrays: one of x values, the other of y values</p></td>
</tr>
<tr class="row-even"><td><p>np.linalg.inv(a)</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>inverse of square matrix a</p></td>
</tr>
<tr class="row-odd"><td><p>x=np.linalg.solve(a,b)</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>solution of ax=b (using pseudo inverse)</p></td>
</tr>
<tr class="row-even"><td><p>[U,S,V] = np.linalg.svd(a)</p></td>
<td><ul class="simple">
<li></li>
</ul>
</td>
<td><p>singular value decomposition of a (V is transposed!)</p></td>
</tr>
<tr class="row-odd"><td><p>np.fft.fft2(a), np.fft.ifft2(a)</p></td>
<td></td>
<td><p>filter available (Inverse) 2D fourier transform of a</p></td>
</tr>
<tr class="row-even"><td><p>a[a&gt;0]=5</p></td>
<td><p>a[a&gt;0] = 5</p></td>
<td><p>sets all elements &gt; 0 of a to 5</p></td>
</tr>
<tr class="row-odd"><td><p>a[np.isnan(a)]=0</p></td>
<td><p>a[np.isnan(a)]=5</p></td>
<td><p>sets all NaN values of a to 5</p></td>
</tr>
<tr class="row-even"><td><p>arr2 = arr1.reshape([3,2])</p></td>
<td><p>dObj2 = dObj1.reshape([3,2])</p></td>
<td><p>reshapes arr1 to new size (equal number of items)</p></td>
</tr>
</tbody>
</table>
<p>For a detailed methods-summery of the <em>dataObject</em> see <a class="reference internal" href="../09_reference/reference.html#itom-script-reference"><span class="std std-ref">itom Script Reference</span></a>.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="pymod-load-save-files.html" class="btn btn-neutral float-right" title="8.3. Save and load images and other files" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="pymod-itom.html" class="btn btn-neutral float-left" title="8.1. Python-Module itom" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2011-2021, Institut fuer Technische Optik (ITO), University Stuttgart. Bug report: https://bitbucket.org/itom/itom/issues.
      <span class="lastupdated">
        Last updated on Mar 05, 2021.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>