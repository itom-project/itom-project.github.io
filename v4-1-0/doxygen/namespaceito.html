<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9"/>
<title>itom: ito Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="itomLogo2_48.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">itom
   &#160;<span id="projectnumber">4.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceito.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ito Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_add_in_config_dialog.html">AbstractAddInConfigDialog</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract base class for configuration dialogs of plugins  <a href="classito_1_1_abstract_add_in_config_dialog.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_add_in_config_dialog_private.html">AbstractAddInConfigDialogPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_add_in_dock_widget.html">AbstractAddInDockWidget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract base class for dock widgets (toolboxes) of plugins  <a href="classito_1_1_abstract_add_in_dock_widget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_add_in_dock_widget_private.html">AbstractAddInDockWidgetPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_api_widget.html">AbstractApiWidget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_api_widget_private.html">AbstractApiWidgetPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_code_editor_widget.html">AbstractCodeEditorWidget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_d_obj_figure.html">AbstractDObjFigure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_d_obj_pcl_figure.html">AbstractDObjPclFigure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_dock_widget.html">AbstractDockWidget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">abstract dock widget class which inherits QDockWidget. The content of QDockWidget consists of an instance of QMainWindow. The real widget is then placed as central widget of this QMainWindow. QMainWindow has the ability to show a menubar as well as a toolbar, which is used in different versions depending on docked state. Inherit <a class="el" href="classito_1_1_abstract_dock_widget.html" title="abstract dock widget class which inherits QDockWidget. The content of QDockWidget consists of an inst...">AbstractDockWidget</a> in order to realize content of QMainWindow.  <a href="classito_1_1_abstract_dock_widget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_figure.html">AbstractFigure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_figure_private.html">AbstractFigurePrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_filter_dialog.html">AbstractFilterDialog</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_itom_designer_plugin.html">AbstractItomDesignerPlugin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_node.html">AbstractNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every plot designer plugin in itom, that should be able to open dependent sub-plots (e.g. a 1d line cut is a subplot of its 2d parent plot), must be inherited from this class <a class="el" href="classito_1_1_abstract_node.html" title="Every plot designer plugin in itom, that should be able to open dependent sub-plots (e...">AbstractNode</a>. However, <a class="el" href="classito_1_1_abstract_node.html" title="Every plot designer plugin in itom, that should be able to open dependent sub-plots (e...">AbstractNode</a> is no widget class of Qt. Therefore it is also possible to create non-visible classes derived from <a class="el" href="classito_1_1_abstract_node.html" title="Every plot designer plugin in itom, that should be able to open dependent sub-plots (e...">AbstractNode</a>. This allows creating a directed net of nodes where changes of some input parameters are propagated through all relevant sub-nodes.  <a href="classito_1_1_abstract_node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_node_private.html">AbstractNodePrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_param_property_manager.html">AbstractParamPropertyManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_param_property_manager_private.html">AbstractParamPropertyManagerPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_abstract_property_page_widget.html">AbstractPropertyPageWidget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_actuator_thread_ctrl.html">ActuatorThreadCtrl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to give plugin developers an easy access to actuators in other threads.  <a href="classito_1_1_actuator_thread_ctrl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_actuator.html">AddInActuator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for all actuator plugin classes  <a href="classito_1_1_add_in_actuator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_actuator_private.html">AddInActuatorPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_algo.html">AddInAlgo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for all "algorithm" plugin classes  <a href="classito_1_1_add_in_algo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_algo_private.html">AddInAlgoPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_base.html">AddInBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all plugins.  <a href="classito_1_1_add_in_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_base_private.html">AddInBasePrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_data_i_o.html">AddInDataIO</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for all dataIO plugin classes  <a href="classito_1_1_add_in_data_i_o.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_data_i_o_private.html">AddInDataIOPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_grabber.html">AddInGrabber</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherit from <a class="el" href="classito_1_1_add_in_grabber.html" title="Inherit from AddInGrabber if you write a camera/grabber plugin. Please call the constructor of AddInG...">AddInGrabber</a> if you write a camera/grabber plugin. Please call the constructor of <a class="el" href="classito_1_1_add_in_grabber.html" title="Inherit from AddInGrabber if you write a camera/grabber plugin. Please call the constructor of AddInG...">AddInGrabber</a> within your plugin constructor.  <a href="classito_1_1_add_in_grabber.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_grabber_private.html">AddInGrabberPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_interface_base.html">AddInInterfaceBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward declaration to private container class of AddInAlog  <a href="classito_1_1_add_in_interface_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_interface_base_private.html">AddInInterfaceBasePrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_manager.html">AddInManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class for AddIn management  <a href="classito_1_1_add_in_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_add_in_manager_private.html">AddInManagerPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_a_i_manager_widget.html">AIManagerWidget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_algo_interface_validator.html">AlgoInterfaceValidator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The class <a class="el" href="classito_1_1_algo_interface_validator.html" title="The class AlgoInterfaceValidator provides validators and checks in order to verify that a certain fil...">AlgoInterfaceValidator</a> provides validators and checks in order to verify that a certain filter or algoWidget that pretends to implement a certain interface really fits to the requirements and conditions of this interface.  <a href="classito_1_1_algo_interface_validator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_algo_interface_validator_private.html">AlgoInterfaceValidatorPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_api_functions.html">ApiFunctions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1api_functions_graph.html">apiFunctionsGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_app_management.html">AppManagement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; <a class="el" href="classito_1_1_app_management.html" title="< AppManagement (in order to provide access to basic organizers, managers and other main components t...">AppManagement</a> (in order to provide access to basic organizers, managers and other main components to every instance  <a href="classito_1_1_app_management.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_auto_indent_mode.html">AutoIndentMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_auto_interval.html">AutoInterval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class for a interval type containing a min-max-range and an auto-flag.  <a href="classito_1_1_auto_interval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_auto_interval_property.html">AutoIntervalProperty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_bookmark_dock_widget.html">BookmarkDockWidget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the bookmark toolbox which is mainly a view of the <a class="el" href="class_bookmark_model.html" title="model for management of all bookmarks. This model will be displayed by a viewer-widget in the main wi...">BookmarkModel</a>.  <a href="classito_1_1_bookmark_dock_widget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_bookmark_item.html">BookmarkItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">item of <a class="el" href="class_bookmark_model.html" title="model for management of all bookmarks. This model will be displayed by a viewer-widget in the main wi...">BookmarkModel</a>  <a href="structito_1_1_bookmark_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_break_point_dock_widget.html">BreakPointDockWidget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_break_point_item.html">BreakPointItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">item of <a class="el" href="class_break_point_model.html" title="model for management of all breakpoints. This model will be displayed by a viewer-widget in the main ...">BreakPointModel</a>  <a href="structito_1_1_break_point_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_breakpoint_panel.html">BreakpointPanel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_byte_array.html">ByteArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a Qt-free class for byte arrays (strings) without specific encoding information.  <a href="classito_1_1_byte_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_call_stack_dock_widget.html">CallStackDockWidget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">docking  <a href="classito_1_1_call_stack_dock_widget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_calltip_runnable.html">CalltipRunnable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; runnable that executes a calltip call to Jedi by the thread pool of Python Jedi Runner.  <a href="classito_1_1_calltip_runnable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_caret_line_highlighter_mode.html">CaretLineHighlighterMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_channel.html">Channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A channel defines a propagation pipline between two parameters of two nodes. The nodes are instances of the class <a class="el" href="classito_1_1_abstract_node.html" title="Every plot designer plugin in itom, that should be able to open dependent sub-plots (e...">AbstractNode</a>, which is for instance a base class of <a class="el" href="classito_1_1_abstract_figure.html">AbstractFigure</a>, and therefore each plot designer plugin in itom.  <a href="classito_1_1_channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_channel_private.html">ChannelPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_char_array_meta.html">CharArrayMeta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins ">Param</a> of type <a class="el" href="classito_1_1_char_array_meta.html" title="Meta-information for Param of type CharArrayMeta. ">CharArrayMeta</a>.  <a href="classito_1_1_char_array_meta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_char_based_fold_detector.html">CharBasedFoldDetector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_char_based_fold_detector_private.html">CharBasedFoldDetectorPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_char_meta.html">CharMeta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins ">Param</a> of type Char.  <a href="classito_1_1_char_meta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_checker_bookmark_panel.html">CheckerBookmarkPanel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_class_info_container.html">ClassInfoContainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_code_checker_item.html">CodeCheckerItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_code_completion_mode.html">CodeCompletionMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_code_editor.html">CodeEditor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_code_editor_style.html">CodeEditorStyle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_col_curve.html">ColCurve</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><blockquote class="doxtable">
<p>forward declaration </p>
</blockquote>
 <a href="classito_1_1_col_curve.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_completion_runnable.html">CompletionRunnable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; runnable that executes a completion call to Jedi by the thread pool of Python Jedi Runner.  <a href="classito_1_1_completion_runnable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1complex128__.html">complex128_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">wrapper class for a complex128 value. This class is used, since the std::complex stl class is not exported over DLLs  <a href="structito_1_1complex128__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_console_widget.html">ConsoleWidget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_i_o_thread_ctrl.html">DataIOThreadCtrl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to give plugin developers an easy access to cameras in other threads.  <a href="classito_1_1_data_i_o_thread_ctrl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object.html">DataObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">dataObject contains a n-dimensional matrix  <a href="classito_1_1_data_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object_tags_private.html">DataObjectTagsPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_data_object_tag_type.html">DataObjectTagType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant storage class for either a double or a string value.  <a href="classito_1_1_data_object_tag_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_delay_job_runner.html">DelayJobRunner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_delay_job_runner_arg_text_block.html">DelayJobRunnerArgTextBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_delay_job_runner_arg_text_cursor.html">DelayJobRunnerArgTextCursor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_delay_job_runner_base.html">DelayJobRunnerBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_delay_job_runner_generic_arg.html">DelayJobRunnerGenericArg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_delay_job_runner_no_args.html">DelayJobRunnerNoArgs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_deque_command_list.html">DequeCommandList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_designer_widget_organizer.html">DesignerWidgetOrganizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_about_q_itom.html">DialogAboutQItom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_close_itom.html">DialogCloseItom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_edit_breakpoint.html">DialogEditBreakpoint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_goto.html">DialogGoto</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_icon_browser.html">DialogIconBrowser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_loaded_plugins.html">DialogLoadedPlugins</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_new_plugin_instance.html">DialogNewPluginInstance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_open_file_with_filter.html">DialogOpenFileWithFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_open_new_gui.html">DialogOpenNewGui</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_pip_manager.html">DialogPipManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_pip_manager_install.html">DialogPipManagerInstall</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_dialog_pip_manager_install_defaults.html">DialogPipManagerInstallDefaults</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_plugin_picker.html">DialogPluginPicker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_properties.html">DialogProperties</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_reload_module.html">DialogReloadModule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_replace.html">DialogReplace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_save_file_with_filter.html">DialogSaveFileWithFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_select_user.html">DialogSelectUser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_snapshot.html">DialogSnapshot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_timer_manager.html">DialogTimerManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_user_management.html">DialogUserManagement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_user_management_edit.html">DialogUserManagementEdit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_dialog_variable_detail.html">DialogVariableDetail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_d_obj_const_iterator.html">DObjConstIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">constant iterator through data object  <a href="classito_1_1_d_obj_const_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_d_obj_iterator.html">DObjIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterator through data object  <a href="classito_1_1_d_obj_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_d_obj_meta.html">DObjMeta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins ">Param</a> of type DObjPtr.  <a href="classito_1_1_d_obj_meta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_double_array_meta.html">DoubleArrayMeta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins ">Param</a> of type <a class="el" href="classito_1_1_double_array_meta.html" title="Meta-information for Param of type DoubleArrayMeta. ">DoubleArrayMeta</a>.  <a href="classito_1_1_double_array_meta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_double_interval_meta.html">DoubleIntervalMeta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins ">Param</a> of type <a class="el" href="classito_1_1_double_interval_meta.html" title="Meta-information for Param of type DoubleIntervalMeta. ">DoubleIntervalMeta</a>.  <a href="classito_1_1_double_interval_meta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_double_meta.html">DoubleMeta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins ">ito::Param</a> of type Double.  <a href="classito_1_1_double_meta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_error_line_highlighter_mode.html">ErrorLineHighlighterMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_exec_func_params.html">ExecFuncParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_fct_call_param_container.html">FctCallParamContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">each instance of this class contains the parameters (including return parameter) for any function call, which is parsed by the Qt-signal-slot system. This class is especially used for wrapping function calls between C++ and any python method. The convention for the main member variables corresponds to the usual Qt-way to wrap such function calls.  <a href="classito_1_1_fct_call_param_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_figure_category.html">FigureCategory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_figure_plugin.html">FigurePlugin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_figure_plugin_delegate.html">FigurePluginDelegate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_figure_widget.html">FigureWidget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_file_system_dock_widget.html">FileSystemDockWidget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_filter_params.html">FilterParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_fold_detector.html">FoldDetector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_fold_detector_private.html">FoldDetectorPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_folding_panel.html">FoldingPanel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_fold_scope.html">FoldScope</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_function_cancellation_and_observer.html">FunctionCancellationAndObserver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can be passed to a long running method (e.g. as QSharedPointer instance) for two reasons:  <a href="classito_1_1_function_cancellation_and_observer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_function_cancellation_and_observer_private.html">FunctionCancellationAndObserverPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_func_weak_ref.html">FuncWeakRef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_get_help_runnable.html">GetHelpRunnable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; runnable that executes a calltip call to Jedi by the thread pool of Python Jedi Runner.  <a href="classito_1_1_get_help_runnable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_go_back_navigation_item.html">GoBackNavigationItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_go_to_assignment_runnable.html">GoToAssignmentRunnable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; runnable that executes a goto definition / assignment call to Jedi by the thread pool of Python Jedi Runner.  <a href="classito_1_1_go_to_assignment_runnable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_gui_helper.html">GuiHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_help_dock_widget.html">HelpDockWidget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_help_system.html">HelpSystem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_help_tree_dock_widget.html">HelpTreeDockWidget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_h_w_meta.html">HWMeta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins ">Param</a> of type HWPtr.  <a href="classito_1_1_h_w_meta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_indenter_mode.html">IndenterMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_indent_fold_detector.html">IndentFoldDetector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_int_array_meta.html">IntArrayMeta</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_interval_meta.html">IntervalMeta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins ">Param</a> of type <a class="el" href="classito_1_1_int_array_meta.html">IntArrayMeta</a> that represent an interval [minimum, maximum).  <a href="classito_1_1_interval_meta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_int_meta.html">IntMeta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins ">Param</a> of type Int.  <a href="classito_1_1_int_meta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_i_o_helper.html">IOHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains several static methods to load or save various file formats.  <a href="classito_1_1_i_o_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_itom_editor_factory_private.html">ItomEditorFactoryPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_itom_file_system_model.html">ItomFileSystemModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instead of the default QFileSystemModel, this model is able to provide a more flexible support for drop or paste operations if the destination file already exists. If the file should be duplicated (from one folder to the same folder), a (copy)-suffix is appended to the base-filename. If the source is another directory, but the file has the same name, the user is prompted if he wants to overwrite the source file or not.  <a href="classito_1_1_itom_file_system_model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_palette.html">ItomPalette</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_itom_palette_base.html">ItomPaletteBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_param_helper.html">ItomParamHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_param_helper_3_01char_01_4.html">ItomParamHelper&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_param_helper_3_01complex128_01_4.html">ItomParamHelper&lt; complex128 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_param_helper_3_01float64_01_4.html">ItomParamHelper&lt; float64 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_param_helper_3_01int32_01_4.html">ItomParamHelper&lt; int32 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_itom_param_helper_3_01unsigned_01char_01_4.html">ItomParamHelper&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_itom_plot_handle.html">ItomPlotHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class for a interval type containing the plot handle / unique id and name.  <a href="classito_1_1_itom_plot_handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_itom_spin_box.html">ItomSpinBox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_jedi_assignment.html">JediAssignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_jedi_assignment_request.html">JediAssignmentRequest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_jedi_calltip.html">JediCalltip</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_jedi_calltip_request.html">JediCalltipRequest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_jedi_completion.html">JediCompletion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_jedi_completion_request.html">JediCompletionRequest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_jedi_get_help.html">JediGetHelp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_jedi_get_help_request.html">JediGetHelpRequest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_jedi_runnable.html">JediRunnable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; base class for all runnables, that are executed with <a class="el" href="classito_1_1_python_jedi_runner.html" title="< Thread-safe helper class for PythonEngine to manage calls to the Python Jedi package. ">PythonJediRunner</a>  <a href="classito_1_1_jedi_runnable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_last_command_dock_widget.html">LastCommandDockWidget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_last_command_tree_widget.html">LastCommandTreeWidget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_leaf_filter_proxy_model.html">LeafFilterProxyModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a special search function to the help model. The normal filtermodel hides nodes if they don't contain the searched term, even though the children contain it.  <a href="classito_1_1_leaf_filter_proxy_model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_line_background_marker_mode.html">LineBackgroundMarkerMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_line_edit_delegate.html">LineEditDelegate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_line_number_panel.html">LineNumberPanel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_main_application.html">MainApplication</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classito_1_1_main_application.html" title="The MainApplication class is the basic management class for the entire application. ">MainApplication</a> class is the basic management class for the entire application.  <a href="classito_1_1_main_application.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_main_window.html">MainWindow</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_manager.html">Manager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_menu_only_for_enter.html">MenuOnlyForEnter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_method_description.html">MethodDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small wrapper class with all necessary information for any method, signal or slot of class which should be inherited from QObject*.  <a href="classito_1_1_method_description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_mode.html">Mode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_modes_manager.html">ModesManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_occurrences_highlighter_mode.html">OccurrencesHighlighterMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_outline_item.html">OutlineItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_outline_selector_widget.html">OutlineSelectorWidget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">framless dialog, shown as popup over a script editor, to display the outline.  <a href="classito_1_1_outline_selector_widget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_palette_organizer.html">PaletteOrganizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_panel.html">Panel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_panels_manager.html">PanelsManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param.html">Param</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class for parameter handling e.g. to pass paramters to plugins  <a href="classito_1_1_param.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_base.html">ParamBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_char_array_property_manager.html">ParamCharArrayPropertyManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_char_array_property_manager_private.html">ParamCharArrayPropertyManagerPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_char_property_factory.html">ParamCharPropertyFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_char_property_factory_private.html">ParamCharPropertyFactoryPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_char_property_manager.html">ParamCharPropertyManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_char_widget.html">ParamCharWidget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_char_widget_private.html">ParamCharWidgetPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_double_array_property_manager.html">ParamDoubleArrayPropertyManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_double_array_property_manager_private.html">ParamDoubleArrayPropertyManagerPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_double_property_factory.html">ParamDoublePropertyFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classito_1_1_param_double_property_factory.html" title="The ParamDoublePropertyFactory class provides QSpinBox widgets for properties created by QtIntPropert...">ParamDoublePropertyFactory</a> class provides QSpinBox widgets for properties created by <a class="el" href="class_qt_int_property_manager.html" title="The QtIntPropertyManager provides and manages int properties. ">QtIntPropertyManager</a> objects.  <a href="classito_1_1_param_double_property_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_double_property_factory_private.html">ParamDoublePropertyFactoryPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_double_property_manager.html">ParamDoublePropertyManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_double_widget.html">ParamDoubleWidget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_double_widget_private.html">ParamDoubleWidgetPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_helper.html">ParamHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_input_dialog.html">ParamInputDialog</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_input_parser.html">ParamInputParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_int_array_property_manager.html">ParamIntArrayPropertyManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_int_array_property_manager_private.html">ParamIntArrayPropertyManagerPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_interval_property_factory.html">ParamIntervalPropertyFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classito_1_1_param_interval_property_factory.html" title="The ParamIntervalPropertyFactory class provides RangeWidget widgets for properties created by ParamIn...">ParamIntervalPropertyFactory</a> class provides <a class="el" href="class_range_widget.html">RangeWidget</a> widgets for properties created by <a class="el" href="classito_1_1_param_interval_property_manager.html">ParamIntervalPropertyManager</a> objects.  <a href="classito_1_1_param_interval_property_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_interval_property_factory_private.html">ParamIntervalPropertyFactoryPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_interval_property_manager.html">ParamIntervalPropertyManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_int_property_factory.html">ParamIntPropertyFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_int_property_factory_private.html">ParamIntPropertyFactoryPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_int_property_manager.html">ParamIntPropertyManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_int_widget.html">ParamIntWidget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_int_widget_private.html">ParamIntWidgetPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_meta.html">ParamMeta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all meta-information classes.  <a href="classito_1_1_param_meta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_other_property_manager.html">ParamOtherPropertyManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_rect_property_manager.html">ParamRectPropertyManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_rect_property_manager_private.html">ParamRectPropertyManagerPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_string_property_factory.html">ParamStringPropertyFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classito_1_1_param_string_property_factory.html" title="The ParamStringPropertyFactory class provides QLineEdit widgets for properties created by ParamString...">ParamStringPropertyFactory</a> class provides QLineEdit widgets for properties created by <a class="el" href="classito_1_1_param_string_property_manager.html">ParamStringPropertyManager</a> objects.  <a href="classito_1_1_param_string_property_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_string_property_factory_private.html">ParamStringPropertyFactoryPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_string_property_manager.html">ParamStringPropertyManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_string_widget.html">ParamStringWidget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_param_string_widget_private.html">ParamStringWidgetPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_p_c_l_point.html">PCLPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">generic class that covers one single point of different possible types provided by the Point Cloud Library (PCL).  <a href="classito_1_1_p_c_l_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_p_c_l_point_cloud.html">PCLPointCloud</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">generic class that covers one single point cloud of different possible types provided by the Point Cloud Library (PCL).  <a href="classito_1_1_p_c_l_point_cloud.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_p_c_l_polygon_mesh.html">PCLPolygonMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">generic class that covers a shared pointer to pcl::PolygonMesh that is a class for a polygonal mesh provided by the point cloud library (PCL)  <a href="classito_1_1_p_c_l_polygon_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_picker_sort_filter_proxy_model.html">PickerSortFilterProxyModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_pip_general_options.html">PipGeneralOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_pip_install.html">PipInstall</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_pip_manager.html">PipManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_plugin_info.html">PluginInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_plugin_load_status.html">PluginLoadStatus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct provides a structure for saving the load status of any plugins or designerWidgets.  <a href="structito_1_1_plugin_load_status.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_plug_in_model.html">PlugInModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class for visualizing the available (loaded) plugins  <a href="classito_1_1_plug_in_model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_plug_in_model_private.html">PlugInModelPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_plugin_thread_ctrl.html">PluginThreadCtrl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classito_1_1_data_i_o_thread_ctrl.html" title="Helper class to give plugin developers an easy access to cameras in other threads. ">DataIOThreadCtrl</a> and <a class="el" href="classito_1_1_actuator_thread_ctrl.html" title="Helper class to give plugin developers an easy access to actuators in other threads. ">ActuatorThreadCtrl</a>.  <a href="classito_1_1_plugin_thread_ctrl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_process_organizer.html">ProcessOrganizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_py_assignment.html">PyAssignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_py_auto_indent_mode.html">PyAutoIndentMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_py_calltips_mode.html">PyCalltipsMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_py_c_map.html">PyCMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; the following map translates Qt/C++ datatypes into their Python representations. This is for instance used in the info()-method in Python to show the user the Python syntax.  <a href="structito_1_1_py_c_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_py_code_formatter.html">PyCodeFormatter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_py_docstring_generator_mode.html">PyDocstringGeneratorMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_py_goto_assignment_mode.html">PyGotoAssignmentMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_py_stream.html">PyStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">static class which implements a new python type. The members cout and cerr of the python system are set to variables of this type <a class="el" href="classito_1_1_py_stream.html" title="static class which implements a new python type. The members cout and cerr of the python system are s...">PyStream</a> in order to observe the python's <em>cout</em> and <em>cerr</em> stream and to transmit the stream's content to the main application.  <a href="classito_1_1_py_stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_auto_interval.html">PythonAutoInterval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_common.html">PythonCommon</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_data_object.html">PythonDataObject</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_engine.html">PythonEngine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_figure.html">PythonFigure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_font.html">PythonFont</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_itom.html">PythonItom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_jedi_runner.html">PythonJediRunner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Thread-safe helper class for <a class="el" href="classito_1_1_python_engine.html">PythonEngine</a> to manage calls to the Python Jedi package.  <a href="classito_1_1_python_jedi_runner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_message_dock_widget.html">PythonMessageDockWidget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_message_tree_widget.html">PythonMessageTreeWidget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_none.html">PythonNone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty class that is the QVariant registered type for None in Python. Nothing more than this.  <a href="classito_1_1_python_none.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_numeric.html">PythonNumeric</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_python_package.html">PythonPackage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_param_conversion.html">PythonParamConversion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_plot_item.html">PythonPlotItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_plugins.html">PythonPlugins</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class summing up the functionality of itom - hardware python plugins  <a href="classito_1_1_python_plugins.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_progress_observer.html">PythonProgressObserver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_proxy.html">PythonProxy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_python_q_object_marshal.html">PythonQObjectMarshal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_qt_conversion.html">PythonQtConversion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion class with mainly static methods, which convert values between Qt and standard C++ data types and PyObject* values.  <a href="classito_1_1_python_qt_conversion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_qt_signal_mapper.html">PythonQtSignalMapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the possibility to redirect any signal emitted in an user-defined GUI to different python methods.  <a href="classito_1_1_python_qt_signal_mapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_qt_signal_mapper_base.html">PythonQtSignalMapperBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for <a class="el" href="classito_1_1_python_qt_signal_mapper.html" title="This class provides the possibility to redirect any signal emitted in an user-defined GUI to differen...">PythonQtSignalMapper</a>  <a href="classito_1_1_python_qt_signal_mapper_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_qt_signal_target.html">PythonQtSignalTarget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_region.html">PythonRegion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_rgba.html">PythonRgba</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_shape.html">PythonShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_shared_pointer_guard.html">PythonSharedPointerGuard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_state_publisher.html">PythonStatePublisher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One instance of this class is created by <a class="el" href="classito_1_1_main_application.html#adcf50afa731e277a9bf82e3d2f78d820" title="setup of application ">MainApplication::setupApplication</a> and runs in the main thread of itom. Its onPythonStateChanged slot is connected to the pythonStateChanged signal of <a class="el" href="classito_1_1_python_engine.html">PythonEngine</a>. Other widgets should rather connect to pythonStateChanged of this class than to the direct signal of <a class="el" href="classito_1_1_python_engine.html">PythonEngine</a>. This is mainly for one reason: Whenever a short script is run in Python (not debug), it might be that the execution is so short, that it is a waste of computing resources to switch the GUI to a busy state during this short exeuction. Therefore, the transition to the <code>run</code> state is signalled by this class with a short delay. Whenever, the 'idle' state is signalled by the <a class="el" href="classito_1_1_python_engine.html">PythonEngine</a> before the delay exceeds, nothing is signalled by this class. This only holds for this transition. All other python state transitions are immediately reported to all connected classes.  <a href="classito_1_1_python_state_publisher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_syntax_highlighter.html">PythonSyntaxHighlighter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_timer.html">PythonTimer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_python_ui.html">PythonUi</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_py_workspace_container.html">PyWorkspaceContainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_py_workspace_item.html">PyWorkspaceItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">every item in the workspace is represented by one <a class="el" href="classito_1_1_py_workspace_item.html" title="every item in the workspace is represented by one PyWorkspaceItem ">PyWorkspaceItem</a>  <a href="classito_1_1_py_workspace_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_q_debug_stream.html">QDebugStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_q_list_view_itom.html">QListViewItom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_q_property_helper.html">QPropertyHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_q_table_view_itom.html">QTableViewItom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_q_tab_widget_itom.html">QTabWidgetItom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_q_tree_view_itom.html">QTreeViewItom</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_q_vector2_d_property.html">QVector2DProperty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_q_vector3_d_property.html">QVector3DProperty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_q_vector4_d_property.html">QVector4DProperty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_ramer_douglas_peucker_data.html">RamerDouglasPeuckerData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">each range value has a start and end point. Optionally range can be marked as <a class="el" href="classito_1_1_range.html#a9019bdda86a9b42d3e804a26f6c46602">Range::all()</a>, which indicates a full range  <a href="classito_1_1_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_range_meta.html">RangeMeta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins ">Param</a> of type <a class="el" href="classito_1_1_int_array_meta.html">IntArrayMeta</a> that represent a range [minVal, maxVal].  <a href="classito_1_1_range_meta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_rect_meta.html">RectMeta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins ">Param</a> of type <a class="el" href="classito_1_1_int_array_meta.html">IntArrayMeta</a> that represent a rectangle (left, top, width, height).  <a href="classito_1_1_rect_meta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_ret_val.html">RetVal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for managing status values (like errors or warning)  <a href="classito_1_1_ret_val.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_rgba32.html">Rgba32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements basic functionality for color handling in itom.  This class implements ARGB32 into itom. In openCV-mat this will be represented by an 4channel uint8-plane. The functions of this class are inspired by <a href="http://virjo.googlecode.com/svn/trunk/SFML_Windows/src/SFML/Graphics/Color.cpp,">http://virjo.googlecode.com/svn/trunk/SFML_Windows/src/SFML/Graphics/Color.cpp,</a> written by Laurent Gomila (<a href="#" onclick="location.href='mai'+'lto:'+'lau'+'re'+'nt.'+'go'+'m@g'+'ma'+'il.'+'co'+'m'; return false;">laure<span style="display: none;">.nosp@m.</span>nt.g<span style="display: none;">.nosp@m.</span>om@gm<span style="display: none;">.nosp@m.</span>ail.<span style="display: none;">.nosp@m.</span>com</a>)  <a href="classito_1_1_rgba32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_rgba_base32.html">RgbaBase32</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_r_g_b_channel.html">RGBChannel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_script_dock_widget.html">ScriptDockWidget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">widget containing one or multiple script editors (tabbed). This widget can either be a docking widget, docked in a docking area in the main window or it can be a floatable window which has a standard window behaviour.  <a href="classito_1_1_script_dock_widget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_script_editor_actions.html">ScriptEditorActions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this struct can hold common actions for all script editor and script dock widgets  <a href="structito_1_1_script_editor_actions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_script_editor_organizer.html">ScriptEditorOrganizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">organizes script editors, independent on their appearance (docked or window-style)  <a href="classito_1_1_script_editor_organizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_script_editor_printer.html">ScriptEditorPrinter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_script_editor_storage.html">ScriptEditorStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_selector_delegate.html">SelectorDelegate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_sem_ver_version.html">SemVerVersion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">provides version string parsing and comparison based on semantic versioning  <a href="classito_1_1_sem_ver_version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_shape.html">Shape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_shape_d_object.html">ShapeDObject</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_shape_private.html">ShapePrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_shortcut_action.html">ShortcutAction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_string_meta.html">StringMeta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-information for <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins ">Param</a> of type String.  <a href="classito_1_1_string_meta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_string_meta_private.html">StringMetaPrivate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_style_item.html">StyleItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_subsequence_completer.html">SubsequenceCompleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_subsequence_sort_filter_proxy_model.html">SubsequenceSortFilterProxyModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_symbol_matcher_mode.html">SymbolMatcherMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_syntax_highlighter_base.html">SyntaxHighlighterBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_tab_switcher_widget.html">TabSwitcherWidget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show tabs in mru order and change between them.  <a href="classito_1_1_tab_switcher_widget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_text_block_user_data.html">TextBlockUserData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_text_decoration.html">TextDecoration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_text_decorations_manager.html">TextDecorationsManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_text_decorations_signals.html">TextDecorationsSignals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_timer_callback.html">TimerCallback</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_timer_model.html">TimerModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">model for management of all timer objects. This model will be is used as model for the view in the timer manager.  <a href="classito_1_1_timer_model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_ui_container.html">UiContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Every instance of this class contains information about one user interface (main window, dialog, dock widget...) which is organized by <a class="el" href="classito_1_1_ui_organizer.html" title="The UiOrganizer is started as singleton instance within itom and organizes all main windows...">UiOrganizer</a>.  <a href="structito_1_1_ui_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_ui_container_item.html">UiContainerItem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_ui_data_container.html">UiDataContainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_ui_organizer.html">UiOrganizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classito_1_1_ui_organizer.html" title="The UiOrganizer is started as singleton instance within itom and organizes all main windows...">UiOrganizer</a> is started as singleton instance within itom and organizes all main windows, dialogs, widgets,... which are currently loaded at runtime from any ui-file or from a widget, provided by any algorithm plugin.  <a href="classito_1_1_ui_organizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_user_info_struct.html">UserInfoStruct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_user_interaction_watcher.html">UserInteractionWatcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_user_model.html">UserModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class for for visualizing the available users  <a href="classito_1_1_user_model.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_user_organizer.html">UserOrganizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class handling users and their rights  <a href="classito_1_1_user_organizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_user_ui_dialog.html">UserUiDialog</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structito_1_1_visible_block.html">VisibleBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_find_word.html">WidgetFindWord</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_info_box.html">WidgetInfoBox</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_console_general.html">WidgetPropConsoleGeneral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_console_last_command.html">WidgetPropConsoleLastCommand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_console_wrap.html">WidgetPropConsoleWrap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_editor_auto_code_format.html">WidgetPropEditorAutoCodeFormat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_editor_auto_completion.html">WidgetPropEditorAutoCompletion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_editor_calltips.html">WidgetPropEditorCalltips</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_editor_code_checkers.html">WidgetPropEditorCodeCheckers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_editor_docstring_generator.html">WidgetPropEditorDocstringGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_editor_general.html">WidgetPropEditorGeneral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_editor_goto_assignment.html">WidgetPropEditorGotoAssignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_editor_scripts.html">WidgetPropEditorScripts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_editor_styles.html">WidgetPropEditorStyles</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_figure_plugins.html">WidgetPropFigurePlugins</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_general_application.html">WidgetPropGeneralApplication</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_general_language.html">WidgetPropGeneralLanguage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_general_plot_settings.html">WidgetPropGeneralPlotSettings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_general_styles.html">WidgetPropGeneralStyles</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_help_dock.html">WidgetPropHelpDock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_palettes.html">WidgetPropPalettes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_plugins_actuators.html">WidgetPropPluginsActuators</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_plugins_algorithms.html">WidgetPropPluginsAlgorithms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_python_general.html">WidgetPropPythonGeneral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_python_startup.html">WidgetPropPythonStartup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_prop_workspace_unpack.html">WidgetPropWorkspaceUnpack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_widget_wrapper.html">WidgetWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One instance of this class acts as wrapper for several import public methods of classes, derived from QObject, which should be made available by the call-method in python.  <a href="classito_1_1_widget_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_word_click_mode.html">WordClickMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_word_hover_tooltip_mode.html">WordHoverTooltipMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_workspace_dock_widget.html">WorkspaceDockWidget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">docking widget for contents of type workspace widget  <a href="classito_1_1_workspace_dock_widget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_workspace_tree_item.html">WorkspaceTreeItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tiny derivative of QTreeWidgetItem, that overwrites the comparison operator  <a href="classito_1_1_workspace_tree_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classito_1_1_workspace_widget.html">WorkspaceWidget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">major class <a class="el" href="classito_1_1_workspace_widget.html" title="major class WorkspaceWidget to show a tree widget for the global and local workspace toolbox ...">WorkspaceWidget</a> to show a tree widget for the global and local workspace toolbox  <a href="classito_1_1_workspace_widget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1d184b85b3805334e65f8cb73dfd2616"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d184b85b3805334e65f8cb73dfd2616"></a>
typedef QList&lt; <a class="el" href="classito_1_1_method_description.html">MethodDescription</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MethodDescriptionList</b></td></tr>
<tr class="separator:a1d184b85b3805334e65f8cb73dfd2616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451fc8ba164bbf0cc88fb512632e989f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a451fc8ba164bbf0cc88fb512632e989f"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tFreeFunc</b>) (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr class="separator:a451fc8ba164bbf0cc88fb512632e989f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdbaa8bc53f99a7b738fd4aa0465a88"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cdbaa8bc53f99a7b738fd4aa0465a88"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tSecureFreeFunc</b>) (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr class="separator:a2cdbaa8bc53f99a7b738fd4aa0465a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e4e8c1c77d76405513f3e86833f10f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7e4e8c1c77d76405513f3e86833f10f"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCreateFunc</b>) (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned char dimensions, const int *sizes, const unsigned char continuous, const uchar *continuousDataPtr, const int *steps)</td></tr>
<tr class="separator:ac7e4e8c1c77d76405513f3e86833f10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611d350dd9286e73b69a3bcc322cd90c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a611d350dd9286e73b69a3bcc322cd90c"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCreateFuncWithCVPlanes</b>) (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned char dimensions, const int *sizes, const cv::Mat *planes, const unsigned int nrOfPlanes)</td></tr>
<tr class="separator:a611d350dd9286e73b69a3bcc322cd90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30896789a8db9db313f683bcb1aaed9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac30896789a8db9db313f683bcb1aaed9"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCopyToFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, unsigned char regionOnly)</td></tr>
<tr class="separator:ac30896789a8db9db313f683bcb1aaed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5361dc762a7657e4c470f1936c90031c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5361dc762a7657e4c470f1936c90031c"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tDeepCopyPartialFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr class="separator:a5361dc762a7657e4c470f1936c90031c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11da0f46c2b787a136b3b79f015d69f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11da0f46c2b787a136b3b79f015d69f2"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tZerosFunc</b>) (const int sizeY, const int sizeX, uchar **dstMat)</td></tr>
<tr class="separator:a11da0f46c2b787a136b3b79f015d69f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ce32252f04bf7dca22185f8b2a09c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16ce32252f04bf7dca22185f8b2a09c9"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tOnesFunc</b>) (const int sizeY, const int sizeX, uchar **dstMat)</td></tr>
<tr class="separator:a16ce32252f04bf7dca22185f8b2a09c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a39a3a613f71978f7716e9d8aec14cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a39a3a613f71978f7716e9d8aec14cb"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tNansFunc</b>) (const int sizeY, const int sizeX, uchar **dstMat)</td></tr>
<tr class="separator:a6a39a3a613f71978f7716e9d8aec14cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e29a01d5cf3939c8f816a96d3d581e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e29a01d5cf3939c8f816a96d3d581e7"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tRandFunc</b>) (const int sizeY, const int sizeX, const double value1, const double value2, const bool randMode, uchar **dstMat)</td></tr>
<tr class="separator:a3e29a01d5cf3939c8f816a96d3d581e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cae282677c874ba8561668d3a69254"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55cae282677c874ba8561668d3a69254"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCopyMatFunc</b>) (const uchar **src, uchar **&amp;dst, bool transposed, const int sizeofs)</td></tr>
<tr class="separator:a55cae282677c874ba8561668d3a69254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112cde59b55d320c925dcd234c36e539"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a112cde59b55d320c925dcd234c36e539"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tAssignScalarFunc</b>) (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> type, const void *scalar)</td></tr>
<tr class="separator:a112cde59b55d320c925dcd234c36e539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd6bae7d8f55c5a5e1ff0884a43af04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cd6bae7d8f55c5a5e1ff0884a43af04"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tAssignScalarMaskFunc</b>) (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *mask, const <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> type, const void *scalar)</td></tr>
<tr class="separator:a7cd6bae7d8f55c5a5e1ff0884a43af04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb42819d9a726e984d3e2e91334d3e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bb42819d9a726e984d3e2e91334d3e9"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tAddFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst)</td></tr>
<tr class="separator:a6bb42819d9a726e984d3e2e91334d3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c78cdac3fc81eff2e6bab4d0738dca2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c78cdac3fc81eff2e6bab4d0738dca2"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tAddScalarFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjIn, ito::float64 scalar, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut)</td></tr>
<tr class="separator:a8c78cdac3fc81eff2e6bab4d0738dca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbc7ea86983fe37c1f55d39071e4542"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bbc7ea86983fe37c1f55d39071e4542"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tAddComplexScalarFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjIn, ito::complex128 scalar, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut)</td></tr>
<tr class="separator:a3bbc7ea86983fe37c1f55d39071e4542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef317d14861cd718943b80bfdf25532"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaef317d14861cd718943b80bfdf25532"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tSubFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst)</td></tr>
<tr class="separator:aaef317d14861cd718943b80bfdf25532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cad2f62212dde9e4cd30f47f2a500d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cad2f62212dde9e4cd30f47f2a500d5"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tOpMulFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst)</td></tr>
<tr class="separator:a7cad2f62212dde9e4cd30f47f2a500d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ce2f7ec51fcd3f06ab016cdbb4c7e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24ce2f7ec51fcd3f06ab016cdbb4c7e8"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tOpScalarMulFunc</b>) (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const float64 &amp;factor)</td></tr>
<tr class="separator:a24ce2f7ec51fcd3f06ab016cdbb4c7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0698f0ae098fd721138039fc94eb83"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c0698f0ae098fd721138039fc94eb83"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tOpScalarComplexMulFunc</b>) (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const complex128 &amp;factor)</td></tr>
<tr class="separator:a8c0698f0ae098fd721138039fc94eb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b763c0343a5498754917874494966b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b763c0343a5498754917874494966b4"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCmpFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst, int cmpOp)</td></tr>
<tr class="separator:a2b763c0343a5498754917874494966b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0391a2b8e00dd918e8a0aa0f1b990d0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0391a2b8e00dd918e8a0aa0f1b990d0d"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCmpFuncScalar</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const float64 &amp;value, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst, int cmpOp)</td></tr>
<tr class="separator:a0391a2b8e00dd918e8a0aa0f1b990d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8ec26b9a9be2450276196cd65186af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d8ec26b9a9be2450276196cd65186af"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tShiftLFunc</b>) (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const unsigned char shiftbit)</td></tr>
<tr class="separator:a6d8ec26b9a9be2450276196cd65186af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03f33ec01633d693ad063d021d6cbb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad03f33ec01633d693ad063d021d6cbb1"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tShiftRFunc</b>) (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const unsigned char shiftbit)</td></tr>
<tr class="separator:ad03f33ec01633d693ad063d021d6cbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5650aca444293d670d2dda76bce62319"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5650aca444293d670d2dda76bce62319"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tBitAndFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst)</td></tr>
<tr class="separator:a5650aca444293d670d2dda76bce62319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77069864af7256a3c4ea9bd663e95d1a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77069864af7256a3c4ea9bd663e95d1a"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tBitOrFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst)</td></tr>
<tr class="separator:a77069864af7256a3c4ea9bd663e95d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0d823a9deb928da547620ca8c6a758"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d0d823a9deb928da547620ca8c6a758"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tBitXorFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst)</td></tr>
<tr class="separator:a2d0d823a9deb928da547620ca8c6a758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162604b00f1ced8bd5913cec8976c1e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a162604b00f1ced8bd5913cec8976c1e8"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tGetRangeFunc</b>) (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const int dtop, const int dbottom, const int dleft, const int dright)</td></tr>
<tr class="separator:a162604b00f1ced8bd5913cec8976c1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d835708eaff2f29e1fda18178a87e29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d835708eaff2f29e1fda18178a87e29"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tAdjustROIFunc</b>) (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, int dtop, int dbottom, int dleft, int dright)</td></tr>
<tr class="separator:a8d835708eaff2f29e1fda18178a87e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c6ccb035803721b08b868a4b77feef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5c6ccb035803721b08b868a4b77feef"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tEyeFunc</b>) (const int size, uchar **dstMat)</td></tr>
<tr class="separator:aa5c6ccb035803721b08b868a4b77feef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc53ae45ca1101fa230df7d0949e88ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc53ae45ca1101fa230df7d0949e88ea"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tConjFunc</b>) (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr class="separator:afc53ae45ca1101fa230df7d0949e88ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0881163ba9ad2e3efab38c59bb9a76e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0881163ba9ad2e3efab38c59bb9a76e"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tMulFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *res, const double scale)</td></tr>
<tr class="separator:ae0881163ba9ad2e3efab38c59bb9a76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566ad376647930bd5e362270fd24081b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a566ad376647930bd5e362270fd24081b"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tDivFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *res)</td></tr>
<tr class="separator:a566ad376647930bd5e362270fd24081b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa519691333f339219224e35eb807a9cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa519691333f339219224e35eb807a9cd"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tplaneStackFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *mats, const int &amp;num, const unsigned int &amp;axis, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *res)</td></tr>
<tr class="separator:aa519691333f339219224e35eb807a9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae963c23afee59dac6cb0547dada8fd82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae963c23afee59dac6cb0547dada8fd82"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tlineCutFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const int *coordinates, const int &amp;len, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *res)</td></tr>
<tr class="separator:ae963c23afee59dac6cb0547dada8fd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8d097af9c422202fba5ef2237093a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef8d097af9c422202fba5ef2237093a0"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tConvertToFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, const int dest_type, const double alpha, const double beta)</td></tr>
<tr class="separator:aef8d097af9c422202fba5ef2237093a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57bce353693697fe8ab7e87de25f351"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad57bce353693697fe8ab7e87de25f351"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tAbsFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr class="separator:ad57bce353693697fe8ab7e87de25f351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b63777f0506dfc5e26826d4ba6182c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9b63777f0506dfc5e26826d4ba6182c"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tArgFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr class="separator:aa9b63777f0506dfc5e26826d4ba6182c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbd388ab1a3f07ae662513b68aca6f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4dbd388ab1a3f07ae662513b68aca6f2"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tRealFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr class="separator:a4dbd388ab1a3f07ae662513b68aca6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c67754cbb46b140e8db20197fd65fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19c67754cbb46b140e8db20197fd65fc"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tImagFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr class="separator:a19c67754cbb46b140e8db20197fd65fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c0a6aa436c8df1d03d8a4ff1c00c9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0c0a6aa436c8df1d03d8a4ff1c00c9c"></a>
typedef <a class="el" href="classito_1_1_ret_val.html">RetVal</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tMakeContinuousFunc</b>) (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;resDObj)</td></tr>
<tr class="separator:ae0c0a6aa436c8df1d03d8a4ff1c00c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc13e103066f5289eb209201fab760cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc13e103066f5289eb209201fab760cc"></a>
typedef std::ostream &amp;(*&#160;</td><td class="memItemRight" valign="bottom"><b>tCoutFunc</b>) (std::ostream &amp;out, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr class="separator:acc13e103066f5289eb209201fab760cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6565e20e3db02c664dd726d501f157"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b6565e20e3db02c664dd726d501f157"></a>
typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><b>tIsOrganizedFunc</b>) (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:a2b6565e20e3db02c664dd726d501f157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09369e342beb0981e11766f6dee67d47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09369e342beb0981e11766f6dee67d47"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>tSetWidthFunc</b>) (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, uint32_t width)</td></tr>
<tr class="separator:a09369e342beb0981e11766f6dee67d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad1b8fffc9c051d134442f18b46133b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afad1b8fffc9c051d134442f18b46133b"></a>
typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>tGetWidthFunc</b>) (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:afad1b8fffc9c051d134442f18b46133b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0230b814ec8d8f18019a4db00527018e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0230b814ec8d8f18019a4db00527018e"></a>
typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>tGetSizeFunc</b>) (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:a0230b814ec8d8f18019a4db00527018e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dff35d1bb3d43b7e35b869a41c66e50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dff35d1bb3d43b7e35b869a41c66e50"></a>
typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>tGetHeightFunc</b>) (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:a2dff35d1bb3d43b7e35b869a41c66e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9182140da4a7bafa3fa5afedcc2dc217"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9182140da4a7bafa3fa5afedcc2dc217"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>tSetHeightFunc</b>) (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, uint32_t height)</td></tr>
<tr class="separator:a9182140da4a7bafa3fa5afedcc2dc217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff2bed758999d5db329d67705312bfad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff2bed758999d5db329d67705312bfad"></a>
typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><b>tGetDenseFunc</b>) (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:aff2bed758999d5db329d67705312bfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7025bb403c91b2edd840d2c601258c30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7025bb403c91b2edd840d2c601258c30"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>tSetDenseFunc</b>) (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, bool dense)</td></tr>
<tr class="separator:a7025bb403c91b2edd840d2c601258c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e793dc6a72720b8c85a180bf16ecd7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98e793dc6a72720b8c85a180bf16ecd7"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>tScaleXYZFunc</b>) (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, ito::float32 scaleX, ito::float32 scaleY, ito::float32 scaleZ)</td></tr>
<tr class="separator:a98e793dc6a72720b8c85a180bf16ecd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca36534b3906d655b58118158843b48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ca36534b3906d655b58118158843b48"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>tMoveXYZFunc</b>) (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, ito::float32 dX, ito::float32 dY, ito::float32 dZ)</td></tr>
<tr class="separator:a4ca36534b3906d655b58118158843b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a1017783e3e856722dd5ccae4c4001"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27a1017783e3e856722dd5ccae4c4001"></a>
typedef std_msgs::Header(*&#160;</td><td class="memItemRight" valign="bottom"><b>tGetHeaderFunc</b>) (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:a27a1017783e3e856722dd5ccae4c4001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8c6f50e85a7a643eb0b0774fbf96de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea8c6f50e85a7a643eb0b0774fbf96de"></a>
typedef std::string(*&#160;</td><td class="memItemRight" valign="bottom"><b>tGetFieldsListFunc</b>) (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:aea8c6f50e85a7a643eb0b0774fbf96de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915bd1bc04cba3156ef471313240f635"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a915bd1bc04cba3156ef471313240f635"></a>
typedef std::vector&lt; sensor_msgs::PointField &gt;(*&#160;</td><td class="memItemRight" valign="bottom"><b>tGetFieldsInfoFunc</b>) (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:a915bd1bc04cba3156ef471313240f635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fb202dafeb356c898458642f0f679d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3fb202dafeb356c898458642f0f679d"></a>
typedef unsigned char *(*&#160;</td><td class="memItemRight" valign="bottom"><b>tGenericPointAccessFunc</b>) (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, size_t &amp;strideBytes)</td></tr>
<tr class="separator:ad3fb202dafeb356c898458642f0f679d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae32c3810507441acb734e00d7f627c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afae32c3810507441acb734e00d7f627c"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>tPcAddFunc</b>) (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc1, const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc2, <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pcRes)</td></tr>
<tr class="separator:afae32c3810507441acb734e00d7f627c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9ae906d46c8619a12e3d87f78b8877"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f9ae906d46c8619a12e3d87f78b8877"></a>
typedef const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>tGetItemFunc</b>) (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, size_t n)</td></tr>
<tr class="separator:a2f9ae906d46c8619a12e3d87f78b8877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af372d3548517100eff491c509f786137"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af372d3548517100eff491c509f786137"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>tSetItemFunc</b>) (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, size_t n, <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:af372d3548517100eff491c509f786137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7101c3e58286da523788ee4d90bd25d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7101c3e58286da523788ee4d90bd25d3"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>tPushBackFunc</b>) (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:a7101c3e58286da523788ee4d90bd25d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5dcf058e9a0ce929dd7abba63e7140"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf5dcf058e9a0ce929dd7abba63e7140"></a>
typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><b>tEmptyFunc</b>) (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:adf5dcf058e9a0ce929dd7abba63e7140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405d2eb6efbf807684f3d2e940daee99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a405d2eb6efbf807684f3d2e940daee99"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>tReserveResizeFunc</b>) (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, size_t n, bool reserveNotResize)</td></tr>
<tr class="separator:a405d2eb6efbf807684f3d2e940daee99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b73fee25d90f264bb6856dac1635c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56b73fee25d90f264bb6856dac1635c0"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>tClearFunc</b>) (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:a56b73fee25d90f264bb6856dac1635c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2395faf24936dde0069ed8302fece9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b2395faf24936dde0069ed8302fece9"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>tEraseFunc</b>) (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, uint32_t startIndex, uint32_t endIndex)</td></tr>
<tr class="separator:a9b2395faf24936dde0069ed8302fece9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2907d995d1695e1005223053cab56b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2907d995d1695e1005223053cab56b2"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>tInsertFunc</b>) (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, uint32_t index, const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:ac2907d995d1695e1005223053cab56b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a6e9ace75645d3010dbb885fe05f66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9a6e9ace75645d3010dbb885fe05f66"></a>
typedef <a class="el" href="classito_1_1_r_g_b_channel.html">RGBChannel</a>&lt; <a class="el" href="classito_1_1_rgba32.html#a2b5362f1f324db75958f50d4f846d0a8ad6d2a9d4a537c3c6c33813641f9d644c">Rgba32::RGBA_A</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AlphaChannel</b></td></tr>
<tr class="separator:ae9a6e9ace75645d3010dbb885fe05f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf216996d3046c629bf9889cd4a0bc90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf216996d3046c629bf9889cd4a0bc90"></a>
typedef <a class="el" href="classito_1_1_r_g_b_channel.html">RGBChannel</a>&lt; <a class="el" href="classito_1_1_rgba32.html#a2b5362f1f324db75958f50d4f846d0a8a37412adab4f6c251b414a0a4b1f3fc30">Rgba32::RGBA_R</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RedChannel</b></td></tr>
<tr class="separator:adf216996d3046c629bf9889cd4a0bc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02405a0ec6cb97dffe9a46b2aa6d1ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac02405a0ec6cb97dffe9a46b2aa6d1ae"></a>
typedef <a class="el" href="classito_1_1_r_g_b_channel.html">RGBChannel</a>&lt; <a class="el" href="classito_1_1_rgba32.html#a2b5362f1f324db75958f50d4f846d0a8aaa872e0ac87c9c3ba3ba7ef42263c7ff">Rgba32::RGBA_G</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GreenChannel</b></td></tr>
<tr class="separator:ac02405a0ec6cb97dffe9a46b2aa6d1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2c6e352aaa11b4d818c1e15edade65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a2c6e352aaa11b4d818c1e15edade65"></a>
typedef <a class="el" href="classito_1_1_r_g_b_channel.html">RGBChannel</a>&lt; <a class="el" href="classito_1_1_rgba32.html#a2b5362f1f324db75958f50d4f846d0a8a255cf94836b0caca9cb73549649b0cc5">Rgba32::RGBA_B</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>BlueChannel</b></td></tr>
<tr class="separator:a5a2c6e352aaa11b4d818c1e15edade65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb68169378e1801c903a3c11472ed1b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfb68169378e1801c903a3c11472ed1b"></a>
typedef int8_t&#160;</td><td class="memItemRight" valign="bottom"><b>int8</b></td></tr>
<tr class="separator:adfb68169378e1801c903a3c11472ed1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28e9c7a6873a87cb6a6d4c9e8293380"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af28e9c7a6873a87cb6a6d4c9e8293380"></a>
typedef int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>int16</b></td></tr>
<tr class="separator:af28e9c7a6873a87cb6a6d4c9e8293380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d30f17fdb55cf4b8832bf284045732"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7d30f17fdb55cf4b8832bf284045732"></a>
typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>int32</b></td></tr>
<tr class="separator:af7d30f17fdb55cf4b8832bf284045732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a109f9ea5c8d2dbe9dc1647c0d20bfc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a109f9ea5c8d2dbe9dc1647c0d20bfc"></a>
typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>uint8</b></td></tr>
<tr class="separator:a8a109f9ea5c8d2dbe9dc1647c0d20bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed4f11b7fc17f66fb746c9ec331a1f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ed4f11b7fc17f66fb746c9ec331a1f9"></a>
typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>uint16</b></td></tr>
<tr class="separator:a0ed4f11b7fc17f66fb746c9ec331a1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c56952b10680ef46b594cfeaf56f898"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c56952b10680ef46b594cfeaf56f898"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>uint32</b></td></tr>
<tr class="separator:a8c56952b10680ef46b594cfeaf56f898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca36c5597ed39e5ef07b688d29e16a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afca36c5597ed39e5ef07b688d29e16a4"></a>
typedef float&#160;</td><td class="memItemRight" valign="bottom"><b>float32</b></td></tr>
<tr class="separator:afca36c5597ed39e5ef07b688d29e16a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dc6b3b1081db881220b71b74e70319"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1dc6b3b1081db881220b71b74e70319"></a>
typedef double&#160;</td><td class="memItemRight" valign="bottom"><b>float64</b></td></tr>
<tr class="separator:ab1dc6b3b1081db881220b71b74e70319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b874ecd64788e7d33c8d2b1f76febe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46b874ecd64788e7d33c8d2b1f76febe"></a>
typedef std::complex&lt; ito::float32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>complex64</b></td></tr>
<tr class="separator:a46b874ecd64788e7d33c8d2b1f76febe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b9394bb5bcc3baf7409f0e5f8ebfe2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63b9394bb5bcc3baf7409f0e5f8ebfe2"></a>
typedef std::complex&lt; ito::float64 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>complex128</b></td></tr>
<tr class="separator:a63b9394bb5bcc3baf7409f0e5f8ebfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8811ca8b85b70b969122b25a7c84e0ee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8811ca8b85b70b969122b25a7c84e0ee">tMsgType</a> { <br />
&#160;&#160;<b>msgReturnInfo</b>, 
<b>msgReturnWarning</b>, 
<b>msgReturnError</b>, 
<b>msgTextInfo</b>, 
<br />
&#160;&#160;<b>msgTextWarning</b>, 
<b>msgTextError</b>
<br />
 }</td></tr>
<tr class="separator:a8811ca8b85b70b969122b25a7c84e0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f53103e5eeaadb04a6919cd4f281537"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f53103e5eeaadb04a6919cd4f281537"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>tPythonDbgCmd</b> { <br />
&#160;&#160;<b>pyDbgNone</b> =0, 
<b>pyDbgContinue</b> =1, 
<b>pyDbgStep</b> =2, 
<b>pyDbgStepOut</b> =4, 
<br />
&#160;&#160;<b>pyDbgStepOver</b> =8, 
<b>pyDbgQuit</b> =16
<br />
 }</td></tr>
<tr class="separator:a2f53103e5eeaadb04a6919cd4f281537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c537d397c7af6d4b273afd6f6e9f5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0c537d397c7af6d4b273afd6f6e9f5b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>tPythonTransitions</b> { <br />
&#160;&#160;<b>pyTransBeginRun</b> = 1, 
<b>pyTransEndRun</b> = 2, 
<b>pyTransBeginDebug</b> = 4, 
<b>pyTransEndDebug</b> = 8, 
<br />
&#160;&#160;<b>pyTransDebugWaiting</b> = 16, 
<b>pyTransDebugContinue</b> = 32, 
<b>pyTransDebugExecCmdBegin</b> = 64, 
<b>pyTransDebugExecCmdEnd</b> = 128
<br />
 }</td></tr>
<tr class="separator:ad0c537d397c7af6d4b273afd6f6e9f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb29ce39506daa250135c4385cc4a64a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb29ce39506daa250135c4385cc4a64a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>tPythonState</b> { <br />
&#160;&#160;<b>pyStateIdle</b> = 1, 
<b>pyStateRunning</b> = 2, 
<b>pyStateDebugging</b> = 4, 
<b>pyStateDebuggingWaiting</b> = 8, 
<br />
&#160;&#160;<b>pyStateDebuggingWaitingButBusy</b> = 16
<br />
 }</td></tr>
<tr class="separator:aeb29ce39506daa250135c4385cc4a64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5fc3280291c823cb4f430cd5a94cb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec5fc3280291c823cb4f430cd5a94cb0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aec5fc3280291c823cb4f430cd5a94cb0">UserRole</a> { <b>userRoleBasic</b> = 0, 
<b>userRoleDeveloper</b> = 1, 
<b>userRoleAdministrator</b> = 2
 }</td></tr>
<tr class="memdesc:aec5fc3280291c823cb4f430cd5a94cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration that defines some user roles. <br /></td></tr>
<tr class="separator:aec5fc3280291c823cb4f430cd5a94cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fc67d4b397d4c70967d4d2243d6482"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9fc67d4b397d4c70967d4d2243d6482"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae9fc67d4b397d4c70967d4d2243d6482">UserFeature</a> { <br />
&#160;&#160;<b>featDeveloper</b> = 0x01, 
<b>featFileSystem</b> = 0x02, 
<b>featUserManagement</b> = 0x04, 
<b>featPlugins</b> = 0x08, 
<br />
&#160;&#160;<b>featConsoleRead</b> = 0x10, 
<b>featConsoleReadWrite</b> = 0x20, 
<b>featProperties</b> = 0x40
<br />
 }</td></tr>
<tr class="memdesc:ae9fc67d4b397d4c70967d4d2243d6482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration that defines some feature permissions for a user. <br /></td></tr>
<tr class="separator:ae9fc67d4b397d4c70967d4d2243d6482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f7d3b7b09d702494c83c207a488ced"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5f7d3b7b09d702494c83c207a488ced"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>tParamType</b> { <b>none</b> = 0x0, 
<b>intArray</b> = 0x1, 
<b>doubleArray</b> = 0x2, 
<b>charArray</b> = 0x4
 }</td></tr>
<tr class="separator:af5f7d3b7b09d702494c83c207a488ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f52a66afae16e3bb3802d701859fcf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcf">tPluginLoadStatusFlag</a> { <br />
&#160;&#160;<a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcfa0c084ed64a1e58022675c2855494b904">plsfOk</a> = 0x001, 
<a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcfae886791877d339615c79aed5c21d35f0">plsfWarning</a> = 0x002, 
<a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcfa89928bf15c88b96936c0f981580994ba">plsfError</a> = 0x004, 
<a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcfa8e51ce1381d3ccf924b2b6152b554f88">plsfIgnored</a> = 0x008, 
<br />
&#160;&#160;<a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcfa83b35bae2ed80b743503263abc05ddf8">plsfRelDbg</a> = 0x100, 
<a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcfa266ad0ed0ef69190509ee0f625f29880">plsfIncompatible</a> = 0x200
<br />
 }</td></tr>
<tr class="separator:ae8f52a66afae16e3bb3802d701859fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8b8f2858876413dd8728084943ab30"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30">tPluginType</a> { <br />
&#160;&#160;<a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30a4cab6a4edc95b2ef6846c79aedd818cb">typeDataIO</a> = 0x1, 
<a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30a67b1093d817ca4c45de9b4b1075045b1">typeActuator</a> = 0x2, 
<a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30a8c028979c4b81e7eaa0a7f51e1e62d26">typeAlgo</a> = 0x4, 
<a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30af4dfe66a7744cc365947716d5bdb9f6d">typeGrabber</a> = 0x80, 
<br />
&#160;&#160;<a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30a95ac93a74aac433a17c998c1810e3e51">typeADDA</a> = 0x100, 
<a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30ad2e2fbe4821bac18934a307bd89428c2">typeRawIO</a> = 0x200
<br />
 }</td></tr>
<tr class="memdesc:a3d8b8f2858876413dd8728084943ab30"><td class="mdescLeft">&#160;</td><td class="mdescRight">tPluginType enumeration  <a href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30">More...</a><br /></td></tr>
<tr class="separator:a3d8b8f2858876413dd8728084943ab30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4779b960376c89061f1b12ae3738383"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383">tActuatorStatus</a> { <br />
&#160;&#160;<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a599af524525e8c64bddf91298784e767">actuatorUnknown</a> = 0x0001, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a8b74ac01caf78e23c95f58b02eaab2a0">actuatorInterrupted</a> = 0x0002, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a159167245176483f6062495f2baadd00">actuatorMoving</a> = 0x0004, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383af8836b7f26106593b4d36a5c857ec048">actuatorAtTarget</a> = 0x0008, 
<br />
&#160;&#160;<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a84db4f5b5d047c90ca78d93b46656874">actuatorTimeout</a> = 0x0010, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383ae70cba1af756a2c62c1fc2957643b424">actuatorEndSwitch</a> = 0x0100, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a6edddb993c8b1438045128e4f8a7788f">actuatorLeftEndSwitch</a> = 0x0200, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a3d4d3a51e6e7e7fee69ae59d359f8be7">actuatorRightEndSwitch</a> = 0x0400, 
<br />
&#160;&#160;<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a881194f1151f767dc6b69b7b57f05aa7">actuatorEndSwitch1</a> = 0x0200, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a7f12ac7236bef5c2b68b52b33f07591d">actuatorEndSwitch2</a> = 0x0400, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383af55796f42d5efcd1ea80324402d4d72f">actuatorRefSwitch</a> = 0x0800, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a993a882ad6ec2c8f7657483b637a9f87">actuatorLeftRefSwitch</a> = 0x1000, 
<br />
&#160;&#160;<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a85d7cfb84b5000f7ac16726433589e39">actuatorRightRefSwitch</a> = 0x2000, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383ad8597b3d30e8dc840ea8e6dc0021aefe">actuatorRefSwitch1</a> = 0x1000, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a68b893c663eea43740f0bc7d18446b00">actuatorRefSwitch2</a> = 0x2000, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a5a1d7a7c2ab70910db005617b3a8571a">actuatorAvailable</a> = 0x4000, 
<br />
&#160;&#160;<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a83f4cf9f8319fbbeec0b7f75f4d07682">actuatorEnabled</a> = 0x8000, 
<b>actuatorError</b> = 0x10000, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a067270bd694afa11b542e1768d50b06b">actMovingMask</a> = actuatorUnknown | actuatorInterrupted | actuatorMoving | actuatorAtTarget | actuatorTimeout, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a088d0d001f7e269d045e17084e31a343">actEndSwitchMask</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383afe023404e59f14ea85192ecf4a205d3e">actRefSwitchMask</a>, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383ab8727b678dd0975d5259d4ef6e0c2c71">actSwitchesMask</a> = actEndSwitchMask | actRefSwitchMask, 
<a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a13165fe6a2fd39d5092982cf35388dfc">actStatusMask</a> = actuatorAvailable | actuatorEnabled | actuatorError
<br />
 }</td></tr>
<tr class="memdesc:ab4779b960376c89061f1b12ae3738383"><td class="mdescLeft">&#160;</td><td class="mdescRight">tActuatorStatus enumeration  <a href="namespaceito.html#ab4779b960376c89061f1b12ae3738383">More...</a><br /></td></tr>
<tr class="separator:ab4779b960376c89061f1b12ae3738383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bda469be01178ac6cf406bcba2ee73"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a20bda469be01178ac6cf406bcba2ee73">tAutoLoadPolicy</a> { <a class="el" href="namespaceito.html#a20bda469be01178ac6cf406bcba2ee73a8ec2058becac1ccaae65864d6f961cdf">autoLoadAlways</a> = 0x1, 
<a class="el" href="namespaceito.html#a20bda469be01178ac6cf406bcba2ee73ad39587830e30b302adc4421224049c28">autoLoadNever</a> = 0x2, 
<a class="el" href="namespaceito.html#a20bda469be01178ac6cf406bcba2ee73a4c932e4379045955c6194e202c0b6b2d">autoLoadKeywordDefined</a> = 0x4
 }</td></tr>
<tr class="separator:a20bda469be01178ac6cf406bcba2ee73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d769b26bbab936560f4c95674ff5477"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8d769b26bbab936560f4c95674ff5477">tAutoSavePolicy</a> { <a class="el" href="namespaceito.html#a8d769b26bbab936560f4c95674ff5477a9ca1d2e8fbcc5c11e86bd24fcdec9e50">autoSaveAlways</a> = 0x1, 
<a class="el" href="namespaceito.html#a8d769b26bbab936560f4c95674ff5477a977bb0b86cfdfa0e8486241790087703">autoSaveNever</a> = 0x2
 }</td></tr>
<tr class="separator:a8d769b26bbab936560f4c95674ff5477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3b401f17cb5d7d7cc67d4063714b0f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#abd3b401f17cb5d7d7cc67d4063714b0f">PlotDataType</a> { <br />
&#160;&#160;<a class="el" href="namespaceito.html#abd3b401f17cb5d7d7cc67d4063714b0faea2db09dcf5e943d5f6cda364c5dd063">DataObjLine</a> = 0x0001, 
<a class="el" href="namespaceito.html#abd3b401f17cb5d7d7cc67d4063714b0fa012498cd87eba951ae2a78a8c3e7e17c">DataObjPlane</a> = 0x0002, 
<a class="el" href="namespaceito.html#abd3b401f17cb5d7d7cc67d4063714b0fab7d003b3b16dcbfa0338ef4ab807bb00">DataObjPlaneStack</a> = 0x0004, 
<a class="el" href="namespaceito.html#abd3b401f17cb5d7d7cc67d4063714b0fab6ff58696dec6c2e0839a001388fa947">PointCloud</a> = 0x0008, 
<br />
&#160;&#160;<a class="el" href="namespaceito.html#abd3b401f17cb5d7d7cc67d4063714b0fa2da3a841845c2c99c1abb5d67c53f54e">PolygonMesh</a> = 0x0010
<br />
 }</td></tr>
<tr class="memdesc:abd3b401f17cb5d7d7cc67d4063714b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">enumeration that describes the type of input data that a designer plot widget accepts  <a href="namespaceito.html#abd3b401f17cb5d7d7cc67d4063714b0f">More...</a><br /></td></tr>
<tr class="separator:abd3b401f17cb5d7d7cc67d4063714b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f4ab0831a04329db11d3389d368ed9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55f4ab0831a04329db11d3389d368ed9"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a55f4ab0831a04329db11d3389d368ed9">PlotDataFormat</a> { <br />
&#160;&#160;<b>Format_Gray8</b> = 0x0001, 
<b>Format_Gray16</b> = 0x0002, 
<b>Format_Gray32</b> = 0x0004, 
<b>Format_RGB32</b> = 0x0008, 
<br />
&#160;&#160;<b>Format_ARGB32</b> = 0x0010, 
<b>Format_CMYK32</b> = 0x0020, 
<b>Format_Float32</b> = 0x0040, 
<b>Format_Float64</b> = 0x0080, 
<br />
&#160;&#160;<b>Format_Complex</b> = 0x0100
<br />
 }</td></tr>
<tr class="memdesc:a55f4ab0831a04329db11d3389d368ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">allowed data formats <br /></td></tr>
<tr class="separator:a55f4ab0831a04329db11d3389d368ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f79137047f084843967eb04c3db750"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00f79137047f084843967eb04c3db750"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a00f79137047f084843967eb04c3db750">PlotFeature</a> { <br />
&#160;&#160;<b>Static</b> = 0x0001, 
<b>Live</b> = 0x0002, 
<b>Cartesian</b> = 0x0004, 
<b>Polar</b> = 0x0008, 
<br />
&#160;&#160;<b>Cylindrical</b> = 0x0010, 
<b>OpenGl</b> = 0x0020, 
<b>Cuda</b> = 0x0040, 
<b>X3D</b> = 0x0080, 
<br />
&#160;&#160;<b>PlotLine</b> = 0x0100, 
<b>PlotImage</b> = 0x0200, 
<b>PlotISO</b> = 0x0400, 
<b>Plot3D</b> = 0x0800
<br />
 }</td></tr>
<tr class="memdesc:a00f79137047f084843967eb04c3db750"><td class="mdescLeft">&#160;</td><td class="mdescRight">this enumeration describe the features a designer plot widget provides concerning the visualization of data objects, point clouds or polygonal meshes <br /></td></tr>
<tr class="separator:a00f79137047f084843967eb04c3db750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7adfec26f89a6c728461c89a7f169aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7adfec26f89a6c728461c89a7f169aa"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>tPalette</b> { <br />
&#160;&#160;<b>tPaletteNoType</b> = 0x00, 
<b>tPaletteGray</b> = 0x01, 
<b>tPaletteRGB</b> = 0x02, 
<b>tPaletteFC</b> = 0x04, 
<br />
&#160;&#160;<b>tPaletteIndexed</b> = 0x08, 
<b>tPaletteLinear</b> = 0x10, 
<b>tPaletteReadOnly</b> = 0x20
<br />
 }</td></tr>
<tr class="separator:ac7adfec26f89a6c728461c89a7f169aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3656645e7f004701417ecdc79b10202"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202">tRetValue</a> { <a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a2ced39cc25866a04f2fb1c9f1d6a542e">retOk</a> = 0x0, 
<a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a59b8253725a061086f085758a117002b">retWarning</a> = 0x1, 
<a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a199f41b7779e742e0a3cc281c42c97c0">retError</a> = 0x2
 }</td></tr>
<tr class="separator:af3656645e7f004701417ecdc79b10202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffb516f2476128f38e91f09cad1dcfb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8ffb516f2476128f38e91f09cad1dcfb">tCompareResult</a> { <b>tCmpEqual</b>, 
<b>tCmpCompatible</b>, 
<b>tCmpFailed</b>
 }</td></tr>
<tr class="separator:a8ffb516f2476128f38e91f09cad1dcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ad4ffb19fff6fffd09b91e020eda90"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a93ad4ffb19fff6fffd09b91e020eda90">tStreamMessageType</a> { <b>msgStreamOut</b> = 1, 
<b>msgStreamErr</b> = 2, 
<b>msgStreamIn</b> = 3
 }</td></tr>
<tr class="separator:a93ad4ffb19fff6fffd09b91e020eda90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7eee7faabd3db8463dc9b7922afdba"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">tDataType</a> { <br />
&#160;&#160;<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa35aa1b8e08158b49ebbf6bdfb4b6a508">tInt8</a> = 0, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaad21eb4541e782dc23501912f788a38bd">tUInt8</a> = 1, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa142219f864f22d3b2e6f116f5f5cd936">tInt16</a> = 2, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa68d7e991164d07a036f40379a101112b">tUInt16</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa47b295973c6b4b7de62599401c16df62">tInt32</a> = 4, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaaf08334798ddd5082595350b296a7a868">tUInt32</a> = 5, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa17ad621a0158b30fc85eb1e89b93ce3b">tFloat32</a> = 6, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa6b9559a5cfa765160ae209ecdc258ed6">tFloat64</a> = 7, 
<br />
&#160;&#160;<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa722b93c77819223b8d630ab0fca5a0ec">tComplex64</a> = 8, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa39fef9b8e46915c6ba232020e2fe2e7a">tComplex128</a> = 9, 
<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdbaa8473d2c11cdf726247c29c5ecf7dfbaa">tRGBA32</a> = 10
<br />
 }</td></tr>
<tr class="separator:acc7eee7faabd3db8463dc9b7922afdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71867bc7a24c8fcb06b8cf63f5a3360e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360e">tPCLPointType</a> { <br />
&#160;&#160;<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360eaa2585c0961b5f357d98ed732c17b9359">pclInvalid</a> = 0x0000, 
<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360ea6273432d3a0ca503e1a77d27ad8ab994">pclXYZ</a> = 0x0001, 
<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360ea6385e470bdc9a9e3aead145eb0ded4d8">pclXYZI</a> = 0x0002, 
<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360eaefd9ce8422846a24673536424375f223">pclXYZRGBA</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360ea5f6680f5c10ff985f0be8ce06780e16a">pclXYZNormal</a> = 0x0008, 
<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360ea9c19394acf64356ecfc0ed60bc6c8b52">pclXYZINormal</a> = 0x0010, 
<a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360ea6dd64651a1b85540ac80b6efa5eeb738">pclXYZRGBNormal</a> = 0x0020
<br />
 }</td></tr>
<tr class="separator:a71867bc7a24c8fcb06b8cf63f5a3360e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c77880830b4f6080a797b213c7abafc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c77880830b4f6080a797b213c7abafc"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>rttiNodeType</b> { <br />
&#160;&#160;<b>rttiUnknown</b> = 0x0000, 
<b>rttiPlotNode</b> = 0x1000, 
<b>rttiFilterNode</b> = 0x2000, 
<b>rttiPlotNodeDObj</b> = 0x0100, 
<br />
&#160;&#160;<b>rttiPlotNodePCL</b> = 0x0200, 
<b>rttiPlotNode1D</b> = 0x0001, 
<b>rttiPlotNode2D</b> = 0x0002, 
<b>rttiPlotNode25D</b> = 0x0003, 
<br />
&#160;&#160;<b>rttiPlotNode3D</b> = 0x0004
<br />
 }</td></tr>
<tr class="separator:a2c77880830b4f6080a797b213c7abafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acc5689776d117be8e33dfb5956d4f960"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc5689776d117be8e33dfb5956d4f960"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cmpPanelByOrderInZoneReverse</b> (const std::pair&lt; Panel::Ptr, int &gt; &amp;a, const std::pair&lt; Panel::Ptr, int &gt; &amp;b)</td></tr>
<tr class="separator:acc5689776d117be8e33dfb5956d4f960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a900a24f75d0e2cb471dc39a6ae14d1a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a900a24f75d0e2cb471dc39a6ae14d1a3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sortDecorationsByDrawOrder</b> (const TextDecoration::Ptr &amp;a, const TextDecoration::Ptr &amp;b)</td></tr>
<tr class="separator:a900a24f75d0e2cb471dc39a6ae14d1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa873eda83edbfb282e0b0fc353743b4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa873eda83edbfb282e0b0fc353743b4c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cmpParenthesisByPosReversed</b> (const <a class="el" href="classito_1_1_utils_1_1_parenthesis_info.html">Utils::ParenthesisInfo</a> &amp;a, const <a class="el" href="classito_1_1_utils_1_1_parenthesis_info.html">Utils::ParenthesisInfo</a> &amp;b)</td></tr>
<tr class="separator:aa873eda83edbfb282e0b0fc353743b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529e69b02b06e693de75a613be94b465"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a529e69b02b06e693de75a613be94b465"></a>
QString&#160;</td><td class="memItemRight" valign="bottom"><b>parseCalltip</b> (const <a class="el" href="structito_1_1_jedi_calltip.html">ito::JediCalltip</a> &amp;tip)</td></tr>
<tr class="separator:a529e69b02b06e693de75a613be94b465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab76ee6b53673f0dbb405308ddfc0605"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab76ee6b53673f0dbb405308ddfc0605"></a>
QColor&#160;</td><td class="memItemRight" valign="bottom"><b>mergedColor</b> (const QColor &amp;colorA, const QColor &amp;colorB, float factor)</td></tr>
<tr class="separator:aab76ee6b53673f0dbb405308ddfc0605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab008d9aafbd388d8a79130f807082b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ab008d9aafbd388d8a79130f807082b"></a>
QList&lt; QPair&lt; QRegularExpressionMatch, QStringList &gt; &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>hasNextMatch</b> (const QList&lt; QPair&lt; QRegularExpressionMatch, QStringList &gt; &gt; &amp;matches, QString &amp;captureGroup)</td></tr>
<tr class="separator:a0ab008d9aafbd388d8a79130f807082b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf37efb55197454fffce8b78d62fbc5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cf37efb55197454fffce8b78d62fbc5"></a>
QString&#160;</td><td class="memItemRight" valign="bottom"><b>any</b> (const QString &amp;name, const QStringList &amp;alternates)</td></tr>
<tr class="separator:a7cf37efb55197454fffce8b78d62fbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5599403c75472b43902e25a6628db82a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5599403c75472b43902e25a6628db82a"></a>
QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a5599403c75472b43902e25a6628db82a">enumValuesText</a> (const QMetaEnum &amp;enumerator)</td></tr>
<tr class="memdesc:a5599403c75472b43902e25a6628db82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; returns a help string that contains all possible keys of the enumerator in the form key1 (value1), key2 (value2) ... <br /></td></tr>
<tr class="separator:a5599403c75472b43902e25a6628db82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a69198fb9449e1750a65dabb3911cd3"><td class="memItemLeft" align="right" valign="top">QMap&lt; QString, QString &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a2a69198fb9449e1750a65dabb3911cd3">getItomVersionMap</a> ()</td></tr>
<tr class="memdesc:a2a69198fb9449e1750a65dabb3911cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called to get all version numbers that itom contains.  <a href="#a2a69198fb9449e1750a65dabb3911cd3">More...</a><br /></td></tr>
<tr class="separator:a2a69198fb9449e1750a65dabb3911cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6559978809d15a1f0421b83f7ff4b004"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6559978809d15a1f0421b83f7ff4b004"></a>
QDataStream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (QDataStream &amp;out, const <a class="el" href="structito_1_1_bookmark_item.html">BookmarkItem</a> &amp;obj)</td></tr>
<tr class="separator:a6559978809d15a1f0421b83f7ff4b004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab742b942527554b8864d9fe869126dd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab742b942527554b8864d9fe869126dd3"></a>
QDataStream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (QDataStream &amp;in, <a class="el" href="structito_1_1_bookmark_item.html">BookmarkItem</a> &amp;obj)</td></tr>
<tr class="separator:ab742b942527554b8864d9fe869126dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e9de463e6bb8a123be7e0435b5a8fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25e9de463e6bb8a123be7e0435b5a8fe"></a>
QDataStream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (QDataStream &amp;out, const <a class="el" href="structito_1_1_break_point_item.html">BreakPointItem</a> &amp;obj)</td></tr>
<tr class="separator:a25e9de463e6bb8a123be7e0435b5a8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e76ddc8f9036d1de55f03ea8d8f00b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e76ddc8f9036d1de55f03ea8d8f00b6"></a>
QDataStream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (QDataStream &amp;in, <a class="el" href="structito_1_1_break_point_item.html">BreakPointItem</a> &amp;obj)</td></tr>
<tr class="separator:a0e76ddc8f9036d1de55f03ea8d8f00b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01244bd1f2f2bc62040ed24856e00ff1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01244bd1f2f2bc62040ed24856e00ff1"></a>
QDataStream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (QDataStream &amp;out, const <a class="el" href="structito_1_1_script_editor_storage.html">ito::ScriptEditorStorage</a> &amp;obj)</td></tr>
<tr class="separator:a01244bd1f2f2bc62040ed24856e00ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ca7cb1f82cb947bbda0d495db69237"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8ca7cb1f82cb947bbda0d495db69237"></a>
QDataStream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (QDataStream &amp;in, <a class="el" href="structito_1_1_script_editor_storage.html">ito::ScriptEditorStorage</a> &amp;obj)</td></tr>
<tr class="separator:ad8ca7cb1f82cb947bbda0d495db69237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c874cad04d8bb1bac354a4acfc9520"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08c874cad04d8bb1bac354a4acfc9520"></a>
<a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getObjectChildrenInfoRecursive</b> (const QObject *obj, bool recursive, QSharedPointer&lt; QStringList &gt; &amp;objectNames, QSharedPointer&lt; QStringList &gt; &amp;classNames)</td></tr>
<tr class="separator:a08c874cad04d8bb1bac354a4acfc9520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21c7a20ff939ecd6f7e3cf14325a50f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae21c7a20ff939ecd6f7e3cf14325a50f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeAndDeleteLayoutItem</b> (QLayout *layout, QLayoutItem *item)</td></tr>
<tr class="separator:ae21c7a20ff939ecd6f7e3cf14325a50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ff221d843622a726a1d019b46c607c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51ff221d843622a726a1d019b46c607c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (autoIntervalInit_doc,&quot;autoInterval(min = -math.inf, max = math.inf, auto = True) -&gt; autoInterval \n\
\n\
Creates a new (auto) interval object.\n\
\n\
\n\
Properties and slots of :class:`uiItem` objects (e.g. plots) sometimes have parameters \n\
of type :class:`autoInterval`. It is either possible to pass an :class:`autoInterval` \n\
instance, the string ``auto`` or a list or tuple with the two limit values ``[min, max]``. \n\
\n\
Example:: \n\
\n\
    [i,h] = plot(dataObject.randN([100, 100], 'int8'))\n\
    h['xAxisInterval'] = autoInterval(20, 80)\n\
    h['yAxisInterval'] = 'auto' \n\
    h['zAxisInterval'] = [-90, 90] \n\
\n\
Parameters \n\
----------- \n\
min : float, optional \n\
    minimum value of interval (default: -:obj:`math.inf`). \n\
max : float, optional \n\
    maximum value of interval (default: :obj:`math.inf`). \n\
auto : bool, optional \n\
    ``False`` if interval is fixed, ``True`` if the interval can be scaled \n\
    automatically (default).&quot;)</td></tr>
<tr class="separator:a51ff221d843622a726a1d019b46c607c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7f2a954ffd66e6118117ccaa3737a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b7f2a954ffd66e6118117ccaa3737a8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (autoInterval_name_doc,&quot;name() -&gt; str \n\
\n\
Returns the name of this object. \n\
\n\
Returns \n\
------- \n\
str \n\
    name of this object ``autoInterval``.&quot;)</td></tr>
<tr class="separator:a4b7f2a954ffd66e6118117ccaa3737a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e361b5e49a68c03ce683d681e66b530"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e361b5e49a68c03ce683d681e66b530"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (autoInterval_min_doc,&quot;float : Gets or sets the minimum value of the interval.&quot;)</td></tr>
<tr class="separator:a6e361b5e49a68c03ce683d681e66b530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2452376dee6676bc5aeaafe067fc14e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2452376dee6676bc5aeaafe067fc14e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (autoInterval_max_doc,&quot;float : Gets or sets the maximum value of the interval.&quot;)</td></tr>
<tr class="separator:ad2452376dee6676bc5aeaafe067fc14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099aac84b9fafb4aae93d8dfbfa22ffb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a099aac84b9fafb4aae93d8dfbfa22ffb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (autoInterval_auto_doc,&quot;bool : Gets or sets if this interval has an automatic range.&quot;)</td></tr>
<tr class="separator:a099aac84b9fafb4aae93d8dfbfa22ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaadeb5a84e7fa9f44207f4f6ea80a85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#acaadeb5a84e7fa9f44207f4f6ea80a85">checkAndSetParamVal</a> (PyObject *tempObj, <a class="el" href="classito_1_1_param.html">ito::Param</a> *param, int *set)</td></tr>
<tr class="separator:acaadeb5a84e7fa9f44207f4f6ea80a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0733e868f1be90670675e6984876ba2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0733e868f1be90670675e6984876ba2f"></a>
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a0733e868f1be90670675e6984876ba2f">checkAndSetParamVal</a> (PyObject *pyObj, const <a class="el" href="classito_1_1_param.html">ito::Param</a> *defaultParam, <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &amp;outParam, int *set)</td></tr>
<tr class="memdesc:a0733e868f1be90670675e6984876ba2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to print out parameters to a dictionary and the itom-console. <br /></td></tr>
<tr class="separator:a0733e868f1be90670675e6984876ba2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cd71e9927f55c7ff8c890c7a8ed850"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21cd71e9927f55c7ff8c890c7a8ed850"></a>
PyObject *&#160;</td><td class="memItemRight" valign="bottom"><b>printOutParams</b> (const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *params, bool asErr, bool addInfos, const int num, bool printToStdStream)</td></tr>
<tr class="separator:a21cd71e9927f55c7ff8c890c7a8ed850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4dfe4f49c35f2a0d4028b5066a116a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a9b4dfe4f49c35f2a0d4028b5066a116a">errOutInitParams</a> (const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *params, const int num, const char *reason)</td></tr>
<tr class="separator:a9b4dfe4f49c35f2a0d4028b5066a116a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141b897a464e5d831cf05c76f19f24b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a141b897a464e5d831cf05c76f19f24b4"></a>
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><b>parseInitParams</b> (const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *defaultParamListMand, const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *defaultParamListOpt, PyObject *args, PyObject *kwds, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;paramListMandOut, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;paramListOptOut)</td></tr>
<tr class="separator:a141b897a464e5d831cf05c76f19f24b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af336f965d8dcb64d35de938c63e18e53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#af336f965d8dcb64d35de938c63e18e53">copyParamVector</a> (const QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *paramVecIn, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;paramVecOut)</td></tr>
<tr class="separator:af336f965d8dcb64d35de938c63e18e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9596d29ad4cb556064117c73031bd0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad9596d29ad4cb556064117c73031bd0d">copyParamVector</a> (const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramVecIn, QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; &amp;paramVecOut)</td></tr>
<tr class="separator:ad9596d29ad4cb556064117c73031bd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c6bd4bcdbd9f72e50bbbe132b204db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ac1c6bd4bcdbd9f72e50bbbe132b204db">copyParamVector</a> (const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramVecIn, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;paramVecOut)</td></tr>
<tr class="separator:ac1c6bd4bcdbd9f72e50bbbe132b204db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01723110515894b52457c2e3ffbb3d6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a01723110515894b52457c2e3ffbb3d6f">findAndDeleteReservedInitKeyWords</a> (PyObject *kwds, bool *enableAutoLoadParams)</td></tr>
<tr class="separator:a01723110515894b52457c2e3ffbb3d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddc375b0c7a21152f858961b7914412"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeddc375b0c7a21152f858961b7914412"></a>
PyObject *&#160;</td><td class="memItemRight" valign="bottom"><b>buildFilterOutputValues</b> (QVector&lt; QVariant &gt; *outVals, <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> &amp;retValue)</td></tr>
<tr class="separator:aeddc375b0c7a21152f858961b7914412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74874a13907e13fe5588b50a0acaad3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74874a13907e13fe5588b50a0acaad3c"></a>
PyObject *&#160;</td><td class="memItemRight" valign="bottom"><b>parseParamMetaAsDict</b> (const <a class="el" href="classito_1_1_param_meta.html">ito::ParamMeta</a> *meta)</td></tr>
<tr class="separator:a74874a13907e13fe5588b50a0acaad3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf6fce61a26436009f63cd0e37da946"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecf6fce61a26436009f63cd0e37da946"></a>
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aecf6fce61a26436009f63cd0e37da946">createEmptyParamBaseFromParamVector</a> (const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramVecIn, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;paramVecOut)</td></tr>
<tr class="memdesc:aecf6fce61a26436009f63cd0e37da946"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function searches for reserves Keywords (e.g. autoLoadParams) sets the corresponding bool parameter to the right value and than deletes the keyword. <br /></td></tr>
<tr class="separator:aecf6fce61a26436009f63cd0e37da946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436531932ee63c6830b212c7f5531ec1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a436531932ee63c6830b212c7f5531ec1">PyDoc_STRVAR</a> (dataObjectInit_doc,&quot;dataObject(dims = [], dtype = \&quot;uint8\&quot;, continuous = 0, data = None) -&gt; dataObject \n\
\n\
Creates a new n-dimensional dataObject array. \n\
\n\
The :class:`dataObject` represents a multidimensional array of fixed-size items \n\
(integer, floating-point or complex values) and contains further, optional, meta \n\
information, like units, axis descriptions, scalings, general tags, ... \n\
Recently the following data types (dtype) are supported: \n\
\n\
* Integer (int8, uint8, int16, uint16, int32),\n\
* Floating point (float32, float64 (=&gt; double)),\n\
* Complex (complex64 (2x float32), complex128 (2x float64)).\n\
* Color (rgba32 (uint32 or uint[4] containing the four 8bit values [R, G, B, Alpha])).\n\
\n\
Arrays can also be constructed using some of the static pre-initialization methods \n\
:meth:`zeros`, :meth:`ones`, :meth:`rand` or :meth:`randN`  \n\
(refer to the See Also section below). \n\
\n\
Parameters \n\
----------- \n\
dims : sequence of int, optional \n\
    ``dims`` is a list or tuple indicating the size of each dimension. The length \n\
    of this sequence defines the dimension of this dataObject. As an example, \n\
    ``dims = [2, 3]`` creates a two-dimensional dataObject with two rows and three columns. \n\
    If ``dims`` is not given, an empty data object is created. \n\
dtype : str, optional \n\
    Data type of each element in the array. Possible values are: \n\
    'int8', 'uint8', 'int16', 'uint16', 'int32', 'float32', 'float64', 'complex64', \n\
    'complex128', 'rgba32'. \n\
continuous : int, optional \n\
    The last two dimensions of a dataObject are always stored as continuous junk of memory, \n\
    denoted as plane. If ``continuous`` is set to ``1``, even a dataObject with a dimension \n\
    ``n &gt; 2`` will allocate one big block of memory and continuously stores the matrix data \n\
    there. \n\
    If ``continuous`` is 0, different junks of memory are allocated for each plane, the planes \n\
    are referenced by means of an index vector. This is recommended for large arrays, since \n\
    the operating system might get trouble allocated one very big continuous junk of memory, \n\
    instead of multiple smaller ones. \n\
data : int or float or complex or rgba or sequence of int or sequence of float or sequence of complex or dataObject or np.ndarray, optional \n\
    If ``data`` is a single value, all values in the dataObject are set to this single value. \n\
    Else, the sequence or array-like object must have the same number of values than \n\
    the data object. These values will then be assigned to the new data object (filled row by row).\n\
\n\
Notes \n\
------ \n\
The :class:`itom.dataObject` is a direct wrapper for the underlying C++ class *dataObject*. \n\
This array class mainly is based on the class *Mat* of the computer vision library (OpenCV). \n\
\n\
In order to handle huge matrices, the data object can divide one array into chunks in memory.\n\
Each subpart (called matrix-plane) is two-dimensional and covers data of the last two dimensions.\n\
In C++-context each of these matrix-planes is of type cv::Mat_&lt;type&gt; and can be used with \n\
every operator given by the openCV-framework (version 2.3.1 or higher).\n\
\n\
The dimensions of the matrix are structured descending. So if we assume to have a n-dimensional \n\
matrix ``A``, where each dimension has its size s_i, the dimensions order is n, .., z, y, x and \n\
the corresponding sizes of ``A`` are [s_n, s_(n-1),  s_(n-2), ..., s_y, s_x].\n\
\n\
In order to make the data object compatible to continuously organized data structures, like \n\
numpy-arrays, it is also possible to have all matrix-planes in one data-block in memory \n\
(not recommended for huge matrices). Nevertheless, the indicated data structure with the \n\
two-dimensional sub-matrix-planes is still existing. The data organization is equal to the \n\
one of openCV, hence, two-dimensional matrices are stored row-by-row (C-style)...\n\
\n\
In addition to OpenCV, itom.dataObject supports complex valued data types for all operators and methods. \n\
\n\
Warning 'uint32' is currently not available, since it is not fully supported by the underlying OpenCV matrices.\n\
\n\
**Deep Copy, Shallow Copy and ROI** \n\
\n\
It is possible to set a n-dimensional region of interest (ROI) to each matrix, the virtual dimensions,\n\
which will be delivered if the user asks for the matrix size.\n\
To avoid copy operations where possible a simple =_Operator will also make a shallow copy of the object.\n\
Shallow copies share the same data (elements and meta data) with the original object, hence manipulations of one object will affect the\n\
original object and all shallow copies.\n\
\n\
The opposite a deep copy of a dataObject (by sourceObject.copy()) creates a complete mew matrix with own meta data object.\n\
\n\
Example::\n\
    \n\
    #Create an object \n\
    dObj = dataObject([5, 10, 10], 'int8')\n\
    \n\
    # Make a shallow copy \n\
    dObjShallow = dObj \n\
    \n\
    # Make a shallow copy on ROI\n\
    dObjROI = dObj[1, :, :] \n\
    \n\
    # Set the value of element [1, 0, 0] to 0\n\
    dObj[1, 0, 0] = 0\n\
    \n\
    # Make a deep copy of the dObjROI\n\
    dObjROICopy = dObjROI.copy()\n\
    \n\
    # Set the value of dObjROICopy element [0, 0, 0] to 127 without effecting other objects\n\
    dObjROICopy[0, 0, 0] = 127\n\
\n\
**Constructor** \n\
\n\
The function dataObject([dims [, dtype='uint8'[, continuous = 0][, data = valueOrSequence]]])\n\
creates a new itom-dataObject filled with undefined data.\n\
If no parameters are given, an uninitilized DataObject (dims = 0, no sizes) is created.\n\
\n\
As second possibility you can also use the copy-constructor 'dataObject(anyArray : Union[dataObject, np.ndarray], dtype : str = '', continuous : int = 0)', \n\
where 'anyArray' must be any array-like structure which is parsable by the numpy-interface. If a dtype is given or if continuous is 1, \n\
the new data object will be a type-casted (and / or continuous) copy of 'anyArray'.\n\
\n\
See Also \n\
---------- \n\
ones : Static method to construct a data object filled with ones. \n\
zeros : Static method to construct a data object filled with zeros. \n\
nans : Static method to construct a data object (float or complex only) with NaNs. \n\
rand : Static method to construct a randomly filled data object (uniform distribution). \n\
randN : Static method to construct a randomly filled data object (gaussian distribution).&quot;)</td></tr>
<tr class="memdesc:a436531932ee63c6830b212c7f5531ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">brief description  <a href="#a436531932ee63c6830b212c7f5531ec1">More...</a><br /></td></tr>
<tr class="separator:a436531932ee63c6830b212c7f5531ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161072a68f40504c61ded5803eab3dc9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a161072a68f40504c61ded5803eab3dc9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrDims_doc,&quot;int : Gets the number of dimensions of this data object.&quot;)</td></tr>
<tr class="separator:a161072a68f40504c61ded5803eab3dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e54dc8142c9b40990cd2ef9fd6ce3a6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e54dc8142c9b40990cd2ef9fd6ce3a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrType_doc,&quot;str : Gets the data type name of the values in this dataObject. \n\
\n\
This type string has one of these values: ``uint8``, ``int8``, ``uint16``, \n\
``int16``, ``int32``, ``float32``, ``float64``, ``complex64``, ``complex128``, \n\
``rgba32``.&quot;)</td></tr>
<tr class="separator:a3e54dc8142c9b40990cd2ef9fd6ce3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd6c3e8d3315d642833964caed336c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbd6c3e8d3315d642833964caed336c0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrContinuous_doc,&quot;bool : Returns ``True`` if this dataObject is continuous, otherwise ``False``. \n\
\n\
If ``True``, the whole matrix is allocated in one huge block in memory, hence, \n\
this data object can be transformed into a numpy representation \n\
without reallocating memory.&quot;)</td></tr>
<tr class="separator:abbd6c3e8d3315d642833964caed336c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d707115dade92ef11c1288ddeaf77c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1d707115dade92ef11c1288ddeaf77c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrShape_doc,&quot;tuple of int : Gets the shape of this data object. \n\
\n\
The shape is a tuple where each element is the size of one dimension of this \n\
dataObject. As an example ``shape = [2, 3]`` corresponds to a ``2 x 3`` dataObject. \n\
\n\
Notes\n\
------\n\
In difference to the shape attribute of :class:`numpy.ndarray`, this attribute cannot \n\
be set. \n\
\n\
See Also \n\
--------- \n\
size : Alternative method to return the size of all or any specific axis&quot;)</td></tr>
<tr class="separator:af1d707115dade92ef11c1288ddeaf77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57886d9f3d3fa9168efd40f36696405"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae57886d9f3d3fa9168efd40f36696405"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrTags_doc,&quot;types.MappingProxyType : Gets or sets a dictionary with tags of this data object. \n\
\n\
This attribute returns a :obj:`dict_proxy` object of the tag dictionary of this \n\
data object. This object is read-only. However you can assign an entire new \n\
dictionary to this attribute that fully replaces the old tag dictionary. \n\
The tag dictionary can contain arbitrary pairs of key -&gt; value where value is either \n\
a :class:`str` or a :class:`float` value. \n\
\n\
Special tags are the key ``protocol`` that contains the newline-separated protocol \n\
string of the data object (see: :meth:`addToProtocol`) or the key ``title`` that  \n\
can for instance be used as title in any plots. \n\
\n\
You can add single elements using the method :meth:`setTag` or you can delete tags \n\
using :meth:`deleteTag`.\n\
\n\
Do NOT use **special character** within the tag key because they are not XML-save.&quot;)</td></tr>
<tr class="separator:ae57886d9f3d3fa9168efd40f36696405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0197f43ff050afe741a97e539946768d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0197f43ff050afe741a97e539946768d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrAxisScales_doc,&quot;tuple of float : Gets or sets the optional scale values for each axis [unit/px]. \n\
\n\
This attribute gives access to the internal axis scales [unit/px] expressed as \n\
a :class:`tuple` of :class:`float` values. The i-th value in the tuple corresponds \n\
to the scaling factor of the i-th axis. Either assign a new tuple with the same \n\
length than the number of dimensions or change single values using tuple indexing. \n\
\n\
Definition: ``Physical unit = (px-Coordinate - offset)* scale`` \n\
\n\
If the data object is plot with scalings != 1, the scaled (physical) units are \n\
displayed in the plot. \n\
\n\
See Also \n\
--------- \n\
setAxisScale : Alternative method to set the scale value of one single axis&quot;)</td></tr>
<tr class="separator:a0197f43ff050afe741a97e539946768d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ecf8f694c38c12dd472db05cdfa98c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53ecf8f694c38c12dd472db05cdfa98c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrAxisOffsets_doc,&quot;tuple of float : Gets or sets the optional offset values for each axis [px]. \n\
\n\
This attribute gives access to the internal axis offsets [px] expressed as \n\
a :class:`tuple` of :class:`float` values. The i-th value in the tuple corresponds \n\
to the pixel-offset of the i-th axis. Either assign a new tuple with the same length \n\
than the number of dimensions or change single values using tuple indexing. \n\
\n\
Definition: ``Physical unit = (px-Coordinate - offset)* scale`` \n\
\n\
If the data object is plot with offsets != 0, the scaled (physical) units are \n\
displayed in the plot. \n\
\n\
See Also \n\
--------- \n\
setAxisOffset : Alternative method to set the offset value of one single axis&quot;)</td></tr>
<tr class="separator:a53ecf8f694c38c12dd472db05cdfa98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674d40e9b63c2f2cfe5543c7fb8dd93e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a674d40e9b63c2f2cfe5543c7fb8dd93e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrAxisDescriptions_doc,&quot;tuple of str : Gets or sets the optional description of each axis. \n\
\n\
This tuple contains the description of each axis. The length of this tuple \n\
is equal to the number of dimensions of the dataObject. \n\
\n\
You can either assign a new tuple with the same length or change single values using \n\
tuple indexing. \n\
\n\
The axis descriptions are considered if the data object is plotted. \n\
\n\
See Also \n\
--------- \n\
setAxisDescriptions : alternative method to change the description string of one single axis.&quot;)</td></tr>
<tr class="separator:a674d40e9b63c2f2cfe5543c7fb8dd93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b19e02b4b1905c83280a94f14afb536"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b19e02b4b1905c83280a94f14afb536"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrAxisUnits_doc,&quot;tuple of str : Gets or sets the optional unit value of each axis. \n\
\n\
This tuple contains the unit value of each axis. The length of this tuple \n\
is equal to the number of dimensions of the dataObject. \n\
\n\
You can either assign a new tuple with the same length or change single values using \n\
tuple indexing. \n\
\n\
The axis units are considered if the data object is plotted. \n\
\n\
See Also \n\
--------- \n\
setAxisDescriptions : alternative method to change the description string of one single axis.&quot;)</td></tr>
<tr class="separator:a1b19e02b4b1905c83280a94f14afb536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c76117a2f82399dd9aa391e7ad1ca7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c76117a2f82399dd9aa391e7ad1ca7a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrValueUnit_doc,&quot;str : Gets or sets the unit of the values of the dataObject. \n\
\n\
The value unit is considered if the dataObject is plotted.&quot;)</td></tr>
<tr class="separator:a1c76117a2f82399dd9aa391e7ad1ca7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458f701ec8a3cb8d136f42fc8b9cba4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a458f701ec8a3cb8d136f42fc8b9cba4f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrValueDescription_doc,&quot;str : Gets or sets the description of the values of the dataObject. \n\
\n\
The value description is considered if the dataObject is plotted.&quot;)</td></tr>
<tr class="separator:a458f701ec8a3cb8d136f42fc8b9cba4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2f4a48b592872ec0b6ab3fe7facd50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca2f4a48b592872ec0b6ab3fe7facd50"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrValueScale_doc,&quot;float : Gets the scaling factor for the values. This value is always 1.0.&quot;)</td></tr>
<tr class="separator:aca2f4a48b592872ec0b6ab3fe7facd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa679ab97e995f1a84586effd75415d55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa679ab97e995f1a84586effd75415d55"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrValueOffset_doc,&quot;float : Gets the offset value for the values. This value is always 0.0.&quot;)</td></tr>
<tr class="separator:aa679ab97e995f1a84586effd75415d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bcf4d6563383f985a156e4009ec7d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21bcf4d6563383f985a156e4009ec7d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrValue_doc,&quot;tuple : Gets or sets the values of this dataObject, defined as flattened tuple \n\
\n\
If this attribute is called by means of a getter, a tuple is returned which is \n\
created by iterating through the values of the data object (row-wise). The values \n\
in the tuple depend on the :attr:`dtype` of this dataObject and can be :class:`int`, \n\
:class:`float`, :class:`complex` or :class:`rgba`. Analog to this, pass a new tuple \n\
of number values and the correct size to change the values of this dataObject. The \n\
size and shape of the object cannot be changed. \n\
\n\
Example: ::\n\
\n\
    b = dataObject[1, 1:10, 1, 1].value\n\
    # or for the first value \n\
    b = dataObject[1, 1:10, 1, 1].value[0]\n\
    # The elements of the tuple are adressed with b[idx].&quot;)</td></tr>
<tr class="separator:a21bcf4d6563383f985a156e4009ec7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8513a405785053b3fb2f51d398720165"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8513a405785053b3fb2f51d398720165"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrRotationalMatrix_doc,&quot;list of list of float : Gets or sets the 3x3 rotation matrix of this dataObject. \n\
\n\
This rotation matrix is part of the meta information section and is not used \n\
for any other purposes. \n\
\n\
The rotation matrix is given as nested list of three elements. Each element is \n\
another list of three float values and correspond to one row in the ``3 x 3`` \n\
rotation matrix.&quot;)</td></tr>
<tr class="separator:a8513a405785053b3fb2f51d398720165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15927814f132e113639a9e2c8673ef1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15927814f132e113639a9e2c8673ef1c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSetAxisOffset_doc,&quot;setAxisOffset(axisNum, axisOffset) \n\
\n\
Sets the offset value of one specific axis of this dataObject. \n\
\n\
Each axis in the data object can get a specific offset value, given in pixels. \n\
The offset value for one axis can be set by this method. Getting or setting \n\
single or all offset values for all axis can also be achieved by the attribute \n\
:attr:`axisOffsets`. \n\
\n\
The conversion between physical and pixel units is: \n\
\n\
``physical_value = (pixel_value - axisOffset) * axisScale`` \n\
\n\
Parameters  \n\
------------\n\
axisNum : int\n\
    The axis index in the range [0, n), where ``n`` is the dimension of this dataObject. \n\
axisOffset : float\n\
    New axis offset value in pixels. \n\
\n\
Raises \n\
------- \n\
RuntimeError \n\
    if the given ``axisNum`` is out of range. \n\
\n\
See Also \n\
--------- \n\
axisOffsets : this attribute can directly be used to get or set the axis offset(s) of single or all axes&quot;)</td></tr>
<tr class="separator:a15927814f132e113639a9e2c8673ef1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4ce0f90c1a60cb88bb6930033ed3d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e4ce0f90c1a60cb88bb6930033ed3d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSetAxisScale_doc,&quot;setAxisScale(axisNum, axisScale) \n\
\n\
Sets the scaling value of one specific axis of this dataObject. \n\
\n\
Each axis in the data object can get a specific scale value, given in ``axisUnits`` \n\
per pixels. The scale value for one axis can be set by this method. Getting or setting \n\
single or all scaling values for all axis can also be achieved by the attribute \n\
:attr:`axisScales`. \n\
\n\
The conversion between physical and pixel units is: \n\
\n\
``physical_value = (pixel_value - axisOffset) * axisScale`` \n\
\n\
Parameters \n\
----------\n\
axisNum : int\n\
    The axis index in the range [0, n), where ``n`` is the dimension of this dataObject. \n\
axisScale : float\n\
    New scale value for this axis in [unit/px]. \n\
\n\
Raises \n\
------- \n\
RuntimeError \n\
    if the given ``axisNum`` is out of range. \n\
\n\
See Also \n\
--------- \n\
axisScales : this attribute can directly be used to get or set the axis scale(s) of single or all axes&quot;)</td></tr>
<tr class="separator:a8e4ce0f90c1a60cb88bb6930033ed3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd44ab5fc4084409b7715593e1afd7cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd44ab5fc4084409b7715593e1afd7cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSetAxisDescription_doc,&quot;setAxisDescription(axisNum, axisDescription) \n\
\n\
Sets the axis description of one axis. \n\
\n\
Each axis in the data object can get a specific description string (e.g. 'x-axis'). \n\
\n\
Parameters  \n\
------------\n\
axisNum : int\n\
    The axis index in the range [0, n), where ``n`` is the dimension of this dataObject. \n\
axisDescription : str\n\
    New axis description.\n\
\n\
Raises \n\
------- \n\
RuntimeError \n\
    if the given ``axisNum`` is out of range \n\
\n\
See Also \n\
--------- \n\
axisDescriptions : this attribute can directly be used to get or set the axis description(s) of single or all axes&quot;)</td></tr>
<tr class="separator:abd44ab5fc4084409b7715593e1afd7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf029848b4a21f048604f52a1ec14aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbf029848b4a21f048604f52a1ec14aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSetAxisUnit_doc,&quot;setAxisUnit(axisNum, axisUnit) \n\
\n\
Sets the unit of the specified axis. \n\
\n\
Each axis in the data object can get a specific unit string (e.g. 'mm'). \n\
\n\
Parameters  \n\
------------\n\
axisNum : int\n\
    The axis index in the range [0, n), where ``n`` is the dimension of this dataObject. \n\
axisUnit : str\n\
    New axis unit.\n\
\n\
Raises \n\
------- \n\
RuntimeError  \n\
    if the given ``axisNum`` is out of range. \n\
\n\
See Also \n\
--------- \n\
axisUnits : this attribute can directly be used to get or set the axis unit(s) of single or all axes&quot;)</td></tr>
<tr class="separator:abbf029848b4a21f048604f52a1ec14aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cdbd80935fe6f3e920bbe78fcdc8c78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cdbd80935fe6f3e920bbe78fcdc8c78"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectPhysToPix_doc,&quot;physToPix(values, axes = 0) -&gt; Union[float, Tuple[float]] \n\
\n\
Returns transformed values from physical to pixel coordinates. \n\
\n\
This method transforms a physical axis coordinate into its corresponding pixel \n\
coordinate. The transformation is defined by the current offset and scale value of \n\
the specific axis: \n\
\n\
``phys = (pix - offset) * scaling`` \n\
\n\
If no axes parameter is given, the values are assumed to belong the the ascending axis \n\
list (0, 1, 2, 3...). The returned pixel value is clipped by the <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> size of the data \n\
object in the requested dimension ``[0, shape[axis] - 1]``. \n\
\n\
Parameters  \n\
------------\n\
values : float or sequence of float\n\
    One single physical coordinate or a tuple of physical coordinates.\n\
axes : int or sequence of int, optional \n\
    If ``values`` is a single value, axes must be ``None`` or one integer, that defines \n\
    the axis for which the transformation should be calculated. \n\
    If ``values`` is a tuple of float values, axes can be one single value (all values \n\
    are transformed with respect to the same axis), or a tuple of int, whose size must be \n\
    equal to the size of the ``axes`` tuple. Each value is then transformed with the \n\
    corresponding value in ``axes``. \n\
    If ``None`` is given, ``axes`` is assumed to be an ascending list of values ``0, 1, 2, ...``. \n\
\n\
Returns \n\
-------- \n\
float or tuple of float \n\
    The transformed physical coordinates for the given axes to pixel coordinates. \n\
\n\
Raises \n\
------- \n\
ValueError \n\
    if the given axes is out of range \n\
RuntimeWarning \n\
    if requested physical unit is outside of the range of the requested axis. \n\
    The returned pixel value is clipped to the closest boundary value.&quot;)</td></tr>
<tr class="separator:a6cdbd80935fe6f3e920bbe78fcdc8c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fadecc9559e3c3397a5dfceb0c8723"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56fadecc9559e3c3397a5dfceb0c8723"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectPixToPhys_doc,&quot;pixToPhys(values, axes = 0) -&gt; Union[float, Tuple[float]] \n\
\n\
Returns transformed values from pixel to physical coordinates. \n\
\n\
This method transforms a pixel axis coordinate into its corresponding physical \n\
coordinate. The transformation is defined by the current offset and scale value of \n\
the specific axis: \n\
\n\
``pix = (phys / scaling) + offset`` \n\
\n\
If no axes parameter is given, the values are assumed to belong the the ascending axis \n\
list (0, 1, 2, 3...). The returned pixel value is clipped by the <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> size of the data \n\
object in the requested dimension ``[0, shape[axis] - 1]``. \n\
\n\
Parameters  \n\
------------\n\
values : float or sequence of float\n\
    One single pixel coordinate or a tuple of pixel coordinates.\n\
axes : int or sequence of int, optional \n\
    If ``values`` is a single value, axes must be ``None`` or one integer, that defines \n\
    the axis for which the transformation should be calculated. \n\
    If ``values`` is a tuple of float values, axes can be one single value (all values \n\
    are transformed with respect to the same axis), or a tuple of int, whose size must be \n\
    equal to the size of the ``axes`` tuple. Each value is then transformed with the \n\
    corresponding value in ``axes``. \n\
    If ``None`` is given, ``axes`` is assumed to be an ascending list of values ``0, 1, 2, ...``. \n\
\n\
Returns \n\
-------- \n\
float or tuple of float \n\
    The transformed pixel coordinates for the given axes to physical coordinates. \n\
\n\
Raises \n\
------- \n\
ValueError \n\
    if the given axes is out of range.&quot;)</td></tr>
<tr class="separator:a56fadecc9559e3c3397a5dfceb0c8723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1530c1897d2e3e5767b3a9e13f55b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec1530c1897d2e3e5767b3a9e13f55b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSetTag_doc,&quot;setTag(key, value) \n\
\n\
Set the ``value`` of a tag with the given ``key`` name. \n\
\n\
If a tag with the given ``key`` exists, its value is overwritten. Else, a tag with \n\
that ``key`` is added to the tags. \n\
\n\
Parameters  \n\
----------\n\
key : str\n\
    the name of the tag.\n\
tagvalue : str or float\n\
    The new value of the tag. Must be a :obj:`str` or a :obj:`float` value. \n\
\n\
Notes \n\
----- \n\
Do NOT use 'special character' within the tag key because they are not XML-save.&quot;)</td></tr>
<tr class="separator:aec1530c1897d2e3e5767b3a9e13f55b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173e6be441bb2de803f905ca36c4ad04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a173e6be441bb2de803f905ca36c4ad04"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectDeleteTag_doc,&quot;deleteTag(key) -&gt; bool \n\
\n\
Deletes a tag specified by ``key`` from the tag dictionary. \n\
\n\
Parameters  \n\
------------\n\
key : str\n\
    the name of the tag to be deleted.\n\
\n\
Returns \n\
-------- \n\
success : bool \n\
    ``True`` if tag with given key existed and could be deleted, otherwise ``False``.&quot;)</td></tr>
<tr class="separator:a173e6be441bb2de803f905ca36c4ad04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594ab5e575b7db8e680d657d2d23cdb8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a594ab5e575b7db8e680d657d2d23cdb8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectTagExists_doc,&quot;existTag(key) -&gt; bool \n\
\n\
Checks if a certain tag key exists. \n\
\n\
Checks whether a tag with the given ``key`` exists in tag dictionary of this \n\
data object and returns ``True`` if such a tag exists, else ``False``. \n\
\n\
Parameters  \n\
------------\n\
key : str\n\
    the key of the tag.\n\
\n\
Returns \n\
-------- \n\
bool\n\
    ``True`` if tag exists, else ``False``&quot;)</td></tr>
<tr class="separator:a594ab5e575b7db8e680d657d2d23cdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edd1e0b2377aa78b94e885bca45b3ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1edd1e0b2377aa78b94e885bca45b3ea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectGetTagListSize_doc,&quot;getTagListSize() -&gt; int \n\
\n\
Returns the number of tags in the tag dictionary.\n\
\n\
Every data object can have an arbitrary number of tags stored in the tag dictionary. \n\
This method returns the number of different tags, where the protocol is also one \n\
tag with the key ``protocol``. \n\
\n\
Returns \n\
------- \n\
length : int \n\
    Size of the tag dictionary. The optional protocol also counts as one item.&quot;)</td></tr>
<tr class="separator:a1edd1e0b2377aa78b94e885bca45b3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1850803f0d6a9259eb1efb36507f47c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1850803f0d6a9259eb1efb36507f47c9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectAddToProtocol_doc,&quot;addToProtocol(newLine) \n\
\n\
Appends one string entry to the protocol list. \n\
\n\
Appends a line of text to the protocol string of this data object. \n\
If this data object has got a region of interest defined, the rectangle of the ROI is \n\
automatically appended to ``newLine``. The protocol string ends with a newline character. \n\
\n\
Address the content of the protocol by ``obj.tags[\&quot;protocol\&quot;]``. The protocol is \n\
contained in the ordinary tag dictionary of this data object under the key ``protocol``. \n\
\n\
Parameters  \n\
------------\n\
newLine : str\n\
    The text to be added to the protocol.&quot;)</td></tr>
<tr class="separator:a1850803f0d6a9259eb1efb36507f47c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629685caa31520fb6acd08af6c19a191"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a629685caa31520fb6acd08af6c19a191"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectName_doc,&quot;name() -&gt; str \n\
\n\
Returns the name of this object \n\
\n\
Returns \n\
------- \n\
str \n\
    the name of this object (``dataObject``)&quot;)</td></tr>
<tr class="separator:a629685caa31520fb6acd08af6c19a191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe452541a2c857e8f0f6ae3c140b490a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe452541a2c857e8f0f6ae3c140b490a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectData_doc,&quot;data() \n\
\n\
Prints the content of the dataObject to the command line in a readable form.&quot;)</td></tr>
<tr class="separator:afe452541a2c857e8f0f6ae3c140b490a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c361e6894bef483b97aaa5ac0bd109e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c361e6894bef483b97aaa5ac0bd109e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectConj_doc,&quot;conj() \n\
\n\
Converts this dataObject into its complex-conjugate (inline). \n\
\n\
Every value of this :class:`dataObject` is replaced by its complex-conjugate value. \n\
\n\
Raises \n\
------- \n\
TypeError \n\
    if the data type of this data object is not complex.\n\
\n\
See Also \n\
--------- \n\
conjugate : does the same operation but returns a complex-conjugated copy of this data object&quot;)</td></tr>
<tr class="separator:a5c361e6894bef483b97aaa5ac0bd109e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8a5be2c1cf5cd51529ab53bf653043"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a8a5be2c1cf5cd51529ab53bf653043"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectConjugate_doc,&quot;conjugate() -&gt; dataObject \n\
\n\
Returns a copy of this dataObject where every element is complex-conjugated. \n\
\n\
Returns \n\
------- \n\
dataObject \n\
    element-wise complex conjugate of this data object \n\
\n\
Raises \n\
------- \n\
TypeError \n\
    if the data type of this data object is not complex.\n\
\n\
See Also \n\
--------- \n\
conj : does the same operation but manipulates this object inline.&quot;)</td></tr>
<tr class="separator:a9a8a5be2c1cf5cd51529ab53bf653043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673319d36613da12bc85ede43a4cf99b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a673319d36613da12bc85ede43a4cf99b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectAdj_doc,&quot;adj() \n\
\n\
Adjugates this dataObject (plane-by-plane). \n\
\n\
Every plane (spanned by the last two axes) is transposed and every element is \n\
replaced by its complex conjugate value. This is done in-line. \n\
\n\
Raises \n\
------- \n\
TypeError \n\
    if the data type of this data object is not complex.\n\
\n\
See Also \n\
--------- \n\
adjugate : does the same operation but returns the resulting data object&quot;)</td></tr>
<tr class="separator:a673319d36613da12bc85ede43a4cf99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a744c26ba10456b1636b708b8e41380"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a744c26ba10456b1636b708b8e41380"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectAdjugate_doc,&quot;adjugate() -&gt; dataObject \n\
\n\
Returns the plane-wise adjugated array of this dataObject. \n\
\n\
If this data object has a complex type, the tranposed data object is returned where \n\
every element is complex conjugated. For data objects with more than two dimensions \n\
the tranposition is done plane-wise, hence, only the last two dimensions are permuted. \n\
\n\
Returns \n\
------- \n\
dataObject \n\
    adjugate of this dataObject. \n\
\n\
Raises \n\
------- \n\
TypeError \n\
    if the data type of this data object is not complex.\n\
\n\
See Also \n\
--------- \n\
adj : does the same operation but manipulates this object inline.&quot;)</td></tr>
<tr class="separator:a1a744c26ba10456b1636b708b8e41380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a5f6ac00b3c0a5e8d39c07fd4373fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16a5f6ac00b3c0a5e8d39c07fd4373fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectTrans_doc,&quot;trans() -&gt; dataObject \n\
\n\
Returns the (plane-wise) transposed dataObject. \n\
\n\
Return a new data object with the same data type than this object and where every \n\
plane (data spanned by the last two dimensions) is transposed respectively \n\
such that the last two axes are permuted. The :attr:`shape` of the returned \n\
dataObject is then equal to the :attr:`shape` of this dataObject, but the last two \n\
values in the shape tuple are swapped. \n\
\n\
Returns \n\
-------- \n\
dataObject \n\
    A copy of this dataObject is returned where every plane is its transposed plane.&quot;)</td></tr>
<tr class="separator:a16a5f6ac00b3c0a5e8d39c07fd4373fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72371b3799c73b46e06c2778445c9528"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72371b3799c73b46e06c2778445c9528"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectMakeContinuous_doc,&quot;makeContinuous() -&gt; dataObject \n\
\n\
Returns a continuous representation of this dataObject.\n\
\n\
Per default a dataObject with more than two dimensions allocates separated chunks of \n\
memory for every plane, where a plane is always the matrix given by the last two \n\
dimensions. This separated storage usually allows allocating more memory for huge for \n\
instance three dimensional matrices. However, in order to generate a dataObject that is \n\
directly compatible to Numpy or other C-style matrix structures, the entire allocated \n\
memory must be in one block, that is called continuous. If you create a Numpy array \n\
from a dataObject that is not continuous, this function is implicitely called in order \n\
to firstly make the dataObject continuous before passing to Numpy. \n\
\n\
Returns \n\
-------- \n\
dataObject \n\
    If this dataObject is not continuous, its continuous representation is returned \n\
    as deep copy. A deep copy is also returned if this object is already :attr:`continuous`.&quot;)</td></tr>
<tr class="separator:a72371b3799c73b46e06c2778445c9528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2083f30ce3df955612723ad8cf2b4e5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2083f30ce3df955612723ad8cf2b4e5b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSize_doc,&quot;size(axisIndex = None) -&gt; Union[int, Tuple[int]] \n\
\n\
Returns the size of the selected axis of this dataObject or the entire shape tuple, if no specific axis is given. \n\
\n\
Parameters  \n\
------------\n\
axisIndex : int, optional\n\
    If ``axisIndex`` is given, only the size of the indicated axis is returned as \n\
    single number. \n\
\n\
Returns \n\
-------- \n\
int or tuple of int \n\
    A tuple containing the sizes of all dimensions or one single size value \n\
    if ``axisIndex`` is given. \n\
\n\
Raises \n\
------ \n\
DeprecatedWarning \n\
    This method is deprecated. For a more consistent syntax with \n\
    :class:`numpy.ndarray` objects, use :attr:`shape` instead. \n\
\n\
See Also \n\
--------- \n\
shape : the read-only attribute shape is equal to ``size()``.&quot;)</td></tr>
<tr class="separator:a2083f30ce3df955612723ad8cf2b4e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede2a45256024bbaefa422ac282a7f26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aede2a45256024bbaefa422ac282a7f26"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectCopy_doc,&quot;copy(regionOnly = False) -&gt; dataObject \n\
\n\
Returns a deep copy of this dataObject\n\
\n\
Parameters \n\
----------- \n\
regionOnly : bool, optional \n\
    If ``regionOnly`` is ``True``, only the current region of interest of this \n\
    dataObject is copied, else the entire dataObject including the shaded areas outside \n\
    of the current region of interest are copied, including the ROI settings [default].\n\
\n\
Returns \n\
------- \n\
dataObject \n\
    Deep copy of this dataObject. \n\
\n\
See Also \n\
-------- \n\
locateROI&quot;)</td></tr>
<tr class="separator:aede2a45256024bbaefa422ac282a7f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11662ccf5b4cc64ae051dbf2b832569"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad11662ccf5b4cc64ae051dbf2b832569"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectMul_doc,&quot;mul(otherObj) -&gt; dataObject \n\
\n\
Returns the result of the element-wise multiplication of this dataObject with otherObj. \n\
\n\
This :class:`dataObject` and ``otherObj`` must have the same :attr:`shape` and \n\
:attr:`dtype` for the element-wise multiplication. \n\
\n\
All meta information (axis scales, offsets, descriptions, units, tags...) of the \n\
resulting object are copied from this data object. \n\
\n\
Parameters  \n\
------------\n\
otherObj : dataObject \n\
    The returned :class:`dataObject` contains the result of the element-wise \n\
    multiplication of all values in this object and ``otherObj``. Must have the \n\
    same shape and data type than this object. \n\
\n\
Returns \n\
-------- \n\
result : dataObject \n\
    Resulting multiplied data object. Values, that exceed the range of the current \n\
    data type, will be set to the ``result modulo max(dtype)``. \n\
\n\
Notes \n\
------ \n\
For a mathematical multiplication see the @-operator.&quot;)</td></tr>
<tr class="separator:ad11662ccf5b4cc64ae051dbf2b832569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31baec15726e59f1c0e41e16eb665f4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31baec15726e59f1c0e41e16eb665f4e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectDiv_doc,&quot;div(otherObj) -&gt; dataObject \n\
\n\
Returns the result of the element-wise division of this dataObject by otherObj. \n\
\n\
This :class:`dataObject` and ``otherObj`` must have the same :attr:`shape` and \n\
:attr:`dtype` for the element-wise division. \n\
\n\
All meta information (axis scales, offsets, descriptions, units, tags...) of the \n\
resulting object are copied from this data object. \n\
\n\
Parameters  \n\
------------\n\
otherObj : dataObject \n\
    The returned :class:`dataObject` contains the result of the element-wise \n\
    division of all values in this object by ``otherObj``. Must have the \n\
    same shape and data type than this object. \n\
\n\
Returns \n\
-------- \n\
result : dataObject \n\
    Resulting divided data object. Values, that exceed the range of the current \n\
    data type, will be set to the ``result modulo max(dtype)``. \n\
\n\
Raises \n\
------ \n\
RuntimeError \n\
    if a **division by zero** occurs for integer or complex data types.&quot;)</td></tr>
<tr class="separator:a31baec15726e59f1c0e41e16eb665f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac151948fe881f81ddb80b841a16047b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac151948fe881f81ddb80b841a16047b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectReshape_doc,&quot;reshape(shape) -&gt; dataObject \n\
\n\
Returns a reshaped (shallow) copy of this dataObject. \n\
\n\
Reshaping means, that the shape (and optionally number of dimensions) of a \n\
:class:`dataObject` might be changed, unless the total number of elements is \n\
not changed. The reshaped and returned :class:`dataObject` has the same data type and \n\
data than this :class:`dataObject`. \n\
\n\
The shape of the returned object corresponds to the parameter ``shape``.  \n\
If the last two dimensions of ``shape`` and of this object are equal and if the \n\
data is not continously organized, a shallow copy can be returned, else a deep \n\
copy has to be created. \n\
\n\
Tags and the rotation matrix are copied. The axis tags are only copied for all axes \n\
whose size will not change beginning from the last axis (``x``). Copying the axis \n\
meta information is stopped after the first axis with a differing new size. \n\
\n\
Parameters \n\
----------- \n\
shape : sequence of int \n\
    New shape of the returned object. A minimal size of this list or tuple is two. \n\
\n\
Returns \n\
-------- \n\
reshaped : dataObject \n\
    The reshaped data object. \n\
\n\
Notes \n\
----- \n\
This method is similar to :meth:`numpy.reshape`.&quot;)</td></tr>
<tr class="separator:ac151948fe881f81ddb80b841a16047b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aa3ffb5ea31bd885114dd0834ac5b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50aa3ffb5ea31bd885114dd0834ac5b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectAstype_doc,&quot;astype(typestring) -&gt; dataObject \n\
\n\
Converts this dataObject to another data type.\n\
\n\
Converts this :class:`dataObject` to a new dataObject with another data type, given by \n\
the string ``typestring`` (e.g. 'uint8'). The converted dataObject is a deep copy of \n\
this object if the new type does not correspond to the current type, else a shallow \n\
copy of this object is returned. \n\
\n\
Parameters \n\
----------- \n\
typestring : str \n\
    Type string indicating the new type (``uint8``, ..., ``float32``, ..., \n\
    ``complex128``). \n\
\n\
Returns \n\
-------- \n\
dataObject \n\
    The converted :class:`dataObject`.&quot;)</td></tr>
<tr class="separator:a50aa3ffb5ea31bd885114dd0834ac5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ead3d91866a85e15846ce9cfc1efb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09ead3d91866a85e15846ce9cfc1efb2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectNormalize_doc,&quot;normalize(minValue = 0.0, maxValue = 1.0, typestring = \&quot;\&quot;) -&gt; dataObject \n\
\n\
Returns a normalized version of this dataObject. \n\
\n\
All values in the returned :class:`dataObject` are normalized with respect to the given \n\
range ``[minValue, maxValue]``. Additionally it is also possible to convert the \n\
resulting data object to another data type (given by the parameter ``typestring``). \n\
Per default, no such a type conversion is done (empty ``typestring`` argument). \n\
\n\
For the normalization, the current minimum and maximum value of this object is \n\
determined: \n\
\n\
.. math:: \n\
\n\
    min_{cur} = min(thisObj) \n\
    max_{cur} = max(thisObj) \n\
\n\
Each value `v` is then normalized by: \n\
\n\
.. math:: v_{norm} = minValue + (v - min_{cur}) * (maxValue - minValue) / (max_{cur} - min_{cur}) \n\
\n\
Parameters \n\
----------- \n\
minValue : float \n\
    minimum value of the normalized range. \n\
maxValue : float \n\
    maximum value of the normalized range. \n\
typestring : str \n\
    Data type for an optional type conversion. If an empty :obj:`str` is given, \n\
    no such a conversion is done. Else possible values are (among others): \n\
    (``uint8``, ..., ``float32``, ..., ``complex128``). \n\
\n\
Returns \n\
-------- \n\
normalized : dataObject \n\
    normalized data object \n\
\n\
Notes \n\
----- \n\
For complex data types, the current minimum and maximum values are calculated \n\
based on the absolute value of the complex values. Therefore, the normalization \n\
can have a different result, than maybe expected.&quot;)</td></tr>
<tr class="separator:a09ead3d91866a85e15846ce9cfc1efb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6c0bab755010a30e6b409ef208b05b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e6c0bab755010a30e6b409ef208b05b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectLocateROI_doc,&quot;locateROI() -&gt; Tuple[List[int], List[int]] \n\
\n\
Returns information about the current region of interest of this dataObject. \n\
\n\
In Python, it is common to use slices of other objects, like lists, tuples, \n\
:class:`numpy.ndarray` among others. This slice represents a subpart of the original \n\
object, however the values within the slice are still the same than in the original \n\
object. \n\
\n\
The same holds for :class:`dataObject`, where a slice will return a shallow \n\
copy of the original object with a maybe reduced size. This is denoted as region \n\
of interest (ROI). Here an example:: \n\
    \n\
    org = dataObject.ones([100, 200], 'float32') \n\
    roi = org[10:20, 5:9]  # slicing \n\
    \n\
    roi[0, 0] = 100  # change one value in roi \n\
    print(org[10, 5])  # returns 100 \n\
\n\
Although the first value in ``roi`` is changed, its corresponding value in ``org`` \n\
is changed, too. This is the principle of shallow copies and slicing / region of \n\
interests. \n\
\n\
This method returns information about the exact **position** of the region of \n\
interest within its original :class:`dataObject`. This is defined by two values \n\
for each axis. The first value indicates the distance between the left, top, etc. border \n\
of the original object and the border of this object. If no region of interest is set, \n\
these values are ``0`` everywhere. \n\
\n\
The second values define the distances between the right, bottom, ... margins of this \n\
object and its original object (or ``0`` everywhere, too). \n\
\n\
This method returns a tuple with two elements: The first is a list with the original \n\
sizes of this data object (if no ROI would have been set), the second is a list with \n\
the offsets from the original data object to the first value in the current region of \n\
interest. \n\
\n\
If no region of interest is set (hence: full region of interest), the first list \n\
corresponds to the one returned by :attr:`shape`, the 2nd list contains ``0`` everyhwere. \n\
\n\
The output of the example above would be:: \n\
    \n\
    print(roi.locateROI()) \n\
    # &gt;&gt;&gt; ([100, 200], [10, 5]) \n\
\n\
Returns \n\
------- \n\
orgSize : list of int \n\
    The original sizes of this object (without ROI). This is equal to :attr:`shape` \n\
    of the original object. \n\
offsets : list of int \n\
    A list with ``N`` values, where ``N`` is the number of dimensions of this object. \n\
    Each value ``n = 1 .. N`` is the offset of the first value of axis ``n`` in this \n\
    object with respect to the original object. \n\
\n\
See Also \n\
-------- \n\
adjustROI : method to change the current region of interest&quot;)</td></tr>
<tr class="separator:a5e6c0bab755010a30e6b409ef208b05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262f5992c000f957555f85a3f5b97e0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a262f5992c000f957555f85a3f5b97e0d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectAdjustROI_doc,&quot;adjustROI(offsets) \n\
\n\
Adjusts the size and position of the region of interest of this object.\n\
\n\
In Python, it is common to use slices of other objects, like lists, tuples, \n\
:class:`numpy.ndarray` among others. This slice represents a subpart of the original \n\
object, however the values within the slice are still the same than in the original \n\
object. \n\
\n\
The same holds for :class:`dataObject`, where a slice will return a shallow \n\
copy of the original object with a maybe reduced size. This is denoted as region \n\
of interest (ROI). Here an example:: \n\
    \n\
    org = dataObject.ones([100, 200], 'float32') \n\
    roi = org[10:20, 5:9]  # slicing \n\
    \n\
    roi[0, 0] = 100  # change one value in roi \n\
    print(org[10, 5])  # returns 100 \n\
\n\
Although the first value in ``roi`` is changed, its corresponding value in ``org`` \n\
is changed, too. This is the principle of shallow copies and slicing / region of \n\
interests. \n\
\n\
This method is used to change to offset and / or size of the current ROI of this \n\
object. Of course, this ROI can never be bigger than the original array data. \n\
In order to change the position and / or size of the current region of interest, \n\
pass a sequence (list or tuple) of integer values. The length of this sequence \n\
must be ``2 * ndim``, where ``ndim`` is the number of dimensions of this object. \n\
Always two adjacent values in this sequence refer to one axis, starting with \n\
the first axis index and ending with the last one. The first value of such a pair \n\
of two values indicate the offset of the region of interest with respect to one \n\
border of this axis (e.g. the left or top border), the 2nd value is the offset \n\
with respect to the other side of this axis (e.g. the right or bottom border). \n\
Negative values decrease the size of the ROI towards the center, positive values \n\
will increase its current size. \n\
\n\
Example: :: \n\
\n\
    d = dataObject([5, 4]) \n\
    droi = dataObject(d)  # make a shallow copy \n\
    droi.adjustROI([-2, 0, -1, -1]) \n\
\n\
Now, ``droi`` has a ROI, whose first value is equal to ``d[2, 1]`` and its shape \n\
is ``(3, 2)``. \n\
\n\
Parameters \n\
----------- \n\
offsets : list of int or tuple of int \n\
    This sequence must have twice as many values than the number of dimensions of \n\
    this :class:`dataObject`. A pair of numbers indicates the shift of the \n\
    current boundaries of the region of interest in every dimension. The first value \n\
    of each pair is the offset of the **left** boundary, the second the shift of the \n\
    **right** boundary. A positive value means a growth of the region of interest, \n\
    a negative one let the region of interest shrink towards the center. \n\
\n\
Raises \n\
------ \n\
RuntimeError \n\
    if desired, new ROI exceeds the original shape of this :class:`dataObject`. \n\
\n\
See Also \n\
--------- \n\
locateROI : method to get the borders of the current ROI&quot;)</td></tr>
<tr class="separator:a262f5992c000f957555f85a3f5b97e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e4ec9c63f94e0ead51d6047c5322c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80e4ec9c63f94e0ead51d6047c5322c9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectSqueeze_doc,&quot;squeeze() -&gt; dataObject \n\
\n\
Returns a squeezed shallow copy (if possible) of this dataObject. \n\
\n\
This method removes every dimension with size equal to ``1``. A shallow copy is only \n\
returned, if the sub-arrays, spanned by the last two dimensions (denoted as planes), \n\
are not affected by the squeeze operation and if the data block in the \n\
:class:`dataObject` is not continuous. Else a deep copy has to be returned due to an \n\
overall re-alignment of the matrix. The returned object can never have less than \n\
two dimensions. If this is the case, the last or second to last dimensions with a size \n\
of ``1`` is not deleted. If :this method returns a shallow copy, a change in a \n\
value will change the same value in the original object, too. \n\
\n\
Returns \n\
-------- \n\
squeezed : dataObject \n\
    The squeezed data object. \n\
\n\
Notes \n\
----- \n\
This method is similar to :meth:`numpy.squeeze`.&quot;)</td></tr>
<tr class="separator:a80e4ec9c63f94e0ead51d6047c5322c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953e1b729bf954ab4ffee9e5b740d211"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a953e1b729bf954ab4ffee9e5b740d211"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrReal_doc,&quot;dataObject : Gets or sets the `<a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a>` part of this ``complex64`` or ``complex128`` object. \n\
\n\
The <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> part object has the same shape than this :class:`dataObject`. If the data type \n\
of this object is ``complex64``, the <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> part object has the data type ``float32``. \n\
For a ``complex128`` object, the <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> part is ``float64``. \n\
\n\
If a <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> part object is set to this attribute, it can be either a :class:`numpy.ndarray` \n\
or a :class:`dataObject` with the same shape than this object and the appropriate data type. \n\
However, it is also possible to pass an :obj:`int` or :obj:`float` value. This value is \n\
then assigned to the <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> part of all complex values. \n\
\n\
Raises \n\
------ \n\
TypeError \n\
    if this :class:`dataObject` has no complex data type.&quot;)</td></tr>
<tr class="separator:a953e1b729bf954ab4ffee9e5b740d211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b1c8d01544111e5ff13f8c5c198cc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4b1c8d01544111e5ff13f8c5c198cc2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrImag_doc,&quot;dataObject : Gets or sets the `<a class="el" href="namespaceito.html#a5293e802d23cc6b2d23d43b09bd598f4">imag</a>` part of this ``complex64`` or ``complex128`` object. \n\
\n\
The imaginary part object has the same shape than this :class:`dataObject`. If the data type \n\
of this object is ``complex64``, the <a class="el" href="namespaceito.html#a5293e802d23cc6b2d23d43b09bd598f4">imag</a> part object has the data type ``float32``. \n\
For a ``complex128`` object, the <a class="el" href="namespaceito.html#a5293e802d23cc6b2d23d43b09bd598f4">imag</a> part is ``float64``. \n\
\n\
If an imaginary part object is set to this attribute, it can be either a :class:`numpy.ndarray` \n\
or a :class:`dataObject` with the same shape than this object and the appropriate data type. \n\
However, it is also possible to pass an :obj:`int` or :obj:`float` value. This value is \n\
then assigned to the imaginary part of all complex values. \n\
\n\
Raises \n\
------ \n\
TypeError \n\
    if this :class:`dataObject` has no complex data type.&quot;)</td></tr>
<tr class="separator:ae4b1c8d01544111e5ff13f8c5c198cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae879cd4e6a64d61304ef33b68c5ef93b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae879cd4e6a64d61304ef33b68c5ef93b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectAbs_doc,&quot;abs() -&gt; dataObject \n\
\n\
Returns a new dataObject with the absolute values of this object. \n\
\n\
The absolute values in the resulting :class:`dataObject` are determined for \n\
both <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> (integer and floating point) and complex data types of this object. \n\
This method raises a ``TypeError`` for a ``rgba32`` data type. \n\
\n\
Raises \n\
------ \n\
TypeError \n\
    if this method is called for a dataObject of data type ``rgba32``. \n\
\n\
Returns \n\
------- \n\
absObj : dataObject \n\
    Array with the same size than this object, that contains the absolute values \n\
    of this object. If the data type of this object is complex, the returned \n\
    object has the corresponding floating point data type. Else, the data type \n\
    is unchanged. If this :class:`dataObject` has an unsigned integer data type, \n\
    its shallow copy is returned without any changes.&quot;)</td></tr>
<tr class="separator:ae879cd4e6a64d61304ef33b68c5ef93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac237e3af05215f4e0aa53fed06a669d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac237e3af05215f4e0aa53fed06a669d3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectArg_doc,&quot;arg() -&gt; dataObject \n\
\n\
Returns a new data object with the argument values of this complex type dataObject. \n\
\n\
This method calculates the argument value of each element in this :class:`dataObject`\n\
and returns these values as new dataObject with the same shape than this object. \n\
This object must be of complex data type (``complex128`` or ``complex64``). \n\
The output data type will be float then (``float64`` or ``float32``).\n\
\n\
Returns \n\
------- \n\
argObj : dataObject \n\
    is the argument function applied to all values of this dataObject.&quot;)</td></tr>
<tr class="separator:ac237e3af05215f4e0aa53fed06a669d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab979a05cfbb07306b1ec8fa9ad3ced40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab979a05cfbb07306b1ec8fa9ad3ced40"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectAttrTagDict_doc,&quot;dict : Gets or sets a dictionary with all meta information of this dataObject. \n\
\n\
The dictionary contains the following key-value-pairs. If a new dictionary \n\
is set to this attribute, all these values must be contained in the dict: \n\
\n\
* axisOffsets : List with offsets of each axis. \n\
* axisScales : List with the scales of each axis. \n\
* axisUnits : List with the unit strings of each axis. \n\
* axisDescriptions : List with the description strings of each axis. \n\
* tags : Dictionary with all tags including the tag **protocol** if at least \n\
  one protocol entry has been added using :meth:`addToProtocol`. \n\
* valueOffset : Offset of each value (0.0). \n\
* valueScale : Scale of each value (1.0). \n\
* valueDescription : Description of the values. \n\
* valueUnit : The unit string of the values. \n\
\n\
This attribute was read-only until itom 4.0. It is settable from itom 4.1 on. \n\
\n\
See Also \n\
-------- \n\
addToProtocol, axisOffsets, axisScales, axisUnits, axisDescriptions, \n\
valueUnit, valueDescription, tags&quot;)</td></tr>
<tr class="separator:ab979a05cfbb07306b1ec8fa9ad3ced40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6ba00a41ffffc722a6f9ce7f943cff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf6ba00a41ffffc722a6f9ce7f943cff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectArray_StructGet_doc,&quot;Any : General python-array interface (do not call this directly) \n\
\n\
This interface makes the data object compatible to every array structure in Python \n\
which does equally implement the array interface (e.g. NumPy). This method is \n\
therefore a helper method for the array interface.&quot;)</td></tr>
<tr class="separator:abf6ba00a41ffffc722a6f9ce7f943cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48eb9d1cce0598505fa89e2b60be73e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab48eb9d1cce0598505fa89e2b60be73e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObjectArray_Interface_doc,&quot;dict : General python-array interface (do not call this directly). \n\
\n\
This interface makes the data object compatible to every array structure in python \n\
which does equally implement the array interface (e.g. NumPy).&quot;)</td></tr>
<tr class="separator:ab48eb9d1cce0598505fa89e2b60be73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa790ad960cc2d7e8ac3f120f8cb6eb0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa790ad960cc2d7e8ac3f120f8cb6eb0f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (dataObject_Array__doc,&quot;__array__(dtype = None) -&gt; np.ndarray \n\
\n\
Returns a numpy.ndarray from this dataObject. If possible a shallow copy is returned. \n\
\n\
If no ``dtype`` is given and if the this :class:`dataObject` is continuous, \n\
a :class:`numpy.ndarray` that shares its memory with this dataObject is returned. \n\
If the desired ``dtype`` does not fit to the type of this :class:`dataObject`, \n\
a casted deep copy is returned. This is also the case if this dataObject is not \n\
continuous. Then a continuous dataObject is created that is the base object of \n\
the returned :class:`numpy.ndarray`. \n\
\n\
Parameters \n\
---------- \n\
dtype : numpy.dtype, optional \n\
    A :class:`numpy.dtype` object that describes the data type, data alignment etc. \n\
    for the returned :class:`numpy.ndarray`. \n\
\n\
Returns \n\
------- \n\
arr : numpy.ndarray \n\
    The converted :class:`numpy.ndarray`&quot;)</td></tr>
<tr class="separator:aa790ad960cc2d7e8ac3f120f8cb6eb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7e9e954f6d263efd80b0f6af917bf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c7e9e954f6d263efd80b0f6af917bf5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObj_ToGray_doc,&quot;toGray(destinationType = \&quot;uint8\&quot;) -&gt; dataObject \n\
\n\
Converts this ``rgba32`` coloured dataObject into a gray-scale dataObject. \n\
\n\
The returned :class:`dataObject` has the same size than this :class:`dataObject` \n\
and the <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a>-value data type, that is given by ``destinationType``. The pixel-wise \n\
conversion is done using the formula: \n\
\n\
.. math: gray = 0.299 * red + 0.587 * green + 0.114 * blue.\n\
\n\
Parameters \n\
----------- \n\
destinationType : {\&quot;uint8\&quot;, \&quot;int8\&quot;, \&quot;uint16\&quot;, \&quot;int16\&quot;, \&quot;int32\&quot;, \&quot;float32\&quot;, \&quot;float64\&quot;}, optional \n\
    Desired data type of the returned dataObject (only <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> value data types allowed). \n\
\n\
Returns \n\
------- \n\
gray : dataObject \n\
    converted gray-scale data object of desired type. \n\
\n\
Raises \n\
------ \n\
TypeError \n\
    if this dataObject is no ``rgba32`` object or if the ``destinationType`` is invalid.&quot;)</td></tr>
<tr class="separator:a1c7e9e954f6d263efd80b0f6af917bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74c810f7e7b2daf288f68309e61f1d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af74c810f7e7b2daf288f68309e61f1d8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObj_SplitColor_doc,&quot;splitColor(color, destinationType = \&quot;uint8\&quot;) -&gt; dataObject \n\
\n\
Splits selected color channels from this coloured ``rgba32`` dataObject. \n\
\n\
A ``rgba32`` coloured :class:`dataObject` contains color values for each item. \n\
Each color value contains a red, green, blue and alpha (transparancy) component (uint8 \n\
each). This method allows extracting one or several of these components from this \n\
dataObject. These components are then returned in single slices of a new, first axis \n\
of the returned dataObject. \n\
\n\
The returned :class:`dataObject` has one axis more than this object. This new axis \n\
is prepended to the existing axes, that have the same shape than this object. The data \n\
type of the returned object is ``destinationType``. \n\
\n\
The size of the first, new axis is equal to the number of letters in ``color``. \n\
Each letter must be one of the characters ``b``, ``r``, ``g`` or ``a``, that stand \n\
for the available channels of the color, that can be extracted. \n\
\n\
Example: :: \n\
    \n\
    color = dataObject.zeros([20, 10], 'rgba32') \n\
    split_colors = color.splitColor(\&quot;rgb\&quot;) \n\
    print(split_colors.shape, split_colors.dtype) \n\
    # printout: [3, 20, 10], \&quot;uint8\&quot; \n\
\n\
In this example, the :attr:`shape` of ``split_colors`` is ``[3, 20, 10]``, since \n\
three channels (red, green and blue) should have been splitted, such that \n\
``split_colors[0, :, :]`` contains the red component, etc. \n\
\n\
Parameters \n\
----------- \n\
color : str \n\
    Desired color string, that indicates the type and order of extracted color \n\
    components. This string can consist of the following letters: ``('b', 'r', 'g', 'a')``. \n\
    It is possible to combine different channels, like ``\&quot;arg\&quot;`` which extracts the \n\
    alpha channel, followed by red and gree. \n\
destinationType : {\&quot;uint8\&quot;, \&quot;int8\&quot;, \&quot;uint16\&quot;, \&quot;int16\&quot;, \&quot;int32\&quot;, \&quot;float32\&quot;, \&quot;float64\&quot;}, optional \n\
    Desired data type of the returned dataObject (only <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> value data types allowed). \n\
\n\
Returns \n\
------- \n\
dataObject \n\
    containing the selected channel values \n\
\n\
Raises \n\
------ \n\
TypeError \n\
    if this :class:`dataObject` is no ``rgba32`` object or if ``destinationType`` \n\
    is no <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> data type.&quot;)</td></tr>
<tr class="separator:af74c810f7e7b2daf288f68309e61f1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff3cf4da9e7d9ee66ce1387a3e12622"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ff3cf4da9e7d9ee66ce1387a3e12622"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObj_ToNumpyColor_doc,&quot;toNumpyColor(addAlphaChannel = 0) -&gt; np.ndarray \n\
\n\
Converts a 2D dataObject of type ``rgba32`` to a 3D numpy.ndarray of type ``uint8``. \n\
\n\
Many Python packages, e.g. OpenCV (cv2) or PIL store coloured array such that the color \n\
components are stored in an additional axis, which is the last axis of all axes. \n\
Hence, there is no specific ``rgba2`` data type for :class:`numpy.ndarray`, like it \n\
is the case for :class:`dataObject`. \n\
\n\
This method converts a coloured :class:`dataObject` of dtype ``rgba32`` to a compatible \n\
:class:`numpy.ndarray`, where the color components are stored in an additional last axis. \n\
The size of this last axis is either ``3`` if ``addAlphaChannel = 0`` or ``4`` otherwise. \n\
The order of this last axis is ``blue``, ``green``, ``red`` and optional ``alpha``. \n\
The remaining first axes of the returned object have the same shape than this dataObject. \n\
\n\
Parameters \n\
----------- \n\
addAlphaChannel : int, optional \n\
    If ``0``, the last dimension of the returned :class:`numpy.ndarray` has a size of ``3`` \n\
    and contains the blue, green and red value, whereas ``1`` adds the alpha value as \n\
    fourth value. \n\
\n\
Returns \n\
------- \n\
arr : numpy.ndarray \n\
    The 3D :class:`numpy.ndarray` of dtype ``uint8``. The shape is ``[*obj.shape, 3]`` or \n\
    ``[*obj.shape, 4]``, depending on ``addAlphaChannel``, where ``obj`` is this \n\
    :class:`dataObject`.&quot;)</td></tr>
<tr class="separator:a8ff3cf4da9e7d9ee66ce1387a3e12622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae13a10dc1632465731541a408411855"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae13a10dc1632465731541a408411855"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectToList_doc,&quot;tolist() -&gt; list \n\
\n\
Returns a nested list with all values of this dataObject. \n\
\n\
An empty :class:`dataObject` with zero dimensions will return an empty list. \n\
Else, the depth of the nested list corresponds to the number of dimensions \n\
of this :class:`dataObject`. The innermost level corresponds to one ``row`` \n\
of this dataObject, or in general, to one set of values along the last \n\
axis of this object. This innermost list contains all these values. \n\
\n\
Returns \n\
------- \n\
list \n\
    Nested list with values of data object. The data types depend on the ``dtype`` \n\
    of this dataObject and can be :obj:`int`, :obj:`float`, :obj:`complex` or \n\
    :class:`rgba`.&quot;)</td></tr>
<tr class="separator:aae13a10dc1632465731541a408411855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8074255289e172b0cd2927a305f51ac9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8074255289e172b0cd2927a305f51ac9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectCreateMask_doc,&quot;createMask(shapes, inverse = False) -&gt; dataObject \n\
\n\
Returns an ``uint8`` mask dataObject where all pixels of this object that are contained in any shape are masked. \n\
\n\
The returned :class:`dataObject` has the same shape than this object and the data type \n\
``uint8``. All pixels in this object, that are contained in any of the given :class:`shape` \n\
will be set to ``255`` in the returned array, otherwise ``0``. \n\
\n\
Parameters \n\
----------- \n\
shapes : shape or list of shape or tuple of shape \n\
    The union of all given shapes (polygons, rectangles, squares, circles and ellipes \n\
    are considered, only) is used to determine if any pixel should be masked in the \n\
    returned mask (value ``255``) or not. \n\
inverse : bool \n\
    If ``True``, masked values are set to ``0`` (instead of ``255``) and all other \n\
    values are set to ``255`` (instead of ``0``). The default is ``False`` (masked = ``255``). \n\
\n\
Returns \n\
------- \n\
mask : dataObject \n\
    uint8 :class:`dataObject` as mask with the same shape, :attr:`axisScales`, \n\
    :attr:`axisOffsets`, :attr:`axisDescriptions` and :attr:`axisUnits` than this \n\
    object.&quot;)</td></tr>
<tr class="separator:a8074255289e172b0cd2927a305f51ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac869749d495dab470050530ac3a6a42b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac869749d495dab470050530ac3a6a42b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectDstack_doc,&quot;dstack(objects) -&gt; dataObject \n\
\n\
Returns a 3D dataObject with the stacked dataObjects in the objects sequence. \n\
\n\
The given dataObjects must all have the same type as well as the same size of both \n\
last axes / dimensions. This method then returns a 3d :class:`dataObject` of the same \n\
type, whose size of the two last axes correspond to those of the input ``objects``. \n\
The returned 3D :class:`dataObject` contains then a stacked representation of all \n\
given input dataObjects depth wise (along first axis). \n\
\n\
If any of the input dataObjects has more than two dimensions, all contained planes \n\
(x,y-matrices) are also stacked in the resulting object.\n\
\n\
Parameters \n\
----------- \n\
objects : list of dataObject or tuple of dataObject \n\
    Sequence (list) of dataObjects containing planes that will be stacked together. \n\
    All dataObjects must be of the same type and have the same shape of planes \n\
    (last two dimensions).\n\
\n\
Returns \n\
------- \n\
stack : dataObject \n\
    If ``objects`` is an empty list or tuple, an empty :class:`dataObject` is returned. \n\
    Else if ``objects`` only contains one array, this array is returned. Otherwise, \n\
    all dataObjects (2D or 3D) in ``objects`` are vertically stacked along the first \n\
    axis, which is prepended to the existing axes before.&quot;)</td></tr>
<tr class="separator:ac869749d495dab470050530ac3a6a42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a855ce38249d9fdcdba7eed5033093ded"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a855ce38249d9fdcdba7eed5033093ded"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectLineCut_doc,&quot;lineCut(coordinates) -&gt; dataObject \n\
\n\
Returns a dataObject with the values of this object along a line with the given coordinates. \n\
\n\
This method uses the **Bresenham** algorithm to get the nearest values along \n\
a line, whose start- and end-point is given by ``coordinates``. These values \n\
are returned in a new :class:`dataObject` with the same data type than this \n\
object. \n\
\n\
This method can be applied to 2D and 3D dataObjects. In the case of a 3D object, \n\
the line cut is defined plane-by-plane and the values are put in one row \n\
for each plane of this object. \n\
\n\
Parameters \n\
----------- \n\
coordinates : list of float or tuple of float \n\
    A sequence of 4 :class:`float` values, that define the physical coordinates \n\
    of the start- and end point of the desired line along which the nearest values \n\
    should be gathered. The values are: ``[x0, y0, x1, y1]``. \n\
\n\
Returns \n\
------- \n\
lineCut : dataObject \n\
    An array of the same data type than this object and shape ``P x N``, that \n\
    contains the nearest values along the given line coordinates. If this \n\
    :class:`dataObject` has two dimensions, ``P = 1``, else ``P`` is equal \n\
    to the size of the first dimension (``shape[0]``). ``N`` corresponds to \n\
    the number of points along the line, defined by the used **Bresenham** \n\
    algorithm. \n\
\n\
Raises \n\
------ \n\
RuntimeError \n\
    if this dataObject has more than three dimensions.&quot;)</td></tr>
<tr class="separator:a855ce38249d9fdcdba7eed5033093ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378a42a18c3c706180653555d988c740"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a378a42a18c3c706180653555d988c740"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectStaticZeros_doc,&quot;dims, dtype= \&quot;uint8\&quot;, continuous = 0) -&gt; dataObject \n\
\n\
Creates a dataObject filled with zeros. \n\
\n\
Parameters \n\
----------- \n\
dims : tuple of int or list of int \n\
    ``dims`` is the shape of the new :class:`dataObject`. The length of this list \n\
    or tuple defines the number of dimensions, e.g. ``[2, 3]`` creates a 2D dataObject\n\
    with two rows and three columns. \n\
dtype : str, optional \n\
    The desired data type for the elements in the returned :class:`dataObject`. \n\
    Possible values are: ``int8``, ``uint8``, ..., ``int32``, ``float32``, \n\
    ``float64``, ``complex64``, ``complex128``, ``rgba32``. \n\
continuous : int, optional \n\
    This value defines if the planes (each sub-array of the last two dimensions) \n\
    are continuously allocated in memory (``1``) or distributed in various smaller \n\
    junks (``0``, default). The latter is recommended for huge, n-dimensional matrices. \n\
    This argument is only considered for ``len(dims) &gt; 2``. \n\
\n\
Returns \n\
------- \n\
array : dataObject \n\
    The newly created dataObject of shape ``dims`` and data type ``dtype``, filled with \n\
    zeros. \n\
\n\
See Also \n\
--------- \n\
eye : method for creating an eye matrix \n\
ones : method for creating a matrix filled with ones \n\
\n\
Notes \n\
------ \n\
For the color data type ``rgba32``, every value will be black and transparent: \n\
``(r=0, g=0, b=0, alpha=0)``.&quot;)</td></tr>
<tr class="separator:a378a42a18c3c706180653555d988c740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025fba438f20bbb22db504d495f6b666"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a025fba438f20bbb22db504d495f6b666"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectStaticOnes_doc,&quot;ones(dims, dtype= \&quot;uint8\&quot;, continuous = 0) -&gt; dataObject \n\
\n\
Creates a dataObject filled ones. \n\
\n\
Parameters \n\
----------- \n\
dims : tuple of int or list of int \n\
    ``dims`` is the shape of the new :class:`dataObject`. The length of this list \n\
    or tuple defines the number of dimensions, e.g. ``[2, 3]`` creates a 2D dataObject\n\
    with two rows and three columns. \n\
dtype : str, optional \n\
    The desired data type for the elements in the returned :class:`dataObject`. \n\
    Possible values are: ``int8``, ``uint8``, ..., ``int32``, ``float32``, \n\
    ``float64``, ``complex64``, ``complex128``, ``rgba32``. \n\
continuous : int, optional \n\
    This value defines if the planes (each sub-array of the last two dimensions) \n\
    are continuously allocated in memory (``1``) or distributed in various smaller \n\
    junks (``0``, default). The latter is recommended for huge, n-dimensional matrices. \n\
    This argument is only considered for ``len(dims) &gt; 2``. \n\
\n\
Returns \n\
------- \n\
array : dataObject \n\
    The newly created dataObject of shape ``dims`` and data type ``dtype``, filled with \n\
    ones. \n\
\n\
See Also \n\
--------- \n\
eye : method for creating an eye matrix \n\
zeros : method for creating a matrix filled with zeros \n\
\n\
Notes \n\
------ \n\
For the color data type ``rgba32``, every value will be white: \n\
``(r=255, g=255, b=255, alpha=255)``.&quot;)</td></tr>
<tr class="separator:a025fba438f20bbb22db504d495f6b666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452a5a6a8799f6f672750cfbc54f3d81"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a452a5a6a8799f6f672750cfbc54f3d81"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectStaticNans_doc,&quot;nans(dims, dtype= \&quot;float32\&quot;, continuous = 0) -&gt; dataObject \n\
\n\
Creates a floating-point dataObject filled with ``NaN`` values. \n\
\n\
Parameters \n\
----------- \n\
dims : tuple of int or list of int \n\
    ``dims`` is the shape of the new :class:`dataObject`. The length of this list \n\
    or tuple defines the number of dimensions, e.g. ``[2, 3]`` creates a 2D dataObject\n\
    with two rows and three columns. \n\
dtype : str, optional \n\
    The desired data type for the elements in the returned :class:`dataObject`. \n\
    Possible values are: ``float32``, ``float64``, ``complex64``, ``complex128``. \n\
continuous : int, optional \n\
    This value defines if the planes (each sub-array of the last two dimensions) \n\
    are continuously allocated in memory (``1``) or distributed in various smaller \n\
    junks (``0``, default). The latter is recommended for huge, n-dimensional matrices. \n\
    This argument is only considered for ``len(dims) &gt; 2``. \n\
\n\
Returns \n\
------- \n\
array : dataObject \n\
    The newly created dataObject of shape ``dims`` and data type ``dtype``, filled with \n\
    ``NaN``. \n\
\n\
See Also \n\
--------- \n\
eye : method for creating an eye matrix \n\
zeros : method for creating a matrix filled with zeros \n\
ones : method for creating a matrix filled with ones.&quot;)</td></tr>
<tr class="separator:a452a5a6a8799f6f672750cfbc54f3d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2adf1d9738c248d5ecbd385c821fde4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2adf1d9738c248d5ecbd385c821fde4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectStaticRand_doc,&quot;rand(dims, dtype= \&quot;uint8\&quot;, continuous = 0) -&gt; dataObject \n\
\n\
Creates a dataObject filled with uniformly distributed random values. \n\
\n\
The value range of the random numbers depend on the desired data type ``dtype``: \n\
\n\
1. **integer types**: The random values are in the range ``[min(dtype), max(dtype)]``. \n\
2. **floating point types**: The random values are in the range ``[0, 1)``. \n\
3. **rgba32**: All colours as well as the alpha value is independently distributed in \n\
   the range ``[0, 255]``. \n\
4. **complex types**: Both the <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> as well as imaginary part is independently \n\
   distributed in the range ``[0, 1)``. \n\
\n\
Parameters \n\
----------- \n\
dims : tuple of int or list of int \n\
    ``dims`` is the shape of the new :class:`dataObject`. The length of this list \n\
    or tuple defines the number of dimensions, e.g. ``[2, 3]`` creates a 2D dataObject\n\
    with two rows and three columns. \n\
dtype : str, optional \n\
    The desired data type for the elements in the returned :class:`dataObject`. \n\
    Possible values are: ``int8``, ``uint8``, ..., ``int32``, ``float32``, \n\
    ``float64``, ``complex64``, ``complex128``, ``rgba32``. \n\
continuous : int, optional \n\
    This value defines if the planes (each sub-array of the last two dimensions) \n\
    are continuously allocated in memory (``1``) or distributed in various smaller \n\
    junks (``0``, default). The latter is recommended for huge, n-dimensional matrices. \n\
    This argument is only considered for ``len(dims) &gt; 2``. \n\
\n\
Returns \n\
------- \n\
array : dataObject \n\
    The newly created dataObject of shape ``dims`` and data type ``dtype``, filled with \n\
    random numbers. \n\
\n\
See Also \n\
--------- \n\
randN : method for creating a matrix filled with gaussian distributed values&quot;)</td></tr>
<tr class="separator:ab2adf1d9738c248d5ecbd385c821fde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e21db92d9e47cdc432da4bb9cb8b96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69e21db92d9e47cdc432da4bb9cb8b96"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectStaticRandN_doc,&quot;randN(dims, dtype= \&quot;uint8\&quot;, continuous = 0) -&gt; dataObject \n\
\n\
Creates a dataObject filled with Gaussian distributed random values. \n\
\n\
The value range of the random numbers depend on the desired data type ``dtype``: \n\
\n\
1. **integer types**: The random values are in the range ``[min(dtype), max(dtype)]``. \n\
2. **floating point types**: The random values are in the range ``[0, 1)``. \n\
3. **rgba32**: All colours as well as the alpha value is independently distributed in \n\
   the range ``[0, 255]``. \n\
4. **complex types**: Both the <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> as well as imaginary part is independently \n\
   distributed in the range ``[0, 1)``. \n\
\n\
The mean ``m`` and standard deviation ``s`` of the Gaussian distribution is as follows: \n\
\n\
* For **integer** and **rgba32** types holds: ``m = (min + max) / 2.0`` and \n\
  ``s = (max - min) / 6.0``. \n\
* For all **floating point** types holds: ``m = 0.0`` and ``s = 1/3``. \n\
\n\
Parameters \n\
----------- \n\
dims : tuple of int or list of int \n\
    ``dims`` is the shape of the new :class:`dataObject`. The length of this list \n\
    or tuple defines the number of dimensions, e.g. ``[2, 3]`` creates a 2D dataObject\n\
    with two rows and three columns. \n\
dtype : str, optional \n\
    The desired data type for the elements in the returned :class:`dataObject`. \n\
    Possible values are: ``int8``, ``uint8``, ..., ``int32``, ``float32``, \n\
    ``float64``, ``complex64``, ``complex128``, ``rgba32``. \n\
continuous : int, optional \n\
    This value defines if the planes (each sub-array of the last two dimensions) \n\
    are continuously allocated in memory (``1``) or distributed in various smaller \n\
    junks (``0``, default). The latter is recommended for huge, n-dimensional matrices. \n\
    This argument is only considered for ``len(dims) &gt; 2``. \n\
\n\
Returns \n\
------- \n\
array : dataObject \n\
    The newly created dataObject of shape ``dims`` and data type ``dtype``, filled with \n\
    random numbers. \n\
\n\
See Also \n\
--------- \n\
rand : method for creating a matrix filled with unformly distributed values&quot;)</td></tr>
<tr class="separator:a69e21db92d9e47cdc432da4bb9cb8b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad86675a84f60b33f4d3c85893159fc6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad86675a84f60b33f4d3c85893159fc6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectStaticEye_doc,&quot;eye(size, dtype= \&quot;uint8\&quot;) -&gt; dataObject \n\
\n\
Creates a two-dimensional, squared ``eye`` matrix.\n\
\n\
An eye matrix is an array where all elements are equal to zero, except for \n\
the diagonal values which are set to ``1``. For ``dtype == rgba32``, the \n\
diagonal values are ``r = 0, g = 0, b = 1, alpha = 0``. \n\
\n\
Parameters \n\
----------- \n\
size : int \n\
    The size of the squared matrix (single integer value).\n\
dtype : str, optional \n\
    The desired data type for the elements in the returned :class:`dataObject`. \n\
    Possible values are: ``int8``, ``uint8``, ..., ``int32``, ``float32``, \n\
    ``float64``, ``complex64``, ``complex128``, ``rgba32``. \n\
\n\
Returns \n\
------- \n\
eyeMatrix : dataObject \n\
    The created eye-matrix as ``size x size`` :class:`dataObject`. \n\
\n\
See Also \n\
--------- \n\
ones : method for creating a matrix filled with ones \n\
zeros : method for creating a matrix filled with zeros&quot;)</td></tr>
<tr class="separator:aad86675a84f60b33f4d3c85893159fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c56df59da870ae62cd4360ebd56504"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34c56df59da870ae62cd4360ebd56504"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectStaticFromNumpyColor_doc,&quot;fromNumpyColor(array) -&gt; dataObject \n\
\n\
Creates a ``rgba32`` dataObject from a three-dimensional numpy.ndarray. \n\
\n\
Static method for creating a 2D ``M x N`` :class:`dataObject` of data type ``rgba32`` \n\
from a three-dimensional, ``uint8`` :class:`numpy.ndarray``. This ``array`` must have \n\
the shape ``M x N x 3`` or ``M x N x 4``. Each vector ``array[i, j, :]`` is then \n\
used to create one ``rgba32`` value in the returned :class:`dataObject`. The meaning \n\
of this vector is: \n\
\n\
1. (blue, green, red) if ``array`` consists of three channels (last dimension). \n\
   The ``rgba32`` value then gets an alpha value set to 255 everywhere. \n\
2. (blue, green, red, alpha) if ``array`` consists of four channels (last dimension). \n\
\n\
This method can especially be used to convert numpy.arrays that are obtained by methods \n\
from packages like ``OpenCV (cv2)`` or ``PIL`` to dataObjects. \n\
\n\
Parameters \n\
----------- \n\
array : numpy.ndarray \n\
    ``M x N x 3`` or ``M x N x 4``, uint8 :class:`numpy.ndarray` \n\
\n\
Returns \n\
------- \n\
dataObject \n\
    Coloured dataObject of shape ``M x N`` and data type ``rgba32``.&quot;)</td></tr>
<tr class="separator:a34c56df59da870ae62cd4360ebd56504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13e756d74bb3982e4c574e298fbec92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad13e756d74bb3982e4c574e298fbec92"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectCopyMetaInfo_doc,&quot;copyMetaInfo(sourceObj, copyAxisInfo = True, copyTags = False) \n\
\n\
Copies meta information of another dataObject to this object. \n\
\n\
This method can be used to copy all or parts of meta information of the \n\
:class:`dataObject` ``sourceObj`` to this object. The following things \n\
are copied, depending on the arguments of this method: \n\
\n\
Axis meta information: \n\
\n\
* axis scaling and offset (see :attr:`axisScales` and :attr:`axisOffsets`) \n\
* axis descriptions and units (see :attr:`axisDescriptions` and :attr:`axisUnits`) \n\
\n\
Tags: \n\
\n\
* the entire tag map (string key vs. string or float value), including the protocol \n\
  string. The existing tag map in this object is deleted first. \n\
\n\
Parameters  \n\
------------\n\
sourceObj : dataObject \n\
    source object, where meta information is copied from. \n\
copyAxisInfo : bool, optional \n\
    If ``True``, all axis meta information is copied. \n\
copyTags : bool, optional \n\
    If ``True``, the tags of this data object are cleared and then set to a copy \n\
    of the tags of ``sourceObj``. \n\
\n\
\n\
See Also \n\
--------- \n\
metaDict : this attribute can directly be used to print meta information of a dataObject.&quot;)</td></tr>
<tr class="separator:ad13e756d74bb3982e4c574e298fbec92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8acc0c93a05cf2620323794c025568f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8acc0c93a05cf2620323794c025568f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObject_base_doc,&quot;None or dataObject or np.ndarray : Optional base object, this object shares its memory with (read-only).&quot;)</td></tr>
<tr class="separator:af8acc0c93a05cf2620323794c025568f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7466be0eb8d68831a0dc9cfeb16b792"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7466be0eb8d68831a0dc9cfeb16b792"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataObjectIterLen_doc,&quot;Private method returning an estimate of len(list(it)).&quot;)</td></tr>
<tr class="separator:af7466be0eb8d68831a0dc9cfeb16b792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c039f012619522c75c572362ae9280"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47c039f012619522c75c572362ae9280"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigureInit_doc,&quot;figure(handle = -1, rows = 1, cols = 1, x0 = -1, y0 = -1, width = -1, height = -1) -&gt; figure \n\
\n\
Creates a new figure window.\n\
\n\
The class :class:`figure` represents a standalone figure window, that can have \n\
various subplots. If an instance of this class is created without further parameters, \n\
a new figure is created and opened having one subplot area (currently empty) and the \n\
integer handle to this figure is returned:: \n\
    \n\
    h: int = figure() \n\
\n\
Subplots are arranged in a regular grid whose size is defined by the optional \n\
parameters ``rows`` and ``cols``. If you create a figure instance with a given handle, \n\
the instance is either a reference to an existing figure that has got this handle or if \n\
it does not exist, a new figure with the desired handle is opened and the handle is \n\
returned, too. \n\
\n\
Using the parameters ``width`` and ``height``, it is possible to control the size of the figure. \n\
If one of both parameters are not set or &lt;= 0 (default), no size adjustment is done at all. \n\
\n\
The size and position control can afterwards done using the property ``geometry`` of \n\
the figure. \n\
\n\
Parameters \n\
------------- \n\
handle : int \n\
    integer handle of the desired figure. \n\
rows : int, optional \n\
    number of rows this figure should have (defines the size of the subplot-grid) \n\
cols : int, optional \n\
    number of columns this figure should have (defines the size of the subplot-grid) \n\
x0 : int, optional \n\
    If ``x0`` is != -1, its left position is set to this value. \n\
y0 : int, optional \n\
    If ``y0`` is != -1, its top position is set to this value. \n\
width : int, optional \n\
    If ``width`` is != -1, the width of the figure window is set to this value. \n\
height : int, optional \n\
    If ``height`` is != -1, the height of the figure window is set to this value. \n\
\n\
Returns \n\
------- \n\
figure \n\
    is the reference to the newly created figure object.&quot;)</td></tr>
<tr class="separator:a47c039f012619522c75c572362ae9280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63dd208d7ee9754437ede793209c5cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab63dd208d7ee9754437ede793209c5cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigurePlot_doc,&quot;plot(data, areaIndex = currentAreaIndex, className = \&quot;\&quot;, properties = {}) -&gt; plotItem \n\
\n\
Plots a dataObject, pointCloud or polygonMesh in the current or given area of this figure.\n\
\n\
Plots an existing :class:`dataObject`, :class:`pointCloud` or :class:`polygonMesh` in \n\
the newly created plot. The style of the plot depends on the object dimensions.\n\
\n\
If no ``className`` is given, the type of the plot is chosen depending on the type and  \n\
the size of the object. The defaults for several plot classes can be adjusted in the  \n\
property dialog of itom. \n\
\n\
You can also set a class name of your preferred plot plugin (see also property dialog of itom). \n\
If your preferred plot is not able to display the given object, a warning is returned and the \n\
default plot type is used again. For :class:`dataObject`, it is also possible to simply set \n\
``className`` to ``1D``, ``2D`` or ``2.5D`` in order to choose the default plot type depending \n\
on these aliases. For :class:`pointCloud` and :class:`polygonMesh` only the alias ``2.5D`` is valid. \n\
\n\
Every plot has several properties that can be configured in the Qt Designer (if the \n\
plot is embedded in a GUI), or by the property toolbox in the plot itself or by using \n\
the :meth:`~itom.uiItem.info` method of the corresponding :class:`itom.uiItem` instance. \n\
\n\
Use the ``properties`` argument to pass a dictionary with properties you want to set \n\
to certain values. \n\
\n\
Parameters\n\
-----------\n\
data : dataObject or pointCloud or polygonMesh \n\
    Is the data object whose region of interest will be plotted.\n\
areaIndex : int, optional \n\
    Area index where the plot canvas should be created (if subplots exists). \n\
    The default ``areaIndex`` is the current subplot area, hence, ``0`` if \n\
    only one plot area exists in the figure. \n\
className : str, optional \n\
    class name of desired plot (if not indicated or if the ``className`` can not be found, \n\
    the default plot will be used (see application settings) \n\
properties : dict, optional \n\
    Optional dictionary of properties that will be directly applied to the \n\
    plot widget.\n\
\n\
Returns \n\
-------- \n\
plotHandle : plotItem \n\
    Handle of the subplot. This handle is used to control the properties of the plot, \n\
    connect signals to it or call slots of the plot.&quot;)</td></tr>
<tr class="separator:ab63dd208d7ee9754437ede793209c5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5c09e8be139a286316040c26af2cc0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b5c09e8be139a286316040c26af2cc0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigurePlot1_doc,&quot;plot1(data, xData = None, areaIndex = currentAreaIndex, className = \&quot;\&quot;, properties = {}) -&gt; plotItem \n\
\n\
Creates a 1D plot of a dataObject ``data`` in the current or given area of this figure.\n\
\n\
If ``xData`` is given, the plot uses this vector for the values of the ``x-axis`` of \n\
the plot.\n\
\n\
The plot type of this function is ``1D`` (see method :meth:`figure.plot`). If a \n\
``className`` is given, that does not support the given type of ``data`` (or ``xData``) \n\
a warning is returned and the default plot class for the given data is used again. \n\
\n\
Every plot has several properties that can be configured in the Qt Designer (if the plot is \n\
embedded in a GUI), or by the property toolbox in the plot itself or by using the \n\
:meth:`~uiItem.info` method of the corresponding :class:`uiItem` instance. \n\
\n\
Use the ``properties`` argument to pass a dictionary with properties you want to set. \n\
\n\
Parameters\n\
-----------\n\
data : dataObject \n\
    Is the data object whose region of interest will be plotted.\n\
xData : dataObject, optional \n\
    1D plots can optionally accept this :class:`dataObject`. If given, the \n\
    values are not displayed on an equally distributed x-scale but with \n\
    the values given by ``xData``. \n\
areaIndex : int, optional \n\
    Area index where the plot canvas should be created (if subplots exists). \n\
    The default ``areaIndex`` is the current subplot area, hence, ``0`` if \n\
    only one plot area exists in the figure. \n\
className : str, optional \n\
    class name of desired plot (if not indicated or if the ``className`` can not be found, \n\
    the default plot will be used (see application settings) \n\
properties : dict, optional \n\
    Optional dictionary of properties that will be directly applied to the \n\
    plot widget.\n\
\n\
Returns \n\
-------- \n\
plotHandle : plotItem \n\
    Handle of the subplot. This handle is used to control the properties of the plot, \n\
    connect signals to it or call slots of the plot.&quot;)</td></tr>
<tr class="separator:a9b5c09e8be139a286316040c26af2cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b38af9a2e07db080c6eb1c6eed4d18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8b38af9a2e07db080c6eb1c6eed4d18"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigurePlot2_doc,&quot;plot2(data, areaIndex = currentAreaIndex, className = \&quot;\&quot;, properties = {}) -&gt; plotItem \n\
\n\
Creates a 2D plot of a dataObject ``data`` in the current or given area of this figure.\n\
\n\
This method plots an existing :class:`dataObject` in the new 2D plot. \n\
The style of the plot depends on the object dimensions. The plot type of this function \n\
is ``2D`` (see method :meth:`figure.plot`).\n\
\n\
If the 2D plot is not able to display the given object, a warning is returned and the \n\
default plot type is used again.\n\
\n\
Every plot has several properties that can be configured in the Qt Designer (if the plot is \n\
embedded in a GUI), or by the property toolbox in the plot itself or by using the \n\
:meth:`~uiItem.info` method of the corresponding :class:`uiItem` instance. \n\
\n\
Use the ``properties`` argument to pass a dictionary with properties you want to set. \n\
\n\
Parameters\n\
-----------\n\
data : dataObject \n\
    is the data, that should be plotted. If a ``className`` it must support dataObjects \n\
    as accepted data type. Else, the default ``className`` for 2D :class:`dataObject` \n\
    is chosen (see itom application settings for default plot types. \n\
areaIndex : int, optional \n\
    Area index where the plot canvas should be created (if subplots exists). \n\
    The default ``areaIndex`` is the current subplot area, hence, ``0`` if \n\
    only one plot area exists in the figure. \n\
className : str, optional \n\
    class name of desired plot (if not indicated or if the ``className`` can not be found, \n\
    the default plot will be used (see application settings) \n\
properties : dict, optional \n\
    Optional dictionary of properties that will be directly applied to the \n\
    plot widget.\n\
\n\
Returns \n\
-------- \n\
plotHandle : plotItem \n\
    Handle of the subplot. This handle is used to control the properties of the plot, \n\
    connect signals to it or call slots of the plot.&quot;)</td></tr>
<tr class="separator:aa8b38af9a2e07db080c6eb1c6eed4d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6262a52b7e0a335b351933cd08ed1e7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6262a52b7e0a335b351933cd08ed1e7c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigurePlot25_doc,&quot;plot25(data, areaIndex = currentAreaIndex, className = \&quot;\&quot;, properties = {}) -&gt; plotItem \n\
\n\
Creates a 2.5D plot of a dataObject, pointCloud or polygonMesh in the current or given area of this figure.\n\
\n\
This method plots ``data`` object in the new plot. The style of the plot depends on \n\
the object dimensions, its plot type is ``2.5D`` (see method :meth:`figure.plot`).\n\
\n\
If the 2.5D plot is not able to display the given object, a warning is returned and \n\
the default plot type is used again.\n\
\n\
Every plot has several properties that can be configured in the Qt Designer (if the plot is \n\
embedded in a GUI), or by the property toolbox in the plot itself or by using the \n\
:meth:`~uiItem.info` method of the corresponding :class:`uiItem` instance. \n\
\n\
Use the ``properties`` argument to pass a dictionary with properties you want to set. \n\
\n\
Parameters\n\
-----------\n\
data : dataObject or pointCloud or polygonMesh \n\
    is the data, that should be plotted. If a ``className`` is given, only the \n\
    type of data, supported by this class, can be displayed. Else, the default \n\
    ``className`` for the kind of data is chosen (see itom application settings \n\
    for default plot types. \n\
areaIndex : int, optional \n\
    Area index where the plot canvas should be created (if subplots exists). \n\
    The default ``areaIndex`` is the current subplot area, hence, ``0`` if \n\
    only one plot area exists in the figure. \n\
className : str, optional \n\
    class name of desired plot (if not indicated or if the ``className`` can not be found, \n\
    the default plot will be used (see application settings) \n\
properties : dict, optional \n\
    Optional dictionary of properties that will be directly applied to the \n\
    plot widget.\n\
\n\
Returns \n\
-------- \n\
plotHandle : plotItem \n\
    Handle of the subplot. This handle is used to control the properties of the plot, \n\
    connect signals to it or call slots of the plot.&quot;)</td></tr>
<tr class="separator:a6262a52b7e0a335b351933cd08ed1e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60dbbccdf8c9393f4da700392fb96c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab60dbbccdf8c9393f4da700392fb96c7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigureLiveImage_doc,&quot;liveImage(cam, areaIndex = currentAreaIndex, className = \&quot;\&quot;, properties = {}) -&gt; plotItem \n\
\n\
Shows a camera live image in the current or given area of this figure. \n\
\n\
If no ``className`` is given, the type of the plot is chosen depending on the type \n\
and the size of the object. The defaults for several plot classes can be adjusted in \n\
the property dialog of itom. \n\
\n\
You can also set a class name of your preferred plot plugin (see also property dialog \n\
of itom). If your preferred plot is not able to display the given object, a warning is \n\
returned and the default plot type is used again. For dataObjects, it is also possible \n\
to simply set ``className`` to `1D` or `2D` in order to choose the default plot type \n\
depending on these aliases. \n\
\n\
Every plot has several properties that can be configured in the Qt Designer (if the \n\
plot is embedded in a GUI), or by the property toolbox in the plot itself or by using \n\
the :meth:`~itom.uiItem.info` method of the corresponding :class:`itom.uiItem` instance. \n\
\n\
Use the ``properties`` argument to pass a dictionary with properties you want to set to \n\
certain values. \n\
\n\
Parameters\n\
-----------\n\
cam : dataIO \n\
    Camera grabber device from which images are acquired.\n\
areaIndex : int, optional \n\
    Area index where the plot canvas should be created (if subplots exists). \n\
    The default ``areaIndex`` is the current subplot area, hence, ``0`` if \n\
    only one plot area exists in the figure. \n\
className : str, optional \n\
    class name of desired plot (if not indicated or if the ``className`` can not be found, \n\
    the default plot will be used (see application settings) \n\
properties : dict, optional \n\
    Optional dictionary of properties that will be directly applied to the \n\
    plot widget.\n\
\n\
Returns \n\
-------- \n\
plotHandle : plotItem \n\
    Handle of the subplot. This handle is used to control the properties of the plot, \n\
    connect signals to it or call slots of the plot.&quot;)</td></tr>
<tr class="separator:ab60dbbccdf8c9393f4da700392fb96c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2232a475a34aeb75ee373c5c445ab30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2232a475a34aeb75ee373c5c445ab30"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigureMatplotlib_doc,&quot;matplotlibFigure(areaIndex = currentAreaIndex, properties = {}) -&gt; plotItem \n\
\n\
Creates a matplotlib canvas at the given area in the figure. \n\
\n\
Creates and returns a matplotlib canvas at the given area or returns an existing one. \n\
This canvas can be used as canvas argument for :class:`matplotlib.pyplot.figure` of \n\
matplotlib and is internally used by the itom backend of matplotlib. \n\
\n\
Parameters\n\
-----------\n\
areaIndex : int, optional \n\
    Area index where the plot canvas should be created (if subplots exists). \n\
    The default ``areaIndex`` is the current subplot area, hence, ``0`` if \n\
    only one plot area exists in the figure. \n\
properties : dict, optional \n\
    Optional dictionary of properties that will be directly applied to the \n\
    plot widget.\n\
\n\
Returns \n\
-------- \n\
plotHandle : plotItem \n\
    Handle of the subplot. This handle is used to control the properties of the plot, connect to \n\
    its signals or call slots of the plot.&quot;)</td></tr>
<tr class="separator:af2232a475a34aeb75ee373c5c445ab30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff01713eb2c9adf7e00da96383c9119e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff01713eb2c9adf7e00da96383c9119e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigureShow_doc,&quot;show() \n\
\n\
Shows the figure if it is currently hidden.&quot;)</td></tr>
<tr class="separator:aff01713eb2c9adf7e00da96383c9119e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d850e6b046cdbf31f5f7133b3b2cc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18d850e6b046cdbf31f5f7133b3b2cc3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigureHide_doc,&quot;hide() \n\
\n\
Hides the figure, but does not delete it.&quot;)</td></tr>
<tr class="separator:a18d850e6b046cdbf31f5f7133b3b2cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95cbf9c723ff10fda49a045325d7168"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae95cbf9c723ff10fda49a045325d7168"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigureSubplot_doc,&quot;subplot(index) -&gt; plotItem \n\
\n\
Returns :class:`plotItem` of desired subplot.\n\
\n\
Parameters \n\
----------- \n\
index : int \n\
    index to desired subplot in the range ``[0, n)``, where n is the number of subplots. \n\
    The subplot at the top, left position has the index 0 and the index is \n\
    incremented row-wise. \n\
\n\
Returns \n\
------- \n\
plotItem \n\
    The plot item of the desired subplot.&quot;)</td></tr>
<tr class="separator:ae95cbf9c723ff10fda49a045325d7168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4173290c378145ba7d91be98200b4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b4173290c378145ba7d91be98200b4f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigure_handle_doc,&quot;int : gets the handle of this figure.&quot;)</td></tr>
<tr class="separator:a7b4173290c378145ba7d91be98200b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae556f533cf48d8ef17b0f0ce255332ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae556f533cf48d8ef17b0f0ce255332ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigure_docked_doc,&quot;bool : gets or sets the docked status of this figure. \n\
\n\
This attribute controls the dock appearance of this figure. If it is docked, the \n\
figure is integrated into the main window of itom, else it is a independent window. \n\
&quot;)</td></tr>
<tr class="separator:ae556f533cf48d8ef17b0f0ce255332ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc2045ea3ff8827b54a34c79f514eaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bc2045ea3ff8827b54a34c79f514eaf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFigure_Close_doc,&quot;close(handle) -&gt; None \\\n\
close(all = \&quot;all\&quot;) -&gt; None \n\
\n\
Closes a specific or all opened figures. \n\
\n\
This method closes and deletes either one specific figure (if ``handle`` is given \n\
and valid), or all opened figures (if the string argument ``\&quot;all\&quot;`` is given). \n\
All figure can only be closed, if no other figure references this figure (e.g. \n\
line cut of an image plot (2D). \n\
\n\
Parameters \n\
----------- \n\
handle : int \n\
    a valid figure handle, whose reference figure should be closed. \n\
    This figure handle is for instance obtained by the first value of the \n\
    returned tuple of :meth:`plot`, :meth:`plot1`, :meth:`plot2` among others. \n\
all : {\&quot;all\&quot;} \n\
    Pass the string ``\&quot;all\&quot;``  if all closeable opened figures should be closed. \n\
\n\
Notes \n\
------- \n\
If a :class:`figure` instance still keeps a reference to any figure, it is only closed \n\
and will be deleted after that the last referencing instance has been deleted. \n\
\n\
See Also \n\
--------- \n\
itom.close&quot;)</td></tr>
<tr class="separator:a6bc2045ea3ff8827b54a34c79f514eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c6b187404e3d0dfc0554fbed8003dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3c6b187404e3d0dfc0554fbed8003dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyFont_doc,&quot;font(family, pointSize = 0, weight = -1, italic = False) -&gt; font \n\
\n\
Creates a font object. \n\
\n\
This class is a wrapper for the class `QFont` of the Qt framework. \n\
It provides possibilities for creating a font type. \n\
\n\
Parameters \n\
----------- \n\
family : str \n\
    The family name may optionally also include a foundry name, e.g. \&quot;Helvetica [Cronyx]\&quot;. \n\
    If the family is available from more than one foundry and the foundry isn't specified, \n\
    an arbitrary foundry is chosen. If the family isn't available a family will be set \n\
    using a best-matching algorithm. \n\
pointSize : int, optional \n\
    If pointSize is zero or negative, the point size of the font is set to a \n\
    system-dependent default value. Generally, this is 12 points. \n\
weight : int, optional \n\
    Weighting scale from 0 to 99, e.g. ``font.Light``, ``font.Normal`` (default), \n\
    ``font.DemiBold``, ``font.Bold``, ``font.Black``. \n\
italic : bool, optional \n\
    Defines if font is italic or not (default)&quot;)</td></tr>
<tr class="separator:aa3c6b187404e3d0dfc0554fbed8003dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c477ac68d55bf39598c85d8ab99364"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11c477ac68d55bf39598c85d8ab99364"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (font_getFamily_doc,&quot;str : gets / sets the family name of the font. \n\
\n\
The name is case insensitive. It may optionally also include a foundry name, \n\
e.g.  \&quot;Helvetica [Cronyx]\&quot;. If the family is available from more than one \n\
foundry and the foundry isn't specified, an arbitrary foundry is chosen. If \n\
the family isn't available a family will be set using a font matching algorithm.&quot;)</td></tr>
<tr class="separator:a11c477ac68d55bf39598c85d8ab99364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da5a8ddadb27c94897d616c121624d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6da5a8ddadb27c94897d616c121624d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (font_getWeight_doc,&quot;int : gets or sets the weight of the font. \n\
\n\
This should be one of the constant values ``font.Light``, ``font.Normal``, \n\
``font.DemiBold``, ``font.Bold``, ``font.Black`` enumeration or any value \n\
in the range [0, 99].&quot;)</td></tr>
<tr class="separator:a6da5a8ddadb27c94897d616c121624d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe3318a58454c644067f63289018829"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fe3318a58454c644067f63289018829"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (font_getPointSize_doc,&quot;int : gets or sets the point size (&gt; 0) of the font.&quot;)</td></tr>
<tr class="separator:a7fe3318a58454c644067f63289018829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5eb1d7277250d107109fea41a505d0f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab5eb1d7277250d107109fea41a505d0f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (font_getItalic_doc,&quot;bool : gets or sets the italic attribute of the font.&quot;)</td></tr>
<tr class="separator:ab5eb1d7277250d107109fea41a505d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d893e666a9ec504714cca9f3485c3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49d893e666a9ec504714cca9f3485c3b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (font_getStrikeOut_doc,&quot;bool : gets or sets the strikeout attribute of the font.&quot;)</td></tr>
<tr class="separator:a49d893e666a9ec504714cca9f3485c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2f787eaca5d990c642287bd80db039"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c2f787eaca5d990c642287bd80db039"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (font_getUnderline_doc,&quot;bool : gets or sets the underline attribute of the font.&quot;)</td></tr>
<tr class="separator:a9c2f787eaca5d990c642287bd80db039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867c0141faf7f9bdac52548150696f0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a867c0141faf7f9bdac52548150696f0a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFont_isFamilyInstalled_DOC,&quot;isFamilyInstalled(family) -&gt; bool \n\
\n\
Checks if the given font family is installed on this computer. \n\
\n\
Parameters \n\
----------- \n\
family : str \n\
    The name of the font family that should be checked \n\
\n\
Returns \n\
--------- \n\
installed : bool \n\
    ``True`` if family is installed, else ``False``.&quot;)</td></tr>
<tr class="separator:a867c0141faf7f9bdac52548150696f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec69a8ccb0bb43512f3310fb5f3b0be3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec69a8ccb0bb43512f3310fb5f3b0be3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFont_installedFontFamilies_DOC,&quot;installedFontFamilies() -&gt; List[str] \n\
\n\
Returns a list of all installed font families. \n\
\n\
Returns \n\
------- \n\
list of str : \n\
    list of the names of all installed font families&quot;)</td></tr>
<tr class="separator:aec69a8ccb0bb43512f3310fb5f3b0be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d36add97f4e7c8d800c284a01a42155"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d36add97f4e7c8d800c284a01a42155"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyOpenEmptyScriptEditor_doc,&quot;scriptEditor()\n\
\n\
Opens new, empty script editor window (undocked).\n\
\n\
Raises \n\
------ \n\
RuntimeError \n\
    if the current user has no permission to open a new script.&quot;)</td></tr>
<tr class="separator:a5d36add97f4e7c8d800c284a01a42155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fb83e8e03388db2744f253abfe1e3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90fb83e8e03388db2744f253abfe1e3b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyNewScript_doc,&quot;newScript()\n\
\n\
Opens an empty, new script in the current script window.\n\
\n\
Raises \n\
------ \n\
RuntimeError \n\
    if the current user has no permission to open a new script.&quot;)</td></tr>
<tr class="separator:a90fb83e8e03388db2744f253abfe1e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54464dd21fc8a15ce621df1966a69d92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54464dd21fc8a15ce621df1966a69d92"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyOpenScript_doc,&quot;openScript(filename) \n\
\n\
Open the given script in current script window.\n\
\n\
Open the python script indicated by *filename* in a new tab in the current, \n\
latest opened editor window. Filename can be either a string with a relative \n\
or absolute filename to the script to open or any object with a ``__file__`` \n\
attribute. This attribute is then read and used as path. \n\
\n\
The relative filename is relative with respect to the current directory. \n\
\n\
Parameters \n\
----------- \n\
filename : str or Any \n\
    Relative or absolute filename to a python script that is then opened \n\
    (in the current editor window). Alternatively an object with a \n\
    ``__file__`` attribute is allowed. \n\
\n\
Raises \n\
------ \n\
RuntimeError \n\
    if the current user has no permission to open a script.&quot;)</td></tr>
<tr class="separator:a54464dd21fc8a15ce621df1966a69d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6d7780cb32cfb3ee7fd67385f53d05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa6d7780cb32cfb3ee7fd67385f53d05"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyShowHelpViewer_doc,&quot;showHelpViewer(collectionFile = \&quot;\&quot;) \n\
\n\
Opens the itom help viewer and displays the itom user documentation or another desired documentation. \n\
\n\
The user documentation is shown in the help viewer window. If ``collectionFile`` \n\
is given, this user-defined collection file is displayed in this help viewer.\n\
\n\
Parameters \n\
----------- \n\
collectionFile : str, optional \n\
	If given, the indicated Qt collection file (.qch) will be loaded in the help viewer.\n\
    Per default, the user documentation is loaded (pass an empty string or nothing).&quot;)</td></tr>
<tr class="separator:afa6d7780cb32cfb3ee7fd67385f53d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d54c1963426828cc214c4fd680ab9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2d54c1963426828cc214c4fd680ab9b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyClearCommandLine_doc,&quot;clc() \n\
\n\
Clears the itom command line (if available).&quot;)</td></tr>
<tr class="separator:ab2d54c1963426828cc214c4fd680ab9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfd51729a3f245e588d18df2dcc7076"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="accfd51729a3f245e588d18df2dcc7076"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlotImage_doc,&quot;plot(data, className = \&quot;\&quot;, properties = {}) -&gt; Tuple[int, plotItem] \n\
\n\
Plots a dataObject, pointCloud or polygonMesh in a new figure window \n\
\n\
Plots an existing :class:`dataObject`, :class:`pointCloud` or :class:`polygonMesh` in a \n\
dockable, not blocking window. The style of the plot depends on the object dimensions.\n\
\n\
If no ``className`` is given, the type of the plot is chosen depending on the type and  \n\
the size of the object. The defaults for several plot classes can be adjusted in the  \n\
property dialog of itom. \n\
\n\
You can also set a class name of your preferred plot plugin (see also property dialog of itom). \n\
If your preferred plot is not able to display the given object, a warning is returned and the \n\
default plot type is used again. For :class:`dataObject`, it is also possible to simply set \n\
``className`` to ``1D``, ``2D`` or ``2.5D`` in order to choose the default plot type depending \n\
on these aliases. For :class:`pointCloud` and :class:`polygonMesh` only the alias ``2.5D`` is valid. \n\
\n\
Every plot has several properties that can be configured in the Qt Designer (if the plot is \n\
embedded in a GUI), or by the property toolbox in the plot itself or by using the info() method \n\
of the corresponding :class:`~itom.uiItem` instance. \n\
\n\
Use the ``properties`` argument to pass a :obj:`dict` with properties you want to set. \n\
\n\
Parameters \n\
----------- \n\
data : dataObject or pointCloud or polygonMesh \n\
    Is the data object, point cloud or polygonal mesh, that will be plotted.\n\
className : str, optional \n\
    class name of desired plot (if not indicated or if the className can not be found, the default \n\
    plot will be used (see application settings)). Depending on the object, you can also set ``className`` \n\
    to ``1D``, ``2D`` or ``2.5D`` for displaying the object in the default plot of \n\
    the indicated categories. If nothing is given, the plot category is guessed from ``data``.\n\
properties : dict, optional \n\
    optional dictionary of properties that will be directly applied to the plot widget. \n\
\n\
Returns \n\
-------- \n\
index : int \n\
    This index is the figure index of the plot figure that is opened by this command. Use \n\
    ``figure(index)`` to get a reference to the figure window of this plot. The plot can \n\
    be closed by ``close(index)``. \n\
plotHandle : plotItem \n\
    Handle of the plot. This handle is used to control the properties of the plot, connect to \n\
    its signals or call slots of the plot. \n\
\n\
See Also \n\
--------- \n\
liveImage, plotItem, plot1, plot2, plot25&quot;)</td></tr>
<tr class="separator:accfd51729a3f245e588d18df2dcc7076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f135f3a603be36b5cbcac96584b6bf1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f135f3a603be36b5cbcac96584b6bf1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlot1d_doc,&quot;plot1(data, xData = None, className = \&quot;\&quot;, properties = {}) -&gt; Tuple[int, plotItem] \n\
\n\
Plots a dataObject as an 1d plot in a new figure window. \n\
\n\
This method plots an existing :class:`dataObject` ``data`` in a dockable, not blocking \n\
window. \n\
\n\
If ``xData`` is given, the plot uses this vector for the values of the x axis of the plot.\n\
\n\
The plot type of this function is ``1D`` (see method :meth:`plot`).\n\
\n\
Every plot has several properties that can be configured in the Qt Designer (if the plot is \n\
embedded in a GUI), or by the property toolbox in the plot itself or by using the \n\
:meth:`~uiItem.info` method of the corresponding :class:`uiItem` instance. \n\
\n\
Use the ``properties`` argument to pass a dictionary with properties you want to set. \n\
\n\
Parameters \n\
----------- \n\
data : dataObject \n\
    Is the :class:`dataObject` whose region of interest will be plotted.\n\
xData : dataObject, optional \n\
    Is the :class:`dataObject` whose values are used for the axis.\n\
className : str, optional \n\
    class name of the desired 1D plot (if not indicated, the default 1D plot will be used, \n\
    see application settings) \n\
properties : dict, optional \n\
    optional dictionary of properties that will be directly applied to the plot widget. \n\
\n\
Returns \n\
-------- \n\
index : int \n\
    This index is the figure index of the plot figure that is opened by this command. \n\
    Use ``figure(index)`` to get a reference to the figure window of this plot. The \n\
    plot can be closed by ``close(index)``. \n\
plotHandle : plotItem \n\
    Handle of the plot. This handle is used to control the properties of the plot, \n\
    connect signals to it or call slots of the plot. \n\
\n\
See Also \n\
---------- \n\
liveImage, plotItem, plot, plot2, plot25&quot;)</td></tr>
<tr class="separator:a4f135f3a603be36b5cbcac96584b6bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d85c4830665ac1489affde45db357ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d85c4830665ac1489affde45db357ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlot2d_doc,&quot;plot2(data, properties = {}) -&gt; Tuple[int, plotItem] \n\
\n\
Plots a dataObject in a new figure window.\n\
\n\
This method plots an existing :class:`dataObject` in a dockable, not blocking window. \n\
The style of the plot depends on the object dimensions. The plot type of this function \n\
is ``2D``.\n\
\n\
Every plot has several properties that can be configured in the Qt Designer (if the \n\
plot is embedded in a GUI), or by the property toolbox in the plot itself or by using \n\
the :meth:`~itom.uiItem.info` method of the corresponding :class:`itom.uiItem` instance. \n\
\n\
Use the ``properties`` argument to pass a dictionary with properties you want to set \n\
to certain values. \n\
\n\
Parameters \n\
----------- \n\
data : dataObject \n\
    Is the :class:`dataObject` whose region of interest will be plotted.\n\
className : str, optional \n\
    class name of the desired `2D` plot (if not indicated default plot will be used, \n\
    see application settings) \n\
properties : dict, optional \n\
    optional dictionary of properties that will be directly applied to the plot widget. \n\
\n\
Returns \n\
-------- \n\
index : int \n\
    This index is the figure index of the plot figure that is opened by this command. \n\
    Use ``figure(index)`` to get a reference to the figure window of this plot. The \n\
    plot can be closed by ``close(index)``. \n\
plotHandle : plotItem \n\
    Handle of the plot. This handle is used to control the properties of the plot, \n\
    connect signals to it or call slots of the plot. \n\
\n\
See Also \n\
---------- \n\
liveImage, plotItem, plot, plot1, plot25&quot;)</td></tr>
<tr class="separator:a3d85c4830665ac1489affde45db357ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190240b82cf6a54b2cde3df5594614e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a190240b82cf6a54b2cde3df5594614e3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlot25d_doc,&quot;plot25(data, className = \&quot;\&quot;, properties = {}) -&gt; Tuple[int, plotItem] \n\
\n\
Plots a dataObject, pointCloud or polygonMesh in a new figure window. \n\
\n\
This method plots the ``data`` object in a dockable, not blocking window. \n\
The style of the plot depends on the object dimensions, its plot type is ``2.5D``.\n\
\n\
Every plot has several properties that can be configured in the Qt Designer (if the \n\
plot is embedded in a GUI), or by the property toolbox in the plot itself or by using \n\
the :meth:`~itom.uiItem.info` method of the corresponding :class:`itom.uiItem` instance. \n\
\n\
Use the ``properties`` argument to pass a dictionary with properties you want to set to  \n\
desired values. \n\
\n\
Parameters \n\
----------- \n\
data : dataObject or pointCloud or polygonMesh \n\
    is the object, that is plotted.\n\
className : str, optional \n\
    class name of the desired `2.5D` plot (if not indicated default plot will be used, \n\
    see application settings) \n\
properties : dict, optional \n\
    optional dictionary of properties that will be directly applied to the plot widget. \n\
\n\
Returns \n\
-------- \n\
index : int \n\
    This index is the figure index of the plot figure that is opened by this command. \n\
    Use ``figure(index)`` to get a reference to the figure window of this plot. The \n\
    plot can be closed by ``close(index)``. \n\
plotHandle : plotItem \n\
    Handle of the plot. This handle is used to control the properties of the plot, \n\
    connect signals to it or call slots of the plot. \n\
\n\
See Also \n\
---------- \n\
liveImage, plotItem, plot, plot1, plot2&quot;)</td></tr>
<tr class="separator:a190240b82cf6a54b2cde3df5594614e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea59dcbf4dcc4bee1a211b8792b7a13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afea59dcbf4dcc4bee1a211b8792b7a13"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyLiveImage_doc,&quot;liveImage(cam, className = \&quot;\&quot;, properties = {}) -&gt; Tuple[int, plotItem] \n\
\n\
Shows a camera live image in a new figure window. \n\
\n\
This method creates a plot-image (2D) and automatically grabs images into this window.\n\
\n\
If no ``className`` is given, the type of the plot is chosen depending on the type \n\
and the size of the object. The defaults for several plot classes can be adjusted in \n\
the property dialog of itom. \n\
\n\
You can also set a class name of your preferred plot plugin (see also property dialog \n\
of itom). If your preferred plot is not able to display the given object, a warning is \n\
returned and the default plot type is used again. For dataObjects, it is also possible \n\
to simply set ``className`` to `1D` or `2D` in order to choose the default plot type \n\
depending on these aliases. \n\
\n\
Every plot has several properties that can be configured in the Qt Designer (if the \n\
plot is embedded in a GUI), or by the property toolbox in the plot itself or by using \n\
the :meth:`~itom.uiItem.info` method of the corresponding :class:`itom.uiItem` instance. \n\
\n\
Use the ``properties`` argument to pass a dictionary with properties you want to set to \n\
certain values. \n\
\n\
Parameters \n\
----------- \n\
cam : dataIO \n\
    Camera grabber device from which images are acquired.\n\
className : str, optional \n\
    class name of desired plot (if not indicated or if the ``className`` can not be found, \n\
    the default plot will be used (see application settings) \n\
properties : dict, optional \n\
    optional dictionary of properties that will be directly applied to the plot widget. \n\
\n\
Returns \n\
-------- \n\
index : int \n\
    This index is the figure index of the plot figure that is opened by this command. \n\
    Use ``figure(index)`` to get a reference to the figure window of this plot. The \n\
    plot can be closed by ``close(index)``. \n\
plotHandle : plotItem \n\
    Handle of the plot. This handle is used to control the properties of the plot, \n\
    connect signals to it or call slots of the plot. \n\
\n\
See Also \n\
--------- \n\
plot, plotItem, plot1, plot2, plot25&quot;)</td></tr>
<tr class="separator:afea59dcbf4dcc4bee1a211b8792b7a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d28eae15e9624a9b374e03abe6d8f83"><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a9d28eae15e9624a9b374e03abe6d8f83">PyWidgetOrFilterHelp</a> (bool getWidgetHelp, PyObject *pArgs, PyObject *pKwds)</td></tr>
<tr class="separator:a9d28eae15e9624a9b374e03abe6d8f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db19758462ee86939e87532884f2353"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5db19758462ee86939e87532884f2353"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFilterHelp_doc,&quot;filterHelp(filterName = \&quot;\&quot;, dictionary = 0, furtherInfos = 0) -&gt; Optional[dict] \n\
\n\
Print outs an online help for the given filter(s) or return help information as dictionary. \n\
\n\
This method prints information about one specific filter (algorithm) or a list of \n\
filters to the console output. If one specific filter, defined in an algorithm plugin, \n\
can be found that case-sensitively fits the given ``filterName``, its full documentation \n\
is printed or returned. Else, a list of filters is printed whose name contains the \n\
given ``filterName``.\n\
\n\
Parameters \n\
----------- \n\
filterName : str, optional \n\
    is the fullname or a part of any filter name which should be displayed. \n\
    If ``filterName`` is empty or no filter matches ``filterName`` (case sensitive) \n\
    a list with all suitable filters is given. \n\
dictionary : int, optional \n\
    if ``1``, a dictionary with all relevant information about the documentation of \n\
    this filter is returned as dictionary and nothing is printed to the command line \n\
    (default: 0). \n\
furtherInfos : int, optional \n\
    Usually, filters or algorithms whose name only contains the given ``filterName`` \n\
    are only listed at the end of the information text. If this parameter is set \n\
    to ``1`` (default: ``0``), the full information for all these filters is printed \n\
    as well. \n\
\n\
Returns \n\
------- \n\
info : dict \n\
    This dictionary is only returned, if ``dictionary`` is set to ``1``. Else ``None`` \n\
    is returned. The dictionary contains relevant information about the desired ``filterName``.&quot;)</td></tr>
<tr class="separator:a5db19758462ee86939e87532884f2353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfea288776e12bc5483c33f329b3f12f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfea288776e12bc5483c33f329b3f12f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyWidgetHelp_doc,&quot;widgetHelp(widgetName = \&quot;\&quot;, dictionary = 0, furtherInfos = 0) -&gt; Optional[dict] \n\
\n\
Print outs an online help for the given widget(s) or return help information as dictionary. \n\
\n\
This method prints information about one specific widget (defined in an algorithm plugin) \n\
or a list of widgets to the console output. If one specific widget \n\
can be found that case-sensitively fits the given ``widgetName``, its full documentation \n\
is printed or returned. Else, a list of widgets is printed whose name contains the \n\
given ``widgetName``.\n\
\n\
Parameters \n\
----------- \n\
widgetName : str, optional \n\
    is the fullname or a part of any widget name which should be displayed. \n\
    If ``widgetName`` is empty or no widget matches ``widgetName`` (case sensitive) \n\
    a list with all suitable widgets is given. \n\
dictionary : int, optional \n\
    if ``1``, a dictionary with all relevant information about the documentation of \n\
    this widget is returned as dictionary and nothing is printed to the command line \n\
    (default: 0). \n\
furtherInfos : int, optional \n\
    Usually, widgets whose name only contains the given ``widgetName`` \n\
    are only listed at the end of the information text. If this parameter is set \n\
    to ``1`` (default: ``0``), the full information for all these widgets is printed \n\
    as well. \n\
\n\
Returns \n\
------- \n\
info : dict \n\
    This dictionary is only returned, if ``dictionary`` is set to ``1``. Else ``None`` \n\
    is returned. The dictionary contains relevant information about the desired ``widgetName``.&quot;)</td></tr>
<tr class="separator:abfea288776e12bc5483c33f329b3f12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299ab721bee3f187c0204a7d8f972ac8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a299ab721bee3f187c0204a7d8f972ac8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginLoaded_doc,&quot;pluginLoaded(pluginName) -&gt; bool \n\
\n\
Checks if a certain plugin could be successfully loaded.\n\
\n\
This method checks if a specified plugin is loaded and returns ``True`` if \n\
this is the case, otherwise ``False``. \n\
\n\
Parameters \n\
----------- \n\
pluginName :  str \n\
    The name of a specified plugin as usually displayed in the plugin window.\n\
\n\
Returns \n\
------- \n\
bool \n\
    ``True``, if the plugin has been loaded and can be used, else ``False``.&quot;)</td></tr>
<tr class="separator:a299ab721bee3f187c0204a7d8f972ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50048fba61bf46d4df151215439776c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50048fba61bf46d4df151215439776c6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlotLoaded_doc,&quot;plotLoaded(plotName) -&gt; bool \n\
\n\
Checks if a certain plot widget is available and loaded.\n\
\n\
This method checks if a specified plot widget is available and loaded and \n\
returns ``True`` in case of success, otherwise ``False``. \n\
\n\
Parameters \n\
----------- \n\
plotName :  str \n\
    The name of a specified plot widget as displayed in the itom property dialog. \n\
\n\
Returns \n\
------- \n\
bool \n\
    ``True``, if the plot has been loaded and can be used, else ``False``.&quot;)</td></tr>
<tr class="separator:a50048fba61bf46d4df151215439776c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecfe6b1b6f0d1aa751afd9c4172724f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ecfe6b1b6f0d1aa751afd9c4172724f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlotHelp_doc,&quot;plotHelp(plotName = \&quot;\&quot;, dictionary = False) -&gt; Optional[Union[List[str], dict]] \n\
\n\
Generates an online help for a desired plot class.\n\
\n\
The output of this method depend on the content of the argument ``plotName``: \n\
\n\
* If it is empty or a star (``*``), a list of all available and loaded plot classes is print to \n\
  the command line (``dictionary=False``) or returned as ``List[str]``. \n\
* If it is a valid plot class name, all relevant information of this plot widget \n\
  (Qt designer plugin), like supported data types, all properties, signals or slots... \n\
  are printed to the command line or returned as nested dictionary structure. \n\
\n\
Parameters \n\
----------- \n\
plotName : str \n\
    See the description above. This value can either be an empty string or a star (``*``) \n\
    or the name of a plot designer plugin class. \n\
dictionary : bool, optional \n\
    if ``True``, this methods returns its output either as :class:`list` of :class:`str` or \n\
    a :class:`dict` with information like slots, signals and properties of the desired plot \n\
    classes (default: ``False``). \n\
\n\
Returns \n\
------- \n\
None or list of str or dict \n\
    Returns ``None``, a list of available plot class names or a nested dictionary with various \n\
    information about the plot class (depending on the arguments).&quot;)</td></tr>
<tr class="separator:a9ecfe6b1b6f0d1aa751afd9c4172724f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1908936e056df4ef8129c11bfa3266a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1908936e056df4ef8129c11bfa3266a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginHelp_doc,&quot;pluginHelp(pluginName, dictionary = False) -&gt; Optional[dict] \n\
\n\
Generates an online help for the specific plugin.\n\
\n\
Information about an itom plugin library (actuator, dataIO or algorithm), gathered \n\
by this method, are the name of the plugin, its version, its type, contained filters \n\
(in case of an algorithm) or the description and initialization parameters (otherwise). \n\
\n\
Parameters \n\
----------- \n\
pluginName : str \n\
    is the fullname of a plugin library as specified in the plugin toolbox.\n\
dictionary : bool, optional \n\
    if ``True``, this method returns a :class:`dict` with all gathered information \n\
    about the plugin. Else (default), this information is printed to the command line. \n\
\n\
Returns \n\
------- \n\
None or dict \n\
    Returns None or a dict depending on the value of parameter ``dictionary``.&quot;)</td></tr>
<tr class="separator:a1908936e056df4ef8129c11bfa3266a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a84d8c1df160b4a35cb2e6858d7e63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2a84d8c1df160b4a35cb2e6858d7e63"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyAboutInfo_doc,&quot;aboutInfo(pluginName) -&gt; str \n\
\n\
Returns the `about` information for the given plugin as string.\n\
\n\
Parameters \n\
----------- \n\
pluginName : str \n\
    is the name of a plugin library as specified in the plugin toolbox.\n\
\n\
Returns \n\
------- \n\
str \n\
    Returns a string containing the about information. \n\
\n\
Raises \n\
------- \n\
RuntimeError \n\
    if ``pluginName`` is an unknown plugin.&quot;)</td></tr>
<tr class="separator:aa2a84d8c1df160b4a35cb2e6858d7e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ff50171d94de4f048bc4b04cff0037"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8ff50171d94de4f048bc4b04cff0037"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyItomVersion_doc,&quot;version(dictionary = False, addPluginInfo = False) -&gt; Optional[dict] \n\
\n\
Retrieves, prints out or returns complete version information of itom (and optionally plugins). \n\
\n\
Parameters \n\
----------- \n\
dictionary : bool, optional \n\
    If ``True``, all information is returned as nested :class:`dict`. \n\
    Otherwise (default), this information is printed to the command line. \n\
addPluginInfo : bool, optional \n\
    If ``True``, version information about all loaded plugins are added, too. \n\
    Default: ``False``. \n\
\n\
Returns \n\
------- \n\
None or dict \n\
    version information as nested dict, if ``dictionary`` is ``True``.&quot;)</td></tr>
<tr class="separator:aa8ff50171d94de4f048bc4b04cff0037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6125590e5e84107f345e034243e059"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b6125590e5e84107f345e034243e059"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyAddButton_doc,&quot;addButton(toolbarName, buttonName, code, icon = \&quot;\&quot;, argtuple = []) -&gt; int \n\
\n\
Adds a button to a toolbar in the main window of itom. \n\
\n\
This function adds a button to a toolbar in the main window of itom. If the button is \n\
pressed the given code, function or method is executed. If the toolbar specified by \n\
``toolbarName`` does not exist, it is created. The button will display an optional \n\
icon, or - if not given / not loadable - the ``buttonName`` is displayed as text. \n\
\n\
Itom comes with basic icons addressable by ``:/../iconname.png``, e.g.\n\
``:/gui/icons/close.png``. These natively available icons are listed in the icon \n\
browser in the menu **edit &gt;&gt; icon browser** of any script window. Furthermore you \n\
can give a relative or absolute path to any allowed icon file (the preferred file \n\
format is png). \n\
\n\
For more information see also the section :ref:`toolbar-addtoolbar` of the documentation. \n\
\n\
**New in itom 4.1**: The ``code`` argument accepts all kind of callable objects, not \n\
only Python methods and functions. \n\
\n\
Parameters \n\
----------- \n\
toolbarName : str \n\
    The name of the toolbar.\n\
buttonName : str \n\
    The name and identifier of the button to create.\n\
code : str or callable \n\
    The code or callable to be executed if the button is pressed.\n\
    If the code is a callable method, it can either be an unbounded function \n\
    (including lambda functions) or a bounded member method of a class instance. \n\
    In the latter case, the button does not keep a reference to the class \n\
    instance, such that a ``RuntimeError`` is raised if the instance is not \n\
    available any more if the button is triggered. \n\
icon : str, optional \n\
    The filename of an icon file. This can also be relative to the application \n\
    directory of **itom**.\n\
argtuple : tuple, optional \n\
    Arguments, which will be passed to the method (in order to avoid cyclic \n\
    references try to only use basic element types). \n\
\n\
Returns \n\
------- \n\
handle : int \n\
    handle to the newly created button (pass it to :meth:`removeButton` to delete \n\
    exactly this button) \n\
\n\
Raises \n\
------- \n\
RuntimeError \n\
    if the main window is not available \n\
\n\
See Also \n\
--------- \n\
removeButton&quot;)</td></tr>
<tr class="separator:a0b6125590e5e84107f345e034243e059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa5b9d69f185e337fc3d7c1388c2b8d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fa5b9d69f185e337fc3d7c1388c2b8d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRemoveButton_doc,&quot;removeButton(handle) -&gt; None \\\n\
removeButton(toolbarName, buttonName = \&quot;\&quot;) -&gt; None \n\
\n\
Removes one or all buttons from a given toolbar in the itom main window. \n\
\n\
This method removes an existing button from a toolbar in the main window of \n\
**itom**. This button must have been created by the method :meth:`addButton` before. \n\
If the toolbar is empty after the removal, it is finally deleted. \n\
\n\
A button can be identified by two different ways: \n\
\n\
1. Either pass the ``handle`` of the button, as returned by :meth:`addButton`. \n\
   This can also be used, if multiple buttons should have the same name. \n\
2. Identify the button by its ``toolbarName`` and ``buttonName``. If more than \n\
   one button is available in the toolbar with the given ``buttonName``, all \n\
   matched buttons are removed. If ``buttonName`` is an empty string (default) \n\
   all buttons that are contained in the toolbar are removed (including the toolbar). \n\
\n\
For more information see also the section :ref:`toolbar-addtoolbar` of the documentation. \n\
\n\
Parameters \n\
----------- \n\
handle : int \n\
    The handle returned by :meth:`addButton`. \n\
toolbarName : str \n\
    The name of the toolbar.\n\
buttonName : str \n\
    The name (str, identifier) of the button to remove (only necessary, \n\
    if ``toolbarName`` is given instead of ``handle``). If an empty string \n\
    all buttons of the given toolbar are removed (including the toolbar itself). \n\
\n\
Raises \n\
------- \n\
RuntimeError \n\
    if the main window is not available or the addressed button could not be found. \n\
\n\
See Also \n\
--------- \n\
addButton&quot;)</td></tr>
<tr class="separator:a1fa5b9d69f185e337fc3d7c1388c2b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592698a08fec1d8f1822f263b864909c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a592698a08fec1d8f1822f263b864909c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyAddMenu_doc,&quot;addMenu(type, key, name = \&quot;\&quot;, code = \&quot;\&quot;, icon = \&quot;\&quot;, argtuple = []) -&gt; int \n\
\n\
This function adds an element to the main window menu bar. \n\
\n\
The root element of every menu list must be of type :attr:`~itom.MENU`. Such a \n\
:attr:`~itom.MENU` element can contain sub-elements. These sub-elements can be either \n\
another :attr:`~itom.MENU`, a :attr:`~itom.SEPARATOR` or a :attr:`~itom.BUTTON`. Only \n\
the :attr:`~itom.BUTTON` itself triggers a signal, which then executes the code, given \n\
by a string or a reference to a callable python method or function. Remember, that this \n\
reference is only stored as a weak pointer. \n\
\n\
If you want to directly add a sub-element, you can give a slash-separated string as ``key`` \n\
argument. Every component of this string then represents the menu element in its specific \n\
level. Only the element in the last can be something else than of type \n\
:attr:`~itom.MENU`.\n\
\n\
Itom comes with basic icons addressable by ``:/../iconname.png``, e.g.\n\
``:/gui/icons/close.png``. These natively available icons are listed in the icon \n\
browser in the menu **edit &gt;&gt; icon browser** of any script window. Furthermore you \n\
can give a relative or absolute path to any allowed icon file (the preferred file \n\
format is png). \n\
\n\
For more information see also the section :ref:`toolbar-createmenu` of the documentation. \n\
\n\
Parameters \n\
----------- \n\
type : int \n\
    The type of the menu-element (:attr:`~itom.BUTTON` : 0 [default], \n\
    :attr:`~itom.SEPARATOR` : 1, :attr:`~itom.MENU` : 2). Use the corresponding \n\
    constans in module :mod:`itom`.\n\
key : str \n\
    A slash-separated string where every sub-element is the key-name for the menu-element \n\
    in the specific level.\n\
name : str, optional \n\
    The text of the menu-element. If it is an empty string, the last component of the \n\
    slash separated ``key`` is used as name. For instance if key is equal to ``item1/item2`` \n\
    the name will be ``item2``. \n\
code : str or callable, optional \n\
    The code to be executed if menu element is pressed.\n\
icon : str, optional \n\
    The filename of an icon-file. This can also be relative to the application directory of \n\
    **itom**.\n\
argtuple : tuple, optional \n\
    Arguments, which will be passed to method (in order to avoid cyclic references try \n\
    to only use basic element types).\n\
\n\
Returns \n\
------- \n\
handle : int \n\
    Handle to the recently added leaf node (action, separator or menu item). Use this \n\
    handle to delete the item including its child items (for type 'menu'). \n\
\n\
Raises \n\
------- \n\
RuntimeError \n\
    if the main window is not available or the given button could not be found. \n\
\n\
See Also \n\
--------- \n\
removeMenu&quot;)</td></tr>
<tr class="separator:a592698a08fec1d8f1822f263b864909c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051899f45914b2f493df1c5dd2fcbb31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a051899f45914b2f493df1c5dd2fcbb31"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRemoveMenu_doc,&quot;removeMenu(key) -&gt; None \\\n\
removeMenu(menuHandle) -&gt; None \n\
\n\
Remove a menu element with the given key or handle. \n\
\n\
This function remove a menu element with the given ``key`` or ``menuHandle``. \n\
key is a slash separated list. The sub-components then \n\
lead the way to the final element, which should be removed. \n\
\n\
Alternatively, it is possible to pass the handle obtained from :meth:`addMenu`. \n\
\n\
For more information see also the section :ref:`toolbar-createmenu` of the \n\
documentation.\n\
\n\
Parameters \n\
----------- \n\
key : str\n\
    The key (can be a slash-separated list) of the menu entry to remove. If it \n\
    is a slash-separated list, the menu entry is searched down the path, \n\
    indicated by the components of the list respectively. \n\
    If the desired menu item has further child items, they are removed, too. \n\
menuHandle : int \n\
    The handle of the menu entry that should be removed (including its \n\
    possible child items). This handle is usually returned by :meth:`addMenu`.\n\
\n\
Raises \n\
------- \n\
RuntimeError \n\
    if the main window is not available or the given button could not be found. \n\
\n\
See Also \n\
--------- \n\
addMenu&quot;)</td></tr>
<tr class="separator:a051899f45914b2f493df1c5dd2fcbb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca2398cecb4d0d0923880d9679c19ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ca2398cecb4d0d0923880d9679c19ea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDumpButtonsAndMenus_doc,&quot;dumpButtonsAndMenus() -&gt; dict \n\
\n\
Gets all user-defined toolbars, menus and its buttons. \n\
\n\
Returns \n\
-------- \n\
dict \n\
    Dictionary with two top-level entries:: \n\
        \n\
        {'toolbars': {}, 'menus': []} \n\
    \n\
    ``toolbars`` contains a dict of all customized toolbars, where each \n\
    item contains all buttons (actions) of this toolbar. ``menus`` contains \n\
    a list of nested dictionaries for each top level menu.&quot;)</td></tr>
<tr class="separator:a4ca2398cecb4d0d0923880d9679c19ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a2727fdee521eab157da425ad42b56"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38a2727fdee521eab157da425ad42b56"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyCheckSignals_doc,&quot;checkSignals() -&gt; int \n\
\n\
Verifies if a Python interrupt request is currently queued. \n\
\n\
Returns \n\
-------- \n\
int \n\
    Returns 1 if an interrupt is currently queued, else 0.&quot;)</td></tr>
<tr class="separator:a38a2727fdee521eab157da425ad42b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4439e4cbbbfb8c2bbdf2bcb82351261"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4439e4cbbbfb8c2bbdf2bcb82351261"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyProcessEvents_doc,&quot;processEvents() \n\
\n\
This method processes posted events for the Python thread. \n\
\n\
Please use this method with care.&quot;)</td></tr>
<tr class="separator:ad4439e4cbbbfb8c2bbdf2bcb82351261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdaba996e7e2ad1b201ba51981ee18d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bdaba996e7e2ad1b201ba51981ee18d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyGetDebugger_doc,&quot;getDebugger() -&gt; itoDebugger.itoDebugger \n\
\n\
Returns the ``itoDebugger`` object of this itom session. \n\
\n\
It is usually not recommended and necessary to use this method or the returned \n\
debugger. This method is available for development and debugging purposes. \n\
\n\
Returns \n\
------- \n\
debugger : itoDebugger.itoDebugger \n\
    is the debugger instance of this itom session.&quot;)</td></tr>
<tr class="separator:a9bdaba996e7e2ad1b201ba51981ee18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af747eee3f341bdfc4573d57114159e28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af747eee3f341bdfc4573d57114159e28"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyGCStartTracking_doc,&quot;gcStartTracking() \n\
\n\
Starts a monitoring session for objects in the garbage collector. \n\
\n\
This method makes a snapshot of all objects currently guarded by \n\
the garbage collector (:mod:`gc`). Before this, ``gc.collect()`` \n\
was called to clear all unnecessary objects. \n\
\n\
Later, call :meth:`gcEndTracking` to get a print out of the \n\
differences between the snapshot at the end and the beginning \n\
of the tracking. \n\
\n\
This methods are usually available for development purposes. \n\
\n\
See Also \n\
-------- \n\
gcEndTracking&quot;)</td></tr>
<tr class="separator:af747eee3f341bdfc4573d57114159e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e847224d4ea175afaadc8eefb6960e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6e847224d4ea175afaadc8eefb6960e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyGCEndTracking_doc,&quot;gcEndTracking() \n\
\n\
Finishes a monitoring session for objects in the garbage collector. \n\
\n\
This method makes a snapshot of all objects currently guarded by \n\
the garbage collector (:mod:`gc`) and compares the list of objects\n\
with the one collected during the last call of :meth:`gcStartTracking`. \n\
\n\
The difference of both lists of printed to the command line. \n\
\n\
This methods are usually available for development purposes. \n\
\n\
Raises \n\
------ \n\
RuntimeError \n\
     if :meth:`gcStartTracking` was not called before. \n\
\n\
See Also \n\
-------- \n\
gcStartTracking&quot;)</td></tr>
<tr class="separator:ac6e847224d4ea175afaadc8eefb6960e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c8eae4d73f6d6c8db0daa103c2a1c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9c8eae4d73f6d6c8db0daa103c2a1c8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (autoReloader_doc,&quot;autoReloader(enabled, checkFileExec = True, checkCmdExec = True, checkFctExec = False) \n\
\n\
dis-/enables the module to automatically reload changed modules. \n\
\n\
Use this method to enable or disable (and configure) a tool that automatically tries to \n\
reload imported modules and their submodules if they have changed since the last run. \n\
\n\
Parameters \n\
---------- \n\
enable : bool \n\
    The auto-reload tool is loaded if it is enabled for the first time. If it is disabled, \n\
    it does not check changes of any imported modules. \n\
checkFileExec : bool \n\
    If ``True`` (default) and auto-reload enabled, a check for modifications is executed \n\
    whenever a script is executed \n\
checkCmdExec : bool \n\
    If ``True`` (default) and auto-reload enabled, a check for modifications is executed \n\
    whenever a command in the command line is executed \n\
checkFctExec : bool \n\
    If ``True`` and auto-reload enabled, a check for modifications is executed whenever a \n\
    function or method is run (e.g. by an event or button click) (default: ``False``)\n\
\n\
Notes \n\
------- \n\
This tool is inspired by and based on the IPython extension `autoreload`. \n\
\n\
Reloading Python modules in a reliable way is in general difficult, \n\
and unexpected things may occur. ``autoReloader`` tries to work around \n\
common pitfalls by replacing function code objects and parts of \n\
classes previously in the module with new versions. This makes the \n\
following things to work: \n\
 \n\
- Functions and classes imported via 'from xxx import foo' are upgraded \n\
  to new versions when 'xxx' is reloaded. \n\
\n\
- Methods and properties of classes are upgraded on reload, so that \n\
  calling 'c.foo()' on an object 'c' created before the reload causes \n\
  the new code for 'foo' to be executed. \n\
 \n\
Some of the known remaining caveats are: \n\
 \n\
- Replacing code objects does not always succeed: changing a @property \n\
  in a class to an ordinary method or a method to a member variable \n\
  can cause problems (but in old objects only). \n\
 \n\
- Functions that are removed (eg. via monkey-patching) from a module \n\
  before it is reloaded are not upgraded. \n\
 \n\
- C extension modules cannot be reloaded, and so cannot be autoreloaded.&quot;)</td></tr>
<tr class="separator:af9c8eae4d73f6d6c8db0daa103c2a1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7ae90ebfba89ac19d9d1a88810fc39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c7ae90ebfba89ac19d9d1a88810fc39"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (getScreenInfo_doc,&quot;getScreenInfo() -&gt; Dict[str, Any] \n\
\n\
Returns dictionary with information about all available screens. \n\
\n\
This method returns a dictionary with information about the current screen \n\
configuration of this computer. \n\
\n\
Returns \n\
------- \n\
dict \n\
    dictionary with the following content is returned: \n\
    \n\
    * screenCount (int): number of available screens \n\
    * primaryScreen (int): index (0-based) of primary screen \n\
    * geometry (tuple): tuple with dictionaries for each screen containing data for \n\
      width (w), height (h) and its top-left-position (x, y)&quot;)</td></tr>
<tr class="separator:a6c7ae90ebfba89ac19d9d1a88810fc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3607195273a6adfbb05d8f23fee59eea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3607195273a6adfbb05d8f23fee59eea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pySaveMatlabMat_doc,&quot;saveMatlabMat(filename, values, matrixName = \&quot;matrix\&quot;) \n\
\n\
Save strings, numbers, arrays or combinations into a Matlab mat file. \n\
\n\
Save one or multiple objects (strings, numbers, arrays, :class:`dataObject`, \n\
:class:`numpy.ndarray`...) to a Matlab *mat* file. There are the following \n\
possibilites for saving, depending on the type of ``values``: \n\
\n\
* ``values`` is a :class:`dict`: All values in the dictionary are stored under their \n\
  corresponding key. \n\
* If ``values`` contains one item only, it is saved under the given ``matrixName``. \n\
* If ``value`` is a :class:`list` or :class:`tuple` of objects, ``matrixName`` must \n\
  either be a sequence with the same length than ``value``. Then, each item in ``values`` \n\
  is stored with the respective name in ``matrixName``. Or ``matrixName`` can be omitted. \n\
  Then, the items are stored under the self-incremented keys ``matrix1``, ``matrix2``, ... \n\
\n\
Parameters \n\
----------- \n\
filename : str \n\
    Filename under which the file should be saved (.mat will be appended if not available)\n\
values : dict or list or tuple or Any \n\
    The value(s) to be stored. Can be either a single object (number, string, \n\
    :class:`dataObject`, :class:`numpy.ndarray` among others, or a :class:`list`, \n\
    :class:`tuple` or :class:`dict` of these single objects. \n\
matrixName : str or list or tuple, optional \n\
    If ``values`` is a single value, this parameter must be one single :class:`str`. \n\
    Else if ``values`` is a sequence it must be a sequence of strings with the same \n\
    length or it can be omitted. If ``values`` is a dictionary, this argument is ignored. \n\
\n\
Raises \n\
------ \n\
ImportError \n\
     if :mod:`scipy` and its module :mod:`scipy.io` could not be imported. \n\
\n\
Notes \n\
----- \n\
This method requires the package :mod:`scipy` and its module :mod:`scipy.io`. \n\
\n\
See Also \n\
-------- \n\
loadMatlabMat&quot;)</td></tr>
<tr class="separator:a3607195273a6adfbb05d8f23fee59eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba99b060ef7d679d6df2c87211621e98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba99b060ef7d679d6df2c87211621e98"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyLoadMatlabMat_doc,&quot;loadMatlabMat(filename) -&gt; dict \n\
\n\
Loads Matlab mat-file by using :mod:`scipy` methods and returns the loaded dictionary. \n\
\n\
Parameters \n\
----------- \n\
filename : str \n\
    Filename from which the data will be imported (.mat will be added if not available)\n\
\n\
Returns \n\
------- \n\
mat : dict \n\
    dictionary with content of file \n\
\n\
Raises \n\
------ \n\
ImportError \n\
     if :mod:`scipy` and its module :mod:`scipy.io` could not be imported. \n\
\n\
Notes \n\
----- \n\
This method requires the package :mod:`scipy` and its module :mod:`scipy.io`. \n\
\n\
See Also \n\
--------- \n\
saveMatlabMat&quot;)</td></tr>
<tr class="separator:aba99b060ef7d679d6df2c87211621e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5c523579724de68bb60b2df64ff073"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e5c523579724de68bb60b2df64ff073"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyFilter_doc,&quot;filter(name : str, *args, _observer = None, **kwds) -&gt; Any \n\
\n\
Invokes a filter (or algorithm) function from an algorithm-plugin. \n\
\n\
This function is used to invoke itom filter-functions or algorithms, declared within \n\
itom-algorithm plugins. The parameters (arguments) depends on the specific filter \n\
function. Call :meth:`filterHelp` to get a list of available filter functions.\n\
\n\
Pass all mandatory or optional arguments of the filter as positional or keyword-based \n\
parameters. Some filters, that implement the additional observer interface, can accept \n\
another :class:`progressObserver` object, that allows monitoring the progress of the \n\
filter and / or interrupting the execution. If such an observer is given, you have to \n\
pass it as keyword-based argument ``_observer``!. \n\
\n\
During the execution of the filter, the python GIL (general interpreter lock) is \n\
released (e.g. for further asynchronous processes. \n\
\n\
Parameters \n\
----------- \n\
name : str \n\
    The name of the filter\n\
*args : Any \n\
    positional arguments for the specific filter-method \n\
_observer : progressObserver, optional \n\
    if the called filter implements the extended interface with progress and status \n\
    information, an optional :class:`progressObserver` object can be given (only as \n\
    keyword-based parameter) which is then used as observer for the current progress of \n\
    the filter execution. It is then also possible to interrupt the execution earlier \n\
    (depending on the implementation of the filter). The observer object is \n\
    reset before passed to the called filter function (using the slot \n\
    :meth:`~progressObserver.reset`). \n\
**kwds : Any \n\
    keyword-based arguments for the specific filter-method. The argument name \n\
    ``_observer`` is reserved for special use. \n\
\n\
Returns \n\
-------- \n\
out : obj \n\
    The returned values depend on the definition of each filter. In general it is a \n\
    tuple of all output parameters that are defined by the filter function.\n\
\n\
See Also \n\
--------- \n\
filterHelp&quot;)</td></tr>
<tr class="separator:a2e5c523579724de68bb60b2df64ff073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f23aa128e5d0f9ff9fef9fb9e82e42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94f23aa128e5d0f9ff9fef9fb9e82e42"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pySaveDataObject_doc,&quot;saveDataObject(filename, dataObject, tagsAsBinary = False) \n\
\n\
Saves a dataObject to the harddrive in a xml-based file format (ido). \n\
\n\
This method writes a :class:`dataObject` into the file specified by ``filename``. \n\
The data is stored in a binary format within a xml-based structure. \n\
All string-tags of the dataObject are encoded in order to avoid xml-errors, \n\
the value of numerical tags are either converted to strings with 15 significant digits \n\
(&gt;32bit) or stored as base64 encoded values. \n\
\n\
Parameters \n\
----------- \n\
filename : str \n\
    absolute or relative file path to the destination file (.ido will be added if \n\
    no valid suffix is given)\n\
dataObject : dataObject \n\
    The `n`-dimensional dataObject to be serialized to the file.\n\
tagsAsBinary : bool, optional \n\
    If ``True`` all number tags are stored as base64 encoded number values in the `ido` \n\
    file. Else (default), they are stored as readable strings. \n\
\n\
Notes \n\
----- \n\
Tagnames which contains special characters might lead to XML-conflics. \n\
\n\
See Also \n\
--------- \n\
loadDataObject&quot;)</td></tr>
<tr class="separator:a94f23aa128e5d0f9ff9fef9fb9e82e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d87a34af924aefe73fcbc64ac120d9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d87a34af924aefe73fcbc64ac120d9d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyLoadDataObject_doc,&quot;loadDataObject(filename, dataObject, doNotAppendIDO = False) \n\
\n\
Loads a dataObject from an IDO file. \n\
\n\
This function reads a `dataObject` from the file specified by filename. \n\
MetaData saveType (string, binary) are extracted from the file and restored within the object.\n\
\n\
Parameters \n\
----------- \n\
filename : str \n\
    absolute or relative ido file path to the target file \n\
dataObject : dataObject \n\
    an allocated, e.g. empty :class:`dataObject`, that is filled with the loaded \n\
    object afterwards. \n\
doNotAppendIDO : bool, optional \n\
    If ``True`` (default: ``False``), the file suffix **ido** is appended to ``filename``. \n\
\n\
Notes \n\
----- \n\
\n\
The value of string tags must be encoded to avoid XML-conflics.\n\
Tag names which contains special characters might lead to XML-conflics.&quot;)</td></tr>
<tr class="separator:a9d87a34af924aefe73fcbc64ac120d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c6998721aa76a462c6d15de809e1e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8c6998721aa76a462c6d15de809e1e0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pySetCentralWidgetsSizes_doc,&quot;setCentralWidgetsSizes(sizes) \n\
\n\
Sets the sizes of the central widgets of itom (including command line) from top to bottom. \n\
\n\
This method can be important if at least one widget has been added from :class:`itom.ui`, \n\
type :attr:`ui.TYPECENTRALWIDGET`. These user defined widgets are then added on top \n\
of the central area of itom and stacked above the command line. The list of sizes \n\
indicates the desired heights of all widgets in the center in pixel (from top to bottom). \n\
\n\
If the list contains too much items, all extra values are ignored. If the list contains \n\
too few values, the result is undefined, but the program will still be well-behaved. \n\
\n\
The overall size of the central area will not be affected. Instead, any additional/missing \n\
space is distributed amongst the widgets according to the relative weight of the sizes. \n\
\n\
If you speciy a size of 0, the widget will be invisible and can be made visible again \n\
using this method or by increasing its size again with the mouse. \n\
\n\
Parameters \n\
----------- \n\
sizes : sequence of int \n\
    Sizes in pixel for each central widget from top to bottom (including the command line). \n\
&quot;)</td></tr>
<tr class="separator:af8c6998721aa76a462c6d15de809e1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6d71aca97b1b923f929192e3e3793e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f6d71aca97b1b923f929192e3e3793e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (getDefaultScaleableUnits_doc,&quot;getDefaultScaleableUnits() -&gt; List[str] \n\
\n\
Gets a list with the strings of the standard scalable units. \n\
\n\
The unit strings returned as a list by this method can be transformed into each \n\
other using :meth:`scaleValueAndUnit`. \n\
\n\
Returns \n\
------- \n\
units : list of str \n\
    List with strings containing all scaleable units \n\
\n\
See Also \n\
-------- \n\
scaleValueAndUnit&quot;)</td></tr>
<tr class="separator:a9f6d71aca97b1b923f929192e3e3793e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d624b8940518a805d6e8557e11a06c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51d624b8940518a805d6e8557e11a06c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (scaleValueAndUnit_doc,&quot;scaleValueAndUnit(scaleableUnits, value, valueUnit) -&gt; Tuple[float, str] \n\
\n\
Rescales a ``value`` and its unit to the next matching SI unit. \n\
\n\
At first, it is checked if the given ''valueUnit'' is contained in the list \n\
of the base units ``scaleableUnits``. If this is the case, \n\
the given ``value`` is scaled such that the returned value is greater or equal \n\
than 1. The scaled value and the new unit is returned then. \n\
\n\
Use the method :meth:`getDefaultScaleableUnits` to obtain a suitable list of SI \\n\
base units. \n\
\n\
Parameters \n\
----------- \n\
scaleableUnits : list of str \n\
    A list of str with all base units that should be considered for scaling. \n\
    If the given ''valueUnit'' is not contained in this list of base units, \n\
    no scaling is done and the returned values are equal to ``[value, valueUnit]``. \n\
value : float \n\
    The value to be scaled\n\
valueUnit : str \n\
    The value unit to be scaled\n\
\n\
Returns \n\
------- \n\
tuple \n\
    The returned tuple has the format ``[newValue, newUnit]``, where ``newValue`` is \n\
    a float and ``newUnit`` is a string. \n\
\n\
Examples \n\
--------- \n\
&gt;&gt;&gt; baseUnits = getDefaultScaleableUnits() \n\
&gt;&gt;&gt; print(scaleValueAndUnit(baseUnits, 0.001, 'm')) \n\
[1, 'mm']&quot;)</td></tr>
<tr class="separator:a51d624b8940518a805d6e8557e11a06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c62020869577c022fd92d39d047bc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05c62020869577c022fd92d39d047bc2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (getAppPath_doc,&quot;getAppPath() -&gt; str\n\
\n\
Returns the absolute path of the base directory of this application.\n\
\n\
The returned value is independent of the current working directory. \n\
\n\
Returns \n\
------- \n\
path : str\n\
    absolute path of this application's base directory&quot;)</td></tr>
<tr class="separator:a05c62020869577c022fd92d39d047bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151b0782c19655ddc51866d3bbe9c3bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a151b0782c19655ddc51866d3bbe9c3bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (getQtToolPath_doc,&quot;getQtToolPath(toolname) -&gt; str \n\
\n\
Gets the absolute path of the given Qt tool \n\
\n\
Parameters \n\
----------- \n\
toolname : str \n\
    The filename of the tool that should be searched \n\
    (e.g. ``qcollectiongenerator``; suffix is not required)\n\
\n\
Returns \n\
------- \n\
path : str \n\
    Absolute path to the given Qt tool. \n\
\n\
Raises \n\
------- \n\
FileExistsError \n\
    if the given toolname could not be found&quot;)</td></tr>
<tr class="separator:a151b0782c19655ddc51866d3bbe9c3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23584f2f92fca45b9fef7707d2d94a50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23584f2f92fca45b9fef7707d2d94a50"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (getCurrentPath_doc,&quot;getCurrentPath() -&gt; str \n\
\n\
Returns the absolute path of the current working directory.\n\
\n\
The current working directory is also displayed on the right side \n\
of the status bar of the main window of itom. \n\
\n\
Returns \n\
------- \n\
str\n\
    the absolute path of the current working directory \n\
\n\
See Also \n\
--------- \n\
setCurrentPath&quot;)</td></tr>
<tr class="separator:a23584f2f92fca45b9fef7707d2d94a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712f5457464bf371b9842dde96475df3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a712f5457464bf371b9842dde96475df3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (setCurrentPath_doc,&quot;setCurrentPath(newPath) -&gt; bool \n\
\n\
Set current working directory to a new absolute path. \n\
\n\
sets the absolute path of the current working directory to 'newPath'. \n\
The current working directory is the base directory for all subsequent relative \n\
pathes of icon-files, script-files, ui-files, relative import statements... \n\
\n\
The current directory is always indicated in the right corner of the status \n\
bar of the main window. \n\
\n\
Parameters \n\
----------- \n\
newPath : str \n\
    The new path for the current working directory.\n\
\n\
Returns \n\
------- \n\
success : bool \n\
    ``True`` in case of success else ``False``. \n\
\n\
See Also \n\
--------- \n\
getCurrentPath&quot;)</td></tr>
<tr class="separator:a712f5457464bf371b9842dde96475df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145c2766df9b92df8821920fe9662084"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a145c2766df9b92df8821920fe9662084"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyCompressData_doc,&quot;compressData(text) -&gt; bytes \n\
\n\
Compresses a given string text, using zlib. \n\
\n\
The compression is done using the zlib library and the command \n\
`qCompress` of the Qt framework. \n\
\n\
Parameters \n\
----------- \n\
text : str \n\
    The string that should be compressed. \n\
level : int \n\
    The compression level: -1 selects the default compression level of `zlib`, else \n\
    a level in the range [0, 9]. \n\
\n\
Returns \n\
------- \n\
compressed_text : bytes \n\
    The compressed version of ``text``. \n\
\n\
See Also \n\
--------- \n\
uncompressData&quot;)</td></tr>
<tr class="separator:a145c2766df9b92df8821920fe9662084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426701f28186eb33ae81d3ca304adf70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a426701f28186eb33ae81d3ca304adf70"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUncompressData_doc,&quot;uncompressData(compressed_text) -&gt; bytes \n\
\n\
Uncompresses a given compressed text, using zlib. \n\
\n\
The uncompression is done using the zlib library and the command \n\
`qUncompress` of the Qt framework. \n\
\n\
Parameters \n\
----------- \n\
compressed_text : bytes \n\
    The compressed bytes string. \n\
\n\
Returns \n\
------- \n\
uncompressed_text : bytes \n\
    The uncompressed ``compressed_text``. \n\
\n\
See Also \n\
--------- \n\
compressData&quot;)</td></tr>
<tr class="separator:a426701f28186eb33ae81d3ca304adf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55732328ff2f7c3148c2d2e992466b42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55732328ff2f7c3148c2d2e992466b42"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegisterResources_doc,&quot;registerResource(rccFileName, mapRoot = \&quot;\&quot;) -&gt; bool \n\
\n\
Registers a resource file with the given rccFileName. \n\
\n\
This method opens a given Qt rcc resource file and registers its content at the location \n\
in the resource tree specified by ``mapRoot``. This ``mapRoot`` must usually be a slash separated \n\
path, starting with a slash. \n\\n\
\n\
To generate a rcc file, create an index of all files, that should be added to the resource file, \n\
in a qrc file and uses the rcc binary from Qt to compile the rcc file. \n\
\n\
This method is new in itom &gt; 4.0.0. \n\
\n\
Parameters \n\
----------- \n\
rccFileName : str\n\
    filepath to the rcc resource file \n\
mapRoot : str, optional \n\
    root key, where the resources should be registered below (default: empty string) \n\
\n\
Returns \n\
---------- \n\
bool \n\
    ``True`` if the file could be successfully opened, else ``False``.\n\
\n\
See Also \n\
--------- \n\
unregisterResource&quot;)</td></tr>
<tr class="separator:a55732328ff2f7c3148c2d2e992466b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf86fec33666092981667f95ba8cc48d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf86fec33666092981667f95ba8cc48d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUnregisterResources_doc,&quot;unregisterResource(rccFileName, mapRoot = \&quot;\&quot;) -&gt; bool \n\
\n\
Unregisters the resource with the given rccFileName. \n\
\n\
This method tries to unload all resources in the given rcc resource file from the location \n\
in the resource tree specified by ``mapRoot``. The ``mapRoot`` must usually be a slash separated \n\
path, starting with a slash. \n\
\n\
This method is new in itom &gt; 4.0.0. \n\
\n\
Parameters \n\
----------- \n\
rccFileName : str\n\
    filepath to the rcc resource file \n\
mapRoot : str, optional \n\
    root key, where the resources should be unloaded from (default: empty string). \n\
\n\
Returns \n\
---------- \n\
bool \n\
    ``True`` if the file could be successfully opened, else ``False``.\n\
\n\
See Also \n\
--------- \n\
registerResource&quot;)</td></tr>
<tr class="separator:abf86fec33666092981667f95ba8cc48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc491a0e073221a29e9420e081b5d14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dc491a0e073221a29e9420e081b5d14"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (setApplicationCursor_doc,&quot;setApplicationCursor(cursorIndex = -1) \n\
\n\
Changes the itom cursor or restores the previously set cursor if -1. \n\
\n\
This methods changes the overall cursor icon of itom where ``cursorIndex`` \n\
corresponds to the Qt enumeration ``Qt::CursorShape``. e.g.:\n\
\n\
    * 0: Arrow \n\
    * 2: Cross Cursor \n\
    * 3: Wait Curson \n\
    * 13: Pointing Hand Cursor \n\
    * 14: Forbidden Cursor \n\
    * 16: Busy Cursor \n\
\n\
Every change of the cursor is put on a stack. The previous cursor type is \n\
restored, if ``cursorIndex`` is set to ``-1``. \n\
\n\
Parameters \n\
----------- \n\
cursorIndex : int, optional\n\
    The cursor enumeration value of the desired cursor shape (``Qt::CursorShape``) \n\
    or ``-1`` if the previous cursor should be restored (default)&quot;)</td></tr>
<tr class="separator:a1dc491a0e073221a29e9420e081b5d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39315b1156c838dc0a14fc62da992be1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39315b1156c838dc0a14fc62da992be1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyLoadIDC_doc,&quot;loadIDC(filename) -&gt; dict \n\
\n\
loads a pickled idc-file and returns the content as dictionary. \n\
\n\
This methods loads the given idc file using the method :meth:`pickle.load` from the \n\
Python buildin module :mod:`pickle` and returns the loaded dictionary. \n\
\n\
Parameters \n\
----------- \n\
filename : str \n\
    Filename to the `idc`-file, that should be loaded. Can be an absolute \n\
    path, or relative with respect to the current working directory. \n\
\n\
Returns \n\
-------- \n\
content : dict \n\
    dictionary with loaded content. \n\
\n\
See Also \n\
--------- \n\
pickle.load, saveIDC&quot;)</td></tr>
<tr class="separator:a39315b1156c838dc0a14fc62da992be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fadcba2f922f854c8d09a7b0b8eef11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fadcba2f922f854c8d09a7b0b8eef11"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pySaveIDC_doc,&quot;saveIDC(filename, dict, overwriteIfExists = True) \n\
\n\
Saves the given dictionary as pickled idc-file.\n\
\n\
This method saves the given dictionary ``dict`` as pickled idc-file using the method \n\
:meth:`pickle.dump` from the builtin module :mod:`pickle`.\n\
The file will be saved with the pickle protocol version 3 (default for Python 3).\n\
\n\
Parameters \n\
----------- \n\
filename : str \n\
    Filename of the destination `idc` file. Can be an absolute filename \n\
    or relative with respect to the current working directory. \n\
dict : dict \n\
    dictionary which should be pickled. All values in the dictionary must be able \n\
    to be pickled (e.g. all Python base types, dataObjects, numpy.ndarrays...). \n\
overwriteIfExists : bool, optional \n\
    If ``True``, an existing file will be overwritten. \n\
\n\
Raises \n\
------ \n\
RuntimeError \n\
    if the file cannot be overwritten or if it exists, but ``overwriteIfExists`` \n\
    is ``False``. \n\
\n\
See Also \n\
--------- \n\
pickle.dump, loadIDC&quot;)</td></tr>
<tr class="separator:a8fadcba2f922f854c8d09a7b0b8eef11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d6ffe6aab6f2ecafdffa708b8e3b5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42d6ffe6aab6f2ecafdffa708b8e3b5a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyCheckIsAdmin_doc,&quot;userIsAdmin() -&gt; bool \n\
\n\
Returns ``True`` if the current user has administrator rights.\n\
\n\
For more information about the user management of itom, see :ref:`gui-user-management`. \n\
\n\
Returns \n\
------- \n\
bool \n\
    ``True`` if current user has administrator rights, otherwise ``False``.\n\
\n\
See Also \n\
-------- \n\
userIsUser, userIsDeveloper, userGetInfo&quot;)</td></tr>
<tr class="separator:a42d6ffe6aab6f2ecafdffa708b8e3b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f0a1e45c2c88468461e7daf2240497"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2f0a1e45c2c88468461e7daf2240497"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyCheckIsDeveloper_doc,&quot;userIsDeveloper() -&gt; bool \n\
\n\
Returns ``True`` if the current user has developer rights.\n\
\n\
This method only returns ``True``, if the current user has developer rights, not if \n\
he has higher rights, like adminstrator. \n\
For more information about the user management of itom, see :ref:`gui-user-management`. \n\
\n\
Returns \n\
------- \n\
bool \n\
    ``True`` if current user has developer rights, otherwise ``False``. \n\
\n\
See Also \n\
-------- \n\
userIsUser, userIsAdministrator, userGetInfo&quot;)</td></tr>
<tr class="separator:ad2f0a1e45c2c88468461e7daf2240497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af387937a44d62d466307c096726383fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af387937a44d62d466307c096726383fb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyCheckIsUser_doc,&quot;userIsUser() -&gt; bool \n\
\n\
Returns ``True`` if the current user has user rights.\n\
\n\
This method only returns ``True``, if the current user has user rights, not if \n\
he has higher rights, like developer or adminstrator. \n\
For more information about the user management of itom, see :ref:`gui-user-management`. \n\
\n\
Returns \n\
------- \n\
bool \n\
    ``True`` if current user has user rights, otherwise ``False``.\n\
\n\
See Also \n\
-------- \n\
userIsDeveloper, userIsAdministrator, userGetInfo&quot;)</td></tr>
<tr class="separator:af387937a44d62d466307c096726383fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eff66ae7f2bd7ae0f2a1bfbdc9998aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0eff66ae7f2bd7ae0f2a1bfbdc9998aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyGetUserInfo_doc,&quot;userGetInfo() -&gt; Dict[str, str] \n\
\n\
Returns a dictionary with relevant information about the current user. \n\
\n\
Returns \n\
------- \n\
dict \n\
    dictionary with the following content is returned: \n\
    \n\
    * Name: The name of the current user \n\
    * Type: The user right type of the current user [user, administrator, developer] \n\
    * ID: The user ID \n\
    * File: The location and name of the corresponding setting file (ini).&quot;)</td></tr>
<tr class="separator:a0eff66ae7f2bd7ae0f2a1bfbdc9998aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f10804a760cba04f3a8d3c7336752c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53f10804a760cba04f3a8d3c7336752c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a53f10804a760cba04f3a8d3c7336752c">PyDoc_STRVAR</a> (pyItom_FigureClose_doc,&quot;close(handle) -&gt; None \\\n\
close(all = \&quot;all\&quot;) -&gt; None \n\
\n\
Closes a specific or all opened figures. \n\
\n\
This method closes and deletes either one specific figure (if ``handle`` is given \n\
and valid), or all opened figures (if the string argument ``\&quot;all\&quot;`` is given). \n\
All figure can only be closed, if no other figure references this figure (e.g. \n\
line cut of an image plot (2D). \n\
\n\
This method is a redirect of the staticmethod :meth:`figure.close`. \n\
\n\
Parameters \n\
----------- \n\
handle : int \n\
    a valid figure handle, whose reference figure should be closed. \n\
    This figure handle is for instance obtained by the first value of the \n\
    returned tuple of :meth:`plot`, :meth:`plot1`, :meth:`plot2` among others. \n\
all : {\&quot;all\&quot;} \n\
    Pass the string ``\&quot;all\&quot;``  if all closeable opened figures should be closed. \n\
\n\
Notes \n\
------- \n\
If a :class:`figure` instance still keeps a reference to any figure, it is only closed \n\
and will be deleted after that the last referencing instance has been deleted. \n\
\n\
See Also \n\
--------- \n\
figure.close&quot;)</td></tr>
<tr class="memdesc:a53f10804a760cba04f3a8d3c7336752c"><td class="mdescLeft">&#160;</td><td class="mdescRight">try to convert object to PyRgba or to None. <br /></td></tr>
<tr class="separator:a53f10804a760cba04f3a8d3c7336752c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba50669ef34000d6f432213ce3a1177"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afba50669ef34000d6f432213ce3a1177"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>PyRgbaOptional_Converter</b> (PyObject *object, <a class="el" href="structito_1_1_python_rgba_1_1_py_rgba.html">PythonRgba::PyRgba</a> **address)</td></tr>
<tr class="separator:afba50669ef34000d6f432213ce3a1177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53bf3bfa8b179ad7e134fbfe0de6c09"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac53bf3bfa8b179ad7e134fbfe0de6c09"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (setPalette_doc,&quot;setPalette(name, colorStops, inverseColor1 = None, inverseColor2 = None, invalidColor = None) \n\
\n\
Changes a given color palette or creates a new one with the given arguments. \n\
\n\
This methods modifies an existing color palette (if a palette with ``name`` \n\
already exists) or creates a new color palette with the given ``name``. An existing \n\
color palette can only be modified, if it has no write protection, which is the case \n\
for all pre-defined color palettes of itom (see color palette editor in itom property \n\
editor). If any of the optional values are not given, default values (from the ``gray`` \n\
color palette) are used, or, if the color palette ``name`` already exists, \n\
these values are left unchanged\n\
\n\
To obtain the parameters of an existing color palette, that can be used as arguments \n\
of this method, unpack the returned dictionary of :meth:`getPalette`. \n\
\n\
It is also possible to modify or create color palettes in the color palette editor of \n\
the itom property dialog. For more information see :ref:`gui-color-palette-editor`. \n\
\n\
Parameters \n\
----------- \n\
name : str \n\
    Name of the color palette. \n\
colorStops : tuple \n\
    Tuple with all color stops of this color palette. Each item of this tuple is \n\
    another tuple with two values. The first value is the float position of the \n\
    color stop in the range [0.0, 1.0]. The 2nd value is the :class:`rgba32` color \n\
    at this position. Colors between two adjacent color stops are linearly interpolated. \n\
    \n\
    The position of the first color stop has to be 0.0, the one of the last stop 1.0.\n\
    There must be at least two colorStops.\n\
inverseColor1 : rgba, optional \n\
    First inverse color, used for instance for line cuts, markers etc. of a 2D plot. \n\
inverseColor2 : rgba, optional \n\
    second inverse color, used for instance for line cuts, markers etc. of a 2D plot. \n\
invalidColor : rgba, optional \n\
    color used for ``NaN`` or ``Inf`` values in plots. If the invalid color is not given \n\
    and an existing color palette also has no invalid color, the color of the first color \n\
    stop is taken. \n\
\n\
See Also \n\
--------- \n\
getPalette, getPaletteList&quot;)</td></tr>
<tr class="separator:ac53bf3bfa8b179ad7e134fbfe0de6c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae402ad93d706e03ccb5a5a35f834bcf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae402ad93d706e03ccb5a5a35f834bcf3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (getPalette_doc,&quot;getPalette(name) -&gt; dict \n\
\n\
Returns all relevant data of an existing color palette. \n\
\n\
If a color palette with this ``name`` exists, its relevant data is returned \n\
as dictionary. The values in this dictionary can also be used to call the \n\
method :meth:`setPalette`. \n\
\n\
Parameters \n\
----------- \n\
name : str \n\
    name of the new palette. \n\
\n\
Returns \n\
-------- \n\
palette : dict \n\
    Dictionary with the following entries: \n\
    \n\
    name : str \n\
        name of the color palette. \n\
    colorStops : tuple \n\
        tuple with all color stops, each element is another tuple whose first value is \n\
        the float position of the stop in the range [0.0, 1.0]. The 2nd value is the \n\
        corresponding :class:`rgba` color. The first color stop is always at \n\
        position 0.0, the last one at position 1.0. \n\
    inverseColor1 : rgba \n\
        first inverse color. \n\
    inverseColor2 : rgba \n\
        2nd inverse color. \n\
    invalidColor : rgba \n\
        color used for ``NaN`` or ``Inf`` values. \n\
\n\
Raises \n\
----------- \n\
RuntimeError \n\
    if no color palette with the given name is available. \n\
\n\
See Also \n\
--------- \n\
setPalette, getPaletteList&quot;)</td></tr>
<tr class="separator:ae402ad93d706e03ccb5a5a35f834bcf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd13da2d2ff85920702e76a2dafe941"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cd13da2d2ff85920702e76a2dafe941"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (getPaletteList_doc,&quot;getPaletteList(type = 0) -&gt; Tuple[str] \n\
\n\
Returns a tuple with the names of all currently available color palettes. \n\
\n\
Parameters \n\
----------- \n\
type : int, optional \n\
    Unused parameter. \n\
\n\
Returns \n\
------- \n\
tuple of str \n\
    Tuple with the names of all available color palettes. \n\
\n\
See Also \n\
--------- \n\
setPalette, getPalette&quot;)</td></tr>
<tr class="separator:a2cd13da2d2ff85920702e76a2dafe941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d1160920019bddf19e6f89c202acd0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8d1160920019bddf19e6f89c202acd0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyClearAll_doc,&quot;clearAll() \n\
\n\
Clears all variables in the global workspace. \n\
\n\
This method clears all variables in the global workspace, that have been \n\
added after the startup process of itom. This only affects variables, that \n\
are also displayed in the workspace toolbox. Variables, like methods, functions, \n\
classes etc. are filtered out, and will therefore not be deleted.\n\
\n\
Variables, that have been created by any startup script will also not be deleted.&quot;)</td></tr>
<tr class="separator:aa8d1160920019bddf19e6f89c202acd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233d059c94b86c423ba60a0b63c8b2aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a233d059c94b86c423ba60a0b63c8b2aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyAMax_doc,&quot;amax(dataObject) -&gt; returns the maximum value of the data object.&quot;)</td></tr>
<tr class="separator:a233d059c94b86c423ba60a0b63c8b2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6b84903b20d30a654e4e4ded6ca906"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d6b84903b20d30a654e4e4ded6ca906"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlotItemInit_doc,&quot;plotItem(figure, subplotIdx = 0) -&gt; plotItem \\\n\
plotItem(uiItem) -&gt; plotItem \\\n\
plotItem(figure, objectID = 0) -&gt; plotItem \n\
\n\
The plotItem is a special :class:`uiItem` and represents itom plot designer widgets. \n\
\n\
This constructor can be used to get a reference of a plot in a :class:`figure`. \n\
The plot can also be in a subplot area of a figure. There are two main uses cases \n\
for the direct usage of this constructor: \n\
\n\
1. If a reference to a general :class:`uiItem` is available, but the referenced \n\
   widget / item is a plot, the :class:`uiItem` can be cast to :class:`plotItem` \n\
   such that additional methods like :meth:`pickPoints` or :meth:`drawAndPickElements` \n\
   become available. \n\
2. If a reference to a :class:`figure` is available, that contains one or more \n\
   plots, the reference to one of these plots can be obtained. The ``subplotIdx`` \n\
   indicates the specific plot, that should be referenced. The default is ``0``. \n\
   If the figure consists of more than one subplot, the index counts the subplots \n\
   row-by-row. \n\
\n\
The 3rd variant of this contructor, using the keyword-based argument ``objectID`` \n\
is only internally used and has no further meaning for a high-level usage. However, \n\
if it is used, ``objectID`` must be used as keyword argument, else ``subplotIdx`` is \n\
assumed to be initialized. \n\
\n\
Parameters \n\
------------ \n\
figure : figure \n\
    The :class:`figure` window, that contains an itom plot. \n\
subplotIdx : int, optional \n\
    The area index of the (sub)plot, that should be referenced. This index is \n\
    considered to be row-wise, such that the center plot in the 2nd row with \n\
    three plots in each row has the index ``4``. The first, left, plot in the \n\
    first row has the index ``0``, which is the default. \n\
objectID : int, optional \n\
    If the internal ``objectID`` of a :class:`uiItem` is available, it can be \n\
    tried to be casted to ``plotItem``. \n\
uiItem : uiItem \n\
    Try to cast this :class:`uiItem` to its inherited class :class:`plotItem`. \n\
    A :obj:`RuntimeError` is raised if this cast is not possible. \n\
\n\
Returns \n\
------- \n\
plotItem \n\
    The initialized :class:`plotItem`.&quot;)</td></tr>
<tr class="separator:a6d6b84903b20d30a654e4e4ded6ca906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b36649a5443956ae636bfe7ce438e58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b36649a5443956ae636bfe7ce438e58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlotItem_pickPoints_doc,&quot;pickPoints(points, maxNrPoints = -1) \n\
\n\
 -&gt; method to let the user pick points on a plot (only if plot supports this) \n\
\n\
This method lets the user select one or multiple points (up to ``maxNrPoints``) in \n\
the canvas of the current plot (if the plot supports this). The operation can be \n\
aborted by pressing the ``Esc`` key. Then a ``RuntimeError` is raised. It can also \n\
be quit earlier by pressing the ``Space`` key. This is also required if an unlimited \n\
number of points can be selected (``maxNrPoints = -1``). \n\
\n\
A pick-points operation is not supported by all plot classes. It is for instance \n\
available for the classes ``itom1dqwtplot`` (see section :ref:`plot-line`) or \n\
``itom2dqwtplot`` (see section :ref:`plot-image`). \n\
\n\
Parameters\n\
-----------\n\
points : dataObject \n\
    This object will be a ``2 x nrOfSelectedPoints`` :class:`dataObject` of dtype \n\
    ``float64`` after the successful call of this method. The first row contains \n\
    the ``x`` coordinates of the selected points, the 2nd row the ``y`` coordinates. \n\
maxNrPoints : int, optional \n\
    Let the user select up to this number of points. The selection \n\
    can be stopped by pressing Space or Esc. ``maxNrPoints`` must be -1 \n\
    for an unlimited number of picked points (default) or a number &gt;= 1. \n\
\n\
Raises \n\
------ \n\
RuntimeError \n\
    if the specific plot class does not provide the necessary methods to support \n\
    this operation. \n\
RuntimeError \n\
    if the operation has been interrupted by the user. ``points`` is an empty \n\
    :class:`dataObject` then. An interruption can occur if the plot is closed \n\
    or if the user pressed the escape key during the operation.&quot;)</td></tr>
<tr class="separator:a0b36649a5443956ae636bfe7ce438e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fee6bdea08a74480c8c99d967eb28f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78fee6bdea08a74480c8c99d967eb28f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlotItem_drawAndPickElements_doc,&quot;drawAndPickElements(elementType, maxNrElements = 1) -&gt; Tuple[shape] \n\
\n\
This method forces the user to draw specific shapes on the canvas of the plot. \n\
\n\
If this method is called, the script execution in paused until the requested \n\
``maxNrElements`` of shapes of the given type ``elementType`` are drawn by the \n\
user on the canvas of the plot. The coordinates of the shapes is then returned \n\
by this method. If the script execution is aborted during the interactive operation \n\
or if the user presses the ``Esc`` key in the plot, this operation is stopped by \n\
a ``RuntimeError``. \n\
\n\
Parameters\n\
-----------\n\
elementType : int \n\
    The element type that the user should interactively draw on the canvas of the plot. \n\
    Allowed types are: \n\
    \n\
    * ``plotItem.PrimitivePoint`` \n\
    * ``plotItem.PrimitiveLine`` \n\
    * ``plotItem.PrimitiveRectangle`` \n\
    * ``plotItem.PrimitiveSquare`` \n\
    * ``plotItem.PrimitiveEllipse`` \n\
    * ``plotItem.PrimitiveCircle`` \n\
    * ``plotItem.PrimitivePolygon`` \n\
    \n\
maxNrElements : int, optional \n\
    Number of elements of the given type, the user has to draw. \n\
    The operation can be aborted by clicking the ``Esc`` key. If this is the \n\
    case, a ``RuntimeError`` is raised. \n\
\n\
Raises \n\
------ \n\
RuntimeError \n\
    if the user interrupts the selection (by pressing the Esc key). \n\
\n\
Returns \n\
-------- \n\
tuple of shape \n\
    A tuple with all drawn elements, represented as :class:`shape` objects is returned.&quot;)</td></tr>
<tr class="separator:a78fee6bdea08a74480c8c99d967eb28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe6cab8c18f8e06ec5b141d57ab1389"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8fe6cab8c18f8e06ec5b141d57ab1389">parseParams</a> (PyObject *args, int length, char **&amp;cargs, char *&amp;cargt)</td></tr>
<tr class="separator:a8fe6cab8c18f8e06ec5b141d57ab1389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa872946454ba282dd90912cb19cce19b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa872946454ba282dd90912cb19cce19b">freeParams</a> (int length, char *&amp;cargt, char **&amp;cargs)</td></tr>
<tr class="separator:aa872946454ba282dd90912cb19cce19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9116ec57a2f79c788a4991e28b4617e8"><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a9116ec57a2f79c788a4991e28b4617e8">getParamList</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib)</td></tr>
<tr class="separator:a9116ec57a2f79c788a4991e28b4617e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abfad65cf3b738c5d98938d20b9e7fe"><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a1abfad65cf3b738c5d98938d20b9e7fe">getParamListInfo</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib, PyObject *args)</td></tr>
<tr class="separator:a1abfad65cf3b738c5d98938d20b9e7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96008563f0d7b3cd050a05cfc0c0e06"><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab96008563f0d7b3cd050a05cfc0c0e06">getParamInfo</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib, PyObject *args)</td></tr>
<tr class="separator:ab96008563f0d7b3cd050a05cfc0c0e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afcf614200505b3662be3fff4db315d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2afcf614200505b3662be3fff4db315d"></a>
PyObject *&#160;</td><td class="memItemRight" valign="bottom"><b>plugin_showConfiguration</b> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib)</td></tr>
<tr class="separator:a2afcf614200505b3662be3fff4db315d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac145e823451a24a203e1a201da54bbdc"><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ac145e823451a24a203e1a201da54bbdc">plugin_showToolbox</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib)</td></tr>
<tr class="separator:ac145e823451a24a203e1a201da54bbdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870a619f4f3ef4e483e8bf469d89ce97"><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a870a619f4f3ef4e483e8bf469d89ce97">plugin_hideToolbox</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib)</td></tr>
<tr class="separator:a870a619f4f3ef4e483e8bf469d89ce97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e243228cf22a98c58d7f4197530126"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0e243228cf22a98c58d7f4197530126"></a>
PyObject *&#160;</td><td class="memItemRight" valign="bottom"><b>plugin_userMutexLock</b> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib, PyObject *args, PyObject *kwds, bool &amp;userMutexLocked)</td></tr>
<tr class="separator:aa0e243228cf22a98c58d7f4197530126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acded9d0d79c50cedf5780c7be1c559ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acded9d0d79c50cedf5780c7be1c559ff"></a>
PyObject *&#160;</td><td class="memItemRight" valign="bottom"><b>plugin_userMutexUnlock</b> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib, bool &amp;userMutexLocked)</td></tr>
<tr class="separator:acded9d0d79c50cedf5780c7be1c559ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affacbb694efedc5072c323235f1cf83b"><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#affacbb694efedc5072c323235f1cf83b">getExecFuncsList</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib)</td></tr>
<tr class="separator:affacbb694efedc5072c323235f1cf83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89b2aaf2edbb230bb22d996d713f02d"><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab89b2aaf2edbb230bb22d996d713f02d">getExecFuncsInfo</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib, PyObject *args, PyObject *kwds)</td></tr>
<tr class="separator:ab89b2aaf2edbb230bb22d996d713f02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9082c16ab511f4da066735faff3262"><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a9f9082c16ab511f4da066735faff3262">getName</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *addInObj)</td></tr>
<tr class="separator:a9f9082c16ab511f4da066735faff3262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0039bf5249d18fd0d228cad6137002e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0039bf5249d18fd0d228cad6137002e"></a>
PyObject *&#160;</td><td class="memItemRight" valign="bottom"><b>execFunc</b> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *aib, PyObject *args, PyObject *kwds)</td></tr>
<tr class="separator:ac0039bf5249d18fd0d228cad6137002e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef056717cc8a683562a568e7caa02cc"><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a2ef056717cc8a683562a568e7caa02cc">getParam</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *addInObj, PyObject *args)</td></tr>
<tr class="separator:a2ef056717cc8a683562a568e7caa02cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e99bc3e1ba2d1c644ee38b4851f3b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78e99bc3e1ba2d1c644ee38b4851f3b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginName_doc,&quot;name() -&gt; str \n\
\n\
Returns the name of this plugin object.\n\
\n\
Returns \n\
-------- \n\
name : str \n\
    name of the plugin, which corresponds to ``<a class="el" href="namespaceito.html#a2ef056717cc8a683562a568e7caa02cc">getParam</a>(\&quot;name\&quot;)`` \n\
\n\
See Also \n\
--------- \n\
<a class="el" href="namespaceito.html#a2ef056717cc8a683562a568e7caa02cc">getParam</a>&quot;)</td></tr>
<tr class="separator:a78e99bc3e1ba2d1c644ee38b4851f3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aedcf9c5525909fea364c02a2091504"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4aedcf9c5525909fea364c02a2091504"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginGetExecFuncsList_doc,&quot;getExecFuncsList() -&gt; List[str] \n\
\n\
Gets a list of the names of additional callable functions of this plugin.\n\
\n\
Each plugin may define a set of functions, extending the standard interface. \n\
These functions are not common to plugins of the same type. They are \n\
executed using:: \n\
    \n\
    instance.exec(\&quot;funcname\&quot;, arg1, arg2, ...)\n\
\n\
To get more information about one specific function, call \n\
:meth:`<a class="el" href="namespaceito.html#ab89b2aaf2edbb230bb22d996d713f02d">getExecFuncsInfo</a>`. \n\
\n\
Returns \n\
------- \n\
list of str \n\
    is a list of additional, callable function names of this plugin object.&quot;)</td></tr>
<tr class="separator:a4aedcf9c5525909fea364c02a2091504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116501f753a4ea8b939a934a63f296d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a116501f753a4ea8b939a934a63f296d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginGetParamList_doc,&quot;getParamList() -&gt; List[str] \n\
\n\
Returns a list of the names of all available parameters of this plugin object.\n\
\n\
Each plugin defines a set of parameters. Each of these parameters maps its ``name`` \n\
to a certain ``value``. The value is represented by the C++ class \n\
:class:`<a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a>` and can have one of the following types \n\
(Python equivalent in brackets): \n\
\n\
* String (str) \n\
* Char (int, [-127, 128]) \n\
* Integer, (int) \n\
* Double (float) \n\
* CharArray (sequence of int) \n\
* IntegerArray (sequence of int) \n\
* DoubleArray (sequence of float) \n\
* <a class="el" href="classito_1_1_data_object.html">DataObject</a> (:class:`dataObject`) \n\
* <a class="el" href="namespaceito.html#abd3b401f17cb5d7d7cc67d4063714b0fa2da3a841845c2c99c1abb5d67c53f54e">PolygonMesh</a> (:class:`polygonMesh`) \n\
* <a class="el" href="namespaceito.html#abd3b401f17cb5d7d7cc67d4063714b0fab6ff58696dec6c2e0839a001388fa947">PointCloud</a> (:class:`pointCloud`) \n\
* Another plugin instance (:class:`dataIO` or :class:`actuator`) \n\
\n\
Using one of the parameter names, its current value can be obtained by \n\
``<a class="el" href="namespaceito.html#a2ef056717cc8a683562a568e7caa02cc">getParam</a>(\&quot;name\&quot;)`` and can be set by ``<a class="el" href="namespaceito.html#a8d52a7127228d59e411619e569fbee41">setParam</a>(\&quot;name\&quot;, newValue)`` \n\
(if not read-only). \n\
\n\
Usually, every plugin object can define its own set of parameters. However, there are \n\
conventions about certain parameters, that must be available and have a specific \n\
meaning for a type of plugin object. \n\
\n\
Returns \n\
------- \n\
list of str \n\
    list of available parameter names in this plugin. \n\
\n\
See Also \n\
--------- \n\
<a class="el" href="namespaceito.html#a2ef056717cc8a683562a568e7caa02cc">getParam</a>, <a class="el" href="namespaceito.html#a8d52a7127228d59e411619e569fbee41">setParam</a>, <a class="el" href="namespaceito.html#a1abfad65cf3b738c5d98938d20b9e7fe">getParamListInfo</a>&quot;)</td></tr>
<tr class="separator:a116501f753a4ea8b939a934a63f296d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63bca5301a43fdf1d1e3e2a0b3b4619a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63bca5301a43fdf1d1e3e2a0b3b4619a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginGetParamListInfo_doc,&quot;getParamListInfo(detailLevel = 1) -&gt; Optional[dict] \n\
\n\
Prints or returns detailed information about all parameters of this plugin object. \n\
\n\
Each plugin defines a set of parameters. Each of these parameters maps its ``name`` \n\
to a certain ``value``. The value is represented by the C++ class \n\
:class:`<a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a>` and can have one of the following types \n\
(Python equivalent in brackets): \n\
\n\
* String (str) \n\
* Char (int, [-127, 128]) \n\
* Integer, (int) \n\
* Double (float) \n\
* CharArray (sequence of int) \n\
* IntegerArray (sequence of int) \n\
* DoubleArray (sequence of float) \n\
* <a class="el" href="classito_1_1_data_object.html">DataObject</a> (:class:`dataObject`) \n\
* <a class="el" href="namespaceito.html#abd3b401f17cb5d7d7cc67d4063714b0fa2da3a841845c2c99c1abb5d67c53f54e">PolygonMesh</a> (:class:`polygonMesh`) \n\
* <a class="el" href="namespaceito.html#abd3b401f17cb5d7d7cc67d4063714b0fab6ff58696dec6c2e0839a001388fa947">PointCloud</a> (:class:`pointCloud`) \n\
* Another plugin instance (:class:`dataIO` or :class:`actuator`) \n\
\n\
Using one of the parameter names, its current value can be obtained by \n\
``<a class="el" href="namespaceito.html#a2ef056717cc8a683562a568e7caa02cc">getParam</a>(\&quot;name\&quot;)`` and can be set by ``<a class="el" href="namespaceito.html#a8d52a7127228d59e411619e569fbee41">setParam</a>(\&quot;name\&quot;, newValue)`` \n\
(if not read-only). \n\
\n\
This method prints a detailed listing with the `name`, `current value`, \n\
`description string` and further `meta information` of every plugin parameter. \n\
Additionally, the column ``R/W`` indicates if this parameter is writable or read-only. \n\
\n\
Dependin`g on ``detailLevel``, this method will not print the listing to the command line \n\
but returns it using a nested :class:`dict`. \n\
\n\
Parameters \n\
----------- \n\
detailLevel : dict, optional \n\
    if ``detailLevel`` is set to ``1``, this method returns a nested dictionary with all \n\
    information about all parameters of this plugin. Otherwise ``None`` is returned and \n\
    the listing is printed in a readable form to the command line (default). \n\
\n\
Returns \n\
------- \n\
None or dict \n\
    See the parameter ``detailLevel`` for the difference in returned values. \n\
\n\
See Also \n\
---------- \n\
<a class="el" href="namespaceito.html#a2ef056717cc8a683562a568e7caa02cc">getParam</a>, <a class="el" href="namespaceito.html#a8d52a7127228d59e411619e569fbee41">setParam</a>, <a class="el" href="namespaceito.html#ab96008563f0d7b3cd050a05cfc0c0e06">getParamInfo</a>, <a class="el" href="namespaceito.html#a9116ec57a2f79c788a4991e28b4617e8">getParamList</a>, <a class="el" href="namespaceito.html#ab96008563f0d7b3cd050a05cfc0c0e06">getParamInfo</a>&quot;)</td></tr>
<tr class="separator:a63bca5301a43fdf1d1e3e2a0b3b4619a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048ab86ef22891f7a690a092de59674b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a048ab86ef22891f7a690a092de59674b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginGetParamInfo_doc,&quot;getParamInfo(name) -&gt; dict \n\
\n\
Returns a nested dictionary with meta information of the desired parameter. \n\
\n\
Plugin parameters in itom not only hold a value, but they can also be equipped \n\
with further meta information, like the minimum or maximum value range, a certain \n\
step size, allowed string values etc. \n\
\n\
These values are returned as nested dictionary (if available, else the dict is \n\
more or less empty). \n\
\n\
Parameters \n\
----------- \n\
name : str \n\
    Name of the plugin parameter. \n\
\n\
Returns \n\
------- \n\
dict \n\
    nested dictionary with meta information assigned to the plugin parameter ``name``.&quot;)</td></tr>
<tr class="separator:a048ab86ef22891f7a690a092de59674b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1ae7f174c8e7ada48fbb9fc30e41fb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d1ae7f174c8e7ada48fbb9fc30e41fb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginGetParam_doc,&quot;getParam(name) -&gt; Union[int, float, str, Tuple[int], Tuple[float], dataObject, polygonMesh, pointCloud, dataIO, actuator] \n\
\n\
Returns the current value of the plugin parameter ``name``. \n\
\n\
The type of the returned value depends on the <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> type of the internal plugin, \n\
which can be: \n\
\n\
* String -&gt; :obj:`str` \n\
* Char, Integer -&gt; :obj:`int` \n\
* Double -&gt; :obj:`float` \n\
* CharArray, IntegerArray -&gt; :obj:`tuple` of :obj:`int` \n\
* DoubleArray -&gt; :obj:`tuple` of :obj:`float` \n\
* <a class="el" href="classito_1_1_data_object.html">DataObject</a> -&gt; :class:`dataObject` \n\
* <a class="el" href="namespaceito.html#abd3b401f17cb5d7d7cc67d4063714b0fa2da3a841845c2c99c1abb5d67c53f54e">PolygonMesh</a> -&gt; :class:`polygonMesh` \n\
* <a class="el" href="namespaceito.html#abd3b401f17cb5d7d7cc67d4063714b0fab6ff58696dec6c2e0839a001388fa947">PointCloud</a> -&gt; :class:`pointCloud` \n\
* Another plugin instance -&gt; :class:`dataIO` or :class:`actuator` \n\
\n\
The ``name`` of the parameter must have the following form: \n\
\n\
* **name** \n\
* **name:additionalTag** (``additionalTag`` can be a special feature of some plugins) \n\
* **name[index]** (only possible if parameter is an array type and you only want to get \n\
  one single value, specified by the integer index ``[0, len(array) - 1]``) \n\
* **name[index]:additionalTag** (a combination of the two possibilies above) \n\
\n\
Parameters \n\
----------- \n\
name : str\n\
    Name of the requested parameter.\n\
\n\
Returns \n\
------- \n\
int or float or str or tuple of int or tuple of float or dataObject or polygonMesh or pointCloud or dataIO or actuator\n\
    Current value of the parameter ``name``. \n\
\n\
Raises \n\
------- \n\
ValueError \n\
    if parameter does not exist \n\
\n\
See Also \n\
--------- \n\
<a class="el" href="namespaceito.html#a8d52a7127228d59e411619e569fbee41">setParam</a>, <a class="el" href="namespaceito.html#a9116ec57a2f79c788a4991e28b4617e8">getParamList</a>, <a class="el" href="namespaceito.html#a1abfad65cf3b738c5d98938d20b9e7fe">getParamListInfo</a>&quot;)</td></tr>
<tr class="separator:a0d1ae7f174c8e7ada48fbb9fc30e41fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a53209eadf585b5bdf80d640bc7869"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af7a53209eadf585b5bdf80d640bc7869"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginSetParam_doc,&quot;setParam(name, value) \n\
\n\
Sets a writeable parameter ``name`` of this plugin object to ``value``. \n\
\n\
Sets the internal plugin parameter with 'name' to a new value. The plugin itsself \n\
can decide whether the given value is accepted as new value. This may depend on the \n\
type of the given value, but also on the allowed value range indicated by further \n\
meta information of the internal parameter. Parameters that are (currently) set to \n\
read-only cannot be set. \n\
\n\
The ``name`` of the parameter must have the following form: \n\
\n\
* **name** \n\
* **name:additionalTag** (additionalTag can be a special feature of some plugins) \n\
* **name[index]** (only possible if parameter is an array type and you only want to get \n\
  one single value, specified by the integer index [0,nrOfArrayItems-1]) \n\
* **name[index]:additionalTag** (a combination of the two possibilies above) \n\
\n\
Parameters \n\
----------- \n\
name : str\n\
    Name of the parameter. \n\
value : int or float or str or tuple of int or tuple of float or dataObject or polygonMesh or pointCloud or dataIO or actuator\n\
    The ``value`` that will be set. The plugin will check if this ``value`` fits \n\
    to possible constraints, given by the parameters's meta information or further \n\
    limitations. \n\
\n\
Raises \n\
------ \n\
RuntimeError \n\
    if the new ``value`` is (currently) not accepted. \n\
\n\
See Also \n\
--------- \n\
<a class="el" href="namespaceito.html#a2ef056717cc8a683562a568e7caa02cc">getParam</a>, <a class="el" href="namespaceito.html#a9116ec57a2f79c788a4991e28b4617e8">getParamList</a>, <a class="el" href="namespaceito.html#a1abfad65cf3b738c5d98938d20b9e7fe">getParamListInfo</a>&quot;)</td></tr>
<tr class="separator:af7a53209eadf585b5bdf80d640bc7869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e43c48c992ee8d5fcd77779ee595f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03e43c48c992ee8d5fcd77779ee595f3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginShowToolbox_doc,&quot;showToolbox() \n\
\n\
Opens the (optional) toolbox of this plugin object in the itom main window. \n\
\n\
Raises \n\
------ \n\
RuntimeError \n\
    if this plugin does not provide a toolbox. \n\
\n\
See Also \n\
--------- \n\
hideToolbox&quot;)</td></tr>
<tr class="separator:a03e43c48c992ee8d5fcd77779ee595f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2664ae7e2e78aa6452efead1cb0d76a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2664ae7e2e78aa6452efead1cb0d76a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginHideToolbox_doc,&quot;hideToolbox() \n\
\n\
Hides the visible toolbox of this plugin object. \n\
\n\
Raises \n\
------ \n\
RuntimeError \n\
    if this plugin does not provide a toolbox. \n\
\n\
See Also \n\
--------- \n\
showToolbox&quot;)</td></tr>
<tr class="separator:ac2664ae7e2e78aa6452efead1cb0d76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c4fe669c4901d1190131080fcd8978"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32c4fe669c4901d1190131080fcd8978"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPluginShowConfiguration_doc,&quot;showConfiguration() \n\
\n\
Shows the (optional) configuration dialog of this plugin as modal dialog. \n\
\n\
Raises \n\
------- \n\
RuntimeError \n\
    if this plugin does not provide a configuration dialog.&quot;)</td></tr>
<tr class="separator:a32c4fe669c4901d1190131080fcd8978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb1609a2c1b7506190fcadaaf602271"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2eb1609a2c1b7506190fcadaaf602271"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyPlugInGetExecFuncsInfo_doc,&quot;getExecFuncsInfo(funcName = \&quot;\&quot;, detailLevel = 0) -&gt; Optional[dict] \n\
\n\
Lists all available additional functions of this plugin or gives a detailed description of one specific ``funcName``. \n\
\n\
Every plugin can define further functions, that are called by the method :meth:`exec`. \n\
This can for instance be used in order to call specific calibration routines of \n\
cameras or actuators. \n\
\n\
This method either prints requested information in a readable form to the command line \n\
or returns this information as nested dictionary. \n\
\n\
Parameters \n\
----------- \n\
funcName : str, optional \n\
    is the fullname or a part of any name of such an additional plugin function. \n\
    If ``funcName`` is an empty string or does not match any plugin function \n\
    (case sensitive), a list of all suitable additional plugin function names is given. \n\
    Else, detailed information about the desired ``funcName`` is given, like its description \n\
    or (optional) arguments that are needed to execute this function. \n\
detailLevel : dict, optional \n\
    if ``detailLevel == 1``, this returns a nested dictionary with detailed information, else \n\
    it is printed to the command line in a readable form (default). \n\
\n\
Returns \n\
------- \n\
None or dict\n\
    The return value depends on the argument ``detailLevel``. \n\
\n\
See Also \n\
-------- \n\
exec&quot;)</td></tr>
<tr class="separator:a2eb1609a2c1b7506190fcadaaf602271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada376978f064e06f934e4d8a263a7f44"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada376978f064e06f934e4d8a263a7f44"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyPlugin_execFunc_doc,&quot;exec(funcName, *args, **kwds) -&gt; Union[Any, Tuple[Any]] \n\
\n\
Calls the additional function ``funcName`` of this plugin. \n\
\n\
Every plugin can define special, additional functions (denoted as ``exec functions``) \n\
that can for instance be used in order to call specific calibration routines \n\
of cameras or actuators. This generic method is used to call one of these specific \n\
functions, that has to be registered in the plugin under the name ``funcName``. \n\
\n\
Every function can define a set of mandatory and / or optional parameters. See \n\
:meth:`<a class="el" href="namespaceito.html#ab89b2aaf2edbb230bb22d996d713f02d">getExecFuncsInfo</a>` or the plugin help viewer of itom for more information. \n\
Pass the mandatory and optional parameters as arguments ``param1``, ``param2`` ... to \n\
this method. \n\
\n\
Additionally, every function can return one or multiple values. Either the single value \n\
or a tuple of all returned values is returned by this method. \n\
\n\
Parameters \n\
----------- \n\
funcName : str \n\
    The name of the additional function.\n\
*args : Any \n\
    Further positional arguments, that are assigned first to all mandatory parameters, \n\
    followed by the optional ones. The mandatory or optional parameters of the called \n\
    function can also given as keyword arguments (see ``**kwds``). \n\
**kwds : Any, optional \n\
    Keyword-based arguments, see ``*args`` above. \n\
\n\
Returns \n\
------- \n\
any or tuple of any \n\
    The returned values depend on the function itself.\n\
\n\
See Also \n\
-------- \n\
<a class="el" href="namespaceito.html#ab89b2aaf2edbb230bb22d996d713f02d">getExecFuncsInfo</a>&quot;)</td></tr>
<tr class="separator:ada376978f064e06f934e4d8a263a7f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f188c3ee3bc431ec1c57985cb51c20"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9f188c3ee3bc431ec1c57985cb51c20"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyPlugin_userMutex_tryLock_doc,&quot;tryLock(timeout = 3000) -&gt; bool \n\
\n\
Tries to lock the user mutex of this plugin. \n\
\n\
Every plugin contains a user mutex, that can be used for arbitrary purposes. \n\
It is not used for any official purposes. You can for instance use this mutex \n\
both from Python and other C++ threads to protect a series of calls to this \n\
plugin to not to be interrupted by other participants. However, it is the \n\
full responsibility of the programmer to carefully use this mutex. \n\
\n\
Please be careful, that this method can lead to a deadlock if ``timeout`` is \n\
set to a negative value (inifinite wait) and if the mutex is not released \n\
by any other thread. Hint: A Python thread is no `<a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a>` thread, it must be \n\
a <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> C++ thread. If you want to use the mutex within two or more Python \n\
threads, it is recommended, to call this method with a defined ``timeout`` \n\
within a loop and wait for this method to return ``True``. This allows \n\
unlocking the mutex by another thread. \n\
\n\
This method is new for plugins that implement the AddInInterface &gt;= 4.2. \n\
\n\
Parameters \n\
---------- \n\
timeout : int \n\
    This method will wait for at most ``timeout`` milliseconds for the \n\
    mutex to become available. If this value is negative, it will wait forever \n\
    until the mutex become available.\n\
\n\
Returns \n\
------- \n\
bool \n\
    ``True`` if the user defined mutex could be locked, else ``False``. \n\
\n\
See Also \n\
-------- \n\
unlock&quot;)</td></tr>
<tr class="separator:ae9f188c3ee3bc431ec1c57985cb51c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac927f4bf6275838e6fd4375443d8827f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac927f4bf6275838e6fd4375443d8827f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyPlugin_userMutex_unlock_doc,&quot;unlock() \n\
\n\
Tries to unlock the user mutex of this plugin. \n\
\n\
Every plugin contains a user mutex, that can be used for arbitrary purposes. \n\
It is not used for any official purposes. You can for instance use this mutex \n\
both from Python and other C++ threads to protect a series of calls to this \n\
plugin to not to be interrupted by other participants. However, it is the \n\
full responsibility of the programmer to carefully use this mutex. \n\
fu\n\
This method is new for plugins that implement the AddInInterface &gt;= 4.2. \n\
\n\
See Also \n\
-------- \n\
lock&quot;)</td></tr>
<tr class="separator:ac927f4bf6275838e6fd4375443d8827f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d52a7127228d59e411619e569fbee41"><td class="memItemLeft" align="right" valign="top">PyObject *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8d52a7127228d59e411619e569fbee41">setParam</a> (<a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *addInObj, PyObject *args)</td></tr>
<tr class="separator:a8d52a7127228d59e411619e569fbee41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68bae4cbba8b83811ae3149f20cd2e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa68bae4cbba8b83811ae3149f20cd2e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorInit_doc,&quot;actuator(name, *args, **kwds) -&gt; actuator \n\
\n\
Creates a new instance of the actuator plugin ``name``. \n\
\n\
This is the constructor for an :class:`actuator` plugin. It initialises an new \n\
instance of the plugin with the given ``name``. The initialisation parameters are \n\
parsed and unnamed parameters are used in their incoming order to fill first \n\
mandatory parameters and afterwards optional parameters. Parameters may be passed \n\
with their name as keyword, too. However, as usual, no positional parameters are \n\
allowed after a keyword-based one.\n\
\n\
See :meth:`pluginHelp` for detailed information about the specific initialisation \n\
parameters.\n\
\n\
Parameters \n\
----------- \n\
name : str \n\
    is the fullname (case sensitive) of an :class:`actuator`-plugin. \n\
*args : Any \n\
    Every ``actuator`` plugin defines a list of mandatory and optional initialization \n\
    parameters. Pass these arguments either as positional (``*args``) or keyword \n\
    based (``**kwds``) arguments, where the mandatory parameters must be given first, \n\
    followed by the optional ones. Not every optional initialization argument must be \n\
    given, else its default value is used. \n\
**kwds : Any \n\
    Further keyword based parameters. See also ``*args``. \n\
\n\
Returns \n\
-------- \n\
actuator \n\
    new instance of the desired actuator plugin.&quot;)</td></tr>
<tr class="separator:aa68bae4cbba8b83811ae3149f20cd2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a893d19e842ebc2dcfad5bbb464841"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07a893d19e842ebc2dcfad5bbb464841"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorCalib_doc,&quot;calib(axisIndex1, *args) \n\
\n\
Starts a calibration or homing routine of one or multiple axes. \n\
\n\
Most actuators have the possibility to calibrate or home certain axes. \n\
Use this command to start the calibration. \n\
\n\
Parameters \n\
----------- \n\
axisIndex1 : int\n\
    Index of the first axis to be calibrated or homed (e.g. 0 for first axis). \n\
*args : int \n\
    Pass further axis indices as 2nd, 3rd, etc. parameter to this function \n\
    if more than one axis should be calibrated or homed. \n\
\n\
Raises \n\
---------- \n\
NotImplemented \n\
    if calibration routine not available in this plugin.&quot;)</td></tr>
<tr class="separator:a07a893d19e842ebc2dcfad5bbb464841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2790c50162ea3b625ea1341644c0a9ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2790c50162ea3b625ea1341644c0a9ad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorSetOrigin_doc,&quot;setOrigin(axisIndex1, *args) \n\
\n\
Defines the current position of the given axes to have the value ``0``. \n\
\n\
The current positions of all indicated axes (``axisIndex1``, ``*args``) are considered \n\
to be ``0`` such that future positioning commands are relative with respect to this \n\
current position. \n\
\n\
Parameters \n\
----------- \n\
axisIndex1 : int\n\
    index of the first axis (e.g. 0 for first axis) \n\
*args : int \n\
    Pass further axis indices as 2nd, 3rd, etc. parameter to this function \n\
    if more than one axis should be origined. \n\
\n\
Raises \n\
---------- \n\
NotImplemented \n\
    if actuator does not support this feature&quot;)</td></tr>
<tr class="separator:a2790c50162ea3b625ea1341644c0a9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385d9dfc7e5e658d82ffbead2001a1a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a385d9dfc7e5e658d82ffbead2001a1a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorGetStatus_doc,&quot;getStatus(axis = -1) -&gt; Union[int, List[int]] \n\
\n\
Returns the status for one single axis or all axes of the actuator object. \n\
\n\
Each axis of an actuator plugin has got a status value that is used for informing \n\
about the current status of the axis. \n\
\n\
The status value is a bitmask (flag), that might contain a combination of the \n\
following values: \n\
\n\
Moving flags: \n\
\n\
* <a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383a599af524525e8c64bddf91298784e767">actuatorUnknown</a>     = 0x0001 : unknown current moving status \n\
* actuatorInterrupted = 0x0002 : movement has been interrupted by the user or another \n\
  error during the movement occurred \n\
* actuatorMoving      = 0x0004 : axis is currently moving \n\
* actuatorAtTarget    = 0x0008 : axis reached the target position \n\
* actuatorTimeout     = 0x0010 : timout during movement. Unknown status of the movement \n\
\n\
Switches flags: \n\
\n\
* actuatorEndSwitch   = 0x0100 : axis reached any end switch (e.g. if only one end switch \n\
  is available) \n\
* actuatorEndSwitch1  = 0x0200 : axis reached the specified left end switch (if set, also \n\
  set actuatorEndSwitch)\n\
* actuatorEndSwitch2  = 0x0400 : axis reached the specified left end switch (if set, also \n\
  set actuatorEndSwitch)\n\
* actuatorRefSwitch   = 0x0800 : axis reached any reference switch (e.g. for calibration...) \n\
* actuatorRefSwitch1  = 0x1000 : axis reached the specified right reference switch \n\
  (if set, also set actuatorRefSwitch)\n\
* actuatorRefSwitch2  = 0x2000 : axis reached the specified right reference switch \n\
  (if set, also set actuatorRefSwitch)\n\
\n\
Status flags: \n\
\n\
* actuatorAvailable   = 0x4000 : the axis is available \n\
* actuatorEnabled     = 0x8000 : the axis is currently enabled and can be moved \n\
* actuatorError       = 0x10000 : axis has encountered error/reports error\n\
\n\
Parameters \n\
----------- \n\
axis : int, optional\n\
    If an index &gt;= 0 is passed, the status of this specific axis is returned. \n\
    Else, a list of status values for all axes is returned (default). \n\
\n\
Returns \n\
------- \n\
int or list of int \n\
    Single status value or a list of status values as combination of the \n\
    possible flag values, given above.&quot;)</td></tr>
<tr class="separator:a385d9dfc7e5e658d82ffbead2001a1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5fee3ac53b137bf95198c750f680de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a5fee3ac53b137bf95198c750f680de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorGetPos_doc,&quot;getPos(axisIndex1, *args) -&gt; Union[float, Tuple[float]] \n\
\n\
Returns the current position(s) of the given axis or axes (in mm or degree).\n\
\n\
This method requests the current position(s) of the given axes and returns it or them. \n\
\n\
Parameters \n\
----------- \n\
axisIndex1 : int\n\
    index of the first axis (e.g. 0 for first axis) \n\
*args : int\n\
    Pass further indices of more axes as additional parameters. \n\
\n\
Returns \n\
------- \n\
positions : float or tuple of float \n\
    Current position as float value if only one axis is given or a tuple of floats \n\
    if multiple axis indices are given. The unit is **mm** or **degree**. \n\
\n\
See Also \n\
--------- \n\
setPosRel, setPosAbs&quot;)</td></tr>
<tr class="separator:a2a5fee3ac53b137bf95198c750f680de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e12c9e537cffe7558c26de571145f86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e12c9e537cffe7558c26de571145f86"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyActuatorPlugin_getType_doc,&quot;getType() -&gt; int \n\
\n\
Returns the type value of this actuator plugin (always: 0x2). \n\
\n\
Returns \n\
------- \n\
int \n\
    actuator type value (``0x2``).&quot;)</td></tr>
<tr class="separator:a8e12c9e537cffe7558c26de571145f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff60f70d145f05cfcf482d64edf89770"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff60f70d145f05cfcf482d64edf89770"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorSetInterrupt_doc,&quot;setInterrupt() \n\
\n\
Request the interruption of the movement of this actuator. \n\
\n\
Sets the interrupt flag of the :class:`actuator`. The actuator interrupts \n\
the movement of all running axes as soon as this flag is checked and handled again.&quot;)</td></tr>
<tr class="separator:aff60f70d145f05cfcf482d64edf89770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731549967bc0e8b9957eaff019e78ee6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a731549967bc0e8b9957eaff019e78ee6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorConnect_doc,&quot;connect(signalSignature, callableMethod, minRepeatInterval = 0) \n\
\n\
Connects a signal of this actuator with the given callable Python method. \n\
\n\
Every :class:`actuator` object can emit different signals whenever a certain event \n\
occurs. Use the method :meth:`info` to get a print-out of a list of possible signals \n\
of the actuator. This method is used to connect a certain callable Python callback \n\
method or function to a specific signal. The callable function can be bounded as well \n\
as unbounded. \n\
\n\
The connection is described by the string signature of the signal (hence the source of \n\
the connection). Such a signature is the name of the signal, followed by the types of \n\
its arguments (the original C++ types). An example is ``targetChanged(QVector&lt;double&gt;)``, \n\
emitted whenever the target position of one or multiple axes changed. This signal can \n\
be connected to a callback function, that accepts one argument (in case of a bounded method, \n\
the ``self`` argument must be an additional first parameter. \n\
\n\
The C++ datatype ``QVector&lt;double&gt;`` will be transformed to ``tuple of float``, for \n\
more type conversions see the table in section :ref:`qtdesigner-datatypes`. In general, \n\
a ``callableMethod`` must be a method or function with the same number of parameters than \n\
the signal has (besides the ``self`` argument). The types are converted based on the itom \n\
C++ &lt;-&gt; Python conversion table (:ref:`qtdesigner-datatypes`). \n\
\n\
If a signal is emitted very often, it can be necessary to limit the call of the callback \n\
function to a certain minimum time interval. This can be given by the ``minRepeatInterval`` \n\
parameter. \n\
\n\
Parameters \n\
----------- \n\
signalSignature : str \n\
    This must be the valid signature, known from the Qt-method *connect* \n\
    (e.g. ``targetChanged(QVector&lt;double&gt;)``) \n\
callableMethod : callable \n\
    valid method or function that is called if the signal is emitted. \n\
minRepeatInterval : int, optional \n\
    If &gt; 0, the same signal only invokes a slot once within the given interval (in ms). \n\
    Default: 0 (all signals will invoke the callable python method. \n\
\n\
See Also \n\
--------- \n\
disconnect, info&quot;)</td></tr>
<tr class="separator:a731549967bc0e8b9957eaff019e78ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96c14d7ea9a475330720c545d66c0e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae96c14d7ea9a475330720c545d66c0e9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorDisconnect_doc,&quot;disconnect(signalSignature, callableMethod) \n\
\n\
Disconnects a connection which must have been established before with exactly the same parameters.\n\
\n\
Parameters \n\
----------- \n\
signalSignature : str \n\
    This must be the valid signature, known from the Qt-method *connect* \n\
    (e.g. ``clicked(bool)``) \n\
callableMethod : callable \n\
    valid method or function, that should not be called any more if the \n\
    given signal is emitted. \n\
\n\
See Also \n\
--------- \n\
connect, info&quot;)</td></tr>
<tr class="separator:ae96c14d7ea9a475330720c545d66c0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45722eec6299ebcabfb2e62991ef15b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45722eec6299ebcabfb2e62991ef15b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorInfo_doc,&quot;info(verbose = 0) \n\
\n\
Prints out information about signal and callable slots of this actuator.\n\
\n\
Parameters \n\
----------- \n\
verbose : int \n\
    0: only slots and signals from the plugin class are printed (default) \n\
    1: all slots and signals from all inherited classes are printed\n\
\n\
See Also \n\
-------- \n\
connect, disconnect&quot;)</td></tr>
<tr class="separator:a45722eec6299ebcabfb2e62991ef15b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4b7505de2474537f0ff7a5e678cf94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#afb4b7505de2474537f0ff7a5e678cf94">parsePosParams</a> (PyObject *args, char **&amp;cargs, char *&amp;cargt, QVector&lt; int &gt; &amp;axisVec, QVector&lt; double &gt; &amp;posVec)</td></tr>
<tr class="separator:afb4b7505de2474537f0ff7a5e678cf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c0e5bfa5ea9ed964c16adc18627352"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0c0e5bfa5ea9ed964c16adc18627352"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorSetPosAbs_doc,&quot;setPosAbs(axisIndex1, pos1, *args) \n\
\n\
Moves the given axis or axes to the indicated absolute position(s) (in mm or degree).\n\
\n\
The parameters of this function are always alternating between the index of one axis \n\
and its new absolute target position as following parameter. As an example, moving \n\
the first three axes would look like::  \n\
    \n\
    myMotor.setPosAbs(0, 10.0, 1, -5.2, 2, 0.7)  # axes 0, 1 and 2 are absolutely moved \n\
\n\
This method starts the absolute positioning of all given axes. If the ``async`` parameter \n\
(see :meth:`<a class="el" href="namespaceito.html#a2ef056717cc8a683562a568e7caa02cc">getParam</a>` and :meth:`<a class="el" href="namespaceito.html#a8d52a7127228d59e411619e569fbee41">setParam</a>`) of the plugin is ``0`` (usually default), \n\
a synchronous positioning is started, hence, this method returns after that all \n\
axes reached their target positions or a timeout occurred. Else, (``async = 1``) this \n\
method immediately returns and the actuator continuous its movement. \n\
\n\
Parameters \n\
----------- \n\
axisIndex1 : int \n\
    index of the first axis, that should be moved. \n\
pos1 : float \n\
    absolute target position for this first axis ``axisIndex1`` (in mm or degree) \n\
*args \n\
    Pass more arguments of the form ``axisIndexX, posX`` to move more than one axis. \n\
\n\
See Also \n\
--------- \n\
getPos, setPosRel&quot;)</td></tr>
<tr class="separator:ae0c0e5bfa5ea9ed964c16adc18627352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0460487b804a01ada375daee11096e08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0460487b804a01ada375daee11096e08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorSetPosRel_doc,&quot;setPosRel(axisIndex1, offset1, *args) \n\
\n\
Moves the given axis or axes to the indicated relative position(s) (in mm or degree).\n\
\n\
The parameters of this function are always alternating between the index of one axis \n\
and its new absolute target position as following parameter. As an example, moving \n\
the first three axes would look like::  \n\
    \n\
    myMotor.setPosAbs(0, 10.0, 1, -5.2, 2, 0.7)  # axes 0, 1 and 2 are absolutely moved \n\
\n\
This method starts the relative positioning of all given axes. If the ``async`` parameter \n\
(see :meth:`<a class="el" href="namespaceito.html#a2ef056717cc8a683562a568e7caa02cc">getParam</a>` and :meth:`<a class="el" href="namespaceito.html#a8d52a7127228d59e411619e569fbee41">setParam</a>`) of the plugin is ``0`` (usually default), \n\
a synchronous positioning is started, hence, this method returns after that all \n\
axes reached their target positions or a timeout occurred. Else, (``async = 1``) this \n\
method immediately returns and the actuator continuous its movement. \n\
\n\
Parameters \n\
----------- \n\
axisIndex1 : int \n\
    index of the first axis, that should be moved. \n\
offset1 : float \n\
    The new target position for the first axis ``axisIndex1`` is given by the current \n\
    position of this axis plus this ``offset1`` value (in mm or degree) \n\
*args \n\
    Pass more arguments of the form ``axisIndexX, offsetX`` to move more than one axis. \n\
\n\
See Also \n\
--------- \n\
getPos, setPosAbs&quot;)</td></tr>
<tr class="separator:a0460487b804a01ada375daee11096e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24b97e326c0b46902574cd4633eb3d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af24b97e326c0b46902574cd4633eb3d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorGetCurrentStatus_doc,&quot;tuple of int : Gets the current status (flag mask, see :py:meth:`~itom.actuator.getStatus`) of all axes \n\
\n\
This property returns a tuple whose size corresponds to the number of axes of this \n\
actuator. The returned tuple contains the current positions of all axes (in mm or degree). \n\
This property is always updated if the plugin signals a change of any current position \n\
via the signal 'actuatorStatusChanged'. Instead of reading this property, you can also \n\
connect to this signal in order to get instantly informed about new current positions. \n\
\n\
The difference between this property and the method :py:meth:`~itom.actuator.getStatus` \n\
is that `getStatus` will only return if the actuator plugin is currently idle. This \n\
property always returns immediately, however it only contains the last reported values \n\
which can slightly differ from the <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> current positions (if the plugin rarely emits its \n\
current states for instance due to performance reasons).&quot;)</td></tr>
<tr class="separator:af24b97e326c0b46902574cd4633eb3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f610f97e14630f79c686a5fb899732"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80f610f97e14630f79c686a5fb899732"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorGetCurrentPositions_doc,&quot;tuple of float : Gets the current positions (in mm or degree) of all axes. \n\
\n\
This property returns a tuple whose size corresponds to the number of axes of this \n\
actuator. The returned tuple contains the current positions of all axes (in mm or degree). \n\
This property is always updated if the plugin signals a change of any current position \n\
via the signal ``actuatorStatusChanged``. Instead of reading this property, you can also \n\
connect to this signal in order to get instantly informed about new current positions. \n\
\n\
This property always returns immediately, however it \n\
only contains the last reported values which can slightly differ from the <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> current \n\
positions (if the plugin rarely emits its current states for instance due to performance \n\
reasons).&quot;)</td></tr>
<tr class="separator:a80f610f97e14630f79c686a5fb899732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0eec9955af3665059a23467608f4cae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0eec9955af3665059a23467608f4cae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyActuatorGetTargetPositions_doc,&quot;tuple of float : Gets the target positions (in mm or degree) of all axes. \n\
\n\
This property returns a tuple whose size corresponds to the number of axes of this \n\
actuator. The returned tuple contains the current target positions of all axes \n\
(in mm or degree). This property is always updated if the plugin signals a change of \n\
any target position via the signal ``targetChanged``. Instead of reading this property, \n\
you can also connect to this signal in order to get instantly informed about new \n\
target positions. \n\
\n\
This property always returns immediately, however it only contains the last reported \n\
values which can slightly differ from the <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> target positions (if the plugin rarely \n\
emits its current states for instance due to performance reasons).&quot;)</td></tr>
<tr class="separator:af0eec9955af3665059a23467608f4cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48899f8b301da197d58b85a8642c67b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48899f8b301da197d58b85a8642c67b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyDataIOInit_doc,&quot;dataIO(name, *args, **kwds) -&gt; dataIO \n\
\n\
Creates a new instance of the dataIO plugin ``name``. \n\
\n\
This is the constructor for an :class:`dataIO` plugin. It initialises an new \n\
instance of the plugin with the given ``name``. The initialisation parameters are \n\
parsed and unnamed parameters are used in their incoming order to fill first \n\
mandatory parameters and afterwards optional parameters. Parameters may be passed \n\
with their name as keyword, too. However, as usual, no positional parameters are \n\
allowed after a keyword-based one.\n\
\n\
See :meth:`pluginHelp` for detailed information about the specific initialisation \n\
parameters.\n\
\n\
Parameters \n\
----------- \n\
name : str \n\
    is the fullname (case sensitive) of an :class:`dataIO`-plugin. \n\
*args : Any \n\
    Every ``actuator`` plugin defines a list of mandatory and optional initialization \n\
    parameters. Pass these arguments either as positional (``*args``) or keyword \n\
    based (``**kwds``) arguments, where the mandatory parameters must be given first, \n\
    followed by the optional ones. Not every optional initialization argument must be \n\
    given, else its default value is used. \n\
**kwds : Any \n\
    Further keyword based parameters. See also ``*args``. \n\
\n\
Returns \n\
-------- \n\
actuator \n\
    new instance of the desired dataIO plugin.&quot;)</td></tr>
<tr class="separator:a48899f8b301da197d58b85a8642c67b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c1193ff49662bed6116b0da5b80746"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4c1193ff49662bed6116b0da5b80746"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_startDevice_doc,&quot;startDevice(count = 1) \n\
\n\
Starts the given dataIO plugin object. \n\
\n\
This command starts the dataIO plugin such that it is ready for data acquisition. \n\
Call this method before you start using commands like :meth:`acquire`, :meth:`getVal` \n\
or :meth:`copyVal`. If the device already is started, an internal start-counter is \n\
incremented by the parameter ``count``. The corresponding :meth:`stopDevice` method \n\
then decrements this counter and finally stops the device once the counter drops to \n\
zero again. \n\
\n\
The counter is necessary, since every connected live image needs to start the device \n\
without knownledge about any previous start. No acquisition is possible, if the device \n\
has not been started, hence the counter is 0. \n\
\n\
Parameters \n\
----------- \n\
count : int, optional \n\
    Number of increments to the internal start-counter (default: 1). \n\
\n\
See Also \n\
--------- \n\
stopDevice&quot;)</td></tr>
<tr class="separator:ad4c1193ff49662bed6116b0da5b80746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cc4a437b261d574148a52fb175c6c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8cc4a437b261d574148a52fb175c6c4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_stopDevice_doc,&quot;stopDevice(count = 1) -&gt; Optional[int] \n\
\n\
Stops the given dataIO plugin object. \n\
\n\
If this method is called as many times as he corresponding :meth:`startDevice` method  \n\
(or if the ``counts`` are equal), the :class:`dataIO` device is stopped (not deleted) \n\
and it is not possible to acquire further data. \n\
\n\
Once a live image is connected to a camera, :meth:`startDevice` is automatically called \n\
at start of the live acquisition and :meth:`stopDevice` at shutdown. \n\
\n\
Parameters \n\
----------- \n\
count : int, optional\n\
    if ``count`` &gt; 1, :meth:`stopDevice` is executed ``count`` times, in order to \n\
    decrement the grabber internal start counter. You can also set ``count = -1``, \n\
    then :meth:`stopDevice` is called in a loop until the internal start counter \n\
    drops to 0. The number of effective counts is then returned.\n\
\n\
Returns \n\
-------- \n\
counts : None or int \n\
    If ``count = -1`` the number of required calls to ``stopDevice`` to finally \n\
    stop the device is returned. For ``count &gt;= 0``, ``None`` is returned. \n\
\n\
See Also \n\
--------- \n\
startDevice&quot;)</td></tr>
<tr class="separator:aa8cc4a437b261d574148a52fb175c6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae203eb91c348b99ca15cfe8513f983cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae203eb91c348b99ca15cfe8513f983cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_acquire_doc,&quot;acquire(trigger = dataIO.TRIGGER_SOFTWARE) \n\
\n\
Triggers a new camera acquisition. \n\
\n\
This method triggers a new data acquisition. This method immediately returns even if \n\
the acquisition is not finished yet. Use :meth:`getVal` or :meth:`copyVal` to get the \n\
acquired data. Both methods will then block until the data is available or a timeout \n\
occurred. \n\
\n\
Before calling :meth:`acquire`, the device must have been started using \n\
:meth:`startDevice`. \n\
\n\
Parameters \n\
----------- \n\
trigger : int, optional\n\
    Type of the trigger: \n\
    \n\
    * ``dataIO.TRIGGER_SOFTWARE = 0`` : a software trigger is started, hence, the \n\
      acquisition is immediately started when calling this method.\n\
    * others : depending on your camera, this parameter can be used to set other \n\
      triggers, like hardware trigger with raising or falling edges... Please consider \n\
      the documentation of the specific device for possible values.&quot;)</td></tr>
<tr class="separator:ae203eb91c348b99ca15cfe8513f983cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3493c7102787e168e15347fccd3b1d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d3493c7102787e168e15347fccd3b1d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_stop_doc,&quot;stop() \n\
\n\
Stops a started, continuous acquisition. \n\
\n\
This method stops a previously started, continuous data acquisition. This method is not \n\
implemented in every plugin. A common example for its implementation is to stop an \n\
infinite, continuous acquisition job of an AD-converter plugin. \n\
\n\
See also\n\
---------\n\
acquire&quot;)</td></tr>
<tr class="separator:a6d3493c7102787e168e15347fccd3b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501b6d9f5d7b30ffb9ab212e83681893"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a501b6d9f5d7b30ffb9ab212e83681893"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_getVal_doc,&quot;getVal(dataObj) -&gt; None \\\n\
getVal(buffer, length = INT_MAX) -&gt; int \n\
\n\
Gets shallow copy of internal camera image if `dataObj` is provided. Else values from the plugins are copied to given buffer. \n\
\n\
Returns a reference (shallow copy) of the recently acquired image (located in the \n\
internal memory if the plugin) if the plugin is a grabber or camera and the buffer is a \n\
:class:`dataObject`. Please consider that the values of the :class:`dataObject` might \n\
change if a new image is acquired since it is only a reference. Therefore consider copying \n\
the :class:`dataObject` or directly use :meth:`copyVal`. \n\
\n\
If no acquisition has been triggered, this method raises a :obj`RuntimeError`. If the \n\
acquisition is not finished yet, this method blocks and waits until the end of the \n\
acquisition. \n\
\n\
If the plugin is another type than a grabber or camera (e.g. serialIO), this method \n\
requires any :obj:`buffer` object that is preallocated with a reasonable size (e.g. \n\
:obj:`bytearray`, :obj:`bytes` or unicode :obj:`str`. Then, the currently available \n\
data is copied into this buffer object and the size of the copied data is returned. If \n\
the buffer is too small, only the data that fits into the buffer is copied. Another \n\
call to :meth:`getVal` will copy the rest. \n\
\n\
Parameters \n\
----------- \n\
dataObj : dataObject \n\
    Usually for cameras and grabber: A reference (shallow copy) to the internal memory \n\
    of the camera plugin is set to the given data object. Therefore its content may \n\
    change if a new image is being acquired by the camera. Consider taking a deep copy \n\
    if the image (:meth:`dataObject.copy`) or use the method :meth:`copyVal`. \n\
buffer : bytearray or bytes or str \n\
    Usually for all other IO devices or AD-converters: The buffer must be an object \n\
    of type :obj:`bytearray`, :obj:`bytes` or unicode :obj:`str`. The ``length`` \n\
    parameter is then set to the size of the allocated buffer. This buffer is then \n\
    filled with data and the filled size is returned (max: ``length``). \n\
length : int, optional \n\
    Size of the given buffer. This value is usually automatically determined and \n\
    must not be given. \n\
\n\
Returns \n\
-------- \n\
None or int \n\
    ``None`` if ``dataObj`` is given, else the size of the values filled into the given \n\
    ``buffer``. \n\
\n\
See Also \n\
--------- \n\
copyVal&quot;)</td></tr>
<tr class="separator:a501b6d9f5d7b30ffb9ab212e83681893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1323f2a84fd4c217025f874fbd564774"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1323f2a84fd4c217025f874fbd564774"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_copyVal_doc,&quot;copyVal(destObject) \n\
\n\
Gets deep copy of data of this plugin, stored in the given data object. \n\
\n\
Returns a deep copy of the recently acquired data (for grabber and ADDA only) of the \n\
camera or AD-converter device. The deep copy sometimes requires one copy operation \n\
more than the similar command :meth:`getVal`. However, :meth:`getVal` only returns \n\
a reference to the plugin internal data structure whose values might be changed if \n\
another data acquisition is started. \n\
\n\
If no acquisition has been triggered, this method raises a RuntimeError. If the \n\
acquisition is not finished yet, this method blocks and waits until the end of the \n\
acquisition. \n\
\n\
Parameters \n\
----------- \n\
destObject : dataObject\n\
    `dataObject` where the plugin data is copied to. Either provide an empty \n\
    :class:`dataObject` or a :class:`dataObject` whose shape exactly fits to the \n\
    shape of the available data of the plugin. Therefore you can allocate a \n\
    3D data object, set a region of interest to one plane such that the data from \n\
    the plugin is copied into this plane. \n\
\n\
Raises \n\
------- \n\
RuntimeError \n\
    if the dataIO plugin is anything else than ADDA or grabber\n\
    or if no acquisition has been triggered \n\
\n\
See Also \n\
--------- \n\
getVal&quot;)</td></tr>
<tr class="separator:a1323f2a84fd4c217025f874fbd564774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7bd9e36898c125aec0bf27f7eec6cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf7bd9e36898c125aec0bf27f7eec6cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_setVal_doc,&quot;setVal(dataObj) -&gt; None \\\n\
setVal(buffer, length = 1) -&gt; None \n\
\n\
Transfers a dataObject to an ADDA plugin for write, or a bytearray to other dataIO plugins for general purposes. \n\
\n\
If the :class:`dataIO` plugin has the subtype ``ADDA`` (analog-digital converter), \n\
this method is used to send data to one or more analog outputs of the device. \n\
In this case a :class:`dataObject` must be given as first and only argument. \n\
and the second argument ``length`` must be 1. \n\
\n\
For other dataIO plugins, the first argument must be any buffer object, like \n\
a :obj:`bytearray`, :obj:`bytes` or unicode :obj:`str`. The ``length`` is then extracted \n\
from this value. However it is also possible to define a user-defined size using the \n\
``length`` argument. \n\
\n\
Parameters \n\
----------- \n\
dataObj : dataObject \n\
    The array, that should be transmitted to the output of an analog-digital converter. \n\
    Usually, the shape of this array is ``M x N``, where ``M`` channels will obtain up \n\
    to ``N`` new values. This argument is used for ``ADDA`` :class:`dataIO` devices.\n\
buffer : bytearray or bytes or str \n\
    Other :class:`dataIO` devices than ``ADDA`` need to pass a buffer object, \n\
    like a :obj:`bytearray`, :obj:`bytes` or unicode :obj:`str`. \n\
length : int, optional \n\
    Usually, this value is not required, since the length of the ``buffer`` is \n\
    automatically extracted from the given object.&quot;)</td></tr>
<tr class="separator:acf7bd9e36898c125aec0bf27f7eec6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8e156819684b27b06a41b80f0cd1cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada8e156819684b27b06a41b80f0cd1cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_enableAutoGrabbing_doc,&quot;enableAutoGrabbing() \n\
\n\
Enables auto grabbing for the grabber (camera...). \n\
\n\
If the auto grabbing flag is set, the camera acquisition is continuously triggered \n\
if at least one live image is connected to the camera. The default and minimum interval \n\
between two grabs is 20 ms. It can be changed via :meth:`setAutoGrabbingInterval`. \n\
If the grabbing process is slower, the camera tries to acquire new images as fast \n\
as possible. \n\
\n\
Enabling this auto grabbing mechanism can be undesired behaviour for instance if a \n\
measurement is started where the acquisition should be controlled by a specific \n\
script or something similar. In this case, disable the auto grabbing property. \n\
All connected live images will then get new images only if :meth:`getVal` or \n\
:meth:`copyVal` is called. \n\
\n\
This method enables the auto grabbing timer. \n\
\n\
See Also \n\
--------- \n\
setAutoGrabbing, disableAutoGrabbing, getAutoGrabbing, setAutoGrabbingInterval&quot;)</td></tr>
<tr class="separator:ada8e156819684b27b06a41b80f0cd1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abce19702f9f235eae227a1e41ec3cedb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abce19702f9f235eae227a1e41ec3cedb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_disableAutoGrabbing_doc,&quot;disableAutoGrabbing() \n\
\n\
Disables auto grabbing for this grabber (camera...). \n\
\n\
If the auto grabbing flag is set, the camera acquisition is continuously triggered \n\
if at least one live image is connected to the camera. The default and minimum interval \n\
between two grabs is 20 ms. It can be changed via :meth:`setAutoGrabbingInterval`. \n\
If the grabbing process is slower, the camera tries to acquire new images as fast \n\
as possible. \n\
\n\
Enabling this auto grabbing mechanism can be undesired behaviour for instance if a \n\
measurement is started where the acquisition should be controlled by a specific \n\
script or something similar. In this case, disable the auto grabbing property. \n\
All connected live images will then get new images only if :meth:`getVal` or \n\
:meth:`copyVal` is called. \n\
\n\
This method disables the auto grabbing timer. \n\
\n\
See Also \n\
--------- \n\
setAutoGrabbing, enableAutoGrabbing, getAutoGrabbing, setAutoGrabbingInterval&quot;)</td></tr>
<tr class="separator:abce19702f9f235eae227a1e41ec3cedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3757108a885c21317ec2fb5cf51503f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3757108a885c21317ec2fb5cf51503f4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_setAutoGrabbing_doc,&quot;setAutoGrabbing(enable) \n\
\n\
Enables or disables the auto grabbing property of this grabber device. \n\
\n\
If the auto grabbing flag is set, the camera acquisition is continuously triggered \n\
if at least one live image is connected to the camera. \n\
\n\
Enabling this auto grabbing mechanism can be undesired behaviour for instance if a \n\
measurement is started where the acquisition should be controlled by a specific \n\
script or something similar. In this case, disable the auto grabbing property. \n\
All connected live images will then get new images only if :meth:`getVal` or \n\
:meth:`copyVal` is called. \n\
\n\
Parameters \n\
----------- \n\
enable : bool \n\
    ``True`` will enable the auto grabbing timer, ``False`` disables it. \n\
\n\
See Also \n\
--------- \n\
enableAutoGrabbing, disableAutoGrabbing, getAutoGrabbing&quot;)</td></tr>
<tr class="separator:a3757108a885c21317ec2fb5cf51503f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2672e37620585821301159dc7910311e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2672e37620585821301159dc7910311e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_getAutoGrabbing_doc,&quot;getAutoGrabbing() -&gt; bool \n\
\n\
Returns if the auto grabbing property of this grabber device is enabled or disabled. \n\
\n\
If the auto grabbing flag is set, the camera acquisition is continuously triggered \n\
if at least one live image is connected to the camera. \n\
\n\
Enabling this auto grabbing mechanism can be undesired behaviour for instance if a \n\
measurement is started where the acquisition should be controlled by a specific \n\
script or something similar. In this case, disable the auto grabbing property. \n\
All connected live images will then get new images only if :meth:`getVal` or \n\
:meth:`copyVal` is called. \n\
\n\
Returns \n\
------- \n\
bool \n\
    ``True`` if the auto grabbing timer is currently active, otherwise ``False``. \n\
\n\
See Also \n\
--------- \n\
enableAutoGrabbing, disableAutoGrabbing, setAutoGrabbing&quot;)</td></tr>
<tr class="separator:a2672e37620585821301159dc7910311e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5fca3dee8de1fec255d9a38e3f501c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f5fca3dee8de1fec255d9a38e3f501c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_setAutoGrabbingInterval_doc,&quot;setAutoGrabbingInterval() \n\
\n\
Changes the minimum auto grabbing interval (in ms) between two auto-grabbed datasets. \n\
\n\
If auto grabbing is enabled for a grabber device, a timer is set that continuously \n\
acquires data or images from the devices and sends it to all connected plots or \n\
other listeners. The timer event will occur with a certain interval (in ms). However, \n\
if the image acquisition requires more time than the interval, several timer events \n\
will be automatically omitted, such that the next image is only acquired if the \n\
grabber device is in an idle state again. Hence, the interval is considered to be a \n\
minimum value. \n\
\n\
The default interval of newly started grabber devices in 20 ms. It is possible to \n\
change this interval even if auto grabbing is currently disabled. The new interval \n\
will be considered from the next activation on. \n\
\n\
Parameters \n\
----------- \n\
interval : int\n\
    New minimum auto grabbing timer interval in `ms`. \n\
\n\
See Also \n\
--------- \n\
enableAutoGrabbing, disableAutoGrabbing, getAutoGrabbing, setAutoGrabbing, getAutoGrabbingInterval&quot;)</td></tr>
<tr class="separator:a5f5fca3dee8de1fec255d9a38e3f501c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ef62041fe975fad793ad30266f5541"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5ef62041fe975fad793ad30266f5541"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_getAutoGrabbingInterval_doc,&quot;getAutoGrabbingInterval() -&gt; int \n\
\n\
Returns the current auto grabbing interval (in ms), even if auto grabbing is disabled. \n\
\n\
If auto grabbing is enabled for a grabber device, a timer is set that continuously \n\
acquires data or images from the devices and sends it to all connected plots or \n\
other listeners. The timer event will occur with a certain interval (in ms). However, \n\
if the image acquisition requires more time than the interval, several timer events \n\
will be automatically omitted, such that the next image is only acquired if the \n\
grabber device is in an idle state again. Hence, the interval is considered to be a \n\
minimum value. \n\
\n\
The default interval of newly started grabber devices in 20 ms. \n\
\n\
Returns \n\
------- \n\
int \n\
    the current auto grabbing timer interval in `ms`. \n\
\n\
See Also \n\
--------- \n\
enableAutoGrabbing, disableAutoGrabbing, getAutoGrabbing, setAutoGrabbing, setAutoGrabbingInterval&quot;)</td></tr>
<tr class="separator:ac5ef62041fe975fad793ad30266f5541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29fc1140732fa7195d7b043644362a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae29fc1140732fa7195d7b043644362a7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_connect_doc,&quot;connect(signalSignature, callableMethod, minRepeatInterval = 0) \n\
\n\
Connects a signal of this dataIO device with the given callable Python method. \n\
\n\
Every :class:`dataIO` object can emit different signals whenever a certain event \n\
occurs. Use the method :meth:`info` to get a print-out of a list of possible signals \n\
of the dataIO device. This method is used to connect a certain callable Python callback \n\
method or function to a specific signal. The callable function can be bounded as well \n\
as unbounded. \n\
\n\
The connection is described by the string signature of the signal (hence the source of \n\
the connection). Such a signature is the name of the signal, followed by the types of \n\
its arguments (the original C++ types). An example is ``destroyed()``, \n\
emitted if this device is internally deleted. This signal can \n\
be connected to a callback function with no arguments, since the signal has no arguments, \n\
too. In case of a bounded method, the ``self`` argument must be given in any case. \n\
\n\
If the signal should have further arguments with specific datatypes, they are transformed \n\
into corresponding Python data types. A table of supported conversions is given in section \n\
:ref:`qtdesigner-datatypes`. In general, a ``callableMethod`` must be a method or \n\
function with the same number of parameters than the signal has (besides the \n\
``self`` argument). \n\
\n\
If a signal is emitted very often, it can be necessary to limit the call of the callback \n\
function to a certain minimum time interval. This can be given by the ``minRepeatInterval`` \n\
parameter. \n\
\n\
Parameters \n\
----------- \n\
signalSignature : str \n\
    This must be the valid signature, known from the Qt-method *connect* \n\
    (e.g. ``targetChanged(QVector&lt;double&gt;)``) \n\
callableMethod : callable \n\
    valid method or function that is called if the signal is emitted. \n\
minRepeatInterval : int, optional \n\
    If &gt; 0, the same signal only invokes a slot once within the given interval (in ms). \n\
    Default: 0 (all signals will invoke the callable python method. \n\
\n\
See Also \n\
--------- \n\
disconnect, info&quot;)</td></tr>
<tr class="separator:ae29fc1140732fa7195d7b043644362a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6661bd59f16825f5aa7944882a82fa66"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6661bd59f16825f5aa7944882a82fa66"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_disconnect_doc,&quot;disconnect(signalSignature, callableMethod) \n\
\n\
Disconnects a connection which must have been established before with exactly the same parameters.\n\
\n\
Parameters \n\
----------- \n\
signalSignature : str \n\
    This must be the valid signature, known from the Qt-method *connect* \n\
    (e.g. ``clicked(bool)``) \n\
callableMethod : callable \n\
    valid method or function, that should not be called any more if the \n\
    given signal is emitted. \n\
\n\
See Also \n\
--------- \n\
connect, info&quot;)</td></tr>
<tr class="separator:a6661bd59f16825f5aa7944882a82fa66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae62c17fa26d8066518f3172faebc70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ae62c17fa26d8066518f3172faebc70"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_getType_doc,&quot;getType() -&gt; int \n\
\n\
Returns the type value of this specific dataIO plugin. \n\
\n\
Possible values are: \n\
\n\
* ``0x081``: a camera or general grabber device \n\
* ``0x101``: a analog-digital converter device \n\
* ``0x201``: any other kind of device (e.g. data transfer, like serial ports, \n\
  USB ports, ... but also other devices like a power supply...). \n\
\n\
Returns \n\
------- \n\
int \n\
    dataIO type indentifier.&quot;)</td></tr>
<tr class="separator:a7ae62c17fa26d8066518f3172faebc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86c77724d43c29b7f5d4a330e08192d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa86c77724d43c29b7f5d4a330e08192d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyDataIOPlugin_info_doc,&quot;info(verbose = 0) \n\
\n\
Prints out information about signal and callable slots of this actuator.\n\
\n\
Parameters \n\
----------- \n\
verbose : int \n\
    0: only slots and signals from the plugin class are printed (default) \n\
    1: all slots and signals from all inherited classes are printed\n\
\n\
See Also \n\
-------- \n\
connect, disconnect&quot;)</td></tr>
<tr class="separator:aa86c77724d43c29b7f5d4a330e08192d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b663299db355a3fbde447b19dcde12f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b663299db355a3fbde447b19dcde12f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyProgressObserver_doc,&quot;progressObserver(progressBar = None, label = None, progressMinimum = 0, progressMaximum = 100) -&gt; progressObserver \n\
\n\
Creates a progressObserver object. \n\
\n\
A :class:`progressObserver` object can be passed to functions, that might need some \n\
time to be finished, such that these functions can regularily report their current \n\
progress (as number as well as text) via this progress observer. These reported progress \n\
values are then displayed in the passed ``progressBar`` and / or ``label``. \n\
For more information see also this section: :ref:`filter_interruptible`. \n\
\n\
Target functions, that can make use of this :class:`progressObserver` can be contained in \n\
itom algorithm plugins. However these functions must implement the **FilterDefExt** \n\
interface, which is available from itom 3.3 on. Check the method :py:meth:`itom.filterHelp` \n\
or the help widget of itom in order to find out whether a filter \n\
in an algorithm plugin has this ability. \n\
\n\
If a filter accepts a :class:`progressObserver`, pass this object to the keyword \n\
argument ``_observe`` of the method :py:meth:`itom.filter`. Algorithms, that accept \n\
this kind of observer can also use the same observer to interrupt the algorithm once \n\
the additional interrupt flag of the observer is set. This flag is either set whenever \n\
a Python script execution is interrupted or if a signal of a widget has been emitted that \n\
was previously connected to this interrupt flag using the method \n\
:py:meth:`~itom.uiItem.invokeProgressObserverCancellation`. \n\
\n\
Parameters \n\
----------- \n\
progressBar : uiItem, optional \n\
    This is an optional handle to a progress bar in any user interface. The minimum \n\
    requirement is that the given widget has at least a slot 'setValue(int)', which \n\
    is called once this progress observer reports a new progress value (bound between \n\
    ``progressMinimum`` and ``progressMaximum``. \n\
label : uiItem, optional \n\
    This argument is very similar to ``progressBar``, however it requires a handle to a label \n\
    widget or any other widget that has a slot ``setText(QString)``. This slot is called \n\
    whenever the target algorithm for this observer reports a new progress text. \n\
progressMinimum : int, optional \n\
    Minimum progress value that should be used and reported by the target of this observer. \n\
progressMaximum : int, optional \n\
    Maximum progress value that should be used and reported by the target of this observer. \n\
\n\
Notes \n\
-------- \n\
This class wraps the C++ class `<a class="el" href="classito_1_1_function_cancellation_and_observer.html">ito::FunctionCancellationAndObserver</a>`.&quot;)</td></tr>
<tr class="separator:a9b663299db355a3fbde447b19dcde12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa67379bf2dbf7f9c5889fa5892361c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abaa67379bf2dbf7f9c5889fa5892361c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (progressObserver_getProgressMinimum_doc,&quot;int : Gets the minimum value of the progress. \n\
\n\
The minimum progress value is the minimum scalar value that the observed \n\
function or algorithm should set as its lowest progress value.&quot;)</td></tr>
<tr class="separator:abaa67379bf2dbf7f9c5889fa5892361c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d67e9187799fa77998ae2a82df12a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1d67e9187799fa77998ae2a82df12a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (progressObserver_getProgressMaximum_doc,&quot;int : Gets the maximum value of the progress. \n\
\n\
The maximum progress value is the maximum scalar value that the observed \n\
function or algorithm should set as its highest progress value.&quot;)</td></tr>
<tr class="separator:ac1d67e9187799fa77998ae2a82df12a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2e50a2606b275fa3db88eb8d56b577"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c2e50a2606b275fa3db88eb8d56b577"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (progressObserver_progressValue_doc,&quot;int : gets or sets the current progress value.\n\
\n\
If the current progress value is set, the signal ``progressValueChanged(int)`` \n\
is emitted. It can for instance be connected to a ``setValue`` slot of a \n\
`QProgressBar`. The ``progressValue`` will be clipped to ``progressMinimum`` \n\
and  ``progressMaximum``.&quot;)</td></tr>
<tr class="separator:a1c2e50a2606b275fa3db88eb8d56b577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a280e88ade5135bb68337b175121622"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a280e88ade5135bb68337b175121622"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (progressObserver_progressText_doc,&quot;str : the current progress text\n\
\n\
This attribute gives access to the current progress text.\n\
When set, the signal ``progressTextChanged`` is emitted. It can for instance be\n\
connected to a ``setText`` slot of a `QLabel`. The text should inform about \n\
the step, the long-running method is currently executing.&quot;)</td></tr>
<tr class="separator:a9a280e88ade5135bb68337b175121622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b630a346b2c817e43a399a2b965ba19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7b630a346b2c817e43a399a2b965ba19"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (progressObserver_isCancelled_doc,&quot;bool : returns ``True`` if a cancellation request has been signalled, otherwise ``False``.&quot;)</td></tr>
<tr class="separator:a7b630a346b2c817e43a399a2b965ba19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6969aa4886ff8ffe8cfacde2c5f39ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6969aa4886ff8ffe8cfacde2c5f39ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (progressObserver_requestCancellation_doc,&quot;requestCancellation() \n\
\n\
Requests the cancellation of the filter.\n\
\n\
If this :class:`progressObserver` is currently passed to an object, filter or \n\
algorithm, that can be cancelled, a cancellation request is sent to this object. \n\
Calling this method will emit the ``cancellationRequested()`` signal.&quot;)</td></tr>
<tr class="separator:af6969aa4886ff8ffe8cfacde2c5f39ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64291fa6016c5769aa9454a470c33501"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64291fa6016c5769aa9454a470c33501"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (progressObserver_reset_doc,&quot;reset() \n\
\n\
Resets this object. \n\
\n\
Resets this object and empties the current progress text, resets the current \n\
progress value to its minimum and resets the cancellation request. \n\
Emits the ``resetDone`` signal.&quot;)</td></tr>
<tr class="separator:a64291fa6016c5769aa9454a470c33501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2191efd009d448dc79d87a55c2a4d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add2191efd009d448dc79d87a55c2a4d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (progressObserver_connect_doc,&quot;connect(signalSignature, callableMethod, minRepeatInterval = 0)\n\
\n\
Connects the signal of the progressObserver with the given callable Python method. \n\
\n\
This object of :class:`progressObserver` wraps an underlying object of the C++ class \n\
``<a class="el" href="classito_1_1_function_cancellation_and_observer.html">ito::FunctionCancellationAndObserver</a>``, which can emit various signals. Use this \n\
method to connect any signal to any callable python method (bounded or unbounded). This \n\
method must have the same number of arguments than the signal and the types of the \n\
signal definition must be convertable into a python object. \n\
\n\
Possible signals are (among others): \n\
\n\
* progressTextChanged(QString) -&gt; emitted when the observed function reports a new progress text, \n\
* progressValueChanged(int) -&gt; emitted whenever the observed function reports a new progress value, \n\
* cancellationRequested() -&gt; emitted if a cancellation of the observed function has been requested, \n\
* resetDone() -&gt; emitted if the progressObserver has been reset. \n\
\n\
New in itom 4.1. \n\
\n\
Parameters \n\
----------- \n\
signalSignature : str \n\
    This must be the valid signature. Possible signatures are: \n\
    ``progressTextChanged(QString)`` or ``progressValueChanged(int)``\n\
callableMethod : callable \n\
    Valid method or function that is called if the signal is emitted. The method must \n\
    provide one parameter for the string or number argument of the signal. \n\
minRepeatInterval : int, optional \n\
    If &gt; 0, the same signal only invokes a slot once within the given interval (in ms). \n\
    Default: 0 (all signals will invoke the callable Python method. \n\
\n\
See Also \n\
--------- \n\
disconnect&quot;)</td></tr>
<tr class="separator:add2191efd009d448dc79d87a55c2a4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ebc391ad696b472126f98f46f43f4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7ebc391ad696b472126f98f46f43f4f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (progressObserver_disconnect_doc,&quot;disconnect(signalSignature, callableMethod) \n\
\n\
Disconnects a connection which must have been established with exactly the same parameters.\n\
\n\
New in itom 4.1. \n\
\n\
Parameters \n\
----------- \n\
signalSignature : str \n\
    This must be the valid signature (``progressTextChanged(QString)`` or ``progressValueChanged(int)``)\n\
callableMethod : callable \n\
    valid method or function, that should not be called any more, if the given signal is \n\
    emitted. \n\
\n\
See Also \n\
--------- \n\
connect&quot;)</td></tr>
<tr class="separator:ae7ebc391ad696b472126f98f46f43f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6801e17ca0c8fd5a1e0658cf27d9f84e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6801e17ca0c8fd5a1e0658cf27d9f84e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (progressObserver_info_doc,&quot;info(verbose = 0) \n\
\n\
Prints information about possible signals to the command line.\n\
\n\
Parameters \n\
----------- \n\
verbose : int \n\
    0: only signals from the plugin class are printed (default) \n\
    1: all signals from all inherited classes are printed&quot;)</td></tr>
<tr class="separator:a6801e17ca0c8fd5a1e0658cf27d9f84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62e8b134ff9dd95bc6055de8c2efc43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab62e8b134ff9dd95bc6055de8c2efc43"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>safeDecrefPyObject</b> (PyObject *obj)</td></tr>
<tr class="separator:ab62e8b134ff9dd95bc6055de8c2efc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0600c4332f0bd77d1878533eb5b25f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b0600c4332f0bd77d1878533eb5b25f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegion_doc,&quot;region() -&gt; region \\\n\
region(otherRegion) -&gt; region \\\n\
region(x, y, w, h, type = region.RECTANGLE) -&gt; region \n\
\n\
Creates a rectangular or elliptical region. \n\
\n\
This class is a wrapper for the class ``QRegion`` of `Qt`. It provides possibilities for \n\
creating pixel-based regions. Furtherone you can calculate new regions based on the \n\
intersection, union or subtraction of other regions. Based on the region it is \n\
possible to get a uint8 masked dataObject, where every point within the entire \n\
region has the value 255 and all other values 0 \n\
\n\
If the constructor is called without argument, an empty region is created. \n\
\n\
Parameters \n\
----------- \n\
otherRegion : region \n\
    Pass this object of :class:`region` to create a copied object of it. \n\
x : int\n\
    x-coordinate of the reference corner of the region \n\
y : int\n\
    y-coordinate of the reference corner of the region \n\
w : int\n\
    width of the region \n\
h : int\n\
    height of the region \n\
type : int, optional \n\
    ``region.RECTANGLE`` creates a rectangular region (default). \n\
    ``region.ELLIPSE`` creates an elliptical region, which is placed inside of the \n\
    given boundaries.&quot;)</td></tr>
<tr class="separator:a9b0600c4332f0bd77d1878533eb5b25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5b307bba484022ff216ea9881af75b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa5b307bba484022ff216ea9881af75b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionContains_doc,&quot;contains(x, y, w = -1, h = -1) -&gt; bool \n\
\n\
This method returns True, if the given point (x,y) or rectangle (x,y,w,h) is fully \n\
contained in this region. Otherwise returns False.\n\
\n\
Parameters \n\
----------- \n\
x : int \n\
    x-coordinate of one corner of the new rectangular region \n\
y : int \n\
    y-coordinate of one corner of the new rectangular region \n\
w : int, optional \n\
    width of the new rectangular region. If not given, point is assumed. \n\
h : int, optional \n\
    height of the new rectangular region. If not given, point is assumed.\n\
\n\
Returns \n\
-------- \n\
bool \n\
    True if point or rectangle is contained in region, otherwise False.&quot;)</td></tr>
<tr class="separator:afa5b307bba484022ff216ea9881af75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746c98b37a36b9ddf1dae184c74230fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a746c98b37a36b9ddf1dae184c74230fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionIntersected_doc,&quot;intersected(x, y, w, h) -&gt; region \\\n\
intersected(region) -&gt; region \n\
\n\
Returns a new region which is the intersection of the given region and this region. \n\
\n\
The intersection only contains points that are part of both regions. \n\
The given region can either by a :class:`region` object or a rectangular \n\
region, defined by its corner points (``x``, ``y``) and its width ``w`` \n\
and height ``h``. \n\
\n\
Parameters \n\
----------- \n\
x : int \n\
    x-coordinate of one corner of the new rectangular region \n\
y : int \n\
    y-coordinate of one corner of the new rectangular region \n\
w : int \n\
    width of the new rectangular region \n\
h : int \n\
    height of the new rectangular region \n\
region : region \n\
    another instance of region \n\
\n\
Returns \n\
------- \n\
region \n\
    new intersected region.&quot;)</td></tr>
<tr class="separator:a746c98b37a36b9ddf1dae184c74230fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac351cdd0f404a05f24cee2d6cdac13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ac351cdd0f404a05f24cee2d6cdac13"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionIntersects_doc,&quot;intersects(x, y, w, h) -&gt; bool \\\n\
intersects(region) -&gt; bool \n\
\n\
Returns True if this region intersects with the given region, otherwise False. \n\
\n\
The given region can either by a :class:`region` object or a rectangular \n\
region, defined by its corner points (``x``, ``y``) and its width ``w`` \n\
and height ``h``. \n\
\n\
Parameters \n\
----------- \n\
x : int \n\
    x-coordinate of one corner of the new rectangular region \n\
y : int \n\
    y-coordinate of one corner of the new rectangular region \n\
w : int \n\
    width of the new rectangular region \n\
h : int \n\
    height of the new rectangular region \n\
region : region \n\
    another instance of region \n\
\n\
Returns \n\
------- \n\
bool \n\
    True if both regions intersect, otherwise False.&quot;)</td></tr>
<tr class="separator:a3ac351cdd0f404a05f24cee2d6cdac13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf981cec06f62bf3050a5db7cd52643b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf981cec06f62bf3050a5db7cd52643b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionSubtracted_doc,&quot;subtracted(x, y, w, h) -&gt; region \\\n\
subtracted(region) -&gt; region \n\
\n\
This method returns a new region, which is the given, new region subtracted from this region. \n\
\n\
The given region can either by a :class:`region` object or a rectangular \n\
region, defined by its corner points (``x``, ``y``) and its width ``w`` \n\
and height ``h``. \n\
\n\
Parameters \n\
----------- \n\
x : int \n\
    x-coordinate of one corner of the new rectangular region \n\
y : int \n\
    y-coordinate of one corner of the new rectangular region \n\
w : int \n\
    width of the new rectangular region \n\
h : int \n\
    height of the new rectangular region \n\
region : region \n\
    another instance of region \n\
\n\
Returns \n\
------- \n\
region \n\
    new, subtraced region.&quot;)</td></tr>
<tr class="separator:acf981cec06f62bf3050a5db7cd52643b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cb002f5a6342b400471701987d12be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50cb002f5a6342b400471701987d12be"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionTranslate_doc,&quot;translate(x, y)\n\
\n\
This method translates this region by the given translation values. \n\
\n\
Parameters \n\
----------- \n\
x : int \n\
    translation in x-direction \n\
y : int \n\
    translation in y-direction \n\
\n\
See Also \n\
--------- \n\
translated&quot;)</td></tr>
<tr class="separator:a50cb002f5a6342b400471701987d12be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4823efd257e4a844e7375e527162a85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4823efd257e4a844e7375e527162a85"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionTranslated_doc,&quot;translated(x, y) -&gt; region\n\
\n\
This method returns a new region, which is translated by the given distances in x and y direction. \n\
\n\
Parameters \n\
----------- \n\
x : int \n\
    translation in x-direction \n\
y : int \n\
    translation in y-direction \n\
\n\
Returns \n\
------- \n\
region \n\
    new translated region.\n\
\n\
See Also \n\
--------- \n\
translate&quot;)</td></tr>
<tr class="separator:ae4823efd257e4a844e7375e527162a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96969fe7db42807dc4ff40d837559df"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac96969fe7db42807dc4ff40d837559df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionUnited_doc,&quot;united(x, y, w, h) -&gt; region \\\n\
united(region) -&gt; region \n\
\n\
returns a region which is the union of the given region with this region. \n\
\n\
This method returns a new region, which is the union of this region with the given region. \n\
The union contains all areas, that are contained in any of both regions. \n\
\n\
The given region can either by a :class:`region` object or a rectangular \n\
region, defined by its corner points (``x``, ``y``) and its width ``w`` \n\
and height ``h``. \n\
\n\
Parameters \n\
----------- \n\
x : int \n\
    x-coordinate of one corner of a rectangular region \n\
y : int \n\
    y-coordinate of one corner of a rectangular region \n\
w : int \n\
    width of the new rectangular region \n\
h : int \n\
    height of the new rectangular region \n\
region : region \n\
    another instance of region \n\
\n\
Returns \n\
------- \n\
region \n\
    new united region.&quot;)</td></tr>
<tr class="separator:ac96969fe7db42807dc4ff40d837559df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d92a9a8192c8c391f8d0e9dd30e536"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15d92a9a8192c8c391f8d0e9dd30e536"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionXored_doc,&quot;xored(x, y, w, h) -&gt; region \\\n\
xored(region) -&gt; region \n\
\n\
returns a region which is an xor combination of the given region with this region. \n\
\n\
This method returns a new region, which is defined by an xor-combination of this \n\
region with the given region. \n\
\n\
The given region can either by a :class:`region` object or a rectangular \n\
region, defined by its corner points (``x``, ``y``) and its width ``w`` \n\
and height ``h``. \n\
\n\
Parameters \n\
----------- \n\
x : int \n\
    x-coordinate of one corner of a rectangular region \n\
y : int \n\
    y-coordinate of one corner of a rectangular region \n\
w : int \n\
    width of the new rectangular region \n\
h : int \n\
    height of the new rectangular region \n\
region : region \n\
    another instance of region \n\
\n\
Returns \n\
------- \n\
region \n\
    new xored region.&quot;)</td></tr>
<tr class="separator:a15d92a9a8192c8c391f8d0e9dd30e536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda84eabedb10ead1e4dd1104c2d8640"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afda84eabedb10ead1e4dd1104c2d8640"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegion_getEmpty_doc,&quot;bool: Returns True if this region is empty, otherwise False&quot;)</td></tr>
<tr class="separator:afda84eabedb10ead1e4dd1104c2d8640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e27568ad89a0cf4e6434a6ce9fd4be8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e27568ad89a0cf4e6434a6ce9fd4be8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegion_getRectCount_doc,&quot;int: Returns the number of rectangles in this region&quot;)</td></tr>
<tr class="separator:a6e27568ad89a0cf4e6434a6ce9fd4be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6012ed821c3b919715b0209a3934c120"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6012ed821c3b919715b0209a3934c120"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegion_getRects_doc,&quot;list of list of int: Returns list of rectangles, whose union defines this region. \n\
\n\
Each rectangle is given by a list of (x, y, width, height).&quot;)</td></tr>
<tr class="separator:a6012ed821c3b919715b0209a3934c120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78025e36735ce7ff134749064b2a365f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78025e36735ce7ff134749064b2a365f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegion_getBoundingRect_doc,&quot;list of int or None: Returns the bounding rectangle of this region or None if it is empty. \n\
\n\
The bounding rectangle is given by a list (x, y, width, height).&quot;)</td></tr>
<tr class="separator:a78025e36735ce7ff134749064b2a365f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bb4450cffc1d9b59586ac978971741"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3bb4450cffc1d9b59586ac978971741"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyRegionCreateMask_doc,&quot;createMask(boundingRegion = None) -&gt; dataObject \n\
\n\
Returns a :class:`~itom.dataObject` with dtype ``uint8`` whose shape corresponds to the \n\
width and height of the bounding rectangle. All pixels contained in the region have a \n\
value of ``255`` while the rest is set to ``0``. The offset value of the dataObject is \n\
set such that it fits to the <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> position of the region, since the first element \n\
in the dataObject corresponds to the left upper corner of the bounding rectangle.\n\
\n\
Indicate a ``boundingRegion`` in order to increase the size of the returned data object. \n\
Its size will have the size of the union between the boundingRegion and the region.\n\
\n\
Parameters \n\
----------- \n\
boundingRegion : region, optional\n\
    If a :class:`region` object is given, the shape of the returned :class:`dataObject`\n\
    is the maximum (union) between this ``boundingRegion`` and this region. \n\
\n\
Returns \n\
------- \n\
mask : dataObject&quot;)</td></tr>
<tr class="separator:ad3bb4450cffc1d9b59586ac978971741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359ff28de8d624b5297d70ae2e02455c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a359ff28de8d624b5297d70ae2e02455c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (rgbaInit_doc,&quot;rgba(r, g, b, alpha=255) -&gt; rgba \n\
\n\
Color value object (RGB + optional alpha channel). \n\
\n\
Creates a new color value from red, green, blue and optional alpha. \n\
If any value &gt; 255 is passed as argument, its modulo with ``256`` is taken instead. \n\
\n\
The :class:`rgba` object implements many methods of the number protocol, \n\
such that it becomes possible to add, subtract, multiply... two colors. In most \n\
cases these operations are executed for each color component independently. \n\
\n\
Parameters \n\
----------- \n\
r : int \n\
    red component [0,255]. \n\
g : int \n\
    green component [0,255]. \n\
b : int \n\
    blue component [0,255]. \n\
alpha : int, optional \n\
    alpha component [0,255], default: 255 (opaque). \n\
\n\
Notes \n\
------ \n\
\n\
For a gray value set all colors to the same value.&quot;)</td></tr>
<tr class="separator:a359ff28de8d624b5297d70ae2e02455c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5a4d61535762e59ae813728d0a14b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e5a4d61535762e59ae813728d0a14b6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyRgba_name_doc,&quot;name() -&gt; str \n\
\n\
Returns the name of this object (``rgba``).&quot;)</td></tr>
<tr class="separator:a2e5a4d61535762e59ae813728d0a14b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e285bd054db282addcecef17accd2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60e285bd054db282addcecef17accd2e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyRgba_toGray_doc,&quot;toGray() -&gt; float \n\
\n\
returns the gray value from the color (alpha is not considered) \n\
\n\
Returns \n\
------- \n\
float : \n\
    The returned gray value is a float value and calculated by \n\
    ``0.299 * r + 0.587 * g + 0.114 * b`` &quot;)</td></tr>
<tr class="separator:a60e285bd054db282addcecef17accd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150a5e72c240711f8be0d1c10874a235"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a150a5e72c240711f8be0d1c10874a235"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyRgba_red_doc,&quot;int : red component of this color [0, 255].&quot;)</td></tr>
<tr class="separator:a150a5e72c240711f8be0d1c10874a235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba92545fa0f9e38aa3b70fb14f436b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ba92545fa0f9e38aa3b70fb14f436b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyRgba_green_doc,&quot;int : red component of this color [0, 255].&quot;)</td></tr>
<tr class="separator:a7ba92545fa0f9e38aa3b70fb14f436b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74c7b95dea56ffb982cbe8273ae846f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa74c7b95dea56ffb982cbe8273ae846f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyRgba_blue_doc,&quot;int : blue component of this color [0, 255].&quot;)</td></tr>
<tr class="separator:aa74c7b95dea56ffb982cbe8273ae846f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804760503e0da2ed12641b9b1eb1c47d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a804760503e0da2ed12641b9b1eb1c47d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyRgba_alpha_doc,&quot;int : alpha (transparency) component of this color [0, 255].&quot;)</td></tr>
<tr class="separator:a804760503e0da2ed12641b9b1eb1c47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6805ff10a69a67783ba946008c03675"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6805ff10a69a67783ba946008c03675"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyShape_doc,&quot;shape(type = shape.Invalid, param1 = None, param2 = None, index = -1, name = \&quot;\&quot;) -&gt; shape \n\
\n\
Creates a shape object of a specific type. \n\
\n\
A shape object is used to describe a vectorized object, that can for instance be displayed \n\
in plots or might also be passed to different methods, e.g. in order to define a masked \n\
area etc. A :class:`shape` object can also be converted into a :class:`region` object, \n\
however the vector information is then projected onto a raster with a given resolution. \n\
\n\
Depending on the ``type``, the following arguments are allowed, where the first \n\
argument must be given to ``param1`` and the 2nd one to ``param2``: \n\
\n\
* ``shape.Invalid``: - \n\
* ``shape.Point``: point \n\
* ``shape.Line``: start-point, end-point \n\
* ``shape.Rectangle``: top left point, bottom right point \n\
* ``shape.Square``: center point, side-length \n\
* ``shape.Ellipse``: top left point, bottom right point of bounding box \n\
* ``shape.Circle``: center point, radius \n\
* ``shape.Polygon``: 2xM float64 array with M points of polygon \n\
\n\
The parameters ``point``, ``start-point``, ... can be all array-like types (e.g. :class:`dataObject`,\n\
:obj:`list`, :obj:`tuple`, :obj:`np.ndarray`) that can be mapped to float64 and have two elements. \n\
\n\
Another possibility to create a :class:`shape` object for a certain type is to use \n\
one of the following static creation functions: \n\
\n\
* :meth:`createPoint` \n\
* :meth:`createLine` \n\
* :meth:`createCircle` \n\
* :meth:`createEllipse` \n\
* :meth:`createSquare` \n\
* :meth:`createRectangle` \n\
* :meth:`createPolygon` \n\
\n\
During construction, all shapes are aligned with respect to the x- and y-axis. Set a \n\
2d transformation (attribute :attr:`transform`) to rotate and move it. \n\
\n\
Parameters \n\
---------- \n\
type : int \n\
    Type of the shape (see list above). \n\
param1 : list of float or tuple of float or dataObject or numpy.ndarray, optional \n\
    1st initialization argument. This argument is depending on the ``type`` (see list above). \n\
param2 : list of float or tuple of float or dataObject or numpy.ndarray, optional \n\
    2nd initialization argument. This argument is depending on the ``type`` (see list above). \n\
index : int \n\
    index of the shape, or ``-1`` if not further specified (default). \n\
name : str  \n\
    name of the shape, can for instance be displayed next to shapes in plots \n\
    (depending on the parameterization of the plot).&quot;)</td></tr>
<tr class="separator:ab6805ff10a69a67783ba946008c03675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff35a8a92fb3d45ff10ae472e2d6e65a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff35a8a92fb3d45ff10ae472e2d6e65a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_staticPoint_doc,&quot;createPoint(point, index = -1, name = '', flags = 0) -&gt; shape \n\
\n\
Returns a new shape object of type ``shape.Point``.\n\
\n\
This static method is equal to the command:: \n\
\n\
    myShape = shape(shape.Point, point, index, name)\n\
    myShape.flags = flags  # optional\n\
\n\
Parameters \n\
-----------\n\
point : sequence of float or dataObject or numpy.ndarray \n\
    (x,y) coordinate of the point, given as any type that can be interpreted as \n\
    array with two float64 values. \n\
index : int, optional \n\
    index of this shape or -1 (default) if not further specified. \n\
name : str, optional \n\
    optional name of this shape (default: \&quot;\&quot;). This name can for instance be \n\
    displayed in a plot. \n\
flags : int, optional \n\
    if the user should not be able to rotate, resize and / or move this shape in any \n\
    plot canvas, then pass an or-combination of the restricitive flag values \n\
    ``shape.ResizeLock``, ``shape.RotateLock`` or ``shape.MoveLock``. \n\
\n\
Returns \n\
------- \n\
shape \n\
    The new shape object.&quot;)</td></tr>
<tr class="separator:aff35a8a92fb3d45ff10ae472e2d6e65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973251057d2d2f1763e2a3bf3879fd99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a973251057d2d2f1763e2a3bf3879fd99"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_staticLine_doc,&quot;createLine(point1, point2, index = -1, name = \&quot;\&quot;, flags = 0) -&gt; shape \n\
\n\
Returns a new shape object of type ``shape.Line``.\n\
\n\
This static method is equal to the command:: \n\
\n\
    myShape = shape(shape.Line, point1, point2, index, name)\n\
    myShape.flags = flags #optional\n\
\n\
Parameters \n\
-----------\n\
point1 : sequence of float or dataObject or numpy.ndarray \n\
    (x,y) coordinate of the first point, given as any type that can be interpreted as \n\
    array with two values \n\
point2 : sequence of float or dataObject or numpy.ndarray \n\
    (x,y) coordinate of the 2nd point, given as any type that can be interpreted as \n\
    array with two values \n\
index : int, optional \n\
    index of this shape or -1 (default) if not further specified. \n\
name : str, optional \n\
    optional name of this shape (default: \&quot;\&quot;). This name can for instance be \n\
    displayed in a plot. \n\
flags : int, optional \n\
    if the user should not be able to rotate, resize and / or move this shape in any \n\
    plot canvas, then pass an or-combination of the restricitive flag values \n\
    ``shape.ResizeLock``, ``shape.RotateLock`` or ``shape.MoveLock``. \n\
\n\
Returns \n\
------- \n\
shape \n\
    The new shape object.&quot;)</td></tr>
<tr class="separator:a973251057d2d2f1763e2a3bf3879fd99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67daaee0301946e5128fe32c89c749c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab67daaee0301946e5128fe32c89c749c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_staticCircle_doc,&quot;createCircle(center, radius, index = -1, name = '', flags = 0) -&gt; shape \n\
\n\
Returns a new shape object of type ``shape.Circle``.\n\
\n\
This static method is equal to the command:: \n\
\n\
    myShape = shape(shape.Circle, center, radius, index, name)\n\
    myShape.flags = flags #optional\n\
\n\
Parameters \n\
-----------\n\
center : sequence of float or dataObject or numpy.ndarray \n\
    (x,y) coordinate of the center point, given as any type that can be interpreted \n\
    as array with two values \n\
radius : float \n\
    radius of the circle \n\
index : int, optional \n\
    index of this shape or -1 (default) if not further specified. \n\
name : str, optional \n\
    optional name of this shape (default: \&quot;\&quot;). This name can for instance be \n\
    displayed in a plot. \n\
flags : int, optional \n\
    if the user should not be able to rotate, resize and / or move this shape in any \n\
    plot canvas, then pass an or-combination of the restricitive flag values \n\
    ``shape.ResizeLock``, ``shape.RotateLock`` or ``shape.MoveLock``. \n\
\n\
Returns \n\
------- \n\
shape \n\
    The new shape object.&quot;)</td></tr>
<tr class="separator:ab67daaee0301946e5128fe32c89c749c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbe7efeb27581473c1774ea01c81291"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fbe7efeb27581473c1774ea01c81291"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_staticEllipse_doc,&quot;createEllipse(corner1 = None, corner2 = None, center = None, size = None, index = -1, name = \&quot;\&quot;, flags = 0) -&gt; shape \n\
\n\
Returns a new shape object of type ``shape.Ellipse``.\n\
\n\
Basically, there are two different ways to construct the ellipse: \n\
Either by the top left and bottom right corner points of the outer bounding box (``corner1`` \n\
and ``corner2``), or by the ``center`` point (x,y) and the ``size``, as array of (width, height). \n\
\n\
Furthermore, you can indicate a ``size`` together with ``corner1`` OR ``corner2``, \n\
where corner1.x + width = corner2.x and corner1.y + height = corner2.y. \n\
\n\
This static method is equal to the command:: \n\
\n\
    myShape = shape(shape.Ellipse, corner1, corner2, index, name)\n\
    myShape.flags = flags #optional\n\
\n\
Parameters \n\
-----------\n\
corner1 : sequence of float or dataObject or numpy.ndarray, optional \n\
    (x,y) coordinate of the top, left corner point of the bounding box, given as \n\
    any type that can be interpreted as array with two values \n\
corner2 : sequence of float or dataObject or numpy.ndarray, optional \n\
    (x,y) coordinate of the bottom, right corner point of the bounding box, given as \n\
    any type that can be interpreted as array with two values \n\
center : sequence of float or dataObject or numpy.ndarray, optional \n\
    (x,y) coordinate of the center point, given as any type that can be interpreted \n\
    as array with two values \n\
size : sequence of float or dataObject or numpy.ndarray, optional \n\
    (width, height) of the rectangle, given as any type that can be interpreted as array \n\
    with two values \n\
index : int, optional \n\
    index of this shape or -1 (default) if not further specified. \n\
name : str, optional \n\
    optional name of this shape (default: \&quot;\&quot;). This name can for instance be \n\
    displayed in a plot. \n\
flags : int, optional \n\
    if the user should not be able to rotate, resize and / or move this shape in any \n\
    plot canvas, then pass an or-combination of the restricitive flag values \n\
    ``shape.ResizeLock``, ``shape.RotateLock`` or ``shape.MoveLock``. \n\
\n\
Returns \n\
------- \n\
shape \n\
    The new shape object.&quot;)</td></tr>
<tr class="separator:a3fbe7efeb27581473c1774ea01c81291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79128baf9aa3b15fb2df9aa428c47bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad79128baf9aa3b15fb2df9aa428c47bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_staticSquare_doc,&quot;createSquare(center, sideLength, index = -1, name = \&quot;\&quot;, flags = 0) -&gt; shape \n\
\n\
Returns a new shape object of type ``shape.Square``.\n\
\n\
This static method is equal to the command:: \n\
\n\
    myShape = shape(shape.Square, center, sideLength, index, name)\n\
    myShape.flags = flags #optional\n\
\n\
Parameters \n\
-----------\n\
center : sequence of float or dataObject or numpy.ndarray \n\
    (x,y) coordinate of the center point, given as any type that can be interpreted \n\
    as array with two values \n\
sideLength : float \n\
    side length of the square \n\
index : int, optional \n\
    index of this shape or -1 (default) if not further specified. \n\
name : str, optional \n\
    optional name of this shape (default: \&quot;\&quot;). This name can for instance be \n\
    displayed in a plot. \n\
flags : int, optional \n\
    if the user should not be able to rotate, resize and / or move this shape in any \n\
    plot canvas, then pass an or-combination of the restricitive flag values \n\
    ``shape.ResizeLock``, ``shape.RotateLock`` or ``shape.MoveLock``. \n\
\n\
Returns \n\
------- \n\
shape \n\
    The new shape object.&quot;)</td></tr>
<tr class="separator:ad79128baf9aa3b15fb2df9aa428c47bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d50d012d6ee6d43a845378c6d89bf4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55d50d012d6ee6d43a845378c6d89bf4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_staticRectangle_doc,&quot;createRectangle(corner1 = None, corner2 = None, center = None, size = None, index = -1, name = \&quot;\&quot;, flags = 0) -&gt; shape \n\
\n\
Returns a new shape object of type ``shape.Rectangle``.\n\
\n\
Basically, there are two different ways to construct a rectangle: \n\
Either by the top left and bottom right corner points (``corner1`` and ``corner2``), \n\
or by the ``center`` point (x, y) and the ``size``, as array of (width, height). \n\
\n\
Furthermore, you can indicate a ``size`` together with ``corner1`` OR ``corner2``, \n\
where corner1.x + width = corner2.x and corner1.y + height = corner2.y. \n\
\n\
This static method is equal to the command:: \n\
\n\
    myShape = shape(shape.Rectangle, corner1, corner2, index, name)\n\
    myShape.flags = flags #optional\n\
\n\
Parameters \n\
-----------\n\
corner1 : sequence of float or dataObject or numpy.ndarray, optional \n\
    (x,y) coordinate of the top, left corner point, given as any type that can be \n\
    interpreted as array with two values \n\
corner2 : sequence of float or dataObject or numpy.ndarray, optional \n\
    (x,y) coordinate of the bottom, right corner point, given as any type that can be \n\
    interpreted as array with two values \n\
center : sequence of float or dataObject or numpy.ndarray, optional \n\
    (x,y) coordinate of the center point, given as any type that can be interpreted \n\
    as array with two values \n\
size : sequence of float or dataObject or numpy.ndarray, optional \n\
    (width, height) of the rectangle, given as any type that can be interpreted as array \n\
    with two values \n\
index : int, optional \n\
    index of this shape or -1 (default) if not further specified. \n\
name : str, optional \n\
    optional name of this shape (default: \&quot;\&quot;). This name can for instance be \n\
    displayed in a plot. \n\
flags : int, optional \n\
    if the user should not be able to rotate, resize and / or move this shape in any \n\
    plot canvas, then pass an or-combination of the restricitive flag values \n\
    ``shape.ResizeLock``, ``shape.RotateLock`` or ``shape.MoveLock``. \n\
\n\
Returns \n\
------- \n\
shape \n\
    The new shape object.&quot;)</td></tr>
<tr class="separator:a55d50d012d6ee6d43a845378c6d89bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a954248c9e734ce33102c937626e29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9a954248c9e734ce33102c937626e29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_staticPolygon_doc,&quot;createPolygon(points, index = -1, name = \&quot;\&quot;, flags = 0) -&gt; shape \n\
\n\
Returns a new shape object of type ``shape.Polygon``.\n\
\n\
This static method is equal to the command:: \n\
\n\
    myShape = shape(shape.Polygon, points, index, name)\n\
    myShape.flags = flags #optional\n\
\n\
Parameters \n\
-----------\n\
points : sequence of sequence of float or dataObject or numpy.ndarray \n\
    An array-like object of shape ``2 x M`` (with M &gt; 2), that can be converted \n\
    to float64. This object defines ``M`` points for the polygon (order: x, y). \n\
    If a sequence is given, it must look like this:: \n\
    \n\
        points = ((1, 2, 3), (4, 5, 6)) \n\
    \n\
    where the first inner tuple defines the x-coordinates, and the 2nd tuple \n\
    the y-coordinates. \n\
index : int, optional \n\
    index of this shape or -1 (default) if not further specified. \n\
name : str, optional \n\
    optional name of this shape (default: \&quot;\&quot;). This name can for instance be \n\
    displayed in a plot. \n\
flags : int, optional \n\
    if the user should not be able to rotate, resize and / or move this shape in any \n\
    plot canvas, then pass an or-combination of the restricitive flag values \n\
    ``shape.ResizeLock``, ``shape.RotateLock`` or ``shape.MoveLock``. \n\
\n\
Returns \n\
------- \n\
shape \n\
    The new shape object.&quot;)</td></tr>
<tr class="separator:ac9a954248c9e734ce33102c937626e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbbd04b3a13152d6c62a99b01df3c0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cbbd04b3a13152d6c62a99b01df3c0b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_getType_doc,&quot;int : Get the type of this shape. \n\
\n\
Possible types are: \n\
\n\
* ``shape.Line`` \n\
* ``shape.Point`` \n\
* ``shape.Rectangle`` \n\
* ``shape.Ellipse`` \n\
* ``shape.Circle`` \n\
* ``shape.Square``&quot;)</td></tr>
<tr class="separator:a0cbbd04b3a13152d6c62a99b01df3c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c287f16cf03b2f7600b4b7fe97e5287"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c287f16cf03b2f7600b4b7fe97e5287"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_getValid_doc,&quot;bool : Returns True if this shape is valid, otherwise False. \n\
\n\
An invalid shape is the one constructed with the type ``shape.Invalid``. All other \n\
shapes are valid.&quot;)</td></tr>
<tr class="separator:a7c287f16cf03b2f7600b4b7fe97e5287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d2846eaa8cbd9f097a2de5e1c08bfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84d2846eaa8cbd9f097a2de5e1c08bfb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_getFlags_doc,&quot;int : Gets or sets a flag (bitmask) that define denied manipulation of this shape. \n\
\n\
It is possible to deny the following manipulations: \n\
\n\
* ``shape.MoveLock`` \n\
* `` shape.RotateLock`` \n\
* `` shape.ResizeLock``&quot;)</td></tr>
<tr class="separator:a84d2846eaa8cbd9f097a2de5e1c08bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6497e96340e74922d38849e49a15485"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6497e96340e74922d38849e49a15485"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_point1_doc,&quot;tuple of float : Gets or sets the 1st point of the bounding box of this shape. \n\
\n\
The first point is the first point of a ``shape.Point`` or ``shape.Line`` or \n\
the upper left point of the bounding box of a ``shape.Rectangle``, ``shape.Square`` \n\
``shape.Ellipse`` or ``shape.Circle``. The point always considers a possible 2D \n\
coordinate transformation matrix.\n\
\n\
For setting this value, it is also possible to pass any other array-like object \n\
with two elements, that can be converted to float64. \n\
\n\
Raises \n\
------ \n\
TypeError \n\
    if this attribute is read or assigned for a type, that has no 2nd point defined.&quot;)</td></tr>
<tr class="separator:ac6497e96340e74922d38849e49a15485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625ddf2c60e9cd459d86f121b6a88022"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a625ddf2c60e9cd459d86f121b6a88022"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_point2_doc,&quot;tuple of float : Gets or sets the second point of the bounding box of this shape. \n\
\n\
The second point is the 2nd point of a ``shape.Line`` or the bottom right point of \n\
the bounding box (types: ``shape.Rectangle``, ``shape.Square``, ``shape.Ellipse`` or \n\
``shape.Circle``). The point always considers a possible 2D coordinate \n\
transformation matrix.\n\
\n\
For setting this value, it is also possible to pass any other array-like object \n\
with two elements, that can be converted to float64. \n\
\n\
Raises \n\
------ \n\
TypeError \n\
    if this attribute is read or assigned for a type, that has no 2nd point defined.&quot;)</td></tr>
<tr class="separator:a625ddf2c60e9cd459d86f121b6a88022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e296a1cdaf0e1f67fb92f35627ba2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4e296a1cdaf0e1f67fb92f35627ba2f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_center_doc,&quot;tuple of float : Gets or sets the center point of this shape. \n\
\n\
The center point is defined for all types of shapes, beside ``shape.Polygon``. \n\
Changing the center point will directly influence the base points of the shape. \n\
\n\
If the value is set, it is also possible to pass any other array-like object with \n\
two values that can be converted to float64. \n\
\n\
Raises \n\
------ \n\
TypeError \n\
    if this attribute is read or assigned for a type, that has no center defined.&quot;)</td></tr>
<tr class="separator:ac4e296a1cdaf0e1f67fb92f35627ba2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0135ef0b85fcb1f84a19e0516449352"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0135ef0b85fcb1f84a19e0516449352"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_angleDeg_doc,&quot;float : Gets or sets the current angle of rotation of the transformation matrix in degree. \n\
\n\
A rotation is always defined counter-clockwise.&quot;)</td></tr>
<tr class="separator:aa0135ef0b85fcb1f84a19e0516449352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951d067fbeb24a1aa90f6f73ff0b7b45"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a951d067fbeb24a1aa90f6f73ff0b7b45"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_angleRad_doc,&quot;float : Gets or sets the current angle of rotation of the transformation matrix in Radians. \n\
\n\
A rotation is always defined counter-clockwise.&quot;)</td></tr>
<tr class="separator:a951d067fbeb24a1aa90f6f73ff0b7b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae435f8167a067add3421a57decd7ea61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae435f8167a067add3421a57decd7ea61"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_radius_doc,&quot;float or tuple of float : Gets or sets the radius of this shape. \n\
\n\
A radius can only be set for shapes of type ``shape.Circle`` or ``shape.Ellipse``. \n\
For a circle, the radius is a scalar float value. For an ellipse, a tuple of \n\
two values ``(a, b)`` define the half side-length in x- and y-direction of \n\
the base coordinate system.\n\
\n\
Raises \n\
------ \n\
TypeError \n\
    if this attribute is read or assigned for a type, that has no radius defined.&quot;)</td></tr>
<tr class="separator:ae435f8167a067add3421a57decd7ea61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaedae5425e20f25b763163ea5289fe6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaaedae5425e20f25b763163ea5289fe6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_width_doc,&quot;float : Gets or sets the width of this shape. \n\
\n\
A width can only be set or read for shapes of type ``shape.Square`` and \n\
``shape.Rectangle``. \n\
\n\
Raises \n\
------ \n\
TypeError \n\
    if this attribute is read or assigned for a type, that has no width defined.&quot;)</td></tr>
<tr class="separator:aaaedae5425e20f25b763163ea5289fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd2a64aefb262f3d0be1ada7a6aa531"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbd2a64aefb262f3d0be1ada7a6aa531"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_height_doc,&quot;float : Gets or sets the height of this shape. \n\
\n\
A height can only be set or read for shapes of type ``shape.Square`` and \n\
``shape.Rectangle``. \n\
\n\
Raises \n\
------ \n\
TypeError \n\
    if this attribute is read or assigned for a type, that has no height defined.&quot;)</td></tr>
<tr class="separator:afbd2a64aefb262f3d0be1ada7a6aa531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5b7f6ac70566175e943d14132b3a68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a5b7f6ac70566175e943d14132b3a68"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_getIndex_doc,&quot;int : Gets or sets the index of this shape. \n\
\n\
The default is -1, however if the shape is a geometric shape of a plot, an \n\
auto-incremented index is assigned once the shape is drawn or set. \n\
If &gt;= 0 it is possible to modify an existing shape with the same index.&quot;)</td></tr>
<tr class="separator:a0a5b7f6ac70566175e943d14132b3a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67789d971d196f02ac7dbafc3f225ac8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67789d971d196f02ac7dbafc3f225ac8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_getName_doc,&quot;str : Gets or sets the name (label) of this shape.&quot;)</td></tr>
<tr class="separator:a67789d971d196f02ac7dbafc3f225ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85395bfff7023431d7b3e7378af7f2ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85395bfff7023431d7b3e7378af7f2ea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_getColor_doc,&quot;None or rgba : Gets or sets color of this shape. \n\
\n\
The default color is an invalid color, given by the ``None`` value. \n\
The color of shapes is for instance be used for visualization purposes in plots.&quot;)</td></tr>
<tr class="separator:a85395bfff7023431d7b3e7378af7f2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba12642820aaa7b0ed0730f481b0d50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaba12642820aaa7b0ed0730f481b0d50"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_getTransform_doc,&quot;dataObject : gets or sets the affine, non scaled 2D transformation matrix as dataObject. \n\
\n\
The returned matrix is a ``2 x 3``, float64 :class:`dataObject`, where the left \n\
``2 x 2`` matrix describes a rotation matrix, and the right ``2 x 1`` part is the \n\
translation vector.&quot;)</td></tr>
<tr class="separator:aaba12642820aaa7b0ed0730f481b0d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced0cd50389358cee5b36bb615f8a776"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aced0cd50389358cee5b36bb615f8a776"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_getArea_doc,&quot;float : Get area of this shape \n\
\n\
Shapes of type ``shape.Line`` and ``shape.Point`` will always return 0.0.&quot;)</td></tr>
<tr class="separator:aced0cd50389358cee5b36bb615f8a776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a0c98c51134095e22a1c47eb06f0cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76a0c98c51134095e22a1c47eb06f0cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_rotateDeg_doc,&quot;rotateDeg(angle) \n\
\n\
Rotate shape by given angle in radians around the center point of this shape \n\
(counterclockwise). This method only affects the :attr:`transform` matrix, not the \n\
base points themselfs. \n\
\n\
Parameters \n\
----------- \n\
angle : float \n\
    is the rotation angle (in radians) by which the shape is rotated by its center. \n\
\n\
See Also \n\
--------- \n\
translate, rotateRad&quot;)</td></tr>
<tr class="separator:a76a0c98c51134095e22a1c47eb06f0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ee2cd24df77e200070cae4a0c3a5b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37ee2cd24df77e200070cae4a0c3a5b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_rotateRad_doc,&quot;rotateRad(angle) \n\
\n\
Rotate shape by given angle in radians around the center point of this shape \n\
(counterclockwise). This method only affects the :attr:`transform` matrix, not the \n\
base points themselfs. \n\
\n\
Parameters \n\
----------- \n\
angle : float \n\
    is the rotation angle (in radians) by which the shape is rotated by its center. \n\
\n\
See Also \n\
--------- \n\
translate, rotateDeg&quot;)</td></tr>
<tr class="separator:a37ee2cd24df77e200070cae4a0c3a5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23971a4b2de83d3b5f924c25777fcbef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23971a4b2de83d3b5f924c25777fcbef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_translate_doc,&quot;translate(dxy) \n\
\n\
Translate shape by given (dx, dy) value. \n\
\n\
Moves the shape by dx and dy along the x- and y-axis of the base coordinate system. \n\
This means, that dx and dy are added to the existing tx and ty values of the current \n\
transformation matrix. \n\
\n\
Parameters \n\
----------- \n\
dxy : sequence of float or dataObject or numpy.ndarray \n\
    array-like object with two elements, that define the desired ``dx`` and ``dy`` \n\
    component. \n\
\n\
See Also \n\
--------- \n\
rotateRad, rotateDeg&quot;)</td></tr>
<tr class="separator:a23971a4b2de83d3b5f924c25777fcbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dab2f167acfcf0ee634b4061a5ad80d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dab2f167acfcf0ee634b4061a5ad80d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_basePoints_doc,&quot;dataObject : base points of this shape, given as ``2 x M``, float64 dataObject. \n\
\n\
The ``M`` base points are untransformed points that describe the shape \n\
dependent on its type: \n\
\n\
* ``shape.Point``: one point \n\
* ``shape.Line`` : start point, end point \n\
* ``shape.Rectangle``, ``shape.Square`` : top left point, bottom right point \n\
* ``shape.Ellipse``, ``shape.Circle`` : top left point, bottom right point of bounding box \n\
* ``shape.Polygon`` : points of polygon, the last and first point are connected, too.&quot;)</td></tr>
<tr class="separator:a8dab2f167acfcf0ee634b4061a5ad80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e234559ce6b9c7b5318bb6e557be5c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e234559ce6b9c7b5318bb6e557be5c4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_region_doc,&quot;region() -&gt; region \n\
\n\
Returns a region object from this shape. \n\
\n\
The :class:`region` object only contains valid regions if the shape has an area &gt; 0. \n\
A region object is an integer based object (pixel raster), therefore the shapes \n\
are rounded to the nearest fixed-point coordinate. \n\
\n\
Returns \n\
------- \n\
region \n\
    The region, whose contour approximates this shape. The inner of \n\
    this shaped is part of the region.&quot;)</td></tr>
<tr class="separator:a0e234559ce6b9c7b5318bb6e557be5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9485b0f645ee4ec3035131f5222eb55c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9485b0f645ee4ec3035131f5222eb55c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_contour_doc,&quot;contour(applyTrafo = True, tol = -1.0) -&gt; dataObject \n\
\n\
Returns the contour points of this shape as ``2 x N``, float64 :class:`dataObject`. \n\
\n\
For most shapes, the contour is exactly given by its corner points. However for \n\
circles or ellipses, the contour has to be approximated by line segments. Use the \n\
argument ``tol`` to set the maximum distance between each line segment and the \n\
<a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> contour of the shape. If ``tol`` is set to -1.0, ``tol`` is assumed to be `1 %` \n\
of the smalles diameter. \n\
\n\
Shapes can have a transformation matrix (attribute :attr:`transform`). If ``applyTrafo`` \n\
is ``True``, the returned contour points correspond to the transformed base shape, else \n\
the contour with respect to the base points is returned. \n\
\n\
Parameters \n\
----------- \n\
applyTrafo : bool \n\
    Define if the transformation matrix (default: unity matrix, attribute :attr:`transform`) \n\
    should be considered for the returned contour points (``True``) or not (``False``). \n\
tol : float \n\
    Maximum tolerance to determine the approximated contour in the case of circular \n\
    or elliptical shapes. The approximated contour consists of line segments, that \n\
    can differ from the <a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> contour by a maximum of ``tol``. If -1.0, the tolerance \n\
    is assumed to be one percent of the smallest diameter.&quot;)</td></tr>
<tr class="separator:a9485b0f645ee4ec3035131f5222eb55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8196bdbce7f51afdedca23d11d232e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace8196bdbce7f51afdedca23d11d232e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_contains_doc,&quot;contains(points) -&gt; Union[bool, dataObject] \n\
\n\
Checks if one or multiple ``points`` are contained in this shape. \n\
\n\
Tests if one or multiple ``points`` lie within the contour of the given shape. If the \n\
shape has an empty area (e.g. points, line...) the test will always return ``False``.\n\
\n\
Parameters  \n\
------------\n\
points : sequence of float or dataObject or numpy.ndarray \n\
    The coordinates ``(x, y)`` of the point to be tested as sequence or an array-like \n\
    object (shape ``2 x N``), where the first row contains the x-coordinates and the \n\
    2nd-row the y-coordinates of ``N`` points to be tested. The array-like object \n\
    must be convertible to ``float64``, which is internally done before testing. \n\
\n\
Returns \n\
-------- \n\
result : bool or dataObject \n\
    If one point is passed as sequence, ``True`` is returned if this point is within \n\
    the contour of this shape, otherwise ``False``. If ``points`` is given as array-like \n\
    object, a ``1 x N`` :class:`dataObject` with dtype ``uint8`` is returned, where \n\
    the value ``255`` indicates, that the corresponding point is inside of the \n\
    shape's contour and ``0`` outside.&quot;)</td></tr>
<tr class="separator:ace8196bdbce7f51afdedca23d11d232e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11eb5aecb244d9bb520f8a68322cd4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab11eb5aecb244d9bb520f8a68322cd4f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_normalized_doc,&quot;normalized() -&gt; shape \n\
\n\
Returns the normalized version of this shape. \n\
\n\
The normalized shape guarantees that the bounding box of the shape never has a \n\
non-negative width or height. Therefore, the order or position of the two corner points \n\
(base points) is switched or changed, if necessary. Shapes different than \n\
rectangles, squares, circles or ellipses are not affected by this such that the \n\
original shape object is returned as it is. \n\
\n\
Returns \n\
------- \n\
normalized : shape \n\
    The normalized shape of this object (for types ``shape.Rectange``, ``shape.Square`` \n\
    ``shape.Circle`` or ``shape.Ellipse``) or this object (for all other types).&quot;)</td></tr>
<tr class="separator:ab11eb5aecb244d9bb520f8a68322cd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c511f0c9a01432f838ccb799454c86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78c511f0c9a01432f838ccb799454c86"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (shape_copy_doc,&quot;copy() -&gt; shape\n\
\n\
Returns a deep copy of this shape. \n\
\n\
Returns \n\
------- \n\
copy : shape \n\
    deep copy of this shape.&quot;)</td></tr>
<tr class="separator:a78c511f0c9a01432f838ccb799454c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e226700a26c4c941b5cff7786b97bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0e226700a26c4c941b5cff7786b97bd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>safeDecrefPyObject2</b> (PyObject *obj)</td></tr>
<tr class="separator:ad0e226700a26c4c941b5cff7786b97bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c60cea8f4c0e0ab37711f2dcb6da6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42c60cea8f4c0e0ab37711f2dcb6da6b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemInit_doc,&quot;uiItem(objectID, objName, widgetClassName, parentObj = None) -&gt; uiItem \\\n\
uiItem(parentObj, objName) -&gt; uiItem \n\
\n\
Base class that represents any widget or layout of an user interface. \n\
\n\
This class represents any widget (graphical, interactive element like a button or \n\
checkbox) on a graphical user interface. An object of this class provides many \n\
functionalities given by the underlying Qt system. For instance, it is posible to \n\
call a public slot of the corresponding widget, connect signals to specific python \n\
methods or functions or change properties of the widget represeted by this object. \n\
\n\
The overall dialog or window as main element of a graphical user interface itself are \n\
instances of the class :class:`ui`. However, they are derived from :class:`uiItem`, \n\
since dialogs or windows internally are widgets as well. \n\
\n\
Widgets, placed at a user interface using the Qt Designer, can be referenced by an \n\
:class:`uiItem` object by their specific ``objectName``, assigned in the Qt Designer \n\
as well. As an example, a simple dialog with one button is created and the text of \n\
the button (objectName: btn) is set to OK: :: \n\
    \n\
    dialog = ui('filename.ui', type=ui.TYPEDIALOG) \n\
    button = dialog.btn #here the reference to the button is obtained \n\
    button[\&quot;text\&quot;] = \&quot;OK\&quot; #set the property text of the button \n\
    \n\
Information about available properties, signals and slots can be obtained using the \n\
method :meth:`uiItem.info`. For more information about creating customized user \n\
interfaces, reference widgets and layouts etc, see the section :ref:`qtdesigner`. \n\
\n\
Parameters \n\
---------- \n\
objectID : int \n\
    is the itom internal identifier number for the widget or layout to be wrapped. \n\
objName : str \n\
    is the ``objectName`` property of the wrapped widget or layout. \n\
widgetClassName : str \n\
    is the Qt class name of the wrapped widget or layout (see :meth:`getClassName`). \n\
parentObj : uiItem \n\
    is the parent :class:`uiItem` of this wrapped widget or layout. \n\
\n\
Returns \n\
------- \n\
uiItem \n\
    is the new :class:`uiItem` object that wraps the indicated widget or layout. \n\
\n\
Notes \n\
------ \n\
It is not intended to directly instantiate this class. Either create a user interface \n\
using the class :class:`ui` or obtain a reference to an existing widget (this is then \n\
an instance of :class:`uiItem`) using the dot-operator of a parent widget or the entire \n\
user interface.&quot;)</td></tr>
<tr class="separator:a42c60cea8f4c0e0ab37711f2dcb6da6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f15abf16b806342c0c9390ea10e3f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1f15abf16b806342c0c9390ea10e3f7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemGetClassName_doc,&quot;getClassName() -&gt; str \n\
\n\
Returns the Qt class name of this uiItem (widget or layout).  \n\
\n\
Every :class:`uiItem` wraps a widget or layout of the user interface. \n\
This method returns the class name of this item, as it is given by the \n\
Qt framework. \n\
\n\
New in itom 4.1. \n\
\n\
Returns \n\
----------- \n\
className : str \n\
    The class name of this :class:`uiItem`.&quot;)</td></tr>
<tr class="separator:ae1f15abf16b806342c0c9390ea10e3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48eab161e2fd14eb1085dd65a9ddb4b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48eab161e2fd14eb1085dd65a9ddb4b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemCall_doc,&quot;call(publicSlotName, *args) \n\
\n\
Calls any public slot or other accessible public method of the widget or layout, referenced by this uiItem. \n\
\n\
This method calls a public or a 'wrapped' slot (see section :ref:`qtdesigner-wrappedslots`) \n\
of the widget or layout, that is referenced by this :class:`uiItem`. \n\
\n\
If only one slot with the given ``publicSlotName`` is available, all arguments ``*args`` \n\
are tried to be cast to the requested types and the slot is called then. If the \n\
designated slot has multiple possible overloads, at first, it is intended to find the \n\
overload where all arguments can be strictly cast from Python types to the indicated \n\
C-types. If this fails, the next overload with a successful, non-strict conversion is \n\
chosen. \n\
\n\
Information about all possible slots of this :class:`uiItem` can be obtained by the \n\
official Qt help or the method :meth:`uiItem.info`. \n\
\n\
Parameters \n\
----------- \n\
publicSlotName : str \n\
    name of the public slot or a specially wrapped slot of the widget or layout. \n\
*args : Any, optional\n\
    Variable length argument list, that is passed to the called slot. The type of each \n\
    value must be convertible to the requested C++ based argument type of the slot \n\
    (see section :ref:`qtdesigner-datatypes`).\n\
\n\
See Also \n\
--------- \n\
info&quot;)</td></tr>
<tr class="separator:a48eab161e2fd14eb1085dd65a9ddb4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f327bac48dea939902ab43498646057"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f327bac48dea939902ab43498646057"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemConnect_doc,&quot;connect(signalSignature, callableMethod, minRepeatInterval = 0) \n\
\n\
Connects a signal of this widget or layout with the given Python callback method. \n\
\n\
The widget or layout class, referenced by an :class:`uiItem` object, can emit \n\
different signals whenever a certain event occurs. See the official Qt help \n\
about a list of all possible signals or use the method :meth:`info` to get a \n\
print-out of a list of possible signals. This method is used to connect a certain \n\
callable Python callback method or function to a specific signal. The callable \n\
function can be bounded as well as unbounded. \n\
\n\
The connection is described by the string signature of the signal (hence the source of \n\
the connection). Such a signature is the name of the signal, followed by the types of \n\
its arguments (the original C++ types). An example is ``clicked(bool)``, \n\
emitted if a button has been clicked. This signal can be connected to a callback function \n\
with one argument, that will then contain the boolean click state of this signal. \n\
In case of a bounded method, the ``self`` argument must be given in any case. \n\
\n\
If the signal should have further arguments with specific datatypes, they are transformed \n\
into corresponding Python data types. A table of supported conversions is given in section \n\
:ref:`qtdesigner-datatypes`. In general, a ``callableMethod`` must be a method or \n\
function with the same number of parameters than the signal has (besides the \n\
``self`` argument). \n\
\n\
If a signal is emitted very often, it can be necessary to limit the call of the callback \n\
function to a certain minimum time interval. This can be given by the ``minRepeatInterval`` \n\
parameter. \n\
\n\
Parameters \n\
----------- \n\
signalSignature : str \n\
    This must be the valid signature, known from the Qt-method *connect* \n\
    (e.g. ``targetChanged(QVector&lt;double&gt;)``) \n\
callableMethod : callable \n\
    valid method or function that is called if the signal is emitted. \n\
minRepeatInterval : int, optional \n\
    If &gt; 0, the same signal only invokes a slot once within the given interval (in ms). \n\
    Default: 0 (all signals will invoke the callable python method. \n\
\n\
Notes \n\
----- \n\
The Python callback method can only be executed if Python is in an idle state. Else, \n\
the trigger is postponed to the next possible time. However, if you want for instance \n\
to have a button that interrupts a long Python operation, it is not possible to use \n\
this :meth:`connect` method to bind the click signal of this button with any \n\
Python script interruption, since the callback method will only be called if the long \n\
operation has finished. For these cases it is recommenden to connect the triggering \n\
signal (e.g. `clicked()`) by the :meth:`invokeKeyboardInterrupt` method. \n\
\n\
See Also \n\
--------- \n\
disconnect, info, invokeKeyboardInterrupt&quot;)</td></tr>
<tr class="separator:a3f327bac48dea939902ab43498646057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98f36341409cb300b16f3731b67c4c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af98f36341409cb300b16f3731b67c4c0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemConnectKeyboardInterrupt_doc,&quot;invokeKeyboardInterrupt(signalSignature) \n\
\n\
Connects the given signal with the immediate invokation of a Python interrupt signal. \n\
\n\
If you use the connect method to link a signal with a python method or function, this \n\
method can only be executed if Python is in an idle status. However, if you want to \n\
immediately raise the Python interrupt signal, use this method to establish the \n\
connection instead of the :meth:`uiItem.connect` command. \n\
\n\
Parameters \n\
----------- \n\
signalSignature : str \n\
    This must be the valid signature, known from the Qt-method *connect* \n\
    (e.g. 'clicked(bool)') \n\
\n\
See Also \n\
--------- \n\
connect, invokeProgressObserverCancellation&quot;)</td></tr>
<tr class="separator:af98f36341409cb300b16f3731b67c4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d92c01e68406a48d5c7f96e5a8f15e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d92c01e68406a48d5c7f96e5a8f15e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemConnectProgressObserverInterrupt_doc,&quot;invokeProgressObserverCancellation(signalSignature, observer) \n\
\n\
Connects the given signal to a slot immediately setting the cancellation flag of this object. \n\
\n\
This method immediately calls the ``requestCancellation`` slot of the given observer \n\
if the signal with the ``signalSignature`` is emitted (independent on the current \n\
state of the Python script execution). \n\
\n\
For more information about the class :class:`requestCancellation`, see also this \n\
section: :ref:`filter_interruptible`. \n\
\n\
Parameters \n\
----------- \n\
signalSignature : str \n\
    This must be the valid signature, known from the Qt-method *connect* \n\
    (e.g. 'clicked(bool)') \n\
observer : progressObserver \n\
    This must be a :class:`progressObserver` object. The given signal is connected \n\
    to the slot ``requestCancellation`` of this progressObserver.\n\
\n\
See Also \n\
--------- \n\
connect, invokeKeyboardInterrupt&quot;)</td></tr>
<tr class="separator:a9d92c01e68406a48d5c7f96e5a8f15e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0aaff9c9096cb7b3586568b97f26fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d0aaff9c9096cb7b3586568b97f26fe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemDisconnect_doc,&quot;disconnect(signalSignature, callableMethod) \n\
\n\
Disconnects a connection which must have been established before with exactly the same parameters.\n\
\n\
Parameters \n\
----------- \n\
signalSignature : str \n\
    This must be the valid signature, known from the Qt-method *connect* \n\
    (e.g. ``clicked(bool)``) \n\
callableMethod : callable \n\
    valid method or function, that should not be called any more if the \n\
    given signal is emitted. \n\
\n\
See Also \n\
--------- \n\
connect, info&quot;)</td></tr>
<tr class="separator:a4d0aaff9c9096cb7b3586568b97f26fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185803431800534276fc76980418630d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a185803431800534276fc76980418630d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemGetProperty_doc,&quot;getProperty(propertyName) -&gt; Union[Any, List[Any]] \n\
n\
Returns the requested property or a list of values for a sequence of requested properties. \n\
\n\
Use this method or the operator [] in order to get the value of one specific property \n\
of this widget or layout or of multiple properties. \n\
\n\
Multiple properties are given by a tuple or list of property names. For one single \n\
property, its value is returned as it is. If the property names are passed as sequence, \n\
a list of same size is returned with the corresponding values. \n\
\n\
Parameters \n\
----------- \n\
propertyName : str or list of str or tuple of str \n\
    Name of one property or sequence (tuple, list...) of property names. \n\
\n\
Returns \n\
------- \n\
value : Any or list of Any \n\
    the value of one single property of a list of values, if a sequence of ``propertyNames`` \n\
    is given as parameter. \n\
\n\
See Also \n\
--------- \n\
setProperty&quot;)</td></tr>
<tr class="separator:a185803431800534276fc76980418630d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72deaea59337478150798bfdfae5a6da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72deaea59337478150798bfdfae5a6da"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemSetProperty_doc,&quot;setProperty(propertyDict) \n\
\n\
Each property in the ``propertyDict`` is set to the dictionaries value. \n\
\n\
As an alternative, a single property can also be set using the operator []. \n\
\n\
Parameters \n\
----------- \n\
propertyDict : dict\n\
    Dictionary with properties (the keys are the property names) and the values \n\
    that should be set.\n\
\n\
See Also \n\
--------- \n\
getProperty&quot;)</td></tr>
<tr class="separator:a72deaea59337478150798bfdfae5a6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec376cb0c494a44e1bf5ccad4faa5a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ec376cb0c494a44e1bf5ccad4faa5a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemGetPropertyInfo_doc,&quot;getPropertyInfo(propertyName = None) -&gt; Union[dict, List[str]] \n\
\n\
Returns a list of all available property names or a dict of meta information of one given ``propertyName``. \n\
\n\
if ``propertyName`` is ``None``, a list of all property names is returned. Else, \n\
a ``Dict[str, Any]`` is returned with meta information about this property. \n\
The structure of this dictionary is as follows: \n\
\n\
* **name**: Name of the property (str). \n\
* **valid**: ``True`` if this property is valid (readable), otherwise ``False``. \n\
* **readable**: ``True`` if this property is readable, otherwise ``False``. \n\
* **writable**: ``True`` if this property can be set to another value, otherwise ``False``. \n\
* **resettable**: ``True`` if this property can be reset to a default value; otherwise returns ``False``. \n\
* **final**: ``True`` if this property is final and cannot be overwritten in derived classes, otherwise ``False``.\n\
* **constant**: ``True`` if this property is constant, otherwise ``False``.\n\
\n\
Parameters \n\
----------- \n\
propertyName : str, optional \n\
    The name of the property whose detailed information should be returned or \n\
    ``None``, if a list of all property names should be returned. \n\
\n\
Returns \n\
------- \n\
names : list of str \n\
    A list of all available property names. \n\
information : dict \n\
    The dictionary with meta information about this property (see above).&quot;)</td></tr>
<tr class="separator:a6ec376cb0c494a44e1bf5ccad4faa5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f317d40631527c859166d65f667373d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f317d40631527c859166d65f667373d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemGetAttribute_doc,&quot;getAttribute(attributeNumber) -&gt; bool \n\
\n\
Returns if a specific WidgetAttribute is set for the referenced widget. \n\
\n\
Widgets have specific attributes that influence their behaviour. These attributes \n\
are contained in the Qt-enumeration ``Qt::WidgetAttribute``. Use this method to \n\
query if the requested ``attributeNumber`` is set / enabled for the referenced widget. \n\
\n\
Important attributes are: \n\
\n\
* Qt::WA_DeleteOnClose (55) -&gt; deletes the widget when it is closed, else it is only \n\
  hidden [default] \n\
* Qt::WA_MouseTracking (2) -&gt; indicates that the widget has mouse tracking enabled \n\
\n\
Parameters \n\
----------- \n\
attributeNumber : int \n\
    Number of the attribute of the widget to query (see Qt enumeration \n\
    ``Qt::WidgetAttribute``) \n\
\n\
Returns \n\
------- \n\
bool \n\
    ``True`` if attribute is set (enabled), otherwise ``False``. \n\
\n\
See Also \n\
--------- \n\
setAttribute&quot;)</td></tr>
<tr class="separator:a6f317d40631527c859166d65f667373d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d818582520b84d49b8f64c60acc6ad1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d818582520b84d49b8f64c60acc6ad1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemSetAttribute_doc,&quot;setAttribute(attributeNumber, value) \n\
\n\
Enables or disables the attribute of the referenced widget.\n\
\n\
Widgets have specific attributes that influence their behaviour. These attributes \n\
are contained in the Qt-enumeration ``Qt::WidgetAttribute``. Use this method to \n\
enable or disable the requested widget attribute, given by its ``attributeNumber``. \n\
\n\
Important attributes are: \n\
\n\
* Qt::WA_DeleteOnClose (55) -&gt; deletes the widget when it is closed, else it is \n\
  only hidden [default]. \n\
* Qt::WA_MouseTracking (2) -&gt; indicates that the widget has mouse tracking enabled. \n\
\n\
Parameters \n\
----------- \n\
attributeNumber : int \n\
    Number of the attribute of the widget to set (enum ``Qt::WidgetAttribute``). \n\
value : bool \n\
    ``True`` if attribute should be enabled, else ``False``. \n\
\n\
See Also \n\
--------- \n\
getAttribute&quot;)</td></tr>
<tr class="separator:a0d818582520b84d49b8f64c60acc6ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca21b5c8c29110d9d69e2428ef67a25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acca21b5c8c29110d9d69e2428ef67a25"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemSetWindowFlags_doc,&quot;setWindowFlags(flags) \n\
\n\
Set the window flags of the referenced widget.\n\
\n\
The window flags are used to set the type of a widget, dialog or window including \n\
further hints to the window system. This method is used to set the entire \n\
or-combination of all ``flags``, contained in the Qt-enumeration ``Qt::WindowType``. \n\
\n\
Please consider, that you have to set all values in ``flags``, that should be \n\
active in the referenced widget. It is possible to get the current flags value of \n\
this widget using :meth:`getWindowFlags``, set or unset some enum values (bits) \n\
and set it again using this method. \n\
\n\
The most important types are: \n\
\n\
* Qt::Widget (0) -&gt; default type for widgets \n\
* Qt::Window (1) -&gt; the widget looks and behaves like a windows (title bar, window \n\
  frame...) \n\
* Qt::Dialog (3) -&gt; window decorated as dialog (no minimize or maximize button...) \n\
\n\
Further hints can be (among others): \n\
\n\
* Qt::FramelessWindowHint (0x00000800) -&gt; borderless window (user cannot move or \n\
  resize the window) \n\
* Qt::WindowTitleBar (0x00001000) -&gt; gives the window a title bar \n\
* Qt::WindowMinimizeButtonHint (0x00004000) -&gt; adds a minimize button to the \n\
  title bar \n\
* Qt::WindowMaximizeButtonHint (0x00008000) -&gt; adds a maximize button to the \n\
  title bar \n\
* Qt::WindowCloseButtonHint (0x00010000) -&gt; adds a close button. \n\
* Qt::WindowStaysOnTopHint (0x00040000) -&gt; this ui element always stays on top of \n\
  other windows \n\
* Qt::WindowCloseButtonHint (0x08000000) -&gt; remove this flag in order to disable the \n\
  close button \n\
\n\
Parameters \n\
----------- \n\
flags : int \n\
    window flags to set (or-combination, see ``Qt::WindowFlags``). \n\
\n\
See Also \n\
---------- \n\
getWindowFlags&quot;)</td></tr>
<tr class="separator:acca21b5c8c29110d9d69e2428ef67a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7040c07ab37243300872424babe5276d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7040c07ab37243300872424babe5276d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemGetWindowFlags_doc,&quot;getWindowFlags() -&gt; int \n\
\n\
Gets the window flags of the referenced widget. \n\
\n\
The returned ``flags`` value is an or-combination, hence bitmask, of enumeration \n\
values of the Qt enumeration ``Qt::WindowType``. \n\
\n\
Returns \n\
-------- \n\
flags : int \n\
    or-combination of ``Qt::WindowType`` describing the type and further hints \n\
    of the referenced widget. \n\
\n\
See Also \n\
--------- \n\
setWindowFlags&quot;)</td></tr>
<tr class="separator:a7040c07ab37243300872424babe5276d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf914e26ca39e6d297f707e349bb4a53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf914e26ca39e6d297f707e349bb4a53"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemInfo_doc,&quot;info(verbose = 0) \n\
\n\
Prints information about properties, public accessible slots and signals of the wrapped widget. \n\
\n\
Parameters \n\
----------- \n\
verbose : int \n\
    * ``0``: only properties, slots and signals that do not come from Qt-classes are \n\
      printed (default) \n\
    * ``1``: properties, slots and signals are printed up to Qt GUI base classes \n\
    * ``2``: all properties, slots and signals are printed&quot;)</td></tr>
<tr class="separator:acf914e26ca39e6d297f707e349bb4a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af191e5c1f7bce442db2432a5a347e179"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af191e5c1f7bce442db2432a5a347e179"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemExists_doc,&quot;exists() -&gt; bool \n\
\n\
Returns True if the widget or layout still exists, otherwise False. \n\
\n\
Returns \n\
------- \n\
bool \n\
    ``True`` if the referenced widget or layout still exists, otherwise ``False``.&quot;)</td></tr>
<tr class="separator:af191e5c1f7bce442db2432a5a347e179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cc15b96cb7d631eee6eaa377cbad99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45cc15b96cb7d631eee6eaa377cbad99"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemChildren_doc,&quot;children(recursive = False) -&gt; Dict[str, str] \n\
\n\
Returns a dict with all child items of the referenced widget. \n\
\n\
Each widget in an user interface can have multiple child items, like radio buttons \n\
within a group box or widgets within a layout. This method returns information about \n\
all child items of this :class:`uiItem`. A dictionary is returned with key-value \n\
pairs, where the key is the ``objectName`` of the child item, and the value its \n\
Qt class name (see :meth:`getClassName`). \n\
\n\
Child items without valid ``objectName`` are not contained in the returned dict. \n\
\n\
Parameters \n\
----------- \n\
recursive : bool \n\
    ``True``: all objects including sub-widgets of widgets are returned, \n\
    ``False``: only children of this :class:`uiItem` are returned (default). \n\
\n\
Returns \n\
------- \n\
dict \n\
    All child items of this item are returned.&quot;)</td></tr>
<tr class="separator:a45cc15b96cb7d631eee6eaa377cbad99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d088d7d484614853d362c14949a6b54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d088d7d484614853d362c14949a6b54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemGetChild_doc,&quot;getChild(widgetName) -&gt; uiItem \n\
\n\
Returns the uiItem of the child widget with the given ``widgetName``. \n\
\n\
This call is equal to ``self.widgetName``, where ``self`` is this :class:`uiItem`. \n\
\n\
Parameters \n\
----------- \n\
widgetName : str \n\
    ``objectName`` of the requested child widget or layout. \n\
\n\
Returns \n\
------- \n\
item : uiItem \n\
    The reference to the searched sub-widget (or layout).\n\
\n\
Raises \n\
------ \n\
AttributeError \n\
    if no widget / layout with ``widgetName`` as ``objectName`` exists.&quot;)</td></tr>
<tr class="separator:a9d088d7d484614853d362c14949a6b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd43275589e15689224bf0b24550dcff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd43275589e15689224bf0b24550dcff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyUiItemGetLayout_doc,&quot;getLayout() -&gt; Optional[uiItem] \n\
\n\
Returns the uiItem of the layout item of this widget (or None). \n\
\n\
Container widgets, like group boxes, tab widgets etc. as well as top level widgets \n\
of a custom user interface can have layouts, that are responsible to arrange \n\
possible child widgets. \n\
\n\
If this uiItem has such a layout, its reference is returned as :class:`uiItem`, too. \n\
Else ``None`` is returned. \n\
\n\
Returns \n\
------- \n\
layout : None or uiItem \n\
    The reference to the searched layout, or ``None`` if no such a layout exists.&quot;)</td></tr>
<tr class="separator:abd43275589e15689224bf0b24550dcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c62da5afd5b54b5a61bfd3f27615a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0c62da5afd5b54b5a61bfd3f27615a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiInit_doc,&quot;ui(filename, type = ui.TYPEDIALOG, dialogButtonBar = ui.BUTTONBAR_NO, dialogButtons = {}, childOfMainWindow = True, deleteOnClose = False, dockWidgetArea = ui.TOPDOCKWIDGETAREA) -&gt; ui \n\
\n\
Loads a user interface file (`ui`) and references this loaded interface by the new ui object. \n\
\n\
If the ui file is created in the `QtDesigner`, you can choose from which base type \n\
you would like to create the user interface (e.g. from a dialog, a window or a widget). \n\
This together with the argument ``type`` will mainly define the kind of user interface \n\
that is actually displayed in `itom`. \n\
\n\
If you want to add a customized user interface as toolbox or into the central part of \n\
the main window of `itom`, it is either recommended to design the interface from a \n\
widget or a main window. The latter has the advantage, that an individual menu or toolbar \n\
can be added. \n\
\n\
If you want to create a standalone window, it is recommended to already design the \n\
user interface from a main window, such that menus, toolbars as well as access to \n\
the statusbar is possible (if desired). \n\
\n\
For the creation of (modal) dialogs, where the user should configure settings or pass \n\
some inputs, it is recommended to either design the interface from a dialog on, or \n\
it is also possible to create a simple widget. In the latter case, itom will put \n\
this interface into a dialog (for ``type = ui.TYPEDIALOG``) and add optional buttons \n\
(like the ``OK`` and ``Cancel`` button). These buttons are then already configured \n\
to work. If you design a dialog from a dialog as base element, you have to connect \n\
buttons for instance with the ``accept()`` or ``reject()`` slot of the dialog by hand. \n\
\n\
For more information see also the section :ref:`qtdesigner` of the user documentation. \n\
\n\
Parameters \n\
----------- \n\
filename : str \n\
    path to the user interface file (.ui), absolute or relative to current directory. \n\
type : int, optional \n\
    This ``type`` defines how the loaded user interface is displayed: \n\
    \n\
    * ``ui.TYPEDIALOG`` (0): The ui-file is the content of a dialog window or, if the \n\
      file already defines a `QDialog`, this dialog is shown as it is. \n\
      This is recommended for the creation of modal dialogs, like settings... \n\
    * ``ui.TYPEWINDOW`` (1): The ui-file must be a `QMainWindow` or its outer widget \n\
      is turned into a main window. This window is then shown. This is recommended \n\
      for \&quot;standalone\&quot; windows, that should be able to be minimized, maximized, contain \n\
      menus or toolbars etc. \n\
    * ``ui.TYPEDOCKWIDGET`` (2): The loaded widget is the content of a dock widget (toolbox) \n\
      and is added to the indicated ``dockWidgetArea`` of the main window of `itom`. \n\
    * ``ui.TYPECENTRALWIDGET`` (3): The loaded ui-file must define a `QWidget` or \n\
      `QMainWindow` and is then added to the central area of `itom`, above the command line. \n\
      It is not allowed to choose this type if the user interface is created from \n\
      a `QDialog`. \n\
    \n\
dialogButtonBar : int, optional \n\
    This argument is only used if ``type == ui.TYPEDIALOG`` and defines if a button bar \n\
    with buttons, given by ``dialogButtons`` should be automatically added to the dialog. \n\
    If this is the case, the role of the buttons is considered, such that clicking the \n\
    ``OK`` or ``Cancel`` button  will automatically close the dialog and return the \n\
    role to the :meth:`show` method (if the dialog is displayed modal). Allowed values: \n\
    \n\
    * ``ui.BUTTONBAR_NO`` (0): do not add any button bar and buttons (default), \n\
    * ``ui.BUTTONBAR_HORIZONTAL`` (1): add a horizontal button bar at the bottom, \n\
    * ``ui.BUTTONBAR_VERTICAL`` (2): add vertical button bar on the right side. \n\
    \n\
dialogButtons : dict, optional \n\
    Only relevant if ``dialogButtonBar`` is not ``ui.BUTTONBAR_NO``: This dictionary \n\
    contains all buttons, that should be added to the button bar. For every entry, \n\
    the key is the role name of the button (enum ``QDialogButtonBox::ButtonRole``, \n\
    e.g. 'AcceptRole', 'RejectRole', 'ApplyRole', 'YesRole', 'NoRole'). The value is \n\
    the text of the button. \n\
childOfMainWindow : bool, optional \n\
    For type ``ui.TYPEDIALOG`` and ``ui.TYPEWINDOW`` only: Indicates if the window \n\
    should be a child of the itom main window. If ``False``, this window has its own \n\
    icon in the taskbar of the operating system. \n\
deleteOnClose : bool, optional \n\
    Indicates if the widget / window / dialog should be deleted if the user closes it \n\
    or if it is hidden. If it is hidden, it can be shown again using :meth:`show`. \n\
dockWidgetArea : int, optional \n\
    Only for ``type == ui.TYPEDOCKWIDGET (2)``. Indicates the position where the \n\
    dock widget should be placed: \n\
    \n\
    * 1 : ``ui.LEFTDOCKWIDGETAREA`` \n\
    * 2 : ``ui.RIGHTDOCKWIDGETAREA`` \n\
    * 4 : ``ui.TOPDOCKWIDGETAREA`` \n\
    * 8 : ``ui.BOTTOMDOCKWIDGETAREA`` \n\
\n\
Returns \n\
------- \n\
window : ui \n\
    A :class:`ui` object, that references the loaded ui-file.&quot;)</td></tr>
<tr class="separator:af0c62da5afd5b54b5a61bfd3f27615a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b8b6d14426280cc5ef057d9f0d0bf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8b8b6d14426280cc5ef057d9f0d0bf3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiShow_doc,&quot;show(modal = 0) -&gt; Optional[int] \n\
\n\
Shows the window or dialog. \n\
\n\
Parameters \n\
----------- \n\
modal : int, optional \n\
    * 0: non-modal, the opened GUI does not block other windows of itom (default)\n\
    * 1: modal (python waits until dialog is hidden)\n\
    * 2: modal (python returns immediately)\n\
\n\
Returns \n\
---------- \n\
None or int \n\
    Usually the value -1 is returned. Only if a dialog is shown with ``modal = 1``, \n\
    the exit code of the shown dialog is returned, once this dialog is closed again. \n\
    This code is: ``1`` if the dialog has been accepted (e.g. by closing it by an OK button \n\
    or ``0`` if the dialog has been rejected (Cancel button or directly closing the dialog \n\
    via the close icon in its title bar. \n\
\n\
See Also \n\
--------- \n\
hide&quot;)</td></tr>
<tr class="separator:ac8b8b6d14426280cc5ef057d9f0d0bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53087c9313f53951d43d1da1594a52a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53087c9313f53951d43d1da1594a52a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiHide_doc,&quot;hide() \n\
\n\
Hides the user interface reference by this ui object. \n\
\n\
A hidden window or dialog can be shown again via the method :py:meth:`show`.\n\
\n\
See Also \n\
--------- \n\
show&quot;)</td></tr>
<tr class="separator:a53087c9313f53951d43d1da1594a52a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f200b7fc6224aad53fb4285345cad9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f200b7fc6224aad53fb4285345cad9b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiIsVisible_doc,&quot;isVisible() -&gt; bool \n\
\n\
Returns ``True`` if the referenced window or dialog is still visible. \n\
\n\
Returns \n\
------- \n\
visible : bool \n\
    ``True`` if user interface is visible, ``False`` if it is hidden.&quot;)</td></tr>
<tr class="separator:a9f200b7fc6224aad53fb4285345cad9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dfb75be22938e492c6badeff523a85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37dfb75be22938e492c6badeff523a85"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>PyUiItem_Converter</b> (PyObject *object, <a class="el" href="structito_1_1_python_ui_1_1_py_ui_item.html">PythonUi::PyUiItem</a> **address)</td></tr>
<tr class="separator:a37dfb75be22938e492c6badeff523a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b67af70a442f71afe819e3d891df96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14b67af70a442f71afe819e3d891df96"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetDouble_doc,&quot;getDouble(title, label, defaultValue, min = -2147483647.0, max = 2147483647.0, decimals = 1, parent = None) -&gt; Tuple[float, bool] \n\
\n\
Shows a dialog to get a float value from the user. \n\
\n\
For more information, see also the section :ref:`msgInputBoxes` of the documentation. \n\
\n\
Parameters \n\
----------- \n\
title : str\n\
    is the title of the dialog. \n\
label : str \n\
    is the label above the input box. \n\
defaultValue : float \n\
    is the default value in the input box. \n\
min : float, optional \n\
    is the allowed minimal value. \n\
max : float, optional \n\
    is the allowed maximal value. \n\
decimals : int, optional \n\
    the maximum number of decimal places. \n\
parent : uiItem, optional \n\
    the dialog is modal with respect to ``parent`` or with respect to the \n\
    main window of `itom`, if ``None``. \n\
\n\
Returns \n\
------- \n\
value : float \n\
    The entered float value. \n\
success : bool \n\
    ``True`` if the dialog has been accepted, otherwise ``False``. \n\
\n\
See Also \n\
--------- \n\
getInt, getText, getItem&quot;)</td></tr>
<tr class="separator:a14b67af70a442f71afe819e3d891df96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6a68c068d37f870aa8904beb5ef8dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b6a68c068d37f870aa8904beb5ef8dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetInt_doc,&quot;getInt(title, label, defaultValue, min = -2147483647, max = 2147483647, step = 1, parent = None) -&gt; Tuple[int, bool] \n\
\n\
Shows a dialog to get an integer value from the user. \n\
\n\
For more information, see also the section :ref:`msgInputBoxes` of the documentation. \n\
\n\
Parameters \n\
----------- \n\
title : str\n\
    is the title of the dialog. \n\
label : str\n\
    is the label above the input box. \n\
defaultValue : int\n\
    is the default value in the input box. \n\
min : int, optional\n\
    is the allowed minimal value. \n\
max : int, optional\n\
    is the allowed maximal value. \n\
step : int, optional\n\
    is the step size if user presses the up/down arrow. \n\
parent : uiItem, optional \n\
    the dialog is modal with respect to ``parent`` or with respect to the \n\
    main window of `itom`, if ``None``. \n\
\n\
Returns \n\
------- \n\
value : int \n\
    The entered integer value. \n\
success : bool \n\
    ``True`` if the dialog has been accepted, otherwise ``False``. \n\
\n\
See Also \n\
--------- \n\
getDouble, getText, getItem&quot;)</td></tr>
<tr class="separator:a1b6a68c068d37f870aa8904beb5ef8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae67b58bcb70a6fdc7565effea5742d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ae67b58bcb70a6fdc7565effea5742d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetItem_doc,&quot;getItem(title, label, stringList, currentIndex = 0, editable = False, parent = None) -&gt; Tuple[str, bool] \n\
\n\
Shows a dialog to let the user select an item from a string list. \n\
\n\
For more information, see also the section :ref:`msgInputBoxes` of the documentation. \n\
\n\
Parameters \n\
----------- \n\
title : str \n\
    is the title of the dialog.\n\
label : str \n\
    is the label above the text box. \n\
stringList : list of str or tuple of str \n\
    is a list or tuple of possible string values. \n\
currentIndex : int, optional\n\
    defines the pre-selected value index from ``stringList``. \n\
editable : bool, optional\n\
    defines whether new entries can be added (``True``) or not (``False``) \n\
parent : uiItem, optional\n\
    the dialog is modal with respect to ``parent`` or with respect to the \n\
    main window of `itom`, if ``None``. \n\
\n\
Returns \n\
------- \n\
value : str \n\
    The currently selected or entered string value. \n\
success : bool \n\
    ``True`` if the dialog has been accepted, otherwise ``False``. \n\
\n\
See Also \n\
--------- \n\
getInt, getDouble, getText&quot;)</td></tr>
<tr class="separator:a1ae67b58bcb70a6fdc7565effea5742d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fc0e3e786ff3fcb9e4a7d1613942a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5fc0e3e786ff3fcb9e4a7d1613942a7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetText_doc,&quot;getText(title, label, defaultString, parent = None) -&gt; Tuple[str, bool] \n\
\n\
Opens a dialog to ask the user for a string value. \n\
\n\
For more information, see also the section :ref:`msgInputBoxes` of the documentation. \n\
\n\
Parameters \n\
----------- \n\
title : str \n\
    is the title of the dialog. \n\
label : str \n\
    is the label above the text box. \n\
defaultString : str \n\
    is the default string in the text box. \n\
parent : uiItem, optional \n\
    the dialog is modal with respect to ``parent`` or with respect to the \n\
    main window of `itom`, if ``None``. \n\
\n\
Returns \n\
------- \n\
value : str \n\
    The entered string value. \n\
success : bool \n\
    ``True`` if dialog has been accepted, otherwise ``False``. \n\
\n\
See Also \n\
--------- \n\
getInt, getDouble, getItem&quot;)</td></tr>
<tr class="separator:ac5fc0e3e786ff3fcb9e4a7d1613942a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72270845a7961fa19364792f5910e35e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72270845a7961fa19364792f5910e35e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiMsgInformation_doc,&quot;msgInformation(title, text, buttons = ui.MsgBoxOk, defaultButton = 0, parent = None) -&gt; Tuple[int, str] \n\
\n\
Opens an information message box. \n\
\n\
For more information, see also the section :ref:`msgInputBoxes` of the documentation. \n\
\n\
Parameters \n\
----------- \n\
title : str \n\
    is the title of the message box. \n\
text : str \n\
    is the message text \n\
buttons : int, optional \n\
    is a flag value (bitmask) of the constants ``ui.MsgBoxXYZ``, where ``XYZ`` is \n\
    a placeholder for different values. Each selected constant indicates the \n\
    corresponding button to display (combine values be the | operator). \n\
defaultButton : int, optional \n\
    is the button constant (see ``buttons``, that should be set as default. \n\
parent : uiItem, optional \n\
    If not ``None``, the dialog will be shown modal to this ``parent`` window. \n\
    Else, it is modal with respect to the main window of `itom`. \n\
\n\
Returns \n\
------- \n\
buttonID : int \n\
    constant of the button that has been clicked to close the message box. \n\
buttonText : str \n\
    caption of the button that has been clicked to close the message box. \n\
\n\
See Also \n\
--------- \n\
msgCritical, msgQuestion, msgWarning&quot;)</td></tr>
<tr class="separator:a72270845a7961fa19364792f5910e35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8fef7e43249cc0710ba796a0ed9726"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e8fef7e43249cc0710ba796a0ed9726"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiMsgQuestion_doc,&quot;msgQuestion(title, text, buttons = ui.MsgBoxOk, defaultButton = 0, parent = None) -&gt; Tuple[int, str] \n\
\n\
Opens a question message box. \n\
\n\
For more information, see also the section :ref:`msgInputBoxes` of the documentation. \n\
\n\
Parameters \n\
----------- \n\
title : str \n\
    is the title of the message box. \n\
text : str \n\
    is the message text \n\
buttons : int, optional \n\
    is a flag value (bitmask) of the constants ``ui.MsgBoxXYZ``, where ``XYZ`` is \n\
    a placeholder for different values. Each selected constant indicates the \n\
    corresponding button to display (combine values be the | operator). \n\
defaultButton : int, optional \n\
    is the button constant (see ``buttons``, that should be set as default. \n\
parent : uiItem, optional \n\
    If not ``None``, the dialog will be shown modal to this ``parent`` window. \n\
    Else, it is modal with respect to the main window of `itom`. \n\
\n\
Returns \n\
------- \n\
buttonID : int \n\
    constant of the button that has been clicked to close the message box. \n\
buttonText : str \n\
    caption of the button that has been clicked to close the message box. \n\
\n\
See Also \n\
--------- \n\
msgCritical, msgWarning, msgInformation&quot;)</td></tr>
<tr class="separator:a8e8fef7e43249cc0710ba796a0ed9726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc7f5c4b335fe911fc80e2b59e8ec0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cc7f5c4b335fe911fc80e2b59e8ec0b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiMsgWarning_doc,&quot;msgWarning(title, text, buttons = ui.MsgBoxOk, defaultButton = 0, parent = None) -&gt; Tuple[int, str] \n\
\n\
Opens a warning message box. \n\
\n\
For more information, see also the section :ref:`msgInputBoxes` of the documentation. \n\
\n\
Parameters \n\
----------- \n\
title : str \n\
    is the title of the message box. \n\
text : str \n\
    is the message text \n\
buttons : int, optional \n\
    is a flag value (bitmask) of the constants ``ui.MsgBoxXYZ``, where ``XYZ`` is \n\
    a placeholder for different values. Each selected constant indicates the \n\
    corresponding button to display (combine values be the | operator). \n\
defaultButton : int, optional \n\
    is the button constant (see ``buttons``, that should be set as default. \n\
parent : uiItem, optional \n\
    If not ``None``, the dialog will be shown modal to this ``parent`` window. \n\
    Else, it is modal with respect to the main window of `itom`. \n\
\n\
Returns \n\
------- \n\
buttonID : int \n\
    constant of the button that has been clicked to close the message box. \n\
buttonText : str \n\
    caption of the button that has been clicked to close the message box. \n\
\n\
See Also \n\
--------- \n\
msgCritical, msgQuestion, msgInformation&quot;)</td></tr>
<tr class="separator:a1cc7f5c4b335fe911fc80e2b59e8ec0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a766553181da205938368123f33d99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7a766553181da205938368123f33d99"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiMsgCritical_doc,&quot;msgCritical(title, text, buttons = ui.MsgBoxOk, defaultButton = 0, parent = None) -&gt; Tuple[int, str] \n\
\n\
Opens a critical message box. \n\
\n\
For more information, see also the section :ref:`msgInputBoxes` of the documentation. \n\
\n\
Parameters \n\
----------- \n\
title : str \n\
    is the title of the message box. \n\
text : str \n\
    is the message text \n\
buttons : int, optional \n\
    is a flag value (bitmask) of the constants ``ui.MsgBoxXYZ``, where ``XYZ`` is \n\
    a placeholder for different values. Each selected constant indicates the \n\
    corresponding button to display (combine values be the | operator). \n\
defaultButton : int, optional \n\
    is the button constant (see ``buttons``, that should be set as default. \n\
parent : uiItem, optional \n\
    If not ``None``, the dialog will be shown modal to this ``parent`` window. \n\
    Else, it is modal with respect to the main window of `itom`. \n\
\n\
Returns \n\
------- \n\
buttonID : int \n\
    constant of the button that has been clicked to close the message box. \n\
buttonText : str \n\
    caption of the button that has been clicked to close the message box. \n\
\n\
See Also \n\
--------- \n\
msgWarning, msgQuestion, msgInformation&quot;)</td></tr>
<tr class="separator:ad7a766553181da205938368123f33d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4a9dcb09d654081b96ac47fb469799"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d4a9dcb09d654081b96ac47fb469799"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetExistingDirectory_doc,&quot;getExistingDirectory(caption, startDirectory, options = 0, parent = None) -&gt; Optional[str] \n\
\n\
Opens a dialog to choose an existing directory. \n\
\n\
For more information, see also the section :ref:`msgInputBoxes` of the documentation. \n\
\n\
Parameters \n\
----------- \n\
caption : str \n\
    is the caption of this dialog. \n\
startDirectory : str \n\
    is the start directory, visible in the dialog. \n\
options : int, optional\n\
    is a flag value (bitmask) of the following options (see ``QFileDialog::Option``): \n\
    \n\
    * 1: ShowDirsOnly [default] \n\
    * 2: DontResolveSymlinks \n\
    * ... (for others see Qt-Help) \n\
    \n\
parent : uiItem, optional \n\
    If not ``None``, the dialog will be shown modal to this ``parent`` window. \n\
    Else, it is modal with respect to the main window of `itom`. \n\
\n\
Returns \n\
------- \n\
directory : None or str \n\
    The absolute path of the selected directory is returned or ``None`` if the dialog \n\
    has been rejected. \n\
\n\
See Also \n\
--------- \n\
getSaveFileName, getOpenFileName&quot;)</td></tr>
<tr class="separator:a7d4a9dcb09d654081b96ac47fb469799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8adb5922d4376a2f93f184ac8fa86cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8adb5922d4376a2f93f184ac8fa86cf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetOpenFileNames_doc,&quot;getOpenFileNames(caption = \&quot;\&quot;, startDirectory = \&quot;\&quot;, filters = \&quot;\&quot;, selectedFilterIndex = 0, options = 0, parent = None) -&gt; Optional[List[str]] \n\
\n\
Shows a dialog for chosing one or multiple file names. The selected file(s) must exist. \n\
\n\
This method creates a modal file dialog to let the user select one or multiple file \n\
names used for opening these files. \n\
\n\
For more information, see also the section :ref:`msgInputBoxes` of the documentation. \n\
\n\
Parameters \n\
----------- \n\
caption : str, optional \n\
    This is the title of the dialog. \n\
startDirectory : str, optional \n\
    The intial directory, shown in the dialog. If an empty string, the current working \n\
    directory will be taken. \n\
filters : str, optional \n\
    Possible filter list or allowed file types / suffixes etc. The entries should be \n\
    separated by ``;;``, for example ``Images (*.png *.jpg);;Text files (*.txt)``. \n\
selectedFilterIndex : int, optional \n\
    The index of the currently selected filter from ``filters``. \n\
options : int, optional\n\
    This corresponds to the Qt flag ``QFileDialog::Options``. \n\
parent : uiItem, optional \n\
    If not ``None``, the dialog will be shown modal to this ``parent`` window. \n\
    Else, it is modal with respect to the main window of `itom`. \n\
\n\
Returns \n\
------- \n\
selectedFileNames : None or list of str \n\
    The selected file pathes or ``None`` if the dialog has been aborted. \n\
\n\
See Also \n\
--------- \n\
getOpenFileName, getSaveFileName&quot;)</td></tr>
<tr class="separator:af8adb5922d4376a2f93f184ac8fa86cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b4419a8bc322caa4955861f92ffee9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16b4419a8bc322caa4955861f92ffee9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetOpenFileName_doc,&quot;getOpenFileName(caption = \&quot;\&quot;, startDirectory = \&quot;\&quot;, filters = \&quot;\&quot;, selectedFilterIndex = 0, options = 0, parent = None) -&gt; Optional[str] \n\
\n\
Shows a dialog for chosing a file name. The selected file must exist. \n\
\n\
This method creates a modal file dialog to let the user select a file name used for opening a file. \n\
\n\
For more information, see also the section :ref:`msgInputBoxes` of the documentation. \n\
\n\
Parameters \n\
----------- \n\
caption : str, optional \n\
    This is the title of the dialog. \n\
startDirectory : str, optional \n\
    The intial directory, shown in the dialog. If an empty string, the current working \n\
    directory will be taken. \n\
filters : str, optional \n\
    Possible filter list or allowed file types / suffixes etc. The entries should be \n\
    separated by ``;;``, for example ``Images (*.png *.jpg);;Text files (*.txt)``. \n\
selectedFilterIndex : int, optional \n\
    The index of the currently selected filter from ``filters``. \n\
options : int, optional\n\
    This corresponds to the Qt flag ``QFileDialog::Options``. \n\
parent : uiItem, optional \n\
    If not ``None``, the dialog will be shown modal to this ``parent`` window. \n\
    Else, it is modal with respect to the main window of `itom`. \n\
\n\
Returns \n\
------- \n\
selectedFileName : None or str \n\
    The selected file path or ``None`` if the dialog has been aborted. \n\
\n\
See Also \n\
--------- \n\
getOpenFileNames, getSaveFileName&quot;)</td></tr>
<tr class="separator:a16b4419a8bc322caa4955861f92ffee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5aff5dec1f85b799945297422afc0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f5aff5dec1f85b799945297422afc0c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiGetSaveFileName_doc,&quot;getSaveFileName(caption = \&quot;\&quot;, startDirectory = \&quot;\&quot;, filters = \&quot;\&quot;, selectedFilterIndex = 0, options = 0, parent = None) -&gt; Optional[str] \n\
\n\
Shows a dialog for chosing a file name. The selected file must not exist. \n\
\n\
This method creates a modal file dialog to let the user select a file name used for saving a file. \n\
\n\
For more information, see also the section :ref:`msgInputBoxes` of the documentation. \n\
\n\
Parameters \n\
----------- \n\
caption : str, optional \n\
    This is the title of the dialog. \n\
startDirectory : str, optional \n\
    The intial directory, shown in the dialog. If an empty string, the current working \n\
    directory will be taken. \n\
filters : str, optional \n\
    Possible filter list or allowed file types / suffixes etc. The entries should be \n\
    separated by ``;;``, for example ``Images (*.png *.jpg);;Text files (*.txt)``. \n\
selectedFilterIndex : int, optional \n\
    The index of the currently selected filter from ``filters``. \n\
options : int, optional\n\
    This corresponds to the Qt flag ``QFileDialog::Options``. \n\
parent : uiItem, optional \n\
    If not ``None``, the dialog will be shown modal to this ``parent`` window. \n\
    Else, it is modal with respect to the main window of `itom`. \n\
\n\
Returns \n\
------- \n\
selectedFileName : None or str \n\
    The selected file path or ``None`` if the dialog has been aborted. \n\
\n\
See Also \n\
--------- \n\
getOpenFileName&quot;)</td></tr>
<tr class="separator:a4f5aff5dec1f85b799945297422afc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8686bf788c49a979921a21bdef8e58f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8686bf788c49a979921a21bdef8e58f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiCreateNewPluginWidget_doc,&quot;createNewPluginWidget(widgetName, *args, **kwds) -&gt; ui \n\
\n\
Loads a widget, defined in an itom algorithm plugin, and returns the :class:`ui` object, that references this widget. \n\
\n\
Itom algorithm plugins cannot only contain algorithms, callable by Python, but also \n\
methods, that return a customized user-interface, widget etc. Use this method to \n\
initialize such an user-interface and returns its corresponding :class:`ui` object. \n\
\n\
For a list of available widget methods, see :meth:`widgetHelp`. Compared to the more \n\
detailed method :meth:`createNewPluginWidget2`, this method uses the following defaults \n\
for the windows appearance: \n\
\n\
* The ``type`` of the widget is derived from the widget itself and cannot be adjusted, \n\
* ``deleteOnClose = False``: The widget or windows will only be hidden if the user \n\
  clicks the close button, \n\
* ``childOfMainWindow = True``: The widget or windows is a child of the main window \n\
  without own symbol in the taskbar, \n\
* ``dockWidgetArea = ui.TOPDOCKWIDGETAREA``: If the widget is derived from `QDockWidget`, \n\
  the dock widget is docked at that location \n\
* ``buttonBarType = ui.BUTTONBAR_NO``, if a dialog is created (if the plugin delivers a \n\
  widget and no windows, dialog or dock widget), the dialog has no automatically \n\
  generated ``OK``, ``Cancel``, ``...`` buttons \n\
\n\
If you want to have other default parameters than these ones, call :meth:`createNewPluginWidget2`. \n\
\n\
Parameters \n\
----------- \n\
widgetName : str \n\
    Name of algorithm widget method. \n\
*args \n\
    Further positional arguments, that are parsed and passed to the widget creation method. \n\
    These arguments are used first to initialize all mandatory parameters, followed by \n\
    the optional ones. \n\
**kwds \n\
    Keyword-based arguments, that are parsed and passed together with the positional \n\
    arguments to the widget creation method. If one argument is given by its keyword, \n\
    no further positional arguments can follow. For this, the mandatory and optional \n\
    parameters of the widget creation method can be considered to be in one list, where \n\
    the optional parameters follow after the mandatory ones. \n\
\n\
Returns \n\
------- \n\
ui \n\
    :class:`ui` object, that represents the loaded widget, dialog or window. The type of \n\
    the ui is mainly defined by the type of the widget. If it is derived from `QMainWindow`, \n\
    a window is opened; if it is derived from `QDockWidget` a dock widget is created, in \n\
    all other cases a dialog is created. \n\
\n\
Notes \n\
----- \n\
Unlike it is the case at the creation of ui's from ui files, you can not directly \n\
parameterize behaviours like the ``deleteOnClose`` flag. This can however be done using \n\
:meth:`setAttribute`. \n\
\n\
See Also \n\
--------- \n\
createNewPluginWidget2, widgetHelp&quot;)</td></tr>
<tr class="separator:ac8686bf788c49a979921a21bdef8e58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5064e163a5b3a609119a1d485bc5ddc1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5064e163a5b3a609119a1d485bc5ddc1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiCreateNewPluginWidget2_doc,&quot;createNewPluginWidget2(widgetName, paramsArgs = [], paramsDict = {}, type = 0xFF, dialogButtonBar = ui.BUTTONBAR_NO, dialogButtons = {}, childOfMainWindow = True, deleteOnClose = False, dockWidgetArea = ui.TOPDOCKWIDGETAREA) -&gt; ui \n\
\n\
Loads a widget, defined in an itom algorithm plugin, and returns the :class:`ui` object, that references this widget. \n\
\n\
Itom algorithm plugins cannot only contain algorithms, callable by Python, but also \n\
methods, that return a customized user-interface, widget etc. Use this method to \n\
initialize such an user-interface and returns its corresponding :class:`ui` object. \n\
\n\
For a list of available widget methods, see :meth:`widgetHelp`. \n\
\n\
Parameters \n\
----------- \n\
widgetName : str \n\
    Name of algorithm widget method. \n\
paramsArgs : tuple \n\
    See ``paramsDict``. \n\
paramsDict : dict \n\
    The widget creation method in the algorithm plugin can depend on several mandatory \n\
    and / or optional parameters. For their initialization, the mandatory and optional \n\
    parameters are considered to be stacked together. At first, the ``paramsArgs`` \n\
    sequence is used to assign a certain number of parameters beginning with the \n\
    mandatory ones. If all ``paramsArgs`` values are assigned, the keyword-based \n\
    values in ``paramsDict`` are tried to be assigned to not yet used mandatory or \n\
    optional parameters. All mandatory parameters must be given (see \n\
    ``widgetHelp(widgetName)`` to obtain information about all required parameters. \n\
type : int, optional \n\
    Desired type of the newly created widget (a widget can also be a standalone dialog, \n\
    dockwidget or window): \n\
    \n\
    * 255 (default) : the type is derived from the original type of the widget, \n\
    * 0 (``ui.TYPEDIALOG``): the ui-file is embedded in auto-created dialog, \n\
    * 1 (``ui.TYPEWINDOW``): the ui-file is handled as main window, \n\
    * 2 (``ui.TYPEDOCKWIDGET``): the ui-file is handled as dock-widget and appended \n\
        to the main-window dock area, \n\
    * 3 (``ui.TYPECENTRALWIDGET``): the ui-file must be a widget or main window \n\
        and is included in the central area of itom, above the command line. \n\
    \n\
dialogButtonBar : int, optional \n\
    Only for ``type`` ``ui.TYPEDIALOG (0)``: Indicates if buttons should be automatically \n\
    added to the dialog: \n\
    \n\
    * 0 (``ui.BUTTONBAR_NO``): do not add any buttons (default), \n\
    * 1 (``ui.BUTTONBAR_HORIZONTAL``): add a horizontal button bar, \n\
    * 2 (``ui.BUTTONBAR_VERTICAL``): add a vertical button bar. \n\
    \n\
dialogButtons : dict, optional \n\
    Only relevant if ``dialogButtonBar`` is not ``ui.BUTTONBAR_NO``: This dictionary \n\
    contains all buttons, that should be added to the button bar. For every entry, \n\
    the key is the role name of the button (enum ``QDialogButtonBox::ButtonRole``, \n\
    e.g. 'AcceptRole', 'RejectRole', 'ApplyRole', 'YesRole', 'NoRole'). The value is \n\
    the text of the button. \n\
childOfMainWindow : bool, optional \n\
    For type ``ui.TYPEDIALOG`` and ``ui.TYPEWINDOW`` only: Indicates if the window \n\
    should be a child of the itom main window. If ``False``, this window has its own \n\
    icon in the taskbar of the operating system. \n\
deleteOnClose : bool, optional \n\
    Indicates if the widget / window / dialog should be deleted if the user closes it \n\
    or if it is hidden. If it is hidden, it can be shown again using :meth:`show`. \n\
dockWidgetArea : int, optional \n\
    Only for ``type`` ``ui.TYPEDOCKWIDGET (2)``. Indicates the position where the \n\
    dock widget should be placed: \n\
    \n\
    * 1 : ``ui.LEFTDOCKWIDGETAREA`` \n\
    * 2 : ``ui.RIGHTDOCKWIDGETAREA`` \n\
    * 4 : ``ui.TOPDOCKWIDGETAREA`` \n\
    * 8 : ``ui.BOTTOMDOCKWIDGETAREA`` \n\
\n\
Returns \n\
------- \n\
ui \n\
    :class:`ui` object, that represents the loaded widget, dialog or window. The type of \n\
    the ui is mainly defined by the type of the widget. If it is derived from `QMainWindow`, \n\
    a window is opened; if it is derived from `QDockWidget` a dock widget is created, in \n\
    all other cases a dialog is created. \n\
\n\
Notes \n\
----- \n\
Unlike it is the case at the creation of ui's from ui files, you can not directly \n\
parameterize behaviours like the ``deleteOnClose`` flag. This can however be done using \n\
:meth:`setAttribute`. \n\
\n\
See Also \n\
--------- \n\
createNewPluginWidget, widgetHelp&quot;)</td></tr>
<tr class="separator:a5064e163a5b3a609119a1d485bc5ddc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedbee0b16c70c22f77df5aaef74baf5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adedbee0b16c70c22f77df5aaef74baf5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (pyUiAvailableWidgets_doc,&quot;availableWidgets() -&gt; List[str] \n\
\n\
List of class names of all available widgets that can be directly loaded in an ui-file at runtime. \n\
\n\
Returns \n\
------- \n\
list of str \n\
    A list of the class names of all widgets, that can be directly loaded in an \n\
    user interface at runtime. These widgets can be built-in widgets of Qt as well \n\
    as additional widgets from designer plugins (like itom plots or other itom widgets.&quot;)</td></tr>
<tr class="separator:adedbee0b16c70c22f77df5aaef74baf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ee6ae3ebd933eb15d243e66336c2a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59ee6ae3ebd933eb15d243e66336c2a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyTimerInit_doc,&quot;timer(interval, callbackFunc, argTuple = (), singleShot = False, name = \&quot;\&quot;, startAfterInit = True) -&gt; timer \n\
\n\
Creates a new timer object for (continously) triggering a callback function \n\
\n\
Creates a timer object that (continuously) calls a python callback function or method. \n\
The timer is active right from the beginning, hence, after creating this object. \n\
If ``singleShot`` is ``True``, the callback function is triggered once after the \n\
interval is passed (denoted as timeout). Else, the callback is continuously triggered \n\
with the given interval. \n\
\n\
Please note, that the timer objects may time out later than expected if Python is \n\
currently busy or the operating system is unable to provide the requested accuracy. \n\
In such a case of timeout overrun, the callback function is only triggered once, \n\
even if multiple timeouts have expired, and then will resume the original interval. \n\
\n\
An active timer can be stopped by the :meth:`stop` method, or if this object is \n\
deleted. Furthermore, itom provides the :ref:`gui-timermanager` dialog, where \n\
all or selected timers can be started or stopped. \n\
\n\
**New in itom 4.1**: Added optional ``startAfterInit`` argument. \n\
\n\
Parameters \n\
----------- \n\
interval : int \n\
    Time out interval in ms. \n\
callbackFunc : callable \n\
    Python method (bounded) or function (unbounded) that should be called whenever \n\
    the timer event raises. \n\
argTuple : tuple, optional \n\
    Tuple of parameters passed as arguments to the callback function. \n\
singleShot : bool, optional \n\
    Defines if this timer only fires one time after its start (``True``) or \n\
    continuously (``False``, default). \n\
name : str, optional \n\
    Is the optional name of this timer. This name is displayed in the timer \n\
    manager dialog (instead of the timer ID, if no name is given. \n\
startAfterInit : bool, optional \n\
    If this optional boolean is set to False the timer will not start after initialization. \n\
    The timer can be started later by using timer.start(). \n\
\n\
Examples \n\
-------- \n\
&gt;&gt;&gt; import time \n\
... \n\
... def callbackFunc(startTime: float, a: int): \n\
...     print(\&quot;%.2f sec elapsed: %i\&quot; % (time.time() - startTime, a)) \n\
... \n\
... myTimer = timer(1000, callbackFunc, argTuple = (time.time(), 25)) \n\
\n\
1.00 sec elapsed: 25 \n\
2.01 sec elapsed : 25 \n\
3.01 sec elapsed : 25 \n\
4.01 sec elapsed : 25&quot;)</td></tr>
<tr class="separator:a59ee6ae3ebd933eb15d243e66336c2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e95ea4d9507410cea30da4ae27ceed6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e95ea4d9507410cea30da4ae27ceed6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyTimerStart_doc,&quot;start() \n\
\n\
Starts the timer. \n\
\n\
This method starts or restarts the timer with its timeout interval. \n\
If the timer is already running, it will be stopped and restarted. \n\
\n\
See Also \n\
--------- \n\
isActive, stop&quot;)</td></tr>
<tr class="separator:a0e95ea4d9507410cea30da4ae27ceed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9679789c40b27df07277dc3599507f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9679789c40b27df07277dc3599507f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyTimerStop_doc,&quot;stop() \n\
\n\
Stops the timer. \n\
\n\
This method stop the timer (if currently active). \n\
\n\
See Also \n\
--------- \n\
isActive, start&quot;)</td></tr>
<tr class="separator:ad9679789c40b27df07277dc3599507f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab757c3eff6d7f644c1639d8fa12d703"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab757c3eff6d7f644c1639d8fa12d703"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyTimerIsActive_doc,&quot;isActive() -&gt; bool \n\
\n\
Indicates if the timer is currently active. \n\
\n\
Returns \n\
------- \n\
bool \n\
    ``True`` if the timer is running, otherwise ``False``.&quot;)</td></tr>
<tr class="separator:aab757c3eff6d7f644c1639d8fa12d703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e371aba694846b0b197de4cb0997176"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e371aba694846b0b197de4cb0997176"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PyDoc_STRVAR</b> (PyTimerSetInterval_doc,&quot;setInterval(interval) \n\
\n\
Sets the timer interval in ms. \n\
\n\
This method sets the timeout interval in milliseconds. If the timer is started, \n\
the callback function is tried to be continously triggered whenever the interval \n\
expired. \n\
\n\
Parameters \n\
----------- \n\
interval : int \n\
    Timeout interval in milliseconds. \n\
\n\
Notes \n\
------ \n\
If Python is currently busy, a timer event can also be triggered at a later time, \n\
if the same trigger event is not already in the execution queue.&quot;)</td></tr>
<tr class="separator:a7e371aba694846b0b197de4cb0997176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa6438005e8abe525274b7f84405a91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8aa6438005e8abe525274b7f84405a91"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cmpStringIntPair</b> (const QPair&lt; QString, int &gt; &amp;a, const QPair&lt; QString, int &gt; &amp;b)</td></tr>
<tr class="separator:a8aa6438005e8abe525274b7f84405a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e95fc6f49db89d791190434cf98c30a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e95fc6f49db89d791190434cf98c30a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setColorButton</b> (const QColor &amp;color, <a class="el" href="class_color_picker_button.html">ColorPickerButton</a> *btn, QLabel *lbl, QLabel *ico)</td></tr>
<tr class="separator:a9e95fc6f49db89d791190434cf98c30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a3656f31e4d6ce4c86457749ebfce2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66a3656f31e4d6ce4c86457749ebfce2"></a>
QString&#160;</td><td class="memItemRight" valign="bottom"><b>dumpChildMenus</b> (const QString &amp;baseKey, const QAction *parent)</td></tr>
<tr class="separator:a66a3656f31e4d6ce4c86457749ebfce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a5bca3d612b5eb6e2c18269aa7ae02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24a5bca3d612b5eb6e2c18269aa7ae02"></a>
QString&#160;</td><td class="memItemRight" valign="bottom"><b>argsWordWrap</b> (QString text, int width)</td></tr>
<tr class="separator:a24a5bca3d612b5eb6e2c18269aa7ae02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3f825169556a2edbbf095cf3e68e40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a3f825169556a2edbbf095cf3e68e40"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>methodBoxAddItem</b> (QComboBox *methodBox, const QIcon &amp;icon, const QString &amp;methPre, const QString &amp;methArgs, const QString &amp;methPost, const QVariant &amp;userData)</td></tr>
<tr class="separator:a8a3f825169556a2edbbf095cf3e68e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d1667ae95cf6b1f5d73b1158ac1d13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1d1667ae95cf6b1f5d73b1158ac1d13"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>doDeleteLater</b> (QObject *obj)</td></tr>
<tr class="separator:ac1d1667ae95cf6b1f5d73b1158ac1d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c024c43b3d17174e8f0b14fdc09cd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a87c024c43b3d17174e8f0b14fdc09cd6">apiFCheckAndSetParamVal</a> (QVariant *tempParam, <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> *param, int *set)</td></tr>
<tr class="separator:a87c024c43b3d17174e8f0b14fdc09cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba757c479378ddaa7db70850c6590f3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aba757c479378ddaa7db70850c6590f3c">apiFParseInitParams</a> (QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *initParamListMand, QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *initParamListOpt, QVector&lt; QVariant &gt; *params)</td></tr>
<tr class="separator:aba757c479378ddaa7db70850c6590f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708f5dc838bfbc92c937b6e6c40df6df"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a708f5dc838bfbc92c937b6e6c40df6df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a708f5dc838bfbc92c937b6e6c40df6df">FreeFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr class="memdesc:a708f5dc838bfbc92c937b6e6c40df6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for freeing allocated data blocks  <a href="#a708f5dc838bfbc92c937b6e6c40df6df">More...</a><br /></td></tr>
<tr class="separator:a708f5dc838bfbc92c937b6e6c40df6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d73ecdcc47919a26ba8d340902589e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12d73ecdcc47919a26ba8d340902589e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (<a class="el" href="namespaceito.html#a708f5dc838bfbc92c937b6e6c40df6df">FreeFunc</a>)</td></tr>
<tr class="separator:a12d73ecdcc47919a26ba8d340902589e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcdb513572138377a5cb93dc672a62c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3dcdb513572138377a5cb93dc672a62c"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a3dcdb513572138377a5cb93dc672a62c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SecureFreeFunc</b> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr class="separator:a3dcdb513572138377a5cb93dc672a62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b147b959b34d59ef380276d466cd40f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b147b959b34d59ef380276d466cd40f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (SecureFreeFunc)</td></tr>
<tr class="separator:a6b147b959b34d59ef380276d466cd40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a25d4f45b211c3ca1f9fc1ef395ed0f"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a3a25d4f45b211c3ca1f9fc1ef395ed0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a3a25d4f45b211c3ca1f9fc1ef395ed0f">CreateFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned char dimensions, const int *sizes, const unsigned char continuous, const uchar *continuousDataPtr, const int *steps)</td></tr>
<tr class="memdesc:a3a25d4f45b211c3ca1f9fc1ef395ed0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">templated method for create  <a href="#a3a25d4f45b211c3ca1f9fc1ef395ed0f">More...</a><br /></td></tr>
<tr class="separator:a3a25d4f45b211c3ca1f9fc1ef395ed0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9df38c6970849400c840b0b767a5c9c"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:af9df38c6970849400c840b0b767a5c9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af9df38c6970849400c840b0b767a5c9c">CreateFuncWithCVPlanes</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const unsigned char dimensions, const int *sizes, const cv::Mat *planes, const unsigned int nrOfPlanes)</td></tr>
<tr class="memdesc:af9df38c6970849400c840b0b767a5c9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">templated method for creation with given vector of cv::Mat-planes  <a href="#af9df38c6970849400c840b0b767a5c9c">More...</a><br /></td></tr>
<tr class="separator:af9df38c6970849400c840b0b767a5c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12bc247542bd015830ad21b2b6ead367"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a12bc247542bd015830ad21b2b6ead367"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a12bc247542bd015830ad21b2b6ead367">CopyToFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, unsigned char regionOnly)</td></tr>
<tr class="memdesc:a12bc247542bd015830ad21b2b6ead367"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for deeply copying the data of one matrix to another given matrix  <a href="#a12bc247542bd015830ad21b2b6ead367">More...</a><br /></td></tr>
<tr class="separator:a12bc247542bd015830ad21b2b6ead367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b00918c766787b2d1cf28f26b73a8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70b00918c766787b2d1cf28f26b73a8f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (<a class="el" href="namespaceito.html#a12bc247542bd015830ad21b2b6ead367">CopyToFunc</a>)</td></tr>
<tr class="separator:a70b00918c766787b2d1cf28f26b73a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e8837df59dec7dcd384ebc68e258b1"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:ad8e8837df59dec7dcd384ebc68e258b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad8e8837df59dec7dcd384ebc68e258b1">DeepCopyPartialFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs)</td></tr>
<tr class="memdesc:ad8e8837df59dec7dcd384ebc68e258b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method to copy the values of the ROI of matrix lhs to the ROI of matrix rhs.  <a href="#ad8e8837df59dec7dcd384ebc68e258b1">More...</a><br /></td></tr>
<tr class="separator:ad8e8837df59dec7dcd384ebc68e258b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6bc2b9a495a2eb034bb4dbf560d04b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d6bc2b9a495a2eb034bb4dbf560d04b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (<a class="el" href="namespaceito.html#ad8e8837df59dec7dcd384ebc68e258b1">DeepCopyPartialFunc</a>)</td></tr>
<tr class="separator:a3d6bc2b9a495a2eb034bb4dbf560d04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a14d1532a9547f01a41b57dd64e042a"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a9a14d1532a9547f01a41b57dd64e042a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a9a14d1532a9547f01a41b57dd64e042a">ZerosFunc</a> (const int sizeY, const int sizeX, uchar **dstMat)</td></tr>
<tr class="memdesc:a9a14d1532a9547f01a41b57dd64e042a"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for creation of zero-valued matrix-plane  <a href="#a9a14d1532a9547f01a41b57dd64e042a">More...</a><br /></td></tr>
<tr class="separator:a9a14d1532a9547f01a41b57dd64e042a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959a36992393397a775dcf93deb711cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a959a36992393397a775dcf93deb711cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (<a class="el" href="namespaceito.html#a9a14d1532a9547f01a41b57dd64e042a">ZerosFunc</a>)</td></tr>
<tr class="separator:a959a36992393397a775dcf93deb711cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79848c29f024a20a641706c8b2cd108"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:ae79848c29f024a20a641706c8b2cd108"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae79848c29f024a20a641706c8b2cd108">OnesFunc</a> (const int sizeY, const int sizeX, uchar **dstMat)</td></tr>
<tr class="memdesc:ae79848c29f024a20a641706c8b2cd108"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for creation of one-valued matrix-plane  <a href="#ae79848c29f024a20a641706c8b2cd108">More...</a><br /></td></tr>
<tr class="separator:ae79848c29f024a20a641706c8b2cd108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a31866f858f93852031f3afe301335b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a2a31866f858f93852031f3afe301335b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a2a31866f858f93852031f3afe301335b">OnesFunc&lt; ito::Rgba32 &gt;</a> (const int sizeY, const int sizeX, uchar **dstMat)</td></tr>
<tr class="memdesc:a2a31866f858f93852031f3afe301335b"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, overloaded template method for creation of one-valued matrix-plane of RGBA32  <a href="#a2a31866f858f93852031f3afe301335b">More...</a><br /></td></tr>
<tr class="separator:a2a31866f858f93852031f3afe301335b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703ce71ad83db052ab6d3f552bdfe51e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a703ce71ad83db052ab6d3f552bdfe51e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (<a class="el" href="namespaceito.html#ae79848c29f024a20a641706c8b2cd108">OnesFunc</a>)</td></tr>
<tr class="separator:a703ce71ad83db052ab6d3f552bdfe51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0e8d58b54879f4392f4bfdffb8ff87"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a1e0e8d58b54879f4392f4bfdffb8ff87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a1e0e8d58b54879f4392f4bfdffb8ff87">NansFunc</a> (const int sizeY, const int sizeX, uchar **dstMat)</td></tr>
<tr class="memdesc:a1e0e8d58b54879f4392f4bfdffb8ff87"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for creation of one-valued matrix-plane  <a href="#a1e0e8d58b54879f4392f4bfdffb8ff87">More...</a><br /></td></tr>
<tr class="separator:a1e0e8d58b54879f4392f4bfdffb8ff87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5f0c5a77029b4abc9e8336aece8c93"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ade5f0c5a77029b4abc9e8336aece8c93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ade5f0c5a77029b4abc9e8336aece8c93">NansFunc&lt; ito::complex64 &gt;</a> (const int sizeY, const int sizeX, uchar **dstMat)</td></tr>
<tr class="memdesc:ade5f0c5a77029b4abc9e8336aece8c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, overloaded template method for creation of one-valued matrix-plane of complex64, complex128  <a href="#ade5f0c5a77029b4abc9e8336aece8c93">More...</a><br /></td></tr>
<tr class="separator:ade5f0c5a77029b4abc9e8336aece8c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa359ef83e7aaebc05bcd5288a7f2e806"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa359ef83e7aaebc05bcd5288a7f2e806"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa359ef83e7aaebc05bcd5288a7f2e806"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>NansFunc&lt; ito::complex128 &gt;</b> (const int sizeY, const int sizeX, uchar **dstMat)</td></tr>
<tr class="separator:aa359ef83e7aaebc05bcd5288a7f2e806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604b37c657ac0f1fbac7fcbae5fe545d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a604b37c657ac0f1fbac7fcbae5fe545d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (<a class="el" href="namespaceito.html#a1e0e8d58b54879f4392f4bfdffb8ff87">NansFunc</a>)</td></tr>
<tr class="separator:a604b37c657ac0f1fbac7fcbae5fe545d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f648a2c958cd46025c0fea3087da1a"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:ac2f648a2c958cd46025c0fea3087da1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ac2f648a2c958cd46025c0fea3087da1a">RandFunc</a> (const int sizeY, const int sizeX, const double value1, const double value2, const bool randMode, uchar **dstMat)</td></tr>
<tr class="memdesc:ac2f648a2c958cd46025c0fea3087da1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for creation of random-valued matrix-plane  <a href="#ac2f648a2c958cd46025c0fea3087da1a">More...</a><br /></td></tr>
<tr class="separator:ac2f648a2c958cd46025c0fea3087da1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194f174c066f155d01ffdbd3910e2b19"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a194f174c066f155d01ffdbd3910e2b19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a194f174c066f155d01ffdbd3910e2b19">RandFunc&lt; ito::complex128 &gt;</a> (const int sizeY, const int sizeX, const double value1, const double value2, const bool randMode, uchar **dstMat)</td></tr>
<tr class="memdesc:a194f174c066f155d01ffdbd3910e2b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for low-level, templated method for creation of random-valued matrix-plane of type complex128  <a href="#a194f174c066f155d01ffdbd3910e2b19">More...</a><br /></td></tr>
<tr class="separator:a194f174c066f155d01ffdbd3910e2b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e33be90b11da88529cd13863e68645"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a36e33be90b11da88529cd13863e68645"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a36e33be90b11da88529cd13863e68645">RandFunc&lt; ito::Rgba32 &gt;</a> (const int sizeY, const int sizeX, const double value1, const double value2, const bool randMode, uchar **dstMat)</td></tr>
<tr class="memdesc:a36e33be90b11da88529cd13863e68645"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for low-level, templated method for creation of random-valued matrix-plane of type rgba32  <a href="#a36e33be90b11da88529cd13863e68645">More...</a><br /></td></tr>
<tr class="separator:a36e33be90b11da88529cd13863e68645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5622772cb7e9b8e058588c74e918f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b5622772cb7e9b8e058588c74e918f0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (<a class="el" href="namespaceito.html#ac2f648a2c958cd46025c0fea3087da1a">RandFunc</a>)</td></tr>
<tr class="separator:a0b5622772cb7e9b8e058588c74e918f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4658756c87f46f61e4bd04b6db9a42"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:ade4658756c87f46f61e4bd04b6db9a42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ade4658756c87f46f61e4bd04b6db9a42">CopyMatFunc</a> (const uchar **src, uchar **&amp;dst, bool transposed, const int sizeofs)</td></tr>
<tr class="memdesc:ade4658756c87f46f61e4bd04b6db9a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method that executes a shallow-copy of every matrix-plane in the source-vector and stores the copies in the destination-vector  <a href="#ade4658756c87f46f61e4bd04b6db9a42">More...</a><br /></td></tr>
<tr class="separator:ade4658756c87f46f61e4bd04b6db9a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b3641a7cf5c73f04a4a614870f71de"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a63b3641a7cf5c73f04a4a614870f71de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a63b3641a7cf5c73f04a4a614870f71de">AssignScalarFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> type, const void *scalar)</td></tr>
<tr class="memdesc:a63b3641a7cf5c73f04a4a614870f71de"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated helper method to assign the given scalar to every element within its ROI in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix ">DataObject</a> src.  <a href="#a63b3641a7cf5c73f04a4a614870f71de">More...</a><br /></td></tr>
<tr class="separator:a63b3641a7cf5c73f04a4a614870f71de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cffb505679d9b9f57fa17777909920"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70cffb505679d9b9f57fa17777909920"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (<a class="el" href="namespaceito.html#a63b3641a7cf5c73f04a4a614870f71de">AssignScalarFunc</a>)</td></tr>
<tr class="separator:a70cffb505679d9b9f57fa17777909920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f6aedbf65b873bc1abddb99c288d8a"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a68f6aedbf65b873bc1abddb99c288d8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a68f6aedbf65b873bc1abddb99c288d8a">AssignScalarMaskFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *mask, const <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> type, const void *scalar)</td></tr>
<tr class="memdesc:a68f6aedbf65b873bc1abddb99c288d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated helper method to assign the given scalar to every element within its ROI in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix ">DataObject</a> src.  <a href="#a68f6aedbf65b873bc1abddb99c288d8a">More...</a><br /></td></tr>
<tr class="separator:a68f6aedbf65b873bc1abddb99c288d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba548418a4d2c85eb197fd5131ca180"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ba548418a4d2c85eb197fd5131ca180"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (<a class="el" href="namespaceito.html#a68f6aedbf65b873bc1abddb99c288d8a">AssignScalarMaskFunc</a>)</td></tr>
<tr class="separator:a4ba548418a4d2c85eb197fd5131ca180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16131a91987cc5836aaf3f3918319b4"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:ae16131a91987cc5836aaf3f3918319b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae16131a91987cc5836aaf3f3918319b4">AddFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjRes)</td></tr>
<tr class="memdesc:ae16131a91987cc5836aaf3f3918319b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all or some of the array elements to the specific value.  <a href="#ae16131a91987cc5836aaf3f3918319b4">More...</a><br /></td></tr>
<tr class="separator:ae16131a91987cc5836aaf3f3918319b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1c79b91475d5cb9717d5d26eb51fd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b1c79b91475d5cb9717d5d26eb51fd3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (<a class="el" href="namespaceito.html#ae16131a91987cc5836aaf3f3918319b4">AddFunc</a>)</td></tr>
<tr class="separator:a5b1c79b91475d5cb9717d5d26eb51fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83bfed0f50e7016e9ccf313e7a95296"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa83bfed0f50e7016e9ccf313e7a95296"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:aa83bfed0f50e7016e9ccf313e7a95296"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AddScalarFunc</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjIn, ito::float64 scalar, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut)</td></tr>
<tr class="separator:aa83bfed0f50e7016e9ccf313e7a95296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed06bef156a5d7412b13d65e34924d22"><td class="memTemplParams" colspan="2"><a class="anchor" id="aed06bef156a5d7412b13d65e34924d22"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aed06bef156a5d7412b13d65e34924d22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AddScalarFunc&lt; ito::Rgba32 &gt;</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjIn, ito::float64 scalar, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut)</td></tr>
<tr class="separator:aed06bef156a5d7412b13d65e34924d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99f2d9dd8a9d7dc93a2ee8386ab8e9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac99f2d9dd8a9d7dc93a2ee8386ab8e9e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (AddScalarFunc)</td></tr>
<tr class="separator:ac99f2d9dd8a9d7dc93a2ee8386ab8e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ac154f1b9a947d5d882a32e576134f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a98ac154f1b9a947d5d882a32e576134f"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a98ac154f1b9a947d5d882a32e576134f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AddComplexScalarFunc</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjIn, ito::complex128 scalar, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut)</td></tr>
<tr class="separator:a98ac154f1b9a947d5d882a32e576134f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0689afa9f75c41137f4e4d6d1001cabb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0689afa9f75c41137f4e4d6d1001cabb"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0689afa9f75c41137f4e4d6d1001cabb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AddComplexScalarFunc&lt; ito::complex64 &gt;</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjIn, ito::complex128 scalar, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut)</td></tr>
<tr class="separator:a0689afa9f75c41137f4e4d6d1001cabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0094382658bc1dc702fdf55f914bb9b8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0094382658bc1dc702fdf55f914bb9b8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0094382658bc1dc702fdf55f914bb9b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AddComplexScalarFunc&lt; ito::complex128 &gt;</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjIn, ito::complex128 scalar, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut)</td></tr>
<tr class="separator:a0094382658bc1dc702fdf55f914bb9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47cc48da91768ca44924834fa9101da"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae47cc48da91768ca44924834fa9101da"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae47cc48da91768ca44924834fa9101da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AddComplexScalarFunc&lt; ito::Rgba32 &gt;</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjIn, ito::complex128 scalar, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut)</td></tr>
<tr class="separator:ae47cc48da91768ca44924834fa9101da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4e846af0aed08147f68aae13cef4ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff4e846af0aed08147f68aae13cef4ff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (AddComplexScalarFunc)</td></tr>
<tr class="separator:aff4e846af0aed08147f68aae13cef4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b438d0eb2715bbea3a573820950808"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:af1b438d0eb2715bbea3a573820950808"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af1b438d0eb2715bbea3a573820950808">SubFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjRes)</td></tr>
<tr class="memdesc:af1b438d0eb2715bbea3a573820950808"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for element-wise subtraction of values from second data object from values of first data object  <a href="#af1b438d0eb2715bbea3a573820950808">More...</a><br /></td></tr>
<tr class="separator:af1b438d0eb2715bbea3a573820950808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5e6e41fcf95987cb8eddcdbaf95b34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a5e6e41fcf95987cb8eddcdbaf95b34"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (<a class="el" href="namespaceito.html#af1b438d0eb2715bbea3a573820950808">SubFunc</a>)</td></tr>
<tr class="separator:a7a5e6e41fcf95987cb8eddcdbaf95b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e47940e1e59401ab78b8844ef709634"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a6e47940e1e59401ab78b8844ef709634"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6e47940e1e59401ab78b8844ef709634">OpMulFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjRes)</td></tr>
<tr class="memdesc:a6e47940e1e59401ab78b8844ef709634"><td class="mdescLeft">&#160;</td><td class="mdescRight">brief description  <a href="#a6e47940e1e59401ab78b8844ef709634">More...</a><br /></td></tr>
<tr class="separator:a6e47940e1e59401ab78b8844ef709634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871edc6ab6966c9e12dc3ab4c08682e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a871edc6ab6966c9e12dc3ab4c08682e6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (<a class="el" href="namespaceito.html#a6e47940e1e59401ab78b8844ef709634">OpMulFunc</a>)</td></tr>
<tr class="separator:a871edc6ab6966c9e12dc3ab4c08682e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd31b9358f256cf6868667a0aa138c1b"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:abd31b9358f256cf6868667a0aa138c1b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#abd31b9358f256cf6868667a0aa138c1b">OpScalarMulFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const float64 &amp;factor)</td></tr>
<tr class="memdesc:abd31b9358f256cf6868667a0aa138c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which multiplies every element of Data Object with a factor  <a href="#abd31b9358f256cf6868667a0aa138c1b">More...</a><br /></td></tr>
<tr class="separator:abd31b9358f256cf6868667a0aa138c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c0c3e6184152b7f5226be04bc182b5"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad1c0c3e6184152b7f5226be04bc182b5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad1c0c3e6184152b7f5226be04bc182b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>OpScalarMulFunc&lt; ito::complex64 &gt;</b> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const float64 &amp;factor)</td></tr>
<tr class="separator:ad1c0c3e6184152b7f5226be04bc182b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337605658a1482cee80a91835c425728"><td class="memTemplParams" colspan="2"><a class="anchor" id="a337605658a1482cee80a91835c425728"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a337605658a1482cee80a91835c425728"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>OpScalarMulFunc&lt; ito::complex128 &gt;</b> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const float64 &amp;factor)</td></tr>
<tr class="separator:a337605658a1482cee80a91835c425728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b2eb0dc06ab3aa0cc9223684461ca1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a74b2eb0dc06ab3aa0cc9223684461ca1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a74b2eb0dc06ab3aa0cc9223684461ca1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>OpScalarMulFunc&lt; ito::Rgba32 &gt;</b> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const float64 &amp;factor)</td></tr>
<tr class="separator:a74b2eb0dc06ab3aa0cc9223684461ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd67b8ca703db1f6610f6b1e2b62701"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1cd67b8ca703db1f6610f6b1e2b62701"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (<a class="el" href="namespaceito.html#abd31b9358f256cf6868667a0aa138c1b">OpScalarMulFunc</a>)</td></tr>
<tr class="separator:a1cd67b8ca703db1f6610f6b1e2b62701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6564539e64aa7be317c6ec9575bb04fd"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a6564539e64aa7be317c6ec9575bb04fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6564539e64aa7be317c6ec9575bb04fd">OpScalarComplexMulFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const complex128 &amp;factor)</td></tr>
<tr class="memdesc:a6564539e64aa7be317c6ec9575bb04fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which multiplies every element of Data Object with a factor  <a href="#a6564539e64aa7be317c6ec9575bb04fd">More...</a><br /></td></tr>
<tr class="separator:a6564539e64aa7be317c6ec9575bb04fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d50c527b86d4abd2c830e4baaa92207"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2d50c527b86d4abd2c830e4baaa92207"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2d50c527b86d4abd2c830e4baaa92207"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>OpScalarComplexMulFunc&lt; ito::complex64 &gt;</b> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const complex128 &amp;factor)</td></tr>
<tr class="separator:a2d50c527b86d4abd2c830e4baaa92207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cde72d624817279d240faf9abf4fe57"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4cde72d624817279d240faf9abf4fe57"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4cde72d624817279d240faf9abf4fe57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>OpScalarComplexMulFunc&lt; ito::complex128 &gt;</b> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const complex128 &amp;factor)</td></tr>
<tr class="separator:a4cde72d624817279d240faf9abf4fe57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6567d6e2ee743ac9a3abf5fc68faaa77"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6567d6e2ee743ac9a3abf5fc68faaa77"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6567d6e2ee743ac9a3abf5fc68faaa77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>OpScalarComplexMulFunc&lt; ito::Rgba32 &gt;</b> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const complex128 &amp;factor)</td></tr>
<tr class="separator:a6567d6e2ee743ac9a3abf5fc68faaa77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b26d2c60930cd40b97d59791e55675"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43b26d2c60930cd40b97d59791e55675"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (<a class="el" href="namespaceito.html#a6564539e64aa7be317c6ec9575bb04fd">OpScalarComplexMulFunc</a>)</td></tr>
<tr class="separator:a43b26d2c60930cd40b97d59791e55675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dee1bec1740d52cf1ba8ff4dec6ae90"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a5dee1bec1740d52cf1ba8ff4dec6ae90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a5dee1bec1740d52cf1ba8ff4dec6ae90">CmpFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst, int cmpOp)</td></tr>
<tr class="memdesc:a5dee1bec1740d52cf1ba8ff4dec6ae90"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which compares each element in source-matrix1 with its corresponding element in source-matrix2 and saves the result in a destionation matrix  <a href="#a5dee1bec1740d52cf1ba8ff4dec6ae90">More...</a><br /></td></tr>
<tr class="separator:a5dee1bec1740d52cf1ba8ff4dec6ae90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ce88e15908f79d00e95dfa580b70d0"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a00ce88e15908f79d00e95dfa580b70d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a00ce88e15908f79d00e95dfa580b70d0">CmpFunc&lt; ito::complex64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst, int cmpOp)</td></tr>
<tr class="memdesc:a00ce88e15908f79d00e95dfa580b70d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for compare function of type complex64  <a href="#a00ce88e15908f79d00e95dfa580b70d0">More...</a><br /></td></tr>
<tr class="separator:a00ce88e15908f79d00e95dfa580b70d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de34931d48e4275b0cd02538fb79863"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a4de34931d48e4275b0cd02538fb79863"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a4de34931d48e4275b0cd02538fb79863">CmpFunc&lt; ito::complex128 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst, int cmpOp)</td></tr>
<tr class="memdesc:a4de34931d48e4275b0cd02538fb79863"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for compare function of type complex128  <a href="#a4de34931d48e4275b0cd02538fb79863">More...</a><br /></td></tr>
<tr class="separator:a4de34931d48e4275b0cd02538fb79863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8672ba101025b2928b4a284710e878d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8672ba101025b2928b4a284710e878d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (<a class="el" href="namespaceito.html#a5dee1bec1740d52cf1ba8ff4dec6ae90">CmpFunc</a>)</td></tr>
<tr class="separator:ae8672ba101025b2928b4a284710e878d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784dd21f0b5d7ce35191efc45d1c1417"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a784dd21f0b5d7ce35191efc45d1c1417"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a784dd21f0b5d7ce35191efc45d1c1417">CmpFuncScalar</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const float64 &amp;value, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst, int cmpOp)</td></tr>
<tr class="memdesc:a784dd21f0b5d7ce35191efc45d1c1417"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which compares each element in source-matrix1 with its corresponding element in source-matrix2 and saves the result in a destionation matrix  <a href="#a784dd21f0b5d7ce35191efc45d1c1417">More...</a><br /></td></tr>
<tr class="separator:a784dd21f0b5d7ce35191efc45d1c1417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e786be3b0546035be54c891e0e1808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a83e786be3b0546035be54c891e0e1808">CmpFuncScalar</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const ito::complex64 &amp;value, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst, int cmpOp)</td></tr>
<tr class="memdesc:a83e786be3b0546035be54c891e0e1808"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for compare function of type complex64  <a href="#a83e786be3b0546035be54c891e0e1808">More...</a><br /></td></tr>
<tr class="separator:a83e786be3b0546035be54c891e0e1808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f7fc946861f8806d9e62ec332a3459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a10f7fc946861f8806d9e62ec332a3459">CmpFuncScalar</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const ito::complex128 &amp;value, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dst, int cmpOp)</td></tr>
<tr class="memdesc:a10f7fc946861f8806d9e62ec332a3459"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for compare function of type complex128  <a href="#a10f7fc946861f8806d9e62ec332a3459">More...</a><br /></td></tr>
<tr class="separator:a10f7fc946861f8806d9e62ec332a3459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bd9641e2c02683184a8e76be9a0ec1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07bd9641e2c02683184a8e76be9a0ec1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (<a class="el" href="namespaceito.html#a784dd21f0b5d7ce35191efc45d1c1417">CmpFuncScalar</a>)</td></tr>
<tr class="separator:a07bd9641e2c02683184a8e76be9a0ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a9c5dc6bb068b2ce6be93f0fcf4b9f"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a66a9c5dc6bb068b2ce6be93f0fcf4b9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a66a9c5dc6bb068b2ce6be93f0fcf4b9f">ShiftLFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const unsigned char shiftbit)</td></tr>
<tr class="memdesc:a66a9c5dc6bb068b2ce6be93f0fcf4b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which element-wisely shifts the values of the source matrix by a certain value to the left  <a href="#a66a9c5dc6bb068b2ce6be93f0fcf4b9f">More...</a><br /></td></tr>
<tr class="separator:a66a9c5dc6bb068b2ce6be93f0fcf4b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d19fd38859c027dcf514812e987c9ee"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a6d19fd38859c027dcf514812e987c9ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6d19fd38859c027dcf514812e987c9ee">ShiftLFunc&lt; ito::float32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr class="memdesc:a6d19fd38859c027dcf514812e987c9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type float32  <a href="#a6d19fd38859c027dcf514812e987c9ee">More...</a><br /></td></tr>
<tr class="separator:a6d19fd38859c027dcf514812e987c9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de5cddc9cbf637156d3acc27566e4b1"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a8de5cddc9cbf637156d3acc27566e4b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8de5cddc9cbf637156d3acc27566e4b1">ShiftLFunc&lt; ito::float64 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr class="memdesc:a8de5cddc9cbf637156d3acc27566e4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type float64  <a href="#a8de5cddc9cbf637156d3acc27566e4b1">More...</a><br /></td></tr>
<tr class="separator:a8de5cddc9cbf637156d3acc27566e4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2674629cfb1e34316dd627781bfa3c0"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa2674629cfb1e34316dd627781bfa3c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa2674629cfb1e34316dd627781bfa3c0">ShiftLFunc&lt; ito::complex64 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr class="memdesc:aa2674629cfb1e34316dd627781bfa3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type complex64  <a href="#aa2674629cfb1e34316dd627781bfa3c0">More...</a><br /></td></tr>
<tr class="separator:aa2674629cfb1e34316dd627781bfa3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c24130d3ca6d2a459d5bf2a8a4b92b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a23c24130d3ca6d2a459d5bf2a8a4b92b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a23c24130d3ca6d2a459d5bf2a8a4b92b">ShiftLFunc&lt; ito::complex128 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr class="memdesc:a23c24130d3ca6d2a459d5bf2a8a4b92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type complex128  <a href="#a23c24130d3ca6d2a459d5bf2a8a4b92b">More...</a><br /></td></tr>
<tr class="separator:a23c24130d3ca6d2a459d5bf2a8a4b92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842490cbe28559727556af0e04bdc24a"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a842490cbe28559727556af0e04bdc24a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a842490cbe28559727556af0e04bdc24a">ShiftLFunc&lt; ito::Rgba32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr class="memdesc:a842490cbe28559727556af0e04bdc24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type rgba32  <a href="#a842490cbe28559727556af0e04bdc24a">More...</a><br /></td></tr>
<tr class="separator:a842490cbe28559727556af0e04bdc24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5006e9d24601a9faad68be2dafaf3d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5006e9d24601a9faad68be2dafaf3d7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (<a class="el" href="namespaceito.html#a66a9c5dc6bb068b2ce6be93f0fcf4b9f">ShiftLFunc</a>)</td></tr>
<tr class="separator:aa5006e9d24601a9faad68be2dafaf3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8040457b6c031cbefb51fbdae76a3bb"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:ab8040457b6c031cbefb51fbdae76a3bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab8040457b6c031cbefb51fbdae76a3bb">ShiftRFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const unsigned char shiftbit)</td></tr>
<tr class="memdesc:ab8040457b6c031cbefb51fbdae76a3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which element-wisely shifts the values of the source matrix by a certain value to the right  <a href="#ab8040457b6c031cbefb51fbdae76a3bb">More...</a><br /></td></tr>
<tr class="separator:ab8040457b6c031cbefb51fbdae76a3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb30836cf7a7a0a3f21cf6fc35848eb"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aabb30836cf7a7a0a3f21cf6fc35848eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aabb30836cf7a7a0a3f21cf6fc35848eb">ShiftRFunc&lt; ito::float32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr class="memdesc:aabb30836cf7a7a0a3f21cf6fc35848eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type float32  <a href="#aabb30836cf7a7a0a3f21cf6fc35848eb">More...</a><br /></td></tr>
<tr class="separator:aabb30836cf7a7a0a3f21cf6fc35848eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b338e54a07664315beb473504a2c8d1"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a8b338e54a07664315beb473504a2c8d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8b338e54a07664315beb473504a2c8d1">ShiftRFunc&lt; ito::float64 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr class="memdesc:a8b338e54a07664315beb473504a2c8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type float64  <a href="#a8b338e54a07664315beb473504a2c8d1">More...</a><br /></td></tr>
<tr class="separator:a8b338e54a07664315beb473504a2c8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad405a0a85400adc16e1c3b1f4e1884b9"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ad405a0a85400adc16e1c3b1f4e1884b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad405a0a85400adc16e1c3b1f4e1884b9">ShiftRFunc&lt; ito::complex64 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr class="memdesc:ad405a0a85400adc16e1c3b1f4e1884b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type complex64  <a href="#ad405a0a85400adc16e1c3b1f4e1884b9">More...</a><br /></td></tr>
<tr class="separator:ad405a0a85400adc16e1c3b1f4e1884b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06888f8baac8366f96641426371bb39"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af06888f8baac8366f96641426371bb39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af06888f8baac8366f96641426371bb39">ShiftRFunc&lt; ito::complex128 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr class="memdesc:af06888f8baac8366f96641426371bb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type complex128  <a href="#af06888f8baac8366f96641426371bb39">More...</a><br /></td></tr>
<tr class="separator:af06888f8baac8366f96641426371bb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3098f35e70fda092a104ac6be8b223c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ae3098f35e70fda092a104ac6be8b223c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae3098f35e70fda092a104ac6be8b223c">ShiftRFunc&lt; ito::Rgba32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const unsigned char)</td></tr>
<tr class="memdesc:ae3098f35e70fda092a104ac6be8b223c"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for shift function of type rgba32  <a href="#ae3098f35e70fda092a104ac6be8b223c">More...</a><br /></td></tr>
<tr class="separator:ae3098f35e70fda092a104ac6be8b223c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af958d9bca56f7971bc30feac415bdaae"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:af958d9bca56f7971bc30feac415bdaae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af958d9bca56f7971bc30feac415bdaae">BitAndFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjRes)</td></tr>
<tr class="memdesc:af958d9bca56f7971bc30feac415bdaae"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which element-wisely executes a bitwise 'and' comparison between values of two dataObjects.  <a href="#af958d9bca56f7971bc30feac415bdaae">More...</a><br /></td></tr>
<tr class="separator:af958d9bca56f7971bc30feac415bdaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab899e141a3847b1a7035c5e56332d6e9"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ab899e141a3847b1a7035c5e56332d6e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab899e141a3847b1a7035c5e56332d6e9">BitAndFunc&lt; ito::float32 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:ab899e141a3847b1a7035c5e56332d6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise and function of type float32  <a href="#ab899e141a3847b1a7035c5e56332d6e9">More...</a><br /></td></tr>
<tr class="separator:ab899e141a3847b1a7035c5e56332d6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3d086c4a7eed78b88a34ad1219dd06"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aef3d086c4a7eed78b88a34ad1219dd06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aef3d086c4a7eed78b88a34ad1219dd06">BitAndFunc&lt; ito::float64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:aef3d086c4a7eed78b88a34ad1219dd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise and function of type float64  <a href="#aef3d086c4a7eed78b88a34ad1219dd06">More...</a><br /></td></tr>
<tr class="separator:aef3d086c4a7eed78b88a34ad1219dd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80cc5a38859d11ae5b8b5d4f9c8c3c9"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa80cc5a38859d11ae5b8b5d4f9c8c3c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa80cc5a38859d11ae5b8b5d4f9c8c3c9">BitAndFunc&lt; ito::complex64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:aa80cc5a38859d11ae5b8b5d4f9c8c3c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise and function of type complex64  <a href="#aa80cc5a38859d11ae5b8b5d4f9c8c3c9">More...</a><br /></td></tr>
<tr class="separator:aa80cc5a38859d11ae5b8b5d4f9c8c3c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2da43a120dd1da62b1d0dfac9ed4b1"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:afc2da43a120dd1da62b1d0dfac9ed4b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#afc2da43a120dd1da62b1d0dfac9ed4b1">BitAndFunc&lt; ito::complex128 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:afc2da43a120dd1da62b1d0dfac9ed4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise and function of type complex128  <a href="#afc2da43a120dd1da62b1d0dfac9ed4b1">More...</a><br /></td></tr>
<tr class="separator:afc2da43a120dd1da62b1d0dfac9ed4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8776a0f7f23f1c21e9ecf6f513fba0f"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aa8776a0f7f23f1c21e9ecf6f513fba0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa8776a0f7f23f1c21e9ecf6f513fba0f">BitAndFunc&lt; ito::Rgba32 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:aa8776a0f7f23f1c21e9ecf6f513fba0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise and function of type rgba32  <a href="#aa8776a0f7f23f1c21e9ecf6f513fba0f">More...</a><br /></td></tr>
<tr class="separator:aa8776a0f7f23f1c21e9ecf6f513fba0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f26f22cf37ce14606bd6dde853f1e8b"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a5f26f22cf37ce14606bd6dde853f1e8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a5f26f22cf37ce14606bd6dde853f1e8b">BitOrFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjRes)</td></tr>
<tr class="memdesc:a5f26f22cf37ce14606bd6dde853f1e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which element-wisely executes a bitwise 'or' comparison between values of two dataObjects.  <a href="#a5f26f22cf37ce14606bd6dde853f1e8b">More...</a><br /></td></tr>
<tr class="separator:a5f26f22cf37ce14606bd6dde853f1e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0b5996a50ddcab865510a424d3d7a4"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a3b0b5996a50ddcab865510a424d3d7a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a3b0b5996a50ddcab865510a424d3d7a4">BitOrFunc&lt; ito::float32 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:a3b0b5996a50ddcab865510a424d3d7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise or function of type float32  <a href="#a3b0b5996a50ddcab865510a424d3d7a4">More...</a><br /></td></tr>
<tr class="separator:a3b0b5996a50ddcab865510a424d3d7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82f393b489f72f5206cfe1fc7e43f93"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ae82f393b489f72f5206cfe1fc7e43f93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae82f393b489f72f5206cfe1fc7e43f93">BitOrFunc&lt; ito::float64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:ae82f393b489f72f5206cfe1fc7e43f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise or function of type float64  <a href="#ae82f393b489f72f5206cfe1fc7e43f93">More...</a><br /></td></tr>
<tr class="separator:ae82f393b489f72f5206cfe1fc7e43f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4a9bac68a02e69f63828971fb69676"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a6f4a9bac68a02e69f63828971fb69676"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6f4a9bac68a02e69f63828971fb69676">BitOrFunc&lt; ito::complex64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:a6f4a9bac68a02e69f63828971fb69676"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise or function of type complex64  <a href="#a6f4a9bac68a02e69f63828971fb69676">More...</a><br /></td></tr>
<tr class="separator:a6f4a9bac68a02e69f63828971fb69676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf39908f4328b8cf684b090560adb3a"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a6bf39908f4328b8cf684b090560adb3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6bf39908f4328b8cf684b090560adb3a">BitOrFunc&lt; ito::complex128 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:a6bf39908f4328b8cf684b090560adb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise or function of type complex128  <a href="#a6bf39908f4328b8cf684b090560adb3a">More...</a><br /></td></tr>
<tr class="separator:a6bf39908f4328b8cf684b090560adb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1ddf3b0cca77656d7af70ed5eef801"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ada1ddf3b0cca77656d7af70ed5eef801"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ada1ddf3b0cca77656d7af70ed5eef801">BitOrFunc&lt; ito::Rgba32 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:ada1ddf3b0cca77656d7af70ed5eef801"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise or function of type rgba32  <a href="#ada1ddf3b0cca77656d7af70ed5eef801">More...</a><br /></td></tr>
<tr class="separator:ada1ddf3b0cca77656d7af70ed5eef801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e15e2fb2cba5fe01f96cc66b65c8345"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a7e15e2fb2cba5fe01f96cc66b65c8345"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a7e15e2fb2cba5fe01f96cc66b65c8345">BitXorFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjRes)</td></tr>
<tr class="memdesc:a7e15e2fb2cba5fe01f96cc66b65c8345"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which element-wisely executes a bitwise 'xor' comparison between values of two dataObjects.  <a href="#a7e15e2fb2cba5fe01f96cc66b65c8345">More...</a><br /></td></tr>
<tr class="separator:a7e15e2fb2cba5fe01f96cc66b65c8345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af127d3f60daba576c1b4245e96817e52"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af127d3f60daba576c1b4245e96817e52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af127d3f60daba576c1b4245e96817e52">BitXorFunc&lt; ito::float32 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:af127d3f60daba576c1b4245e96817e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise xor function of type float32  <a href="#af127d3f60daba576c1b4245e96817e52">More...</a><br /></td></tr>
<tr class="separator:af127d3f60daba576c1b4245e96817e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c68147de5f601fd5ea7b53735c5096"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a55c68147de5f601fd5ea7b53735c5096"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a55c68147de5f601fd5ea7b53735c5096">BitXorFunc&lt; ito::float64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:a55c68147de5f601fd5ea7b53735c5096"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise xor function of type float64  <a href="#a55c68147de5f601fd5ea7b53735c5096">More...</a><br /></td></tr>
<tr class="separator:a55c68147de5f601fd5ea7b53735c5096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98551d38290fbe3f94b77ef58972dda8"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a98551d38290fbe3f94b77ef58972dda8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a98551d38290fbe3f94b77ef58972dda8">BitXorFunc&lt; ito::complex64 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:a98551d38290fbe3f94b77ef58972dda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise xor function of type complex64  <a href="#a98551d38290fbe3f94b77ef58972dda8">More...</a><br /></td></tr>
<tr class="separator:a98551d38290fbe3f94b77ef58972dda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf73d910b4e9d9c344b2b389f9973720"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:adf73d910b4e9d9c344b2b389f9973720"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#adf73d910b4e9d9c344b2b389f9973720">BitXorFunc&lt; ito::complex128 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:adf73d910b4e9d9c344b2b389f9973720"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise xor function of type complex128  <a href="#adf73d910b4e9d9c344b2b389f9973720">More...</a><br /></td></tr>
<tr class="separator:adf73d910b4e9d9c344b2b389f9973720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c785f100a1e386d0ee36ce2cc72941"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a15c785f100a1e386d0ee36ce2cc72941"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a15c785f100a1e386d0ee36ce2cc72941">BitXorFunc&lt; ito::Rgba32 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:a15c785f100a1e386d0ee36ce2cc72941"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialisation for bitwise xor function of type complex128  <a href="#a15c785f100a1e386d0ee36ce2cc72941">More...</a><br /></td></tr>
<tr class="separator:a15c785f100a1e386d0ee36ce2cc72941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e60a4adfd0270199d3cb0b21230c29"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a26e60a4adfd0270199d3cb0b21230c29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a26e60a4adfd0270199d3cb0b21230c29">GetRangeFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, const int dtop, const int dbottom, const int dleft, const int dright)</td></tr>
<tr class="memdesc:a26e60a4adfd0270199d3cb0b21230c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for saving a shallow copy of a source cv::Mat_ to a destination cv::Mat_ with respect to given row- and col-ranges  <a href="#a26e60a4adfd0270199d3cb0b21230c29">More...</a><br /></td></tr>
<tr class="separator:a26e60a4adfd0270199d3cb0b21230c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea3cec515d7dfc29dd5a2ac1002c7e6"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:abea3cec515d7dfc29dd5a2ac1002c7e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#abea3cec515d7dfc29dd5a2ac1002c7e6">AdjustROIFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, int dtop, int dbottom, int dleft, int dright)</td></tr>
<tr class="memdesc:abea3cec515d7dfc29dd5a2ac1002c7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for adjusting the ROI of a data object by the given incremental values  <a href="#abea3cec515d7dfc29dd5a2ac1002c7e6">More...</a><br /></td></tr>
<tr class="separator:abea3cec515d7dfc29dd5a2ac1002c7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51a9284d0a30e2fac9926c85171ca82"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:aa51a9284d0a30e2fac9926c85171ca82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa51a9284d0a30e2fac9926c85171ca82">EyeFunc</a> (const int size, uchar **dstMat)</td></tr>
<tr class="memdesc:aa51a9284d0a30e2fac9926c85171ca82"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for creating an eye-matrix  <a href="#aa51a9284d0a30e2fac9926c85171ca82">More...</a><br /></td></tr>
<tr class="separator:aa51a9284d0a30e2fac9926c85171ca82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7900df15bdd04f8f3b229e3b03e126f"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:ab7900df15bdd04f8f3b229e3b03e126f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab7900df15bdd04f8f3b229e3b03e126f">ConjFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj)</td></tr>
<tr class="memdesc:ab7900df15bdd04f8f3b229e3b03e126f"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method for calculating the conjugated value of each element within the ROI of this data object  <a href="#ab7900df15bdd04f8f3b229e3b03e126f">More...</a><br /></td></tr>
<tr class="separator:ab7900df15bdd04f8f3b229e3b03e126f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2152b55aa6ffffbd308988036921c366"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2152b55aa6ffffbd308988036921c366"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2152b55aa6ffffbd308988036921c366"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a2152b55aa6ffffbd308988036921c366">ConjFunc&lt; int8 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:a2152b55aa6ffffbd308988036921c366"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type int8. throws cv::Exception, since the data type is not complex. <br /></td></tr>
<tr class="separator:a2152b55aa6ffffbd308988036921c366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5eb910cdbd6181467afb726667e299"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6c5eb910cdbd6181467afb726667e299"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6c5eb910cdbd6181467afb726667e299"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6c5eb910cdbd6181467afb726667e299">ConjFunc&lt; uint8 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:a6c5eb910cdbd6181467afb726667e299"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type uint8. throws cv::Exception, since the data type is not complex. <br /></td></tr>
<tr class="separator:a6c5eb910cdbd6181467afb726667e299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada701c5317bb987499c5c60b2a2e3791"><td class="memTemplParams" colspan="2"><a class="anchor" id="ada701c5317bb987499c5c60b2a2e3791"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ada701c5317bb987499c5c60b2a2e3791"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ada701c5317bb987499c5c60b2a2e3791">ConjFunc&lt; int16 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:ada701c5317bb987499c5c60b2a2e3791"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type int16. throws cv::Exception, since the data type is not complex. <br /></td></tr>
<tr class="separator:ada701c5317bb987499c5c60b2a2e3791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8df9376088030094eec904d16fde735"><td class="memTemplParams" colspan="2"><a class="anchor" id="af8df9376088030094eec904d16fde735"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af8df9376088030094eec904d16fde735"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af8df9376088030094eec904d16fde735">ConjFunc&lt; uint16 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:af8df9376088030094eec904d16fde735"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type uint16. throws cv::Exception, since the data type is not complex. <br /></td></tr>
<tr class="separator:af8df9376088030094eec904d16fde735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09333065564b7f43febdbcfaf80966d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad09333065564b7f43febdbcfaf80966d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad09333065564b7f43febdbcfaf80966d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad09333065564b7f43febdbcfaf80966d">ConjFunc&lt; int32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:ad09333065564b7f43febdbcfaf80966d"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type int32. throws cv::Exception, since the data type is not complex. <br /></td></tr>
<tr class="separator:ad09333065564b7f43febdbcfaf80966d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af059de0f69d7423b432a0495a1eb1185"><td class="memTemplParams" colspan="2"><a class="anchor" id="af059de0f69d7423b432a0495a1eb1185"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af059de0f69d7423b432a0495a1eb1185"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af059de0f69d7423b432a0495a1eb1185">ConjFunc&lt; uint32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:af059de0f69d7423b432a0495a1eb1185"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type uint32. throws cv::Exception, since the data type is not complex. <br /></td></tr>
<tr class="separator:af059de0f69d7423b432a0495a1eb1185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ce3961d006b5f2afa1a3d7fe98f498"><td class="memTemplParams" colspan="2"><a class="anchor" id="a45ce3961d006b5f2afa1a3d7fe98f498"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a45ce3961d006b5f2afa1a3d7fe98f498"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a45ce3961d006b5f2afa1a3d7fe98f498">ConjFunc&lt; ito::float32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:a45ce3961d006b5f2afa1a3d7fe98f498"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type float32. throws cv::Exception, since the data type is not complex. <br /></td></tr>
<tr class="separator:a45ce3961d006b5f2afa1a3d7fe98f498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584dd8ae5ea74e47de0f229545a6a43e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a584dd8ae5ea74e47de0f229545a6a43e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a584dd8ae5ea74e47de0f229545a6a43e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a584dd8ae5ea74e47de0f229545a6a43e">ConjFunc&lt; ito::float64 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:a584dd8ae5ea74e47de0f229545a6a43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type float64. throws cv::Exception, since the data type is not complex. <br /></td></tr>
<tr class="separator:a584dd8ae5ea74e47de0f229545a6a43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493d71fcfc188ca158ff9814c0f4ea0b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a493d71fcfc188ca158ff9814c0f4ea0b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a493d71fcfc188ca158ff9814c0f4ea0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a493d71fcfc188ca158ff9814c0f4ea0b">ConjFunc&lt; ito::Rgba32 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:a493d71fcfc188ca158ff9814c0f4ea0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type float64. throws cv::Exception, since the data type is not complex. <br /></td></tr>
<tr class="separator:a493d71fcfc188ca158ff9814c0f4ea0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5867dd1dfd785a687af3de732ddcee"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3b5867dd1dfd785a687af3de732ddcee"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3b5867dd1dfd785a687af3de732ddcee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a3b5867dd1dfd785a687af3de732ddcee">ConjFunc&lt; int64 &gt;</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *)</td></tr>
<tr class="memdesc:a3b5867dd1dfd785a687af3de732ddcee"><td class="mdescLeft">&#160;</td><td class="mdescRight">template specialization for data object of type int64. throws cv::Exception, since the data type is not complex. <br /></td></tr>
<tr class="separator:a3b5867dd1dfd785a687af3de732ddcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec1a7c2c0078e1b856d739a25637728"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2ec1a7c2c0078e1b856d739a25637728"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a2ec1a7c2c0078e1b856d739a25637728"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MulFunc</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *res, const double)</td></tr>
<tr class="separator:a2ec1a7c2c0078e1b856d739a25637728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd82fda76a04b3569bccb68ddf8cf382"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:acd82fda76a04b3569bccb68ddf8cf382"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#acd82fda76a04b3569bccb68ddf8cf382">DivFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *res)</td></tr>
<tr class="memdesc:acd82fda76a04b3569bccb68ddf8cf382"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which does a element-wise division of elements in first source matrix by elements in second source matrix.  <a href="#acd82fda76a04b3569bccb68ddf8cf382">More...</a><br /></td></tr>
<tr class="separator:acd82fda76a04b3569bccb68ddf8cf382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f6a9e3246468144d9ea2e0bb1c7805"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ad6f6a9e3246468144d9ea2e0bb1c7805"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad6f6a9e3246468144d9ea2e0bb1c7805">DivFunc&lt; Rgba32 &gt;</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src1, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src2, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *res)</td></tr>
<tr class="memdesc:ad6f6a9e3246468144d9ea2e0bb1c7805"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which does a element-wise division of elements in first source matrix by elements in second source matrix.  <a href="#ad6f6a9e3246468144d9ea2e0bb1c7805">More...</a><br /></td></tr>
<tr class="separator:ad6f6a9e3246468144d9ea2e0bb1c7805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34793f8ffb88f9af5ab77176c5614dfc"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a34793f8ffb88f9af5ab77176c5614dfc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a34793f8ffb88f9af5ab77176c5614dfc">planeStackFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *mats, const int &amp;num, const unsigned int &amp;axis, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *res)</td></tr>
<tr class="memdesc:a34793f8ffb88f9af5ab77176c5614dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which stacks a sequence of dataObjects horizontally or vertically together .  <a href="#a34793f8ffb88f9af5ab77176c5614dfc">More...</a><br /></td></tr>
<tr class="separator:a34793f8ffb88f9af5ab77176c5614dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b49014c44eac542f39d937e90aa6bf"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa7b49014c44eac542f39d937e90aa6bf"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:aa7b49014c44eac542f39d937e90aa6bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GrayScaleCastFunc</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj, double alpha=1.0)</td></tr>
<tr class="separator:aa7b49014c44eac542f39d937e90aa6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9b33c216cb485106bd20a6201f8add"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b9b33c216cb485106bd20a6201f8add"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a4b9b33c216cb485106bd20a6201f8add"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>extractColor</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;resObj, const char *color, const int &amp;type)</td></tr>
<tr class="separator:a4b9b33c216cb485106bd20a6201f8add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4b4e040bcfd696c06a402b072210e1"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a2c4b4e040bcfd696c06a402b072210e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a2c4b4e040bcfd696c06a402b072210e1">lineCutFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *src, const int *coordinates, const int &amp;len, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *res)</td></tr>
<tr class="memdesc:a2c4b4e040bcfd696c06a402b072210e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method to take a line cut across the planes of a dataObject.  <a href="#a2c4b4e040bcfd696c06a402b072210e1">More...</a><br /></td></tr>
<tr class="separator:a2c4b4e040bcfd696c06a402b072210e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee4c6255dbf062c6e84e716df007801"><td class="memTemplParams" colspan="2">template&lt;typename _TSrc , typename _TDest &gt; </td></tr>
<tr class="memitem:abee4c6255dbf062c6e84e716df007801"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#abee4c6255dbf062c6e84e716df007801">CastFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *srcObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj, double alpha, double beta)</td></tr>
<tr class="memdesc:abee4c6255dbf062c6e84e716df007801"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level templated method to cast each element of source matrix to another type.  <a href="#abee4c6255dbf062c6e84e716df007801">More...</a><br /></td></tr>
<tr class="separator:abee4c6255dbf062c6e84e716df007801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f09a21ffb93200d0566b66e6062ff96"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2f09a21ffb93200d0566b66e6062ff96"></a>
template&lt;typename _TDest &gt; </td></tr>
<tr class="memitem:a2f09a21ffb93200d0566b66e6062ff96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CastFuncFromComplex64</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *srcObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj, double alpha, double beta)</td></tr>
<tr class="separator:a2f09a21ffb93200d0566b66e6062ff96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e915cfd85a26ae5a218daa550d38ef"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae2e915cfd85a26ae5a218daa550d38ef"></a>
template&lt;typename _TDest &gt; </td></tr>
<tr class="memitem:ae2e915cfd85a26ae5a218daa550d38ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CastFuncFromComplex128</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *srcObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj, double alpha, double beta)</td></tr>
<tr class="separator:ae2e915cfd85a26ae5a218daa550d38ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b36c1dae1062f2cf71dedfc547d9a6e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8b36c1dae1062f2cf71dedfc547d9a6e"></a>
template&lt;typename _TDest &gt; </td></tr>
<tr class="memitem:a8b36c1dae1062f2cf71dedfc547d9a6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CastFuncFromRgba32</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *srcObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj, double alpha, double beta)</td></tr>
<tr class="separator:a8b36c1dae1062f2cf71dedfc547d9a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8367d4e513da741ea508d4fb2cda270"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:aa8367d4e513da741ea508d4fb2cda270"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa8367d4e513da741ea508d4fb2cda270">ConvertToFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, const int dest_type, const double alpha, const double beta)</td></tr>
<tr class="memdesc:aa8367d4e513da741ea508d4fb2cda270"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts data in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix ">DataObject</a> lhs to <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix ">DataObject</a> rhs with a given type  <a href="#aa8367d4e513da741ea508d4fb2cda270">More...</a><br /></td></tr>
<tr class="separator:aa8367d4e513da741ea508d4fb2cda270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ab8c51a57848f3912ef1e44f96b3f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="af6ab8c51a57848f3912ef1e44f96b3f9"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af6ab8c51a57848f3912ef1e44f96b3f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConvertToFunc&lt; ito::complex64 &gt;</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, const int dest_type, const double alpha, const double beta)</td></tr>
<tr class="separator:af6ab8c51a57848f3912ef1e44f96b3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9752ddb61cc0c4266339afbccc1057"><td class="memTemplParams" colspan="2"><a class="anchor" id="aad9752ddb61cc0c4266339afbccc1057"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aad9752ddb61cc0c4266339afbccc1057"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConvertToFunc&lt; ito::complex128 &gt;</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, const int dest_type, const double alpha, const double beta)</td></tr>
<tr class="separator:aad9752ddb61cc0c4266339afbccc1057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed204637d610e6874bcb31d7e9561269"><td class="memTemplParams" colspan="2"><a class="anchor" id="aed204637d610e6874bcb31d7e9561269"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aed204637d610e6874bcb31d7e9561269"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConvertToFunc&lt; ito::Rgba32 &gt;</b> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;lhs, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;rhs, const int dest_type, const double alpha, const double beta)</td></tr>
<tr class="separator:aed204637d610e6874bcb31d7e9561269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c9406cd13e3319f6e4c78a17b3acc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46c9406cd13e3319f6e4c78a17b3acc7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKEFUNCLIST</b> (<a class="el" href="namespaceito.html#aa8367d4e513da741ea508d4fb2cda270">ConvertToFunc</a>)</td></tr>
<tr class="separator:a46c9406cd13e3319f6e4c78a17b3acc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7089fa30e7e66b8d57438c07b7c644b"><td class="memTemplParams" colspan="2">template&lt;typename _CmplxTp , typename _Tp &gt; </td></tr>
<tr class="memitem:ae7089fa30e7e66b8d57438c07b7c644b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae7089fa30e7e66b8d57438c07b7c644b">AbsFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr class="memdesc:ae7089fa30e7e66b8d57438c07b7c644b"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, double templated method to save the element-wise absolute value of each element in source matrix to result matrix  <a href="#ae7089fa30e7e66b8d57438c07b7c644b">More...</a><br /></td></tr>
<tr class="separator:ae7089fa30e7e66b8d57438c07b7c644b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f34b4f966d79c5eadb25216a4950620"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a3f34b4f966d79c5eadb25216a4950620"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a3f34b4f966d79c5eadb25216a4950620">AbsFuncReal</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr class="memdesc:a3f34b4f966d79c5eadb25216a4950620"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method to save the element-wise absolute value of each element in source matrix to result matrix  <a href="#a3f34b4f966d79c5eadb25216a4950620">More...</a><br /></td></tr>
<tr class="separator:a3f34b4f966d79c5eadb25216a4950620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d3ecede102f9a0756a89a0a5aa2977"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#af6d3ecede102f9a0756a89a0a5aa2977">abs</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr class="memdesc:af6d3ecede102f9a0756a89a0a5aa2977"><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level value which calculates the absolute value of each element of the input source data object and returns the resulting data object  <a href="#af6d3ecede102f9a0756a89a0a5aa2977">More...</a><br /></td></tr>
<tr class="separator:af6d3ecede102f9a0756a89a0a5aa2977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e126a9e14968fd29e231b9efab55a3b"><td class="memTemplParams" colspan="2">template&lt;typename _CmplxTp , typename _Tp &gt; </td></tr>
<tr class="memitem:a0e126a9e14968fd29e231b9efab55a3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a0e126a9e14968fd29e231b9efab55a3b">ArgFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr class="memdesc:a0e126a9e14968fd29e231b9efab55a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, double templated method to save the element-wise argument of each element in source matrix to result matrix  <a href="#a0e126a9e14968fd29e231b9efab55a3b">More...</a><br /></td></tr>
<tr class="separator:a0e126a9e14968fd29e231b9efab55a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0644ec1daecb3a21762e32eb16c3fb1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a0644ec1daecb3a21762e32eb16c3fb1f">arg</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr class="memdesc:a0644ec1daecb3a21762e32eb16c3fb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level value which calculates the argument value of each element of the input source data object and returns the resulting data object  <a href="#a0644ec1daecb3a21762e32eb16c3fb1f">More...</a><br /></td></tr>
<tr class="separator:a0644ec1daecb3a21762e32eb16c3fb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5756b35dfcc4d0bec5d7c69451cfaebe"><td class="memTemplParams" colspan="2">template&lt;typename _CmplxTp , typename _Tp &gt; </td></tr>
<tr class="memitem:a5756b35dfcc4d0bec5d7c69451cfaebe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a5756b35dfcc4d0bec5d7c69451cfaebe">RealFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr class="memdesc:a5756b35dfcc4d0bec5d7c69451cfaebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, double templated method to save the element-wise real value of each element in source matrix to result matrix  <a href="#a5756b35dfcc4d0bec5d7c69451cfaebe">More...</a><br /></td></tr>
<tr class="separator:a5756b35dfcc4d0bec5d7c69451cfaebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2992d0fdb1e60676a01bdc25477ea85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad2992d0fdb1e60676a01bdc25477ea85">real</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr class="memdesc:ad2992d0fdb1e60676a01bdc25477ea85"><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level value which calculates the real value of each element of the input source data object and returns the resulting data object  <a href="#ad2992d0fdb1e60676a01bdc25477ea85">More...</a><br /></td></tr>
<tr class="separator:ad2992d0fdb1e60676a01bdc25477ea85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444878ac63ad03431280c47024a535d9"><td class="memTemplParams" colspan="2">template&lt;typename _CmplxTp , typename _Tp &gt; </td></tr>
<tr class="memitem:a444878ac63ad03431280c47024a535d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a444878ac63ad03431280c47024a535d9">SetRealFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *valueObj)</td></tr>
<tr class="memdesc:a444878ac63ad03431280c47024a535d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, double templated method to save the element-wise real value of each element in source matrix to result matrix  <a href="#a444878ac63ad03431280c47024a535d9">More...</a><br /></td></tr>
<tr class="separator:a444878ac63ad03431280c47024a535d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e11ebe0a194e906b1d2ddfa780acc8"><td class="memTemplParams" colspan="2">template&lt;typename _CmplxTp , typename _Tp &gt; </td></tr>
<tr class="memitem:a78e11ebe0a194e906b1d2ddfa780acc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a78e11ebe0a194e906b1d2ddfa780acc8">SetImagFunc</a> (<a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *valueObj)</td></tr>
<tr class="memdesc:a78e11ebe0a194e906b1d2ddfa780acc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, double templated method to save the element-wise real value of each element in source matrix to result matrix  <a href="#a78e11ebe0a194e906b1d2ddfa780acc8">More...</a><br /></td></tr>
<tr class="separator:a78e11ebe0a194e906b1d2ddfa780acc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94ef257b87ce7243e79b454cf1cd1f3"><td class="memTemplParams" colspan="2">template&lt;typename _CmplxTp , typename _Tp &gt; </td></tr>
<tr class="memitem:af94ef257b87ce7243e79b454cf1cd1f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af94ef257b87ce7243e79b454cf1cd1f3">ImagFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *resObj)</td></tr>
<tr class="memdesc:af94ef257b87ce7243e79b454cf1cd1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, double templated method to save the element-wise imaginary value of each element in source matrix to result matrix  <a href="#af94ef257b87ce7243e79b454cf1cd1f3">More...</a><br /></td></tr>
<tr class="separator:af94ef257b87ce7243e79b454cf1cd1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5293e802d23cc6b2d23d43b09bd598f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a5293e802d23cc6b2d23d43b09bd598f4">imag</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr class="memdesc:a5293e802d23cc6b2d23d43b09bd598f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level value which calculates the imaginary value of each element of the input source data object and returns the resulting data object  <a href="#a5293e802d23cc6b2d23d43b09bd598f4">More...</a><br /></td></tr>
<tr class="separator:a5293e802d23cc6b2d23d43b09bd598f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2f517b2e6d28b2664e7939d7eb7be6"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:aca2f517b2e6d28b2664e7939d7eb7be6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aca2f517b2e6d28b2664e7939d7eb7be6">MakeContinuousFunc</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;resDObj)</td></tr>
<tr class="memdesc:aca2f517b2e6d28b2664e7939d7eb7be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">low-level, templated method which copies an incontinuously organized data object to a continuously organized resulting data object  <a href="#aca2f517b2e6d28b2664e7939d7eb7be6">More...</a><br /></td></tr>
<tr class="separator:aca2f517b2e6d28b2664e7939d7eb7be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2d269d16022dc1e5835ad308bf5b4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_data_object.html">DataObject</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aeb2d269d16022dc1e5835ad308bf5b4e">makeContinuous</a> (const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr class="memdesc:aeb2d269d16022dc1e5835ad308bf5b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">high-level method which copies an incontinuously organized data object to a continuously organized resulting data object, which is returned  <a href="#aeb2d269d16022dc1e5835ad308bf5b4e">More...</a><br /></td></tr>
<tr class="separator:aeb2d269d16022dc1e5835ad308bf5b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa741bfac35792d62080a58f64eca8861"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa741bfac35792d62080a58f64eca8861"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:aa741bfac35792d62080a58f64eca8861"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>coutValue</b> (const _Tp *val, char *buf)</td></tr>
<tr class="separator:aa741bfac35792d62080a58f64eca8861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a6762e766e05ce887bbfa8d673d492"><td class="memTemplParams" colspan="2"><a class="anchor" id="a37a6762e766e05ce887bbfa8d673d492"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a37a6762e766e05ce887bbfa8d673d492"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>coutValue</b> (const ito::uint8 *val, char *buf)</td></tr>
<tr class="separator:a37a6762e766e05ce887bbfa8d673d492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758568048616982db58572fe6da58d28"><td class="memTemplParams" colspan="2"><a class="anchor" id="a758568048616982db58572fe6da58d28"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a758568048616982db58572fe6da58d28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>coutValue</b> (const ito::int8 *val, char *buf)</td></tr>
<tr class="separator:a758568048616982db58572fe6da58d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449bde8c996ea7f16a8d34711c38d7e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a449bde8c996ea7f16a8d34711c38d7e4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a449bde8c996ea7f16a8d34711c38d7e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>coutValue</b> (const ito::uint16 *val, char *buf)</td></tr>
<tr class="separator:a449bde8c996ea7f16a8d34711c38d7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7ef563e42dcfa03b26eade8f4f0831"><td class="memTemplParams" colspan="2"><a class="anchor" id="abb7ef563e42dcfa03b26eade8f4f0831"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:abb7ef563e42dcfa03b26eade8f4f0831"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>coutValue</b> (const ito::int16 *val, char *buf)</td></tr>
<tr class="separator:abb7ef563e42dcfa03b26eade8f4f0831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210b612fbe67e01250a253cde8c55887"><td class="memTemplParams" colspan="2"><a class="anchor" id="a210b612fbe67e01250a253cde8c55887"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a210b612fbe67e01250a253cde8c55887"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>coutValue</b> (const ito::uint32 *val, char *buf)</td></tr>
<tr class="separator:a210b612fbe67e01250a253cde8c55887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47569c172ff651e5973909c5bca9659"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac47569c172ff651e5973909c5bca9659"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac47569c172ff651e5973909c5bca9659"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>coutValue</b> (const ito::int32 *val, char *buf)</td></tr>
<tr class="separator:ac47569c172ff651e5973909c5bca9659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2a22dc6d94e29402a894d038159471"><td class="memTemplParams" colspan="2"><a class="anchor" id="afb2a22dc6d94e29402a894d038159471"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:afb2a22dc6d94e29402a894d038159471"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>coutValue</b> (const ito::float32 *val, char *buf)</td></tr>
<tr class="separator:afb2a22dc6d94e29402a894d038159471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad359be86d41de2d9fade2a516267309b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad359be86d41de2d9fade2a516267309b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad359be86d41de2d9fade2a516267309b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>coutValue</b> (const ito::float64 *val, char *buf)</td></tr>
<tr class="separator:ad359be86d41de2d9fade2a516267309b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54bd43e5026f7dc628df1ad9b8a5cb3"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab54bd43e5026f7dc628df1ad9b8a5cb3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab54bd43e5026f7dc628df1ad9b8a5cb3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>coutValue</b> (const ito::complex64 *val, char *buf)</td></tr>
<tr class="separator:ab54bd43e5026f7dc628df1ad9b8a5cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95501ba16024461f145dd1985d0efe52"><td class="memTemplParams" colspan="2"><a class="anchor" id="a95501ba16024461f145dd1985d0efe52"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a95501ba16024461f145dd1985d0efe52"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>coutValue</b> (const ito::complex128 *val, char *buf)</td></tr>
<tr class="separator:a95501ba16024461f145dd1985d0efe52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ef7d558568ec956e7ec2944b405a70"><td class="memTemplParams" colspan="2"><a class="anchor" id="a67ef7d558568ec956e7ec2944b405a70"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a67ef7d558568ec956e7ec2944b405a70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>coutValue</b> (const <a class="el" href="classito_1_1_rgba32.html">ito::Rgba32</a> *val, char *buf)</td></tr>
<tr class="separator:a67ef7d558568ec956e7ec2944b405a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e698f5ed1ae906f22a3053c6af304a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a49e698f5ed1ae906f22a3053c6af304a"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a49e698f5ed1ae906f22a3053c6af304a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>coutPlane</b> (std::ostream &amp;out, const cv::Mat *plane, int firstLineIndent, int otherIndent)</td></tr>
<tr class="separator:a49e698f5ed1ae906f22a3053c6af304a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784de664a9fd9ce5daaea0c9398fbb80"><td class="memTemplParams" colspan="2"><a class="anchor" id="a784de664a9fd9ce5daaea0c9398fbb80"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a784de664a9fd9ce5daaea0c9398fbb80"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>coutFunc</b> (std::ostream &amp;out, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr class="separator:a784de664a9fd9ce5daaea0c9398fbb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4caf24758abdf1e0012276c29c06ce37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4caf24758abdf1e0012276c29c06ce37"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a4caf24758abdf1e0012276c29c06ce37">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObj)</td></tr>
<tr class="memdesc:a4caf24758abdf1e0012276c29c06ce37"><td class="mdescLeft">&#160;</td><td class="mdescRight">streaming operator to stream the representation or contant of a data object <br /></td></tr>
<tr class="separator:a4caf24758abdf1e0012276c29c06ce37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a608ef3329e9be21dc3ff3df53082ad"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a4a608ef3329e9be21dc3ff3df53082ad"><td class="memTemplItemLeft" align="right" valign="top">_Tp&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a4a608ef3329e9be21dc3ff3df53082ad">numberConversion</a> (<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> fromType, const void *scalar)</td></tr>
<tr class="memdesc:a4a608ef3329e9be21dc3ff3df53082ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">templated method for converting a given scalar value to the data type, indicated by the template parameter  <a href="#a4a608ef3329e9be21dc3ff3df53082ad">More...</a><br /></td></tr>
<tr class="separator:a4a608ef3329e9be21dc3ff3df53082ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1c451edd01ef3334d4293512e437df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8b1c451edd01ef3334d4293512e437df">convertCmplxTypeToRealType</a> (<a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> cmplxType)</td></tr>
<tr class="memdesc:a8b1c451edd01ef3334d4293512e437df"><td class="mdescLeft">&#160;</td><td class="mdescRight">method which returns the real data type of any given data type  <a href="#a8b1c451edd01ef3334d4293512e437df">More...</a><br /></td></tr>
<tr class="separator:a8b1c451edd01ef3334d4293512e437df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0a019e83e6fd5dc76173c9334436b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a3a0a019e83e6fd5dc76173c9334436b1">guessDataTypeFromCVMat</a> (const cv::Mat *mat, <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> &amp;retval)</td></tr>
<tr class="memdesc:a3a0a019e83e6fd5dc76173c9334436b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">method which guesses the dataObject type from a given cv::Mat*  <a href="#a3a0a019e83e6fd5dc76173c9334436b1">More...</a><br /></td></tr>
<tr class="separator:a3a0a019e83e6fd5dc76173c9334436b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c51786122c5ea8ab864ceafcc36bbad"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a4c51786122c5ea8ab864ceafcc36bbad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a4c51786122c5ea8ab864ceafcc36bbad">getDataType</a> (const _Tp *)</td></tr>
<tr class="memdesc:a4c51786122c5ea8ab864ceafcc36bbad"><td class="mdescLeft">&#160;</td><td class="mdescRight">method which returns the value of enumeration <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>, which corresponds to the type of the given pointer parameter.  <a href="#a4c51786122c5ea8ab864ceafcc36bbad">More...</a><br /></td></tr>
<tr class="separator:a4c51786122c5ea8ab864ceafcc36bbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef07fe7ede18a6c0b0f8536515b87c94"><td class="memTemplParams" colspan="2"><a class="anchor" id="aef07fe7ede18a6c0b0f8536515b87c94"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aef07fe7ede18a6c0b0f8536515b87c94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const uint8 *)</td></tr>
<tr class="separator:aef07fe7ede18a6c0b0f8536515b87c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbef4263650910d0c963588283bf9ca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2bbef4263650910d0c963588283bf9ca"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2bbef4263650910d0c963588283bf9ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const int8 *)</td></tr>
<tr class="separator:a2bbef4263650910d0c963588283bf9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14df31920222d339b848b1192681a3a"><td class="memTemplParams" colspan="2"><a class="anchor" id="af14df31920222d339b848b1192681a3a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af14df31920222d339b848b1192681a3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const uint16 *)</td></tr>
<tr class="separator:af14df31920222d339b848b1192681a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf2e87cdc1b9804a86156d451c378ee"><td class="memTemplParams" colspan="2"><a class="anchor" id="adcf2e87cdc1b9804a86156d451c378ee"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:adcf2e87cdc1b9804a86156d451c378ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const int16 *)</td></tr>
<tr class="separator:adcf2e87cdc1b9804a86156d451c378ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cfd4d664e1de45affac918d4497995"><td class="memTemplParams" colspan="2"><a class="anchor" id="a81cfd4d664e1de45affac918d4497995"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a81cfd4d664e1de45affac918d4497995"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const uint32 *)</td></tr>
<tr class="separator:a81cfd4d664e1de45affac918d4497995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d84834ce11845a31ac5ef667d133536"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d84834ce11845a31ac5ef667d133536"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4d84834ce11845a31ac5ef667d133536"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const int32 *)</td></tr>
<tr class="separator:a4d84834ce11845a31ac5ef667d133536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4771a594b59e3bb23e2f97a2166f602"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac4771a594b59e3bb23e2f97a2166f602"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac4771a594b59e3bb23e2f97a2166f602"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const float32 *)</td></tr>
<tr class="separator:ac4771a594b59e3bb23e2f97a2166f602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f04e3f80b177156ecc41b9965fcda82"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7f04e3f80b177156ecc41b9965fcda82"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7f04e3f80b177156ecc41b9965fcda82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const float64 *)</td></tr>
<tr class="separator:a7f04e3f80b177156ecc41b9965fcda82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbd7d556dbb7e5fb4685799c8cd75f2"><td class="memTemplParams" colspan="2"><a class="anchor" id="abdbd7d556dbb7e5fb4685799c8cd75f2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:abdbd7d556dbb7e5fb4685799c8cd75f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const complex64 *)</td></tr>
<tr class="separator:abdbd7d556dbb7e5fb4685799c8cd75f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876459d01741aa2cc18a6945ab267939"><td class="memTemplParams" colspan="2"><a class="anchor" id="a876459d01741aa2cc18a6945ab267939"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a876459d01741aa2cc18a6945ab267939"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const complex128 *)</td></tr>
<tr class="separator:a876459d01741aa2cc18a6945ab267939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afa7aa932bec45468ff7cd114dca364"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6afa7aa932bec45468ff7cd114dca364"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6afa7aa932bec45468ff7cd114dca364"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType</b> (const <a class="el" href="classito_1_1_rgba32.html">Rgba32</a> *)</td></tr>
<tr class="separator:a6afa7aa932bec45468ff7cd114dca364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055fafe5bca7e7bb1967fbe512c6bb98"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a055fafe5bca7e7bb1967fbe512c6bb98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a055fafe5bca7e7bb1967fbe512c6bb98">getDataType2</a> ()</td></tr>
<tr class="memdesc:a055fafe5bca7e7bb1967fbe512c6bb98"><td class="mdescLeft">&#160;</td><td class="mdescRight">method which returns the value of enumeration <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>, which corresponds to the template parameter (must be a pointer).  <a href="#a055fafe5bca7e7bb1967fbe512c6bb98">More...</a><br /></td></tr>
<tr class="separator:a055fafe5bca7e7bb1967fbe512c6bb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2ea61f8b082b8db1d09dd7427d21b5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5a2ea61f8b082b8db1d09dd7427d21b5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5a2ea61f8b082b8db1d09dd7427d21b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; uint8 * &gt;</b> ()</td></tr>
<tr class="separator:a5a2ea61f8b082b8db1d09dd7427d21b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2836f84ae9979d301e6a0879dd001f6c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2836f84ae9979d301e6a0879dd001f6c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2836f84ae9979d301e6a0879dd001f6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; int8 * &gt;</b> ()</td></tr>
<tr class="separator:a2836f84ae9979d301e6a0879dd001f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d84db4ecaad22a0bb8283f6d3a93e0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a13d84db4ecaad22a0bb8283f6d3a93e0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a13d84db4ecaad22a0bb8283f6d3a93e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; uint16 * &gt;</b> ()</td></tr>
<tr class="separator:a13d84db4ecaad22a0bb8283f6d3a93e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744e4c9b696b0fec1e4f162bb0055f01"><td class="memTemplParams" colspan="2"><a class="anchor" id="a744e4c9b696b0fec1e4f162bb0055f01"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a744e4c9b696b0fec1e4f162bb0055f01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; int16 * &gt;</b> ()</td></tr>
<tr class="separator:a744e4c9b696b0fec1e4f162bb0055f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f297ac84fceae1dea363c45a7dff4e1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f297ac84fceae1dea363c45a7dff4e1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a1f297ac84fceae1dea363c45a7dff4e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; uint32 * &gt;</b> ()</td></tr>
<tr class="separator:a1f297ac84fceae1dea363c45a7dff4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa592e1b1b52384b7bf70d1f799996d1c"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa592e1b1b52384b7bf70d1f799996d1c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa592e1b1b52384b7bf70d1f799996d1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; int32 * &gt;</b> ()</td></tr>
<tr class="separator:aa592e1b1b52384b7bf70d1f799996d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9558058bd3f1e0c679a54b3513ab76"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c9558058bd3f1e0c679a54b3513ab76"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3c9558058bd3f1e0c679a54b3513ab76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; float32 * &gt;</b> ()</td></tr>
<tr class="separator:a3c9558058bd3f1e0c679a54b3513ab76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc64619ef98e392d195206b3e7dcbb8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8cc64619ef98e392d195206b3e7dcbb8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8cc64619ef98e392d195206b3e7dcbb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; float64 * &gt;</b> ()</td></tr>
<tr class="separator:a8cc64619ef98e392d195206b3e7dcbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b18930fcd326f853942fb7cca4a60c1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5b18930fcd326f853942fb7cca4a60c1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5b18930fcd326f853942fb7cca4a60c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; complex64 * &gt;</b> ()</td></tr>
<tr class="separator:a5b18930fcd326f853942fb7cca4a60c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e723d4e92edc5c2f4f0c4b512c7124"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad1e723d4e92edc5c2f4f0c4b512c7124"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad1e723d4e92edc5c2f4f0c4b512c7124"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; complex128 * &gt;</b> ()</td></tr>
<tr class="separator:ad1e723d4e92edc5c2f4f0c4b512c7124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3829b3018db879a922c7873e508dac19"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3829b3018db879a922c7873e508dac19"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3829b3018db879a922c7873e508dac19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getDataType2&lt; Rgba32 * &gt;</b> ()</td></tr>
<tr class="separator:a3829b3018db879a922c7873e508dac19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69998ddb6713a8d497cf342b3489003"><td class="memTemplParams" colspan="2"><a class="anchor" id="af69998ddb6713a8d497cf342b3489003"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:af69998ddb6713a8d497cf342b3489003"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointCloud&lt; _Tp &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointCloudPtrInternal</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> &amp;pc)</td></tr>
<tr class="separator:af69998ddb6713a8d497cf342b3489003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6092977e31f844cd6e96eef77ff3fe11"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6092977e31f844cd6e96eef77ff3fe11"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6092977e31f844cd6e96eef77ff3fe11"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointCloud&lt; pcl::PointXYZ &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointCloudPtrInternal</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> &amp;pc)</td></tr>
<tr class="separator:a6092977e31f844cd6e96eef77ff3fe11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bc358db7b12f39262d4dfbabafb6d5"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab0bc358db7b12f39262d4dfbabafb6d5"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab0bc358db7b12f39262d4dfbabafb6d5"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointCloud&lt; pcl::PointXYZI &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointCloudPtrInternal</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> &amp;pc)</td></tr>
<tr class="separator:ab0bc358db7b12f39262d4dfbabafb6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057d048fed1954b5ee816fb2ea6650f3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a057d048fed1954b5ee816fb2ea6650f3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a057d048fed1954b5ee816fb2ea6650f3"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointCloud&lt; pcl::PointXYZRGBA &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointCloudPtrInternal</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> &amp;pc)</td></tr>
<tr class="separator:a057d048fed1954b5ee816fb2ea6650f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf3e4c4741ed6d95a0ebf3f8b26f308"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1bf3e4c4741ed6d95a0ebf3f8b26f308"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a1bf3e4c4741ed6d95a0ebf3f8b26f308"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointCloud&lt; pcl::PointNormal &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointCloudPtrInternal</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> &amp;pc)</td></tr>
<tr class="separator:a1bf3e4c4741ed6d95a0ebf3f8b26f308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad350f71be29bf9a71d983fdededf2dd0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad350f71be29bf9a71d983fdededf2dd0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad350f71be29bf9a71d983fdededf2dd0"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointCloud&lt; pcl::PointXYZINormal &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointCloudPtrInternal</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> &amp;pc)</td></tr>
<tr class="separator:ad350f71be29bf9a71d983fdededf2dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a9e99fbb9c4feb5796a66230517e5d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a99a9e99fbb9c4feb5796a66230517e5d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a99a9e99fbb9c4feb5796a66230517e5d"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointCloudPtrInternal</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> &amp;pc)</td></tr>
<tr class="separator:a99a9e99fbb9c4feb5796a66230517e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cc25f91c84b4a0b89b9d0db27cca7c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a25cc25f91c84b4a0b89b9d0db27cca7c"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a25cc25f91c84b4a0b89b9d0db27cca7c"><td class="memTemplItemLeft" align="right" valign="top">const pcl::PointCloud&lt; _Tp &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointCloudPtrInternal</b> (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> &amp;pc)</td></tr>
<tr class="separator:a25cc25f91c84b4a0b89b9d0db27cca7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58586c3fd671eefeaf032f2de0e93206"><td class="memTemplParams" colspan="2"><a class="anchor" id="a58586c3fd671eefeaf032f2de0e93206"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a58586c3fd671eefeaf032f2de0e93206"><td class="memTemplItemLeft" align="right" valign="top">const pcl::PointCloud&lt; pcl::PointXYZ &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointCloudPtrInternal</b> (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> &amp;pc)</td></tr>
<tr class="separator:a58586c3fd671eefeaf032f2de0e93206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22345ee98447cec066be46d0d2bbb73e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a22345ee98447cec066be46d0d2bbb73e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a22345ee98447cec066be46d0d2bbb73e"><td class="memTemplItemLeft" align="right" valign="top">const pcl::PointCloud&lt; pcl::PointXYZI &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointCloudPtrInternal</b> (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> &amp;pc)</td></tr>
<tr class="separator:a22345ee98447cec066be46d0d2bbb73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab425883095195d2fc13ff6e897c64060"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab425883095195d2fc13ff6e897c64060"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab425883095195d2fc13ff6e897c64060"><td class="memTemplItemLeft" align="right" valign="top">const pcl::PointCloud&lt; pcl::PointXYZRGBA &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointCloudPtrInternal</b> (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> &amp;pc)</td></tr>
<tr class="separator:ab425883095195d2fc13ff6e897c64060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bc151151316cbdc8d8e533c09e380e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a77bc151151316cbdc8d8e533c09e380e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a77bc151151316cbdc8d8e533c09e380e"><td class="memTemplItemLeft" align="right" valign="top">const pcl::PointCloud&lt; pcl::PointNormal &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointCloudPtrInternal</b> (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> &amp;pc)</td></tr>
<tr class="separator:a77bc151151316cbdc8d8e533c09e380e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b562f87444f34333d22bfe2ca43684"><td class="memTemplParams" colspan="2"><a class="anchor" id="a33b562f87444f34333d22bfe2ca43684"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a33b562f87444f34333d22bfe2ca43684"><td class="memTemplItemLeft" align="right" valign="top">const pcl::PointCloud&lt; pcl::PointXYZINormal &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointCloudPtrInternal</b> (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> &amp;pc)</td></tr>
<tr class="separator:a33b562f87444f34333d22bfe2ca43684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543b948305e1dedfdaf0ff811b640e5a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a543b948305e1dedfdaf0ff811b640e5a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a543b948305e1dedfdaf0ff811b640e5a"><td class="memTemplItemLeft" align="right" valign="top">const pcl::PointCloud&lt; pcl::PointXYZRGBNormal &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointCloudPtrInternal</b> (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> &amp;pc)</td></tr>
<tr class="separator:a543b948305e1dedfdaf0ff811b640e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0efab2e35308e626eaf8660f60f45a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e0efab2e35308e626eaf8660f60f45a"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a4e0efab2e35308e626eaf8660f60f45a"><td class="memTemplItemLeft" align="right" valign="top">_Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointPtrInternal</b> (<a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:a4e0efab2e35308e626eaf8660f60f45a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc88c61bb5af6ed83bda59ae063754c"><td class="memTemplParams" colspan="2"><a class="anchor" id="acbc88c61bb5af6ed83bda59ae063754c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acbc88c61bb5af6ed83bda59ae063754c"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointXYZ *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointPtrInternal</b> (<a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:acbc88c61bb5af6ed83bda59ae063754c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43915bb3f8ad50126fe812dc076ade2"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa43915bb3f8ad50126fe812dc076ade2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa43915bb3f8ad50126fe812dc076ade2"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointXYZI *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointPtrInternal</b> (<a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:aa43915bb3f8ad50126fe812dc076ade2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6a36a7925e011000c69ac7d54cdcd3"><td class="memTemplParams" colspan="2"><a class="anchor" id="abd6a36a7925e011000c69ac7d54cdcd3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:abd6a36a7925e011000c69ac7d54cdcd3"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointXYZRGBA *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointPtrInternal</b> (<a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:abd6a36a7925e011000c69ac7d54cdcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fffafda388010fd02769140ab6824e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a27fffafda388010fd02769140ab6824e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a27fffafda388010fd02769140ab6824e"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointNormal *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointPtrInternal</b> (<a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:a27fffafda388010fd02769140ab6824e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54424c47cb72ab89545b5f486fdfa1db"><td class="memTemplParams" colspan="2"><a class="anchor" id="a54424c47cb72ab89545b5f486fdfa1db"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a54424c47cb72ab89545b5f486fdfa1db"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointXYZINormal *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointPtrInternal</b> (<a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:a54424c47cb72ab89545b5f486fdfa1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34266081c8b381b292e6dbe1b5c8bbb7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a34266081c8b381b292e6dbe1b5c8bbb7"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a34266081c8b381b292e6dbe1b5c8bbb7"><td class="memTemplItemLeft" align="right" valign="top">pcl::PointXYZRGBNormal *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointPtrInternal</b> (<a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:a34266081c8b381b292e6dbe1b5c8bbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0c8a3bc46485c975e18d50c448067e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aee0c8a3bc46485c975e18d50c448067e"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:aee0c8a3bc46485c975e18d50c448067e"><td class="memTemplItemLeft" align="right" valign="top">const _Tp *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointPtrInternal</b> (const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:aee0c8a3bc46485c975e18d50c448067e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a96f5bca0d5d1abe2055b3cdc6716b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a88a96f5bca0d5d1abe2055b3cdc6716b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a88a96f5bca0d5d1abe2055b3cdc6716b"><td class="memTemplItemLeft" align="right" valign="top">const pcl::PointXYZ *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointPtrInternal</b> (const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:a88a96f5bca0d5d1abe2055b3cdc6716b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a4004db1c6c3094984fb3256eb691c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac4a4004db1c6c3094984fb3256eb691c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac4a4004db1c6c3094984fb3256eb691c"><td class="memTemplItemLeft" align="right" valign="top">const pcl::PointXYZI *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointPtrInternal</b> (const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:ac4a4004db1c6c3094984fb3256eb691c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d0974eab6e60f8ffd8251788c0d66d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac6d0974eab6e60f8ffd8251788c0d66d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac6d0974eab6e60f8ffd8251788c0d66d"><td class="memTemplItemLeft" align="right" valign="top">const pcl::PointXYZRGBA *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointPtrInternal</b> (const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:ac6d0974eab6e60f8ffd8251788c0d66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713e48d1c87fc76bb92cad40363c887c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a713e48d1c87fc76bb92cad40363c887c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a713e48d1c87fc76bb92cad40363c887c"><td class="memTemplItemLeft" align="right" valign="top">const pcl::PointNormal *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointPtrInternal</b> (const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:a713e48d1c87fc76bb92cad40363c887c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a9b0a74e8a1b17ffddf7dc10bb4d1f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a40a9b0a74e8a1b17ffddf7dc10bb4d1f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a40a9b0a74e8a1b17ffddf7dc10bb4d1f"><td class="memTemplItemLeft" align="right" valign="top">const pcl::PointXYZINormal *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointPtrInternal</b> (const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:a40a9b0a74e8a1b17ffddf7dc10bb4d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bc9edca5e9ef06552919f18e79ae66"><td class="memTemplParams" colspan="2"><a class="anchor" id="af0bc9edca5e9ef06552919f18e79ae66"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af0bc9edca5e9ef06552919f18e79ae66"><td class="memTemplItemLeft" align="right" valign="top">const pcl::PointXYZRGBNormal *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getPointPtrInternal</b> (const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:af0bc9edca5e9ef06552919f18e79ae66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b348d51c7b556b3547c7fdf7080e51"><td class="memTemplParams" colspan="2"><a class="anchor" id="a11b348d51c7b556b3547c7fdf7080e51"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a11b348d51c7b556b3547c7fdf7080e51"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IsOrganizedFunc</b> (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:a11b348d51c7b556b3547c7fdf7080e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9da6b682329ca73d28cb30845ad79f4"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa9da6b682329ca73d28cb30845ad79f4"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:aa9da6b682329ca73d28cb30845ad79f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetWidthFunc</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, uint32_t width)</td></tr>
<tr class="separator:aa9da6b682329ca73d28cb30845ad79f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf928cd6d178688fb532deecde37d54d"><td class="memTemplParams" colspan="2"><a class="anchor" id="adf928cd6d178688fb532deecde37d54d"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:adf928cd6d178688fb532deecde37d54d"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetWidthFunc</b> (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:adf928cd6d178688fb532deecde37d54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf94255106ca890c5738c1c981b28cfc"><td class="memTemplParams" colspan="2"><a class="anchor" id="adf94255106ca890c5738c1c981b28cfc"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:adf94255106ca890c5738c1c981b28cfc"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetSizeFunc</b> (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:adf94255106ca890c5738c1c981b28cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b33319b2730bbd6e8a4b9b2b76335f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad5b33319b2730bbd6e8a4b9b2b76335f"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:ad5b33319b2730bbd6e8a4b9b2b76335f"><td class="memTemplItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetHeightFunc</b> (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:ad5b33319b2730bbd6e8a4b9b2b76335f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbeab352827c10122127940007718c3b"><td class="memTemplParams" colspan="2"><a class="anchor" id="abbeab352827c10122127940007718c3b"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:abbeab352827c10122127940007718c3b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetHeightFunc</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, uint32_t height)</td></tr>
<tr class="separator:abbeab352827c10122127940007718c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee3327292123032f2975a26fe2e88de"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3ee3327292123032f2975a26fe2e88de"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a3ee3327292123032f2975a26fe2e88de"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetDenseFunc</b> (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:a3ee3327292123032f2975a26fe2e88de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab759fc7fcccf0aa4d06c0850a9e54ea2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab759fc7fcccf0aa4d06c0850a9e54ea2"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:ab759fc7fcccf0aa4d06c0850a9e54ea2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetDenseFunc</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, bool dense)</td></tr>
<tr class="separator:ab759fc7fcccf0aa4d06c0850a9e54ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af441e89697648f0640b8e4668e4c27b0"><td class="memTemplParams" colspan="2"><a class="anchor" id="af441e89697648f0640b8e4668e4c27b0"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:af441e89697648f0640b8e4668e4c27b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ScaleXYZFunc</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, ito::float32 scaleX, ito::float32 scaleY, ito::float32 scaleZ)</td></tr>
<tr class="separator:af441e89697648f0640b8e4668e4c27b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e664fe00f8d3f1aafda05dbfec9876"><td class="memTemplParams" colspan="2"><a class="anchor" id="a99e664fe00f8d3f1aafda05dbfec9876"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a99e664fe00f8d3f1aafda05dbfec9876"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MoveXYZFunc</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, ito::float32 dX, ito::float32 dY, ito::float32 dZ)</td></tr>
<tr class="separator:a99e664fe00f8d3f1aafda05dbfec9876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543de231f734d07609186a3657059e97"><td class="memTemplParams" colspan="2"><a class="anchor" id="a543de231f734d07609186a3657059e97"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a543de231f734d07609186a3657059e97"><td class="memTemplItemLeft" align="right" valign="top">std_msgs::Header&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetHeaderFunc</b> (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:a543de231f734d07609186a3657059e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55749d40e51fa769ac484ec9d31a7ab9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a55749d40e51fa769ac484ec9d31a7ab9"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a55749d40e51fa769ac484ec9d31a7ab9"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetFieldsListFunc</b> (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:a55749d40e51fa769ac484ec9d31a7ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0d695bc4dd4114b0f5c302961781c3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0f0d695bc4dd4114b0f5c302961781c3"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a0f0d695bc4dd4114b0f5c302961781c3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; sensor_msgs::PointField &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetFieldsInfoFunc</b> (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:a0f0d695bc4dd4114b0f5c302961781c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5660afcb64fdee7eb98f111afb1d5181"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5660afcb64fdee7eb98f111afb1d5181"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a5660afcb64fdee7eb98f111afb1d5181"><td class="memTemplItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GenericPointAccessFunc</b> (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, size_t &amp;strideBytes)</td></tr>
<tr class="separator:a5660afcb64fdee7eb98f111afb1d5181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803ca4de198e0e93a8e9000a744e53cb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a803ca4de198e0e93a8e9000a744e53cb"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a803ca4de198e0e93a8e9000a744e53cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PcAddFunc</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc1, const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc2, <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pcRes)</td></tr>
<tr class="separator:a803ca4de198e0e93a8e9000a744e53cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c9f9d1e926ae97e775b55063f65716"><td class="memTemplParams" colspan="2"><a class="anchor" id="a65c9f9d1e926ae97e775b55063f65716"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a65c9f9d1e926ae97e775b55063f65716"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetItemFunc</b> (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, size_t n)</td></tr>
<tr class="separator:a65c9f9d1e926ae97e775b55063f65716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a03720573b051f89b23b969e61e7f81"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2a03720573b051f89b23b969e61e7f81"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a2a03720573b051f89b23b969e61e7f81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetItemFunc</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *, size_t, <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;)</td></tr>
<tr class="separator:a2a03720573b051f89b23b969e61e7f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ba74ef1a8b124192878bebc0508356"><td class="memTemplParams" colspan="2"><a class="anchor" id="a97ba74ef1a8b124192878bebc0508356"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a97ba74ef1a8b124192878bebc0508356"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetItemFunc&lt; pcl::PointXYZ &gt;</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, size_t n, <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:a97ba74ef1a8b124192878bebc0508356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af488f877e2aeeaca7465b393713e559c"><td class="memTemplParams" colspan="2"><a class="anchor" id="af488f877e2aeeaca7465b393713e559c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af488f877e2aeeaca7465b393713e559c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetItemFunc&lt; pcl::PointXYZI &gt;</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, size_t n, <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:af488f877e2aeeaca7465b393713e559c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa20b615f00a0717be9174e2dc323723"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaa20b615f00a0717be9174e2dc323723"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aaa20b615f00a0717be9174e2dc323723"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetItemFunc&lt; pcl::PointXYZRGBA &gt;</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, size_t n, <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:aaa20b615f00a0717be9174e2dc323723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9b772b2ff0f54e5ddc7e3b9f81787e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aac9b772b2ff0f54e5ddc7e3b9f81787e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aac9b772b2ff0f54e5ddc7e3b9f81787e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetItemFunc&lt; pcl::PointNormal &gt;</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, size_t n, <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:aac9b772b2ff0f54e5ddc7e3b9f81787e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff701641ca44f20dc1cca11b69127a8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4ff701641ca44f20dc1cca11b69127a8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4ff701641ca44f20dc1cca11b69127a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetItemFunc&lt; pcl::PointXYZINormal &gt;</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, size_t n, <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:a4ff701641ca44f20dc1cca11b69127a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142eb0df42fff378315dba7f384e0393"><td class="memTemplParams" colspan="2"><a class="anchor" id="a142eb0df42fff378315dba7f384e0393"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a142eb0df42fff378315dba7f384e0393"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>SetItemFunc&lt; pcl::PointXYZRGBNormal &gt;</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, size_t n, <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:a142eb0df42fff378315dba7f384e0393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed851bc391b8b7a46119dd1c198b07e1"><td class="memTemplParams" colspan="2"><a class="anchor" id="aed851bc391b8b7a46119dd1c198b07e1"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:aed851bc391b8b7a46119dd1c198b07e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PushBackFunc</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *, const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;)</td></tr>
<tr class="separator:aed851bc391b8b7a46119dd1c198b07e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7047a561767a02702a448665882d4959"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7047a561767a02702a448665882d4959"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7047a561767a02702a448665882d4959"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PushBackFunc&lt; pcl::PointXYZ &gt;</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:a7047a561767a02702a448665882d4959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e99c3ec56d122a3cc0247c2547efa1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae9e99c3ec56d122a3cc0247c2547efa1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae9e99c3ec56d122a3cc0247c2547efa1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PushBackFunc&lt; pcl::PointXYZI &gt;</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:ae9e99c3ec56d122a3cc0247c2547efa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cbdb80f59de18037f1398355245bfc"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab3cbdb80f59de18037f1398355245bfc"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab3cbdb80f59de18037f1398355245bfc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PushBackFunc&lt; pcl::PointXYZRGBA &gt;</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:ab3cbdb80f59de18037f1398355245bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c99d4c89d0e5178f281cef95333cbf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a85c99d4c89d0e5178f281cef95333cbf"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a85c99d4c89d0e5178f281cef95333cbf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PushBackFunc&lt; pcl::PointNormal &gt;</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:a85c99d4c89d0e5178f281cef95333cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc112489329df18629ee0f522e0b9f0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6fc112489329df18629ee0f522e0b9f0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6fc112489329df18629ee0f522e0b9f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PushBackFunc&lt; pcl::PointXYZINormal &gt;</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:a6fc112489329df18629ee0f522e0b9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552d3fd6164ea407e509f0400879733f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a552d3fd6164ea407e509f0400879733f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a552d3fd6164ea407e509f0400879733f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PushBackFunc&lt; pcl::PointXYZRGBNormal &gt;</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:a552d3fd6164ea407e509f0400879733f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb82dd9b3a9d7ebfb76cd9ed047ffbb1"><td class="memTemplParams" colspan="2"><a class="anchor" id="acb82dd9b3a9d7ebfb76cd9ed047ffbb1"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:acb82dd9b3a9d7ebfb76cd9ed047ffbb1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EmptyFunc</b> (const <a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:acb82dd9b3a9d7ebfb76cd9ed047ffbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790434e06613e3b0b9fdcd0a115c8e35"><td class="memTemplParams" colspan="2"><a class="anchor" id="a790434e06613e3b0b9fdcd0a115c8e35"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a790434e06613e3b0b9fdcd0a115c8e35"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ReserveResizeFunc</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, size_t n, bool reserveNotResize)</td></tr>
<tr class="separator:a790434e06613e3b0b9fdcd0a115c8e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289c3ce7e479876864d394db58e309f0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a289c3ce7e479876864d394db58e309f0"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a289c3ce7e479876864d394db58e309f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ClearFunc</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc)</td></tr>
<tr class="separator:a289c3ce7e479876864d394db58e309f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f863080549dd15c3273c35b065bf74"><td class="memTemplParams" colspan="2"><a class="anchor" id="a48f863080549dd15c3273c35b065bf74"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a48f863080549dd15c3273c35b065bf74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EraseFunc</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, uint32_t startIndex, uint32_t endIndex)</td></tr>
<tr class="separator:a48f863080549dd15c3273c35b065bf74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cb3ef42aff552a2a82abbfab902886"><td class="memTemplParams" colspan="2"><a class="anchor" id="a63cb3ef42aff552a2a82abbfab902886"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a63cb3ef42aff552a2a82abbfab902886"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InsertFunc</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *, uint32_t, const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;)</td></tr>
<tr class="separator:a63cb3ef42aff552a2a82abbfab902886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac97a4680c891bada2a38fd088fb2533"><td class="memTemplParams" colspan="2"><a class="anchor" id="aac97a4680c891bada2a38fd088fb2533"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aac97a4680c891bada2a38fd088fb2533"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InsertFunc&lt; pcl::PointXYZ &gt;</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, uint32_t index, const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:aac97a4680c891bada2a38fd088fb2533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567818e04342a9767588e5aacaefdb2f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a567818e04342a9767588e5aacaefdb2f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a567818e04342a9767588e5aacaefdb2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InsertFunc&lt; pcl::PointXYZI &gt;</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, uint32_t index, const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:a567818e04342a9767588e5aacaefdb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134426314e49ea95b232716a9a42fc13"><td class="memTemplParams" colspan="2"><a class="anchor" id="a134426314e49ea95b232716a9a42fc13"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a134426314e49ea95b232716a9a42fc13"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InsertFunc&lt; pcl::PointXYZRGBA &gt;</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, uint32_t index, const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:a134426314e49ea95b232716a9a42fc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac617151d840fde2de0f8fe24466f323f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac617151d840fde2de0f8fe24466f323f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac617151d840fde2de0f8fe24466f323f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InsertFunc&lt; pcl::PointNormal &gt;</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, uint32_t index, const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:ac617151d840fde2de0f8fe24466f323f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa435147cd5c62c8d26526eda8e04c403"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa435147cd5c62c8d26526eda8e04c403"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa435147cd5c62c8d26526eda8e04c403"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InsertFunc&lt; pcl::PointXYZINormal &gt;</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, uint32_t index, const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:aa435147cd5c62c8d26526eda8e04c403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2443b7a429ca5ab8681e51976c9cd0"><td class="memTemplParams" colspan="2"><a class="anchor" id="afe2443b7a429ca5ab8681e51976c9cd0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:afe2443b7a429ca5ab8681e51976c9cd0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>InsertFunc&lt; pcl::PointXYZRGBNormal &gt;</b> (<a class="el" href="classito_1_1_p_c_l_point_cloud.html">ito::PCLPointCloud</a> *pc, uint32_t index, const <a class="el" href="classito_1_1_p_c_l_point.html">ito::PCLPoint</a> &amp;point)</td></tr>
<tr class="separator:afe2443b7a429ca5ab8681e51976c9cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15adbc6c5994b5e25cf0a3b3ac8f808"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab15adbc6c5994b5e25cf0a3b3ac8f808"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ab15adbc6c5994b5e25cf0a3b3ac8f808">operator==</a> (const <a class="el" href="classito_1_1_byte_array.html">ByteArray</a> &amp;a1, const char *a2)</td></tr>
<tr class="memdesc:ab15adbc6c5994b5e25cf0a3b3ac8f808"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison operator that returns true if the content of a1 is equal to the given zero-terminated string a2. <br /></td></tr>
<tr class="separator:ab15adbc6c5994b5e25cf0a3b3ac8f808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc935531ee304aaef96fe7619e0e9c39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc935531ee304aaef96fe7619e0e9c39"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#adc935531ee304aaef96fe7619e0e9c39">operator==</a> (const char *a1, const <a class="el" href="classito_1_1_byte_array.html">ByteArray</a> &amp;a2)</td></tr>
<tr class="memdesc:adc935531ee304aaef96fe7619e0e9c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison operator that returns true if the content of a2 is equal to the given zero-terminated string a1. <br /></td></tr>
<tr class="separator:adc935531ee304aaef96fe7619e0e9c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5235b3d69233ff82ed7d216dc74a87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b5235b3d69233ff82ed7d216dc74a87"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8b5235b3d69233ff82ed7d216dc74a87">operator!=</a> (const <a class="el" href="classito_1_1_byte_array.html">ByteArray</a> &amp;a1, const char *a2)</td></tr>
<tr class="memdesc:a8b5235b3d69233ff82ed7d216dc74a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison operator that returns true if the content of a1 is not equal to the given zero-terminated string a2. <br /></td></tr>
<tr class="separator:a8b5235b3d69233ff82ed7d216dc74a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b7958e3950a8682bf1b9b0a3573d75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85b7958e3950a8682bf1b9b0a3573d75"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a85b7958e3950a8682bf1b9b0a3573d75">operator!=</a> (const char *a1, const <a class="el" href="classito_1_1_byte_array.html">ByteArray</a> &amp;a2)</td></tr>
<tr class="memdesc:a85b7958e3950a8682bf1b9b0a3573d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">comparison operator that returns true if the content of a2 is not equal to the given zero-terminated string a1. <br /></td></tr>
<tr class="separator:a85b7958e3950a8682bf1b9b0a3573d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373054f9bcab29d904ee9fa250d76fe0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a373054f9bcab29d904ee9fa250d76fe0"></a>
ito::int8&#160;</td><td class="memItemRight" valign="bottom"><b>getInt8</b> (const uchar **ppval)</td></tr>
<tr class="separator:a373054f9bcab29d904ee9fa250d76fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d40707b8207dbd6ce07aff6eb18799"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9d40707b8207dbd6ce07aff6eb18799"></a>
ito::uint8&#160;</td><td class="memItemRight" valign="bottom"><b>getUInt8</b> (const uchar **ppval)</td></tr>
<tr class="separator:ab9d40707b8207dbd6ce07aff6eb18799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e01d8f20c72b63f7fbd8c7d972ebaef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e01d8f20c72b63f7fbd8c7d972ebaef"></a>
ito::int16&#160;</td><td class="memItemRight" valign="bottom"><b>getInt16LE</b> (const uchar **ppval)</td></tr>
<tr class="separator:a4e01d8f20c72b63f7fbd8c7d972ebaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6505b4017001c4fd9716e276006d35c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6505b4017001c4fd9716e276006d35c3"></a>
ito::int16&#160;</td><td class="memItemRight" valign="bottom"><b>getInt16BE</b> (const uchar **ppval)</td></tr>
<tr class="separator:a6505b4017001c4fd9716e276006d35c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39f73da95737ff8a9527f72d80514ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af39f73da95737ff8a9527f72d80514ea"></a>
ito::uint16&#160;</td><td class="memItemRight" valign="bottom"><b>getUInt16LE</b> (const uchar **ppval)</td></tr>
<tr class="separator:af39f73da95737ff8a9527f72d80514ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6986e2dc9d9c71ccfc3d92dd52165743"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6986e2dc9d9c71ccfc3d92dd52165743"></a>
ito::uint16&#160;</td><td class="memItemRight" valign="bottom"><b>getUInt16BE</b> (const uchar **ppval)</td></tr>
<tr class="separator:a6986e2dc9d9c71ccfc3d92dd52165743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3228e631089a1447533277cd869fd542"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3228e631089a1447533277cd869fd542"></a>
ito::int32&#160;</td><td class="memItemRight" valign="bottom"><b>getInt32LE</b> (const uchar **ppval)</td></tr>
<tr class="separator:a3228e631089a1447533277cd869fd542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcc74288d76133ee5ee3c892d55a819"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfcc74288d76133ee5ee3c892d55a819"></a>
ito::uint32&#160;</td><td class="memItemRight" valign="bottom"><b>getUInt32LE</b> (const uchar **ppval)</td></tr>
<tr class="separator:abfcc74288d76133ee5ee3c892d55a819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4319ed87dc01c49b09037903679f7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a4319ed87dc01c49b09037903679f7c"></a>
ito::uint32&#160;</td><td class="memItemRight" valign="bottom"><b>getUInt32BE</b> (const uchar **ppval)</td></tr>
<tr class="separator:a4a4319ed87dc01c49b09037903679f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb2be71fd153961c485898dd44494c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacb2be71fd153961c485898dd44494c8"></a>
qint64&#160;</td><td class="memItemRight" valign="bottom"><b>getInt64LE</b> (const uchar **ppval)</td></tr>
<tr class="separator:aacb2be71fd153961c485898dd44494c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ae2b77f41b8846dd6a72a38a9d3f0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7ae2b77f41b8846dd6a72a38a9d3f0a"></a>
qint64&#160;</td><td class="memItemRight" valign="bottom"><b>getInt64BE</b> (const uchar **ppval)</td></tr>
<tr class="separator:ae7ae2b77f41b8846dd6a72a38a9d3f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d761883af83f6826e9daec54964b314"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d761883af83f6826e9daec54964b314"></a>
quint64&#160;</td><td class="memItemRight" valign="bottom"><b>getUInt64LE</b> (const uchar **ppval)</td></tr>
<tr class="separator:a0d761883af83f6826e9daec54964b314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c794d0fbe4331663300e99cc5b6c0a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39c794d0fbe4331663300e99cc5b6c0a"></a>
quint64&#160;</td><td class="memItemRight" valign="bottom"><b>getUInt64BE</b> (const uchar **ppval)</td></tr>
<tr class="separator:a39c794d0fbe4331663300e99cc5b6c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a25180e8c9bfbe63f5ec9858db38de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03a25180e8c9bfbe63f5ec9858db38de"></a>
ito::float32&#160;</td><td class="memItemRight" valign="bottom"><b>getFloat32LE</b> (const uchar **ppval)</td></tr>
<tr class="separator:a03a25180e8c9bfbe63f5ec9858db38de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682383f74b66b9c079bff0a231106c42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a682383f74b66b9c079bff0a231106c42"></a>
ito::float32&#160;</td><td class="memItemRight" valign="bottom"><b>getFloat32BE</b> (const uchar **ppval)</td></tr>
<tr class="separator:a682383f74b66b9c079bff0a231106c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bdf369f81aaff7e00b70d54e31439b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5bdf369f81aaff7e00b70d54e31439b"></a>
ito::float64&#160;</td><td class="memItemRight" valign="bottom"><b>getFloat64LE</b> (const uchar **ppval)</td></tr>
<tr class="separator:ac5bdf369f81aaff7e00b70d54e31439b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c81da4f2a355af3ebd5428fe32772c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0c81da4f2a355af3ebd5428fe32772c"></a>
ito::float64&#160;</td><td class="memItemRight" valign="bottom"><b>getFloat64BE</b> (const uchar **ppval)</td></tr>
<tr class="separator:ae0c81da4f2a355af3ebd5428fe32772c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217832e3410749ba1502fad1e1c6640e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a217832e3410749ba1502fad1e1c6640e"></a>
ito::int16&#160;</td><td class="memItemRight" valign="bottom"><b>swapInt16</b> (ito::int16 val)</td></tr>
<tr class="separator:a217832e3410749ba1502fad1e1c6640e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4b73128cde94cd1cd1c31d92e6508f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e4b73128cde94cd1cd1c31d92e6508f"></a>
ito::uint16&#160;</td><td class="memItemRight" valign="bottom"><b>swapUInt16</b> (ito::uint16 val)</td></tr>
<tr class="separator:a8e4b73128cde94cd1cd1c31d92e6508f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785bbe9f2351c21c48331932ddd67c28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a785bbe9f2351c21c48331932ddd67c28"></a>
ito::int32&#160;</td><td class="memItemRight" valign="bottom"><b>swapInt32</b> (ito::int32 val)</td></tr>
<tr class="separator:a785bbe9f2351c21c48331932ddd67c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11bde6ccee8d7cb71d69fe9feb4becef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11bde6ccee8d7cb71d69fe9feb4becef"></a>
ito::uint32&#160;</td><td class="memItemRight" valign="bottom"><b>swapUInt32</b> (ito::uint32 val)</td></tr>
<tr class="separator:a11bde6ccee8d7cb71d69fe9feb4becef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3af3b16ba7635fffeee440d71881e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a3af3b16ba7635fffeee440d71881e7"></a>
ito::float32&#160;</td><td class="memItemRight" valign="bottom"><b>swapFloat32</b> (ito::float32 val)</td></tr>
<tr class="separator:a8a3af3b16ba7635fffeee440d71881e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f3e045a81bb8726c908eb95184f788"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65f3e045a81bb8726c908eb95184f788"></a>
ito::float64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a65f3e045a81bb8726c908eb95184f788">swapFloat64</a> (ito::float64 val)</td></tr>
<tr class="memdesc:a65f3e045a81bb8726c908eb95184f788"><td class="mdescLeft">&#160;</td><td class="mdescRight">reads exactly numBytes from device into data and returns an error if less or no data is available <br /></td></tr>
<tr class="separator:a65f3e045a81bb8726c908eb95184f788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f08e4f7bea717dfc95d920eb1a8947"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1f08e4f7bea717dfc95d920eb1a8947"></a>
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ITOMCOMMONQT_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><b>readFromDevice</b> (QIODevice *device, char *data, qint64 numBytes)</td></tr>
<tr class="separator:ab1f08e4f7bea717dfc95d920eb1a8947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1656553da37a695446b1b38962d48985"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1656553da37a695446b1b38962d48985"></a>
ito::int32&#160;</td><td class="memItemRight" valign="bottom"><b>getInt32BE</b> (const uchar **ppval)</td></tr>
<tr class="separator:a1656553da37a695446b1b38962d48985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af758f942701d80f2531249158bb33d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ITOMCOMMONQT_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6af758f942701d80f2531249158bb33d">checkParamVector</a> (QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *params)</td></tr>
<tr class="memdesc:a6af758f942701d80f2531249158bb33d"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks param vector  <a href="#a6af758f942701d80f2531249158bb33d">More...</a><br /></td></tr>
<tr class="separator:a6af758f942701d80f2531249158bb33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4bb116538f127474d6353604b88a55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ITOMCOMMONQT_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8d4bb116538f127474d6353604b88a55">checkParamVectors</a> (QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramsMand, QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramsOpt, QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramsOut)</td></tr>
<tr class="memdesc:a8d4bb116538f127474d6353604b88a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">verifies that the three param vectors are not NULL  <a href="#a8d4bb116538f127474d6353604b88a55">More...</a><br /></td></tr>
<tr class="separator:a8d4bb116538f127474d6353604b88a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f62de950023c3db6e6f899aacc6bd3"><td class="memItemLeft" align="right" valign="top">ITOMCOMMONQT_EXPORT <a class="el" href="classito_1_1_param.html">ito::Param</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae5f62de950023c3db6e6f899aacc6bd3">getParamByName</a> (QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramVec, const char *name, <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> *retval)</td></tr>
<tr class="memdesc:ae5f62de950023c3db6e6f899aacc6bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">brief returns a parameter from the parameter-vector, that fits to a specific name  <a href="#ae5f62de950023c3db6e6f899aacc6bd3">More...</a><br /></td></tr>
<tr class="separator:ae5f62de950023c3db6e6f899aacc6bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c544a621f46e56e7f344c42349e225"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95c544a621f46e56e7f344c42349e225"></a>
ITOMCOMMONQT_EXPORT <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getParamByName</b> (QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *paramVec, const char *name, <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> *retval=NULL)</td></tr>
<tr class="separator:a95c544a621f46e56e7f344c42349e225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb88bcfd3147001e6a36a9eddbe6579d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb88bcfd3147001e6a36a9eddbe6579d"></a>
ITOMCOMMONQT_EXPORT QHash&lt; QString, <a class="el" href="classito_1_1_param.html">ito::Param</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>createParamHashTable</b> (QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramVec)</td></tr>
<tr class="separator:afb88bcfd3147001e6a36a9eddbe6579d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27f538ca78ffe171aa40d09600b1cd0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad27f538ca78ffe171aa40d09600b1cd0"></a>
bool ITOMCOMMONQT_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><b>checkNumericParamRange</b> (const <a class="el" href="classito_1_1_param.html">ito::Param</a> &amp;param, double &amp;value, bool *ok=NULL)</td></tr>
<tr class="separator:ad27f538ca78ffe171aa40d09600b1cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea20a9bf1563f8642db8062c912b2b2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ITOMCOMMONQT_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aea20a9bf1563f8642db8062c912b2b2c">parseParamName</a> (const QString &amp;name, QString &amp;paramName, bool &amp;hasIndex, int &amp;index, QString &amp;additionalTag)</td></tr>
<tr class="memdesc:aea20a9bf1563f8642db8062c912b2b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">parses parameter name with respect to regular expression, assigned for parameter-communcation with plugins  <a href="#aea20a9bf1563f8642db8062c912b2b2c">More...</a><br /></td></tr>
<tr class="separator:aea20a9bf1563f8642db8062c912b2b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c5ea5d26aca3862f620e329316b5ee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15c5ea5d26aca3862f620e329316b5ee"></a>
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ITOMCOMMONQT_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><b>getParamValue</b> (const QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *m_params, const QString &amp;key, <a class="el" href="classito_1_1_param.html">ito::Param</a> &amp;value, QString &amp;pkey, int &amp;index)</td></tr>
<tr class="separator:a15c5ea5d26aca3862f620e329316b5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3f99ca6b24b94df6ac7d7fea70562d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a3f99ca6b24b94df6ac7d7fea70562d"></a>
<a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ITOMCOMMONQT_EXPORT&#160;</td><td class="memItemRight" valign="bottom"><b>setParamValue</b> (const QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *m_params, const QString &amp;key, const <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &amp;value, QString &amp;pkey, int &amp;index)</td></tr>
<tr class="separator:a7a3f99ca6b24b94df6ac7d7fea70562d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124cad7b70aa5f583649232eb051ba20"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a124cad7b70aa5f583649232eb051ba20"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a124cad7b70aa5f583649232eb051ba20">isNotZero</a> (_Tp value)</td></tr>
<tr class="memdesc:a124cad7b70aa5f583649232eb051ba20"><td class="mdescLeft">&#160;</td><td class="mdescRight">method returns whether a given variable is not equal to zero.  <a href="#a124cad7b70aa5f583649232eb051ba20">More...</a><br /></td></tr>
<tr class="separator:a124cad7b70aa5f583649232eb051ba20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1110f06d49f9ee8f6e195a1c9a51b6e"><td class="memTemplParams" colspan="2"><a class="anchor" id="af1110f06d49f9ee8f6e195a1c9a51b6e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af1110f06d49f9ee8f6e195a1c9a51b6e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af1110f06d49f9ee8f6e195a1c9a51b6e">isNotZero&lt; float32 &gt;</a> (float32 value)</td></tr>
<tr class="memdesc:af1110f06d49f9ee8f6e195a1c9a51b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a value is equal to zero for float32. <br /></td></tr>
<tr class="separator:af1110f06d49f9ee8f6e195a1c9a51b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ddde3384f8a17ed35f51c5d9ca4f8d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a65ddde3384f8a17ed35f51c5d9ca4f8d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a65ddde3384f8a17ed35f51c5d9ca4f8d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a65ddde3384f8a17ed35f51c5d9ca4f8d">isNotZero&lt; float64 &gt;</a> (float64 value)</td></tr>
<tr class="memdesc:a65ddde3384f8a17ed35f51c5d9ca4f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a value is equal to zero for float64. <br /></td></tr>
<tr class="separator:a65ddde3384f8a17ed35f51c5d9ca4f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d21d77614c0c51d5dc0d0cc34e06ea0"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a4d21d77614c0c51d5dc0d0cc34e06ea0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a4d21d77614c0c51d5dc0d0cc34e06ea0">isFinite</a> (_Tp)</td></tr>
<tr class="memdesc:a4d21d77614c0c51d5dc0d0cc34e06ea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">method returns whether a given variable is finite.  <a href="#a4d21d77614c0c51d5dc0d0cc34e06ea0">More...</a><br /></td></tr>
<tr class="separator:a4d21d77614c0c51d5dc0d0cc34e06ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c22bb0f8da13737590c55430354dd7a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1c22bb0f8da13737590c55430354dd7a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a1c22bb0f8da13737590c55430354dd7a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a1c22bb0f8da13737590c55430354dd7a">isFinite&lt; float32 &gt;</a> (float32 value)</td></tr>
<tr class="memdesc:a1c22bb0f8da13737590c55430354dd7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a value is finite float32 values. <br /></td></tr>
<tr class="separator:a1c22bb0f8da13737590c55430354dd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c41490f7af72cd17fdbafa1de8e7c19"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8c41490f7af72cd17fdbafa1de8e7c19"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8c41490f7af72cd17fdbafa1de8e7c19"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8c41490f7af72cd17fdbafa1de8e7c19">isFinite&lt; float64 &gt;</a> (float64 value)</td></tr>
<tr class="memdesc:a8c41490f7af72cd17fdbafa1de8e7c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a value is finite float64 values. <br /></td></tr>
<tr class="separator:a8c41490f7af72cd17fdbafa1de8e7c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ac97f8f52951790bbc4b2e21bde137"><td class="memTemplParams" colspan="2"><a class="anchor" id="a80ac97f8f52951790bbc4b2e21bde137"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a80ac97f8f52951790bbc4b2e21bde137"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a80ac97f8f52951790bbc4b2e21bde137">isFinite&lt; complex64 &gt;</a> (complex64 value)</td></tr>
<tr class="memdesc:a80ac97f8f52951790bbc4b2e21bde137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if both components of complex64 value are finite. <br /></td></tr>
<tr class="separator:a80ac97f8f52951790bbc4b2e21bde137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f851235f83497da57bb8c058573b6f"><td class="memTemplParams" colspan="2"><a class="anchor" id="af3f851235f83497da57bb8c058573b6f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af3f851235f83497da57bb8c058573b6f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#af3f851235f83497da57bb8c058573b6f">isFinite&lt; complex128 &gt;</a> (complex128 value)</td></tr>
<tr class="memdesc:af3f851235f83497da57bb8c058573b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if both components of complex128 value are finite. <br /></td></tr>
<tr class="separator:af3f851235f83497da57bb8c058573b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdff8f7ba0e7ffb2c9ebc823b16b6f8d"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:abdff8f7ba0e7ffb2c9ebc823b16b6f8d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#abdff8f7ba0e7ffb2c9ebc823b16b6f8d">isNaN</a> (_Tp value)</td></tr>
<tr class="memdesc:abdff8f7ba0e7ffb2c9ebc823b16b6f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">method returns whether a given variable is NaN / not a Number but maybe Inf.  <a href="#abdff8f7ba0e7ffb2c9ebc823b16b6f8d">More...</a><br /></td></tr>
<tr class="separator:abdff8f7ba0e7ffb2c9ebc823b16b6f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa584532b8cefe9c52bc0a5444628c4f0"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa584532b8cefe9c52bc0a5444628c4f0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa584532b8cefe9c52bc0a5444628c4f0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa584532b8cefe9c52bc0a5444628c4f0">isNaN&lt; float32 &gt;</a> (float32 value)</td></tr>
<tr class="memdesc:aa584532b8cefe9c52bc0a5444628c4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a value is isNaN float32 values. <br /></td></tr>
<tr class="separator:aa584532b8cefe9c52bc0a5444628c4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e922ec7cf0e18d022f61669bd3d04a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a52e922ec7cf0e18d022f61669bd3d04a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a52e922ec7cf0e18d022f61669bd3d04a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a52e922ec7cf0e18d022f61669bd3d04a">isNaN&lt; float64 &gt;</a> (float64 value)</td></tr>
<tr class="memdesc:a52e922ec7cf0e18d022f61669bd3d04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a value is isNaN float64 values. <br /></td></tr>
<tr class="separator:a52e922ec7cf0e18d022f61669bd3d04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ce77a388e6ee67076406d5e585afab"><td class="memTemplParams" colspan="2"><a class="anchor" id="a74ce77a388e6ee67076406d5e585afab"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a74ce77a388e6ee67076406d5e585afab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a74ce77a388e6ee67076406d5e585afab">isNaN&lt; complex64 &gt;</a> (complex64 value)</td></tr>
<tr class="memdesc:a74ce77a388e6ee67076406d5e585afab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if one of the components of complex64 values are not a number. <br /></td></tr>
<tr class="separator:a74ce77a388e6ee67076406d5e585afab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520bc96354a0c44030f55d75a44caa5d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a520bc96354a0c44030f55d75a44caa5d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a520bc96354a0c44030f55d75a44caa5d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a520bc96354a0c44030f55d75a44caa5d">isNaN&lt; complex128 &gt;</a> (complex128 value)</td></tr>
<tr class="memdesc:a520bc96354a0c44030f55d75a44caa5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if one of the components of complex128 values are not a number. <br /></td></tr>
<tr class="separator:a520bc96354a0c44030f55d75a44caa5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1579e24007ee8c3c85fa3d65687a47"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a8a1579e24007ee8c3c85fa3d65687a47"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a8a1579e24007ee8c3c85fa3d65687a47">isInf</a> (_Tp)</td></tr>
<tr class="memdesc:a8a1579e24007ee8c3c85fa3d65687a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">method returns whether a given variable is Inf / not may be NaN.  <a href="#a8a1579e24007ee8c3c85fa3d65687a47">More...</a><br /></td></tr>
<tr class="separator:a8a1579e24007ee8c3c85fa3d65687a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12aad84162a91ef82da196655da86c54"><td class="memTemplParams" colspan="2"><a class="anchor" id="a12aad84162a91ef82da196655da86c54"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a12aad84162a91ef82da196655da86c54"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a12aad84162a91ef82da196655da86c54">isInf&lt; float32 &gt;</a> (float32 value)</td></tr>
<tr class="memdesc:a12aad84162a91ef82da196655da86c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a value is infinite float32 values. <br /></td></tr>
<tr class="separator:a12aad84162a91ef82da196655da86c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb33f0f0d3f5470256b6340824368473"><td class="memTemplParams" colspan="2"><a class="anchor" id="abb33f0f0d3f5470256b6340824368473"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:abb33f0f0d3f5470256b6340824368473"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#abb33f0f0d3f5470256b6340824368473">isInf&lt; float64 &gt;</a> (float64 value)</td></tr>
<tr class="memdesc:abb33f0f0d3f5470256b6340824368473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a value is infinite float64 values. <br /></td></tr>
<tr class="separator:abb33f0f0d3f5470256b6340824368473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8195195b6988a0b10a5466bd7f8b57"><td class="memTemplParams" colspan="2"><a class="anchor" id="afa8195195b6988a0b10a5466bd7f8b57"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:afa8195195b6988a0b10a5466bd7f8b57"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#afa8195195b6988a0b10a5466bd7f8b57">isInf&lt; complex64 &gt;</a> (complex64 value)</td></tr>
<tr class="memdesc:afa8195195b6988a0b10a5466bd7f8b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if one of the components of complex64 values are infinite. <br /></td></tr>
<tr class="separator:afa8195195b6988a0b10a5466bd7f8b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f998cbd833c4e6fb5b2bc69f5d71705"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6f998cbd833c4e6fb5b2bc69f5d71705"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6f998cbd833c4e6fb5b2bc69f5d71705"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6f998cbd833c4e6fb5b2bc69f5d71705">isInf&lt; complex128 &gt;</a> (complex128 value)</td></tr>
<tr class="memdesc:a6f998cbd833c4e6fb5b2bc69f5d71705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if one of the components of complex128 values are infinite. <br /></td></tr>
<tr class="separator:a6f998cbd833c4e6fb5b2bc69f5d71705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76021c3bc27c63380f8f54552d60b70"><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:aa76021c3bc27c63380f8f54552d60b70"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa76021c3bc27c63380f8f54552d60b70">isZeroValue</a> (_Tp v, _Tp)</td></tr>
<tr class="memdesc:aa76021c3bc27c63380f8f54552d60b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">method returns whether a given variable is equal to zero.  <a href="#aa76021c3bc27c63380f8f54552d60b70">More...</a><br /></td></tr>
<tr class="separator:aa76021c3bc27c63380f8f54552d60b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5a7a0ae7391a4fb84c07f6d7e4215e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4f5a7a0ae7391a4fb84c07f6d7e4215e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4f5a7a0ae7391a4fb84c07f6d7e4215e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isZeroValue</b> (<a class="el" href="classito_1_1_rgba32.html">Rgba32</a> v, <a class="el" href="classito_1_1_rgba32.html">Rgba32</a>)</td></tr>
<tr class="separator:a4f5a7a0ae7391a4fb84c07f6d7e4215e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0c918231d83e719101cb150133a3a6"><td class="memTemplParams" colspan="2"><a class="anchor" id="aee0c918231d83e719101cb150133a3a6"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aee0c918231d83e719101cb150133a3a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isZeroValue</b> (float32 v, float32 epsilon)</td></tr>
<tr class="separator:aee0c918231d83e719101cb150133a3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606c101d2a0ebf367b4d862701fc38fe"><td class="memTemplParams" colspan="2"><a class="anchor" id="a606c101d2a0ebf367b4d862701fc38fe"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a606c101d2a0ebf367b4d862701fc38fe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isZeroValue</b> (float64 v, float64 epsilon)</td></tr>
<tr class="separator:a606c101d2a0ebf367b4d862701fc38fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec9cf0f60fc8526da8569e4ff040d89"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaec9cf0f60fc8526da8569e4ff040d89"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aaec9cf0f60fc8526da8569e4ff040d89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isZeroValue</b> (std::complex&lt; ito::float32 &gt; v, std::complex&lt; ito::float32 &gt; epsilon)</td></tr>
<tr class="separator:aaec9cf0f60fc8526da8569e4ff040d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8d0210c6e22d340b1dfd7f9e6129b9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f8d0210c6e22d340b1dfd7f9e6129b9"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a1f8d0210c6e22d340b1dfd7f9e6129b9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isZeroValue</b> (std::complex&lt; ito::float64 &gt; v, std::complex&lt; ito::float64 &gt; epsilon)</td></tr>
<tr class="separator:a1f8d0210c6e22d340b1dfd7f9e6129b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298706f7ef2ee3091d0e394a23f26f62"><td class="memTemplParams" colspan="2"><a class="anchor" id="a298706f7ef2ee3091d0e394a23f26f62"></a>
template&lt;typename _Tp &gt; </td></tr>
<tr class="memitem:a298706f7ef2ee3091d0e394a23f26f62"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceito.html#a298706f7ef2ee3091d0e394a23f26f62">areEqual</a> (_Tp a, _Tp b)</td></tr>
<tr class="memdesc:a298706f7ef2ee3091d0e394a23f26f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">method returns whether two given numbers of the same type are equal. <br /></td></tr>
<tr class="separator:a298706f7ef2ee3091d0e394a23f26f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c8c01cbb27bac698e5bbcffe98a109"><td class="memTemplParams" colspan="2"><a class="anchor" id="a05c8c01cbb27bac698e5bbcffe98a109"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a05c8c01cbb27bac698e5bbcffe98a109"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>areEqual</b> (float32 a, float32 b)</td></tr>
<tr class="separator:a05c8c01cbb27bac698e5bbcffe98a109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3334cbfc7c16fcddc34099a0973f6040"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3334cbfc7c16fcddc34099a0973f6040"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3334cbfc7c16fcddc34099a0973f6040"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>areEqual</b> (float64 a, float64 b)</td></tr>
<tr class="separator:a3334cbfc7c16fcddc34099a0973f6040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b9a90829ea77e9d811eee258bcaeb6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae1b9a90829ea77e9d811eee258bcaeb6"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae1b9a90829ea77e9d811eee258bcaeb6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>areEqual</b> (complex64 a, complex64 b)</td></tr>
<tr class="separator:ae1b9a90829ea77e9d811eee258bcaeb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdb19af7b7c4d4df7ffc602c1422fca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4fdb19af7b7c4d4df7ffc602c1422fca"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4fdb19af7b7c4d4df7ffc602c1422fca"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>areEqual</b> (complex128 a, complex128 b)</td></tr>
<tr class="separator:a4fdb19af7b7c4d4df7ffc602c1422fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c66845fe9e1450f42d33e6191774dcf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c66845fe9e1450f42d33e6191774dcf"></a>
QDataStream ITOMSHAPE_EXPORT &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (QDataStream &amp;out, const <a class="el" href="classito_1_1_shape.html">ito::Shape</a> &amp;shape)</td></tr>
<tr class="separator:a2c66845fe9e1450f42d33e6191774dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2c12cc8f716614d9d0ac61f284aa0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d2c12cc8f716614d9d0ac61f284aa0c"></a>
QDataStream ITOMSHAPE_EXPORT &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (QDataStream &amp;in, <a class="el" href="classito_1_1_shape.html">ito::Shape</a> &amp;shape)</td></tr>
<tr class="separator:a1d2c12cc8f716614d9d0ac61f284aa0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6700407b59c1df38ff5f7235e7246fe5"><td class="memItemLeft" align="right" valign="top">ITOMCOMMONQT_EXPORT <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a6700407b59c1df38ff5f7235e7246fe5">formatDoubleWithUnit</a> (QStringList scaleThisUnitsOnly, QString unitIn, double dVal, double &amp;dValOut, QString &amp;unitOut)</td></tr>
<tr class="memdesc:a6700407b59c1df38ff5f7235e7246fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Function to convert double values with unit to scaled values with scaled units (0.01m -&gt; 10mm)  <a href="#a6700407b59c1df38ff5f7235e7246fe5">More...</a><br /></td></tr>
<tr class="separator:a6700407b59c1df38ff5f7235e7246fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f90e9d0def8c42d6675f889c410cedf"><td class="memItemLeft" align="right" valign="top">ITOMCOMMONQT_EXPORT <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a5f90e9d0def8c42d6675f889c410cedf">generateAutoSaveParamFile</a> (QString plugInName, QFile &amp;paramFile)</td></tr>
<tr class="memdesc:a5f90e9d0def8c42d6675f889c410cedf"><td class="mdescLeft">&#160;</td><td class="mdescRight">loadXML2QLIST loads parameters from an XML-File and saves them to paramList  <a href="#a5f90e9d0def8c42d6675f889c410cedf">More...</a><br /></td></tr>
<tr class="separator:a5f90e9d0def8c42d6675f889c410cedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0411cd240edb9847b61a997a958bc7a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0411cd240edb9847b61a997a958bc7a"></a>
ITOMCOMMONQT_EXPORT <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#af0411cd240edb9847b61a997a958bc7a">loadXML2QLIST</a> (QMap&lt; QString, <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramList, QString id, QFile &amp;paramFile)</td></tr>
<tr class="memdesc:af0411cd240edb9847b61a997a958bc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">saveQLIST2XML writes parameters from paramList to an XML-File <br /></td></tr>
<tr class="separator:af0411cd240edb9847b61a997a958bc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa6f7375af9065c79ddb14d3c1d1f4a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fa6f7375af9065c79ddb14d3c1d1f4a"></a>
ITOMCOMMONQT_EXPORT <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a7fa6f7375af9065c79ddb14d3c1d1f4a">saveQLIST2XML</a> (QMap&lt; QString, <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *paramList, QString id, QFile &amp;paramFile)</td></tr>
<tr class="memdesc:a7fa6f7375af9065c79ddb14d3c1d1f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">mergeQLists copies parameters from newList to oldList and performs some checks <br /></td></tr>
<tr class="separator:a7fa6f7375af9065c79ddb14d3c1d1f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a88bad237520eadc38db91fa5ea1ac6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a88bad237520eadc38db91fa5ea1ac6"></a>
ITOMCOMMONQT_EXPORT <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a4a88bad237520eadc38db91fa5ea1ac6">mergeQLists</a> (QMap&lt; QString, <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *oldList, QMap&lt; QString, <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *newList, bool checkAutoSave, bool deleteUnchangedParams=false)</td></tr>
<tr class="memdesc:a4a88bad237520eadc38db91fa5ea1ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a dataObject to harddrive in a readable ITO-XML-Format (.ido or .idh) <br /></td></tr>
<tr class="separator:a4a88bad237520eadc38db91fa5ea1ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8826921e5df8a0a37e1a43ed2800cc"><td class="memItemLeft" align="right" valign="top">ITOMCOMMONQT_EXPORT <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aca8826921e5df8a0a37e1a43ed2800cc">saveDOBJ2XML</a> (<a class="el" href="classito_1_1_data_object.html">ito::DataObject</a> *dObjOut, QString folderFileName, bool onlyHeaderObjectFile=false, bool doubleAsBinary=false)</td></tr>
<tr class="memdesc:aca8826921e5df8a0a37e1a43ed2800cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import a dataObject from harddrive, saved in the ITO-XML-Format (.ido or .idh)  <a href="#aca8826921e5df8a0a37e1a43ed2800cc">More...</a><br /></td></tr>
<tr class="separator:aca8826921e5df8a0a37e1a43ed2800cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad763de2bc627c32993a7a6e361497065"><td class="memItemLeft" align="right" valign="top">ITOMCOMMONQT_EXPORT <a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad763de2bc627c32993a7a6e361497065">loadXML2DOBJ</a> (<a class="el" href="classito_1_1_data_object.html">ito::DataObject</a> *dObjIn, QString folderFileName, bool onlyHeaderObjectFile=false, bool appendEnding=true)</td></tr>
<tr class="separator:ad763de2bc627c32993a7a6e361497065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8d82ddf3963ec68207576239e7c2f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb8d82ddf3963ec68207576239e7c2f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>paramHelperSetValue</b> (<a class="el" href="classito_1_1_param.html">ito::Param</a> &amp;param, <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> value, const int pos)</td></tr>
<tr class="separator:adb8d82ddf3963ec68207576239e7c2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d394b2ecf4bc3c3e895a7413a117ffa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d394b2ecf4bc3c3e895a7413a117ffa"></a>
QPolygonF&#160;</td><td class="memItemRight" valign="bottom"><b>circle2Polygon</b> (const QPointF &amp;center, qreal radius, qreal tol)</td></tr>
<tr class="separator:a2d394b2ecf4bc3c3e895a7413a117ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72445052a70aa253985a0c76df9042c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab72445052a70aa253985a0c76df9042c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ramerDouglasPeuckerIter</b> (<a class="el" href="structito_1_1_ramer_douglas_peucker_data.html">RamerDouglasPeuckerData</a> &amp;data, int current_index)</td></tr>
<tr class="separator:ab72445052a70aa253985a0c76df9042c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ff1acd7b8b3e2140db87852be40b77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#af3ff1acd7b8b3e2140db87852be40b77">loadXML2QLIST</a> (QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *paramList, QString id, QFile &amp;paramFile)</td></tr>
<tr class="separator:af3ff1acd7b8b3e2140db87852be40b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0f29281bc5cb69fcd9759a369b09eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a1f0f29281bc5cb69fcd9759a369b09eb">saveQLIST2XML</a> (QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *paramList, QString id, QFile &amp;paramFile)</td></tr>
<tr class="separator:a1f0f29281bc5cb69fcd9759a369b09eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487ae8b7490f1de2f8c400eab1859f58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a487ae8b7490f1de2f8c400eab1859f58">mergeQLists</a> (QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *oldList, QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *newList, bool checkAutoSave, bool deleteUnchangedParams)</td></tr>
<tr class="separator:a487ae8b7490f1de2f8c400eab1859f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c6b2139e9995dabe2dbbabd25bab48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a09c6b2139e9995dabe2dbbabd25bab48">writeObjectHeaderToFileV1</a> (QXmlStreamWriter &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut, bool doubleAsBinary, int &amp;elementsize)</td></tr>
<tr class="memdesc:a09c6b2139e9995dabe2dbbabd25bab48"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function writes the header of the Object to the xml stream.  This helper function writes the header (dims, sizes, type) of an object and the metaData (complete DataObjectTags without tagsMap) from the Object to the xml stream. The values of the header are stored as string. The values of each axis-tag / value-tag / rotation matrix are in case of string-type directly written to the stream or in case of double converted to either strings directly (15 significat digits, &gt;32Bit) or stored as lostfree binary (QByteArray::toBase64() to avoid XML-conflict). WARNING: Do not change the header (dims, sizes, type) information or the value of tags exported as binary (d2b).  <a href="#a09c6b2139e9995dabe2dbbabd25bab48">More...</a><br /></td></tr>
<tr class="separator:a09c6b2139e9995dabe2dbbabd25bab48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6e1f7022d1f9024c771f51f01f78da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aad6e1f7022d1f9024c771f51f01f78da">writeObjectTagsToFileV1</a> (QXmlStreamWriter &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut, bool doubleAsBinary)</td></tr>
<tr class="memdesc:aad6e1f7022d1f9024c771f51f01f78da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function writes the tags defined in the tagMap (DataObjectTags) from the Object to the xml stream.  This helper function writes the tags defined in the tagMap (DataObjectTags) from the Object to the xml stream. Therefore the values of each tag are in case of string-type directly written to the stream or in case of double converted to either strings directly (15 significat digits, &gt;32Bit) or stored as lostfree binary (QByteArray::toBase64() to avoid XML-conflict). WARNING: Do not change information or the value of tags exported as binary (d2b).  <a href="#aad6e1f7022d1f9024c771f51f01f78da">More...</a><br /></td></tr>
<tr class="separator:aad6e1f7022d1f9024c771f51f01f78da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96b552c35539676c8a13957de2183ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#af96b552c35539676c8a13957de2183ad">writeObjectDataToFileV1</a> (QXmlStreamWriter &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> *dObjOut, int elementsize)</td></tr>
<tr class="memdesc:af96b552c35539676c8a13957de2183ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function writes the data(cv::mats) from the Object to the xml stream.  This helper function writes the data(cv::mats) from the Object to the xml stream. Therefore the data is converted using QByteArray::toBase64() to avoid XML-conflict with the binary data.  <a href="#af96b552c35539676c8a13957de2183ad">More...</a><br /></td></tr>
<tr class="separator:af96b552c35539676c8a13957de2183ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecd6942c1876cc35f42046db0a098ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#afecd6942c1876cc35f42046db0a098ea">readTillNext</a> (QXmlStreamReader &amp;stream, int &amp;times, int maxtimes)</td></tr>
<tr class="memdesc:afecd6942c1876cc35f42046db0a098ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function reads the stream till the next startElement.  The Qt-Function readNextStartElement sometimes stops at the end-element (:P). So the function tries to read until it reaches the next startelement but only for maxtimes trys the Function checks if the attribute exists and than tries to convert to the value of the attribute either from binary or with string to double functions.  <a href="#afecd6942c1876cc35f42046db0a098ea">More...</a><br /></td></tr>
<tr class="separator:afecd6942c1876cc35f42046db0a098ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98bfefe271214ccda435c4be975f5e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ae98bfefe271214ccda435c4be975f5e4">readDoubleFromXML</a> (QXmlStreamAttributes &amp;attrStream, QString &amp;Element, QString &amp;Attrib, double &amp;val, bool isBinary)</td></tr>
<tr class="memdesc:ae98bfefe271214ccda435c4be975f5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function extracts a double from the xml-Attributes of the Stream  This helper function extracts a double from the xml-Attributes of the Stream copied by the caller with the attrStream = attrStream = stream.attributes();. the Function checks if the attribute exists and than tries to convert to the value of the attribute either from binary or with string to double functions.  <a href="#ae98bfefe271214ccda435c4be975f5e4">More...</a><br /></td></tr>
<tr class="separator:ae98bfefe271214ccda435c4be975f5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3fb95bb073f0055c98ee99e91b9c22a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#aa3fb95bb073f0055c98ee99e91b9c22a">readStdStringFromXML</a> (QXmlStreamAttributes &amp;attrStream, QString &amp;Element, QString &amp;Attrib, std::string &amp;val)</td></tr>
<tr class="memdesc:aa3fb95bb073f0055c98ee99e91b9c22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This helper function extracts a std::string from the xml-Attributes of the Stream  This helper function extracts a std::string from the xml-Attributes of the Stream copied by the caller with the attrStream = attrStream = stream.attributes();. the Function checks if the attribute exists and than tries to convert to the value of the attribute from QString to std::string.  <a href="#aa3fb95bb073f0055c98ee99e91b9c22a">More...</a><br /></td></tr>
<tr class="separator:aa3fb95bb073f0055c98ee99e91b9c22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a8ffb4244dbc37882593e3ae344e74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a49a8ffb4244dbc37882593e3ae344e74">createObjectFromXMLV1</a> (QXmlStreamReader &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObjIn, int &amp;elementsize)</td></tr>
<tr class="memdesc:a49a8ffb4244dbc37882593e3ae344e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates an dataObject from the header of the xml-file  This function creates an dataObject from the header of the xml-file by parsing the XML-stream. The first start element, already read by the calling function must contain the attributes dims, dataType and dim0..dimn-2, dimX, dimY.  <a href="#a49a8ffb4244dbc37882593e3ae344e74">More...</a><br /></td></tr>
<tr class="separator:a49a8ffb4244dbc37882593e3ae344e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b23c44aedc092db34847ec3d850a7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a99b23c44aedc092db34847ec3d850a7c">loadObjectHeaderFromXMLV1</a> (QXmlStreamReader &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObjIn)</td></tr>
<tr class="memdesc:a99b23c44aedc092db34847ec3d850a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fills the MetaData (DataObjectTags) of an allocated dataObject from the values of an xml-file  This function fills the MetaData (DataObjectTags) of an allocated dataObject from the values of an xml-file. This includes the axis-Tags (offset, scale, unit, description), value-Tags ((offset), (scale), unit, description) and the rotation matrix. It does not include the tag-Space (std::map&lt;std::string, DataObjectTagType&gt; m_tags) (e.g. protocol ...)  <a href="#a99b23c44aedc092db34847ec3d850a7c">More...</a><br /></td></tr>
<tr class="separator:a99b23c44aedc092db34847ec3d850a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4132d915f47775d5edcab7874885c27d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a4132d915f47775d5edcab7874885c27d">loadTagSpaceFromXMLV1</a> (QXmlStreamReader &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObjIn)</td></tr>
<tr class="memdesc:a4132d915f47775d5edcab7874885c27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function fills the tagsSpace (DataObjectTags) of an allocated dataObject from the values of an xml-file  This function fills the tagsSpace (DataObjectTags) of an allocated dataObject from the values of an xml-file. This onlye includes the tag-Space (std::map&lt;std::string, DataObjectTagType&gt; m_tags) (e.g. protocol ...) and does not include the axis-Tags (offset, scale, unit, description), value-Tags ((offset), (scale), unit, description) and the rotation matrix.  <a href="#a4132d915f47775d5edcab7874885c27d">More...</a><br /></td></tr>
<tr class="separator:a4132d915f47775d5edcab7874885c27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43463b798f2244f8f380ff8af5337c20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classito_1_1_ret_val.html">RetVal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a43463b798f2244f8f380ff8af5337c20">loadDataFromXMLV1</a> (QXmlStreamReader &amp;stream, <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;dObjIn, int elementsize)</td></tr>
<tr class="memdesc:a43463b798f2244f8f380ff8af5337c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function copies the CDATA from the xml-file to the allocated dataObject.  This function copies the CDATA from the xml-file to the allocated dataObject. The data was before packed (substitution of xml-registered characters) during saving and is unpacked here. The data is stored plane-wise. The function checks if the plane-size if the object is equal to the imported size.  <a href="#a43463b798f2244f8f380ff8af5337c20">More...</a><br /></td></tr>
<tr class="separator:a43463b798f2244f8f380ff8af5337c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6ceb5caccc23ce6cbd6c032df9d3b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d6ceb5caccc23ce6cbd6c032df9d3b2"></a>
static QIcon&#160;</td><td class="memItemRight" valign="bottom"><b>drawCheckBox</b> (bool value)</td></tr>
<tr class="separator:a2d6ceb5caccc23ce6cbd6c032df9d3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1757b1295676fd9c449df6b439cccb85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1757b1295676fd9c449df6b439cccb85"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpChannels</b> (const QList&lt; QSharedPointer&lt; <a class="el" href="classito_1_1_channel.html">Channel</a> &gt; &gt; &amp;channels, <a class="el" href="classito_1_1_abstract_node.html">AbstractNode</a> *an, const QString &amp;prefix)</td></tr>
<tr class="separator:a1757b1295676fd9c449df6b439cccb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aacfb5faee5617334d20f8ff0c2974069"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aacfb5faee5617334d20f8ff0c2974069"></a>
void **&#160;</td><td class="memItemRight" valign="bottom"><b>ITOM_API_FUNCS_GRAPH</b></td></tr>
<tr class="separator:aacfb5faee5617334d20f8ff0c2974069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a87731c8a17f2acd5a5f3de4ae3f262"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><b>ITOM_API_FUNCS_GRAPH_ARR</b> []</td></tr>
<tr class="separator:a0a87731c8a17f2acd5a5f3de4ae3f262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1182d98e161dd3b539921d632f84038d"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structito_1_1_py_c_map.html">ito::PyCMap</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pyCMap</b> []</td></tr>
<tr class="separator:a1182d98e161dd3b539921d632f84038d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1953a8621fd68bd659c9de9bfce5231a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1953a8621fd68bd659c9de9bfce5231a"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>PAPERCOLOR</b> = 1</td></tr>
<tr class="separator:a1953a8621fd68bd659c9de9bfce5231a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c97c87df65f3a136bf22b9c5fd42e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9c97c87df65f3a136bf22b9c5fd42e6"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>WHITESPACECOLOR</b> = 4</td></tr>
<tr class="separator:aa9c97c87df65f3a136bf22b9c5fd42e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353b6f36f722568a109d3a14152756f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a353b6f36f722568a109d3a14152756f6"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>UNMATCHEDBRACECOLOR</b> = 5</td></tr>
<tr class="separator:a353b6f36f722568a109d3a14152756f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b9ec9313f22c816e36029997e61ee3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48b9ec9313f22c816e36029997e61ee3"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>MATCHEDBRACECOLOR</b> = 6</td></tr>
<tr class="separator:a48b9ec9313f22c816e36029997e61ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ac0ce3cb2912c33277c0b2f35f6b36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41ac0ce3cb2912c33277c0b2f35f6b36"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>MARKERERRORCOLOR</b> = 7</td></tr>
<tr class="separator:a41ac0ce3cb2912c33277c0b2f35f6b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77426369135ab346f1bfa0bdffa462e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac77426369135ab346f1bfa0bdffa462e"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>MARKERCURRENTCOLOR</b> = 8</td></tr>
<tr class="separator:ac77426369135ab346f1bfa0bdffa462e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac3536c1477d124d70a7972c795cc8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ac3536c1477d124d70a7972c795cc8e"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>MARKERINPUTCOLOR</b> = 9</td></tr>
<tr class="separator:a3ac3536c1477d124d70a7972c795cc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768afe74423f4aaf83a29d552ecaec29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a768afe74423f4aaf83a29d552ecaec29"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>CARETCOLOR</b> = 10</td></tr>
<tr class="separator:a768afe74423f4aaf83a29d552ecaec29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bd462c025dd53ac64c9439785dbfcf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53bd462c025dd53ac64c9439785dbfcf"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>SELECTIONCOLOR</b> = 11</td></tr>
<tr class="separator:a53bd462c025dd53ac64c9439785dbfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925f91bf84ff207314537d7460d1dc49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a925f91bf84ff207314537d7460d1dc49"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>MARKERSAMESTRINGCOLOR</b> = 12</td></tr>
<tr class="separator:a925f91bf84ff207314537d7460d1dc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f138b07e2cfbd66d2badb5f65add98"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64f138b07e2cfbd66d2badb5f65add98"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>MARKERSCRIPTERRORCOLOR</b> = 13</td></tr>
<tr class="separator:a64f138b07e2cfbd66d2badb5f65add98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af488d39d5fa87dd219cda2bf3d4ccd4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af488d39d5fa87dd219cda2bf3d4ccd4f"></a>
void **&#160;</td><td class="memItemRight" valign="bottom"><b>ITOM_API_FUNCS</b></td></tr>
<tr class="separator:af488d39d5fa87dd219cda2bf3d4ccd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3591ed94bfa2025ea35f80b6b7e1c3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3591ed94bfa2025ea35f80b6b7e1c3a"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>ITOM_API_FUNCS_ARR</b> []</td></tr>
<tr class="separator:ac3591ed94bfa2025ea35f80b6b7e1c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4e931b9ffb4d53504b835419bbf5d5"><td class="memItemLeft" align="right" valign="top">tCoutFunc&#160;</td><td class="memItemRight" valign="bottom"><b>fListCout</b> []</td></tr>
<tr class="separator:a5f4e931b9ffb4d53504b835419bbf5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568df211be05e76f53d2262087e4b0b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a568df211be05e76f53d2262087e4b0b6"></a>
const uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#a568df211be05e76f53d2262087e4b0b6">paramFlagMask</a> = 0xFFFF0000</td></tr>
<tr class="memdesc:a568df211be05e76f53d2262087e4b0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">bits of type lying within this mask are flags (e.g. typeNoAutosave, typeReadonly...) <br /></td></tr>
<tr class="separator:a568df211be05e76f53d2262087e4b0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9158b33ef1d02a45a7d603ed6ad0906"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9158b33ef1d02a45a7d603ed6ad0906"></a>
const uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceito.html#ad9158b33ef1d02a45a7d603ed6ad0906">paramTypeMask</a> = 0x0000FFFF</td></tr>
<tr class="memdesc:ad9158b33ef1d02a45a7d603ed6ad0906"><td class="mdescLeft">&#160;</td><td class="mdescRight">bits of param type lying withing this mask describe the type (typeNoAutosave must be included there) <br /></td></tr>
<tr class="separator:ad9158b33ef1d02a45a7d603ed6ad0906"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>&lt; this is for the plugin param save / load</p>
<p>&lt; this is for the dataobject save / load </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="abd3b401f17cb5d7d7cc67d4063714b0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#abd3b401f17cb5d7d7cc67d4063714b0f">ito::PlotDataType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enumeration that describes the type of input data that a designer plot widget accepts </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="abd3b401f17cb5d7d7cc67d4063714b0faea2db09dcf5e943d5f6cda364c5dd063"></a>DataObjLine&#160;</td><td class="fielddoc">
<p>1xN or Nx1 data object </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abd3b401f17cb5d7d7cc67d4063714b0fa012498cd87eba951ae2a78a8c3e7e17c"></a>DataObjPlane&#160;</td><td class="fielddoc">
<p>2D data object </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abd3b401f17cb5d7d7cc67d4063714b0fab7d003b3b16dcbfa0338ef4ab807bb00"></a>DataObjPlaneStack&#160;</td><td class="fielddoc">
<p>data object with more than one plane </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abd3b401f17cb5d7d7cc67d4063714b0fab6ff58696dec6c2e0839a001388fa947"></a>PointCloud&#160;</td><td class="fielddoc">
<p>point cloud </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abd3b401f17cb5d7d7cc67d4063714b0fa2da3a841845c2c99c1abb5d67c53f54e"></a>PolygonMesh&#160;</td><td class="fielddoc">
<p>polygon mesh </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ab4779b960376c89061f1b12ae3738383"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#ab4779b960376c89061f1b12ae3738383">ito::tActuatorStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tActuatorStatus enumeration </p>
<p>flags used for describing the status of one axis of an actuator plugin.</p>
<p>These flags are intended to be combined in the status bitmask. Usually the bitmask for each mask is saved in the vector <a class="el" href="classito_1_1_add_in_actuator.html#addb73efdf9d6fa907b20de4e4571aedf">ito::AddInActuator::m_currentStatus</a> of an actuator plugin.</p>
<p>The bitmask is divided into different topical areas (moving flags, switches, general status). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a599af524525e8c64bddf91298784e767"></a>actuatorUnknown&#160;</td><td class="fielddoc">
<p>moving status of axis is unknown </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a8b74ac01caf78e23c95f58b02eaab2a0"></a>actuatorInterrupted&#160;</td><td class="fielddoc">
<p>movement has been interrupted by the user, axis is immediately stopped </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a159167245176483f6062495f2baadd00"></a>actuatorMoving&#160;</td><td class="fielddoc">
<p>axis is currently moving </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383af8836b7f26106593b4d36a5c857ec048"></a>actuatorAtTarget&#160;</td><td class="fielddoc">
<p>axis reached target </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a84db4f5b5d047c90ca78d93b46656874"></a>actuatorTimeout&#160;</td><td class="fielddoc">
<p>no signal from axis, timeout </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383ae70cba1af756a2c62c1fc2957643b424"></a>actuatorEndSwitch&#160;</td><td class="fielddoc">
<p>axis reached an undefined end switch </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a6edddb993c8b1438045128e4f8a7788f"></a>actuatorLeftEndSwitch&#160;</td><td class="fielddoc">
<p>axis reached the specified left end switch (if set, also set actuatorEndSwitch), deprecated </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a3d4d3a51e6e7e7fee69ae59d359f8be7"></a>actuatorRightEndSwitch&#160;</td><td class="fielddoc">
<p>axis reached the specified right end switch (if set, also set actuatorEndSwitch), deprecated </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a881194f1151f767dc6b69b7b57f05aa7"></a>actuatorEndSwitch1&#160;</td><td class="fielddoc">
<p>axis reached the specified left end switch (if set, also set actuatorEndSwitch) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a7f12ac7236bef5c2b68b52b33f07591d"></a>actuatorEndSwitch2&#160;</td><td class="fielddoc">
<p>axis reached the specified left end switch (if set, also set actuatorEndSwitch) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383af55796f42d5efcd1ea80324402d4d72f"></a>actuatorRefSwitch&#160;</td><td class="fielddoc">
<p>axis reached an undefined reference switch </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a993a882ad6ec2c8f7657483b637a9f87"></a>actuatorLeftRefSwitch&#160;</td><td class="fielddoc">
<p>axis reached the specified left reference switch (if set, also set actuatorRefSwitch), deprecated </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a85d7cfb84b5000f7ac16726433589e39"></a>actuatorRightRefSwitch&#160;</td><td class="fielddoc">
<p>axis reached the specified right reference switch (if set, also set actuatorRefSwitch), deprecated </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383ad8597b3d30e8dc840ea8e6dc0021aefe"></a>actuatorRefSwitch1&#160;</td><td class="fielddoc">
<p>axis reached the specified right reference switch (if set, also set actuatorRefSwitch) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a68b893c663eea43740f0bc7d18446b00"></a>actuatorRefSwitch2&#160;</td><td class="fielddoc">
<p>axis reached the specified right reference switch (if set, also set actuatorRefSwitch) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a5a1d7a7c2ab70910db005617b3a8571a"></a>actuatorAvailable&#160;</td><td class="fielddoc">
<p>axis is generally available </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a83f4cf9f8319fbbeec0b7f75f4d07682"></a>actuatorEnabled&#160;</td><td class="fielddoc">
<p>axis is enabled for movements </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a067270bd694afa11b542e1768d50b06b"></a>actMovingMask&#160;</td><td class="fielddoc">
<p>bitmask that marks all bits related to the movement </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a088d0d001f7e269d045e17084e31a343"></a>actEndSwitchMask&#160;</td><td class="fielddoc">
<p>bitmask that marks all bits related to end switches </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383afe023404e59f14ea85192ecf4a205d3e"></a>actRefSwitchMask&#160;</td><td class="fielddoc">
<p>bitmask that marks all bits related to reference switches </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383ab8727b678dd0975d5259d4ef6e0c2c71"></a>actSwitchesMask&#160;</td><td class="fielddoc">
<p>bitmask that marks all bits related to reference and end switches </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab4779b960376c89061f1b12ae3738383a13165fe6a2fd39d5092982cf35388dfc"></a>actStatusMask&#160;</td><td class="fielddoc">
<p>bitmask that marks all status flags </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a20bda469be01178ac6cf406bcba2ee73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a20bda469be01178ac6cf406bcba2ee73">ito::tAutoLoadPolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a20bda469be01178ac6cf406bcba2ee73a8ec2058becac1ccaae65864d6f961cdf"></a>autoLoadAlways&#160;</td><td class="fielddoc">
<p>always loads xml file by addInManager </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a20bda469be01178ac6cf406bcba2ee73ad39587830e30b302adc4421224049c28"></a>autoLoadNever&#160;</td><td class="fielddoc">
<p>never automatically loads parameters from xml-file (default) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a20bda469be01178ac6cf406bcba2ee73a4c932e4379045955c6194e202c0b6b2d"></a>autoLoadKeywordDefined&#160;</td><td class="fielddoc">
<p>only loads parameters if keyword autoLoadParams=1 exists in python-constructor </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a8d769b26bbab936560f4c95674ff5477"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a8d769b26bbab936560f4c95674ff5477">ito::tAutoSavePolicy</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a8d769b26bbab936560f4c95674ff5477a9ca1d2e8fbcc5c11e86bd24fcdec9e50"></a>autoSaveAlways&#160;</td><td class="fielddoc">
<p>always saves parameters to xml-file at shutdown </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8d769b26bbab936560f4c95674ff5477a977bb0b86cfdfa0e8486241790087703"></a>autoSaveNever&#160;</td><td class="fielddoc">
<p>never saves parameters to xml-file at shutdown (default) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a8ffb516f2476128f38e91f09cad1dcfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a8ffb516f2476128f38e91f09cad1dcfb">ito::tCompareResult</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enumeration to describe the result of a parameter comparison (e.g. apiCompareParam) </p>

</div>
</div>
<a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DataType enumeration This enum holds the possible values for <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix ">DataObject</a> matrices. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa35aa1b8e08158b49ebbf6bdfb4b6a508"></a>tInt8&#160;</td><td class="fielddoc">
<p>integer, 8bit </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaad21eb4541e782dc23501912f788a38bd"></a>tUInt8&#160;</td><td class="fielddoc">
<p>unsigned integer, 8bit </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa142219f864f22d3b2e6f116f5f5cd936"></a>tInt16&#160;</td><td class="fielddoc">
<p>integer, 16bit </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa68d7e991164d07a036f40379a101112b"></a>tUInt16&#160;</td><td class="fielddoc">
<p>unsigned integer, 16bit </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa47b295973c6b4b7de62599401c16df62"></a>tInt32&#160;</td><td class="fielddoc">
<p>integer, 32bit </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaaf08334798ddd5082595350b296a7a868"></a>tUInt32&#160;</td><td class="fielddoc">
<p>unsigned integer, 32bit (not fully supported) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa17ad621a0158b30fc85eb1e89b93ce3b"></a>tFloat32&#160;</td><td class="fielddoc">
<p>float, 32bit </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa6b9559a5cfa765160ae209ecdc258ed6"></a>tFloat64&#160;</td><td class="fielddoc">
<p>double (64bit) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa722b93c77819223b8d630ab0fca5a0ec"></a>tComplex64&#160;</td><td class="fielddoc">
<p>complex value with real and imaginary part of type float32 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa39fef9b8e46915c6ba232020e2fe2e7a"></a>tComplex128&#160;</td><td class="fielddoc">
<p>complex value with real and imaginary part of type float64 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acc7eee7faabd3db8463dc9b7922afdbaa8473d2c11cdf726247c29c5ecf7dfbaa"></a>tRGBA32&#160;</td><td class="fielddoc">
<p>a uint32 / vec4u value coded as 0xAARRGGBB </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a8811ca8b85b70b969122b25a7c84e0ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a8811ca8b85b70b969122b25a7c84e0ee">ito::tMsgType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>MsgType enumeration This enum holds the possible values for any message type (for qDebugStream e.g.)</p>
<p>This enumeration is deprecated and will be removed in future versions. It is currently unused. Don't use it again. </p>

</div>
</div>
<a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a71867bc7a24c8fcb06b8cf63f5a3360e">ito::tPCLPointType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PCLPointType enumeration This enum holds the possible values for point types supported by the wrapper of the point-cloud library in itom. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360eaa2585c0961b5f357d98ed732c17b9359"></a>pclInvalid&#160;</td><td class="fielddoc">
<p>invalid point </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360ea6273432d3a0ca503e1a77d27ad8ab994"></a>pclXYZ&#160;</td><td class="fielddoc">
<p>point with x,y,z-value </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360ea6385e470bdc9a9e3aead145eb0ded4d8"></a>pclXYZI&#160;</td><td class="fielddoc">
<p>point with x,y,z and intensity value </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360eaefd9ce8422846a24673536424375f223"></a>pclXYZRGBA&#160;</td><td class="fielddoc">
<p>point with x,y,z and r,g,b,a </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360ea5f6680f5c10ff985f0be8ce06780e16a"></a>pclXYZNormal&#160;</td><td class="fielddoc">
<p>point with x,y,z value, its normal vector nx,ny,nz and a curvature value </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360ea9c19394acf64356ecfc0ed60bc6c8b52"></a>pclXYZINormal&#160;</td><td class="fielddoc">
<p>point with the same values than pclXYZNormal and an additional intensity value </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a71867bc7a24c8fcb06b8cf63f5a3360ea6dd64651a1b85540ac80b6efa5eeb738"></a>pclXYZRGBNormal&#160;</td><td class="fielddoc">
<p>point with x,y,z and r,g,b and normal vector (including curvature) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ae8f52a66afae16e3bb3802d701859fcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#ae8f52a66afae16e3bb3802d701859fcf">ito::tPluginLoadStatusFlag</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>PluginLoadStatusFlag enumeration This enum holds the four possible return states for loaded DLLs Ok, Warning, Error and Ignored </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae8f52a66afae16e3bb3802d701859fcfa0c084ed64a1e58022675c2855494b904"></a>plsfOk&#160;</td><td class="fielddoc">
<p>ok </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae8f52a66afae16e3bb3802d701859fcfae886791877d339615c79aed5c21d35f0"></a>plsfWarning&#160;</td><td class="fielddoc">
<p>warning </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae8f52a66afae16e3bb3802d701859fcfa89928bf15c88b96936c0f981580994ba"></a>plsfError&#160;</td><td class="fielddoc">
<p>error </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae8f52a66afae16e3bb3802d701859fcfa8e51ce1381d3ccf924b2b6152b554f88"></a>plsfIgnored&#160;</td><td class="fielddoc">
<p>ignored </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae8f52a66afae16e3bb3802d701859fcfa83b35bae2ed80b743503263abc05ddf8"></a>plsfRelDbg&#160;</td><td class="fielddoc">
<p>is Dbg version </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae8f52a66afae16e3bb3802d701859fcfa266ad0ed0ef69190509ee0f625f29880"></a>plsfIncompatible&#160;</td><td class="fielddoc">
<p>incompatible to this itom version </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a3d8b8f2858876413dd8728084943ab30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a3d8b8f2858876413dd8728084943ab30">ito::tPluginType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tPluginType enumeration </p>
<p>used to describe the plugin type and subtype (in case of DataIO main type) e.g. typeDataIO|typeGrabber for a frame grabber </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a3d8b8f2858876413dd8728084943ab30a4cab6a4edc95b2ef6846c79aedd818cb"></a>typeDataIO&#160;</td><td class="fielddoc">
<p>base type for data input and output (cameras, AD-converter, display windows...) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3d8b8f2858876413dd8728084943ab30a67b1093d817ca4c45de9b4b1075045b1"></a>typeActuator&#160;</td><td class="fielddoc">
<p>base type for actuators and motors </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3d8b8f2858876413dd8728084943ab30a8c028979c4b81e7eaa0a7f51e1e62d26"></a>typeAlgo&#160;</td><td class="fielddoc">
<p>base type for algorithm plugin </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3d8b8f2858876413dd8728084943ab30af4dfe66a7744cc365947716d5bdb9f6d"></a>typeGrabber&#160;</td><td class="fielddoc">
<p>subtype of dataIO for cameras (grabbers), use this type in combination with typeDataIO (OR-combination) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3d8b8f2858876413dd8728084943ab30a95ac93a74aac433a17c998c1810e3e51"></a>typeADDA&#160;</td><td class="fielddoc">
<p>subtype of dataIO for AD and DA-converters, use this type in combination with typeDataIO (OR-combination) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a3d8b8f2858876413dd8728084943ab30ad2e2fbe4821bac18934a307bd89428c2"></a>typeRawIO&#160;</td><td class="fielddoc">
<p>subtype of dataIO for further input-output-devices (like display windows), use this type in combination with typeDataIO (OR-combination) </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="af3656645e7f004701417ecdc79b10202"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202">ito::tRetValue</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RetValue enumeration This enum holds the three possible return states Ok, Warning and Error </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="af3656645e7f004701417ecdc79b10202a2ced39cc25866a04f2fb1c9f1d6a542e"></a>retOk&#160;</td><td class="fielddoc">
<p>ok </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af3656645e7f004701417ecdc79b10202a59b8253725a061086f085758a117002b"></a>retWarning&#160;</td><td class="fielddoc">
<p>warning </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af3656645e7f004701417ecdc79b10202a199f41b7779e742e0a3cc281c42c97c0"></a>retError&#160;</td><td class="fielddoc">
<p>error </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a93ad4ffb19fff6fffd09b91e020eda90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceito.html#a93ad4ffb19fff6fffd09b91e020eda90">ito::tStreamMessageType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enumeration of stream (std::cout, std::cerr, std::cin) message type </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af6d3ecede102f9a0756a89a0a5aa2977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DATAOBJ_EXPORT <a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>high-level value which calculates the absolute value of each element of the input source data object and returns the resulting data object </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new data object with absolute values </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if unknown data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#ae7089fa30e7e66b8d57438c07b7c644b" title="low-level, double templated method to save the element-wise absolute value of each element in source ...">AbsFunc</a>, <a class="el" href="namespaceito.html#a3f34b4f966d79c5eadb25216a4950620" title="low-level, templated method to save the element-wise absolute value of each element in source matrix ...">AbsFuncReal</a></dd></dl>
<p>calculates the absolute values of each element in the given data object and returns the result as new data object </p>

</div>
</div>
<a class="anchor" id="ae7089fa30e7e66b8d57438c07b7c644b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CmplxTp , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::AbsFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>resObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, double templated method to save the element-wise absolute value of each element in source matrix to result matrix </p>
<p>This method takes the absolute value of a complex valued input matrix and stores it in the equivalent real typed result matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is source matrix, must have complex type </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the resulting data object, which has the real data type which corresponds to the complex type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::abs </dd></dl>

</div>
</div>
<a class="anchor" id="a3f34b4f966d79c5eadb25216a4950620"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::AbsFuncReal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>resObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method to save the element-wise absolute value of each element in source matrix to result matrix </p>
<p>This method takes the absolute value of a real typed input matrix and stores it in the equivalent real typed result matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is source matrix, must have real value </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the resulting data object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::abs </dd></dl>

</div>
</div>
<a class="anchor" id="ae16131a91987cc5836aaf3f3918319b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::AddFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObjRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all or some of the array elements to the specific value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assigned</td><td>scalar converted to the actual array type </td></tr>
    <tr><td class="paramname">mask</td><td>Operation mask of the same size as *this and type uint8 or empty data object if no mask should be considered (default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retError in case of error </dd></dl>
<dl class="section see"><dt>See also</dt><dd>AssignScalarValuelow-level, templated method for element-wise addition of two given data objects.</dd></dl>
<p>dObjRes = dObj1 + dObj2</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj1</td><td>is the first data object </td></tr>
    <tr><td class="paramname">*dObj2</td><td>is the second data object </td></tr>
    <tr><td class="paramname">*dObjRes</td><td>is the pointer to the data object, where the values will be written to. This data object must already be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The size check for all data objects must be done before. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>operator +=, operator + </dd></dl>

</div>
</div>
<a class="anchor" id="abea3cec515d7dfc29dd5a2ac1002c7e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::AdjustROIFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dtop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dbottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dright</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method for adjusting the ROI of a data object by the given incremental values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is the data object, whose boundaries should be adjusted </td></tr>
    <tr><td class="paramname">dtop</td><td>- The shift of the top submatrix boundary upwards (positive value means upwards) </td></tr>
    <tr><td class="paramname">dbottom</td><td>- The shift of the bottom submatrix boundary downwards (positive value means downwards) </td></tr>
    <tr><td class="paramname">dleft</td><td>- The shift of the left submatrix boundary to the left (positive value means to the left) </td></tr>
    <tr><td class="paramname">dright</td><td>- The shift of the right submatrix boundary to the right (positive value means to the right) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>for any n-dimensional data object, the ROI of every matrix-plane is adjusted, even if any specific matrix-plane is temporarily not inside of the ROI </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a87c024c43b3d17174e8f0b14fdc09cd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::apiFCheckAndSetParamVal </td>
          <td>(</td>
          <td class="paramtype">QVariant *&#160;</td>
          <td class="paramname"><em>tempParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to check and set initialisation parameters in the initialisation parameter list </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tempParam</td><td>QVariant holding the value to set </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">param</td><td>the param in the parameter list, that is set </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">set</td><td>indicator whether the parameter was set or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk on success, retError otherwise</dd></dl>
<p>The function checks if the types of the passed python parameter and the parameter are compatible and sets the parameter value if it is possible. If the paramter cannot be set an error is returned. </p>

</div>
</div>
<a class="anchor" id="aba757c479378ddaa7db70850c6590f3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::apiFParseInitParams </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *&#160;</td>
          <td class="paramname"><em>initParamListMand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *&#160;</td>
          <td class="paramname"><em>initParamListOpt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; QVariant &gt; *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to read mandatory and optional parameter lists from a given python parameter list according to the plugins definition </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">initParamListMand</td><td>vector holding the mandatory initialisation parameters (filled with default values), the default values are overwritten with the passed values </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">initParamListOpt</td><td>vector holding the optional initialisation parameters (filled with default values), the default values are overwritten with the passed values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>list with python arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kwds</td><td>list with named python arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns <a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a2ced39cc25866a04f2fb1c9f1d6a542e">ito::retOk</a> if the number and type of parameters was correct, <a class="el" href="namespaceito.html#af3656645e7f004701417ecdc79b10202a199f41b7779e742e0a3cc281c42c97c0">ito::retError</a> otherwise</dd></dl>
<p>The function takes as input the vectors with the madatory and optional input parameters used for the plugin initialisation. These vectors must be previously be read using the function getInitParams. The default values of the parameters are overwritten with the values given by python. In case the number or parameters or a parameter type is incorrect the function will abort with an error. </p>

</div>
</div>
<a class="anchor" id="a0644ec1daecb3a21762e32eb16c3fb1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DATAOBJ_EXPORT <a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::arg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>high-level value which calculates the argument value of each element of the input source data object and returns the resulting data object </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new data object with argument values </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if undefined data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#a0e126a9e14968fd29e231b9efab55a3b" title="low-level, double templated method to save the element-wise argument of each element in source matrix...">ArgFunc</a></dd></dl>
<p>calculates the argument of each element in the given data object and returns the result as new data object </p>

</div>
</div>
<a class="anchor" id="a0e126a9e14968fd29e231b9efab55a3b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CmplxTp , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ArgFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>resObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, double templated method to save the element-wise argument of each element in source matrix to result matrix </p>
<p>This method takes the element-wise argument of a complex valued input matrix and stores it in the equivalent real typed result matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is source matrix, must have complex type </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the resulting data object, which has the real data type which corresponds to the complex type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::abs </dd></dl>

</div>
</div>
<a class="anchor" id="a63b3641a7cf5c73f04a4a614870f71de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::AssignScalarFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated helper method to assign the given scalar to every element within its ROI in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix ">DataObject</a> src. </p>
<p>The scalar value is converted to the type of the source data object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td>is the source data object whose elements will be modified </td></tr>
    <tr><td class="paramname">type</td><td>is the data type of the scalar value </td></tr>
    <tr><td class="paramname">*scalar</td><td>is a void pointer to the scalar value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::exception</td><td>if conversion of scalar to dataObject's type is not possible </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>numberConcversion </dd></dl>

</div>
</div>
<a class="anchor" id="a68f6aedbf65b873bc1abddb99c288d8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::AssignScalarMaskFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated helper method to assign the given scalar to every element within its ROI in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix ">DataObject</a> src. </p>
<p>The scalar value is converted to the type of the source data object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td>is the source data object whose elements will be modified </td></tr>
    <tr><td class="paramname">type</td><td>is the data type of the scalar value </td></tr>
    <tr><td class="paramname">*scalar</td><td>is a void pointer to the scalar value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::exception</td><td>if conversion of scalar to dataObject's type is not possible </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>numberConcversion </dd></dl>

</div>
</div>
<a class="anchor" id="af958d9bca56f7971bc30feac415bdaae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitAndFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObjRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method which element-wisely executes a bitwise 'and' comparison between values of two dataObjects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj1</td><td>is the first data object </td></tr>
    <tr><td class="paramname">*dObj2</td><td>is the second data object </td></tr>
    <tr><td class="paramname">*dObjRes</td><td>is the data object, where the result is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>for unsupported data types (template specialization) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="afc2da43a120dd1da62b1d0dfac9ed4b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#af958d9bca56f7971bc30feac415bdaae">ito::BitAndFunc</a>&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for bitwise and function of type complex128 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa80cc5a38859d11ae5b8b5d4f9c8c3c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#af958d9bca56f7971bc30feac415bdaae">ito::BitAndFunc</a>&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for bitwise and function of type complex64 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab899e141a3847b1a7035c5e56332d6e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#af958d9bca56f7971bc30feac415bdaae">ito::BitAndFunc</a>&lt; ito::float32 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for bitwise and function of type float32 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef3d086c4a7eed78b88a34ad1219dd06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#af958d9bca56f7971bc30feac415bdaae">ito::BitAndFunc</a>&lt; ito::float64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for bitwise and function of type float64 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8776a0f7f23f1c21e9ecf6f513fba0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#af958d9bca56f7971bc30feac415bdaae">ito::BitAndFunc</a>&lt; <a class="el" href="classito_1_1_rgba32.html">ito::Rgba32</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for bitwise and function of type rgba32 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f26f22cf37ce14606bd6dde853f1e8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitOrFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObjRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method which element-wisely executes a bitwise 'or' comparison between values of two dataObjects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj1</td><td>is the first data object </td></tr>
    <tr><td class="paramname">*dObj2</td><td>is the second data object </td></tr>
    <tr><td class="paramname">*dObjRes</td><td>is the data object, where the result is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>for unsupported data types (template specialization) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a6bf39908f4328b8cf684b090560adb3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#a5f26f22cf37ce14606bd6dde853f1e8b">ito::BitOrFunc</a>&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for bitwise or function of type complex128 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f4a9bac68a02e69f63828971fb69676"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#a5f26f22cf37ce14606bd6dde853f1e8b">ito::BitOrFunc</a>&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for bitwise or function of type complex64 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b0b5996a50ddcab865510a424d3d7a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#a5f26f22cf37ce14606bd6dde853f1e8b">ito::BitOrFunc</a>&lt; ito::float32 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for bitwise or function of type float32 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae82f393b489f72f5206cfe1fc7e43f93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#a5f26f22cf37ce14606bd6dde853f1e8b">ito::BitOrFunc</a>&lt; ito::float64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for bitwise or function of type float64 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada1ddf3b0cca77656d7af70ed5eef801"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#a5f26f22cf37ce14606bd6dde853f1e8b">ito::BitOrFunc</a>&lt; <a class="el" href="classito_1_1_rgba32.html">ito::Rgba32</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for bitwise or function of type rgba32 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e15e2fb2cba5fe01f96cc66b65c8345"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::BitXorFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObjRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method which element-wisely executes a bitwise 'xor' comparison between values of two dataObjects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj1</td><td>is the first data object </td></tr>
    <tr><td class="paramname">*dObj2</td><td>is the second data object </td></tr>
    <tr><td class="paramname">*dObjRes</td><td>is the data object, where the result is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>for unsupported data types (template specialization) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="adf73d910b4e9d9c344b2b389f9973720"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#a7e15e2fb2cba5fe01f96cc66b65c8345">ito::BitXorFunc</a>&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for bitwise xor function of type complex128 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98551d38290fbe3f94b77ef58972dda8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#a7e15e2fb2cba5fe01f96cc66b65c8345">ito::BitXorFunc</a>&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for bitwise xor function of type complex64 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af127d3f60daba576c1b4245e96817e52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#a7e15e2fb2cba5fe01f96cc66b65c8345">ito::BitXorFunc</a>&lt; ito::float32 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for bitwise xor function of type float32 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55c68147de5f601fd5ea7b53735c5096"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#a7e15e2fb2cba5fe01f96cc66b65c8345">ito::BitXorFunc</a>&lt; ito::float64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for bitwise xor function of type float64 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15c785f100a1e386d0ee36ce2cc72941"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#a7e15e2fb2cba5fe01f96cc66b65c8345">ito::BitXorFunc</a>&lt; <a class="el" href="classito_1_1_rgba32.html">ito::Rgba32</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for bitwise xor function of type complex128 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since this operation is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abee4c6255dbf062c6e84e716df007801"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _TSrc , typename _TDest &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CastFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>srcObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>resObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level templated method to cast each element of source matrix to another type. </p>
<p>The result is stored in the result matrix. Optionally a scaling and offsetting is possible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*srcObj</td><td>is the source data object </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the result data object </td></tr>
    <tr><td class="paramname">alpha</td><td>is the scaling factor (default 1.0) </td></tr>
    <tr><td class="paramname">beta</td><td>is the offset value (default 0.0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if cast failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>cv::saturate_cast </dd></dl>

</div>
</div>
<a class="anchor" id="acaadeb5a84e7fa9f44207f4f6ea80a85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::checkAndSetParamVal </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>tempObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_param.html">ito::Param</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function to check and set initialisation parameters in the initialisation parameter list </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tempObj</td><td>python object holding the value to set </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">param</td><td>the param in the parameter list, that is set </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">set</td><td>indicator whether the parameter was set or not </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk on success, retError otherwise</dd></dl>
<p>The function checks if the types of the passed python parameter and the parameter are compatible and sets the parameter value if it is possible. If the paramter cannot be set an error is returned. </p>

</div>
</div>
<a class="anchor" id="a6af758f942701d80f2531249158bb33d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::checkParamVector </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>checks param vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>is a pointer to QVector&lt;ito::Param&gt;. This pointer is checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classito_1_1_ret_val.html" title="Class for managing status values (like errors or warning) ">ito::RetVal</a>, that contains an error if params is NULL </dd></dl>

</div>
</div>
<a class="anchor" id="a8d4bb116538f127474d6353604b88a55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::checkParamVectors </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramsMand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramsOpt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramsOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>verifies that the three param vectors are not NULL </p>
<p>If any of the given input parameters of type QVector&lt;ito::Param&gt;* are NULL, a <a class="el" href="classito_1_1_ret_val.html" title="Class for managing status values (like errors or warning) ">ito::RetVal</a> is returned, that contains an error. Use this method in any algorithm-method in order to check the given input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsMand</td><td>is the first parameter vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsOpt</td><td>is the second parameter vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramsOut</td><td>is the third parameter vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classito_1_1_ret_val.html" title="Class for managing status values (like errors or warning) ">ito::RetVal</a>, that contains an error if params is NULL </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#a6af758f942701d80f2531249158bb33d" title="checks param vector ">checkParamVector</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5dee1bec1740d52cf1ba8ff4dec6ae90"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CmpFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmpOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method which compares each element in source-matrix1 with its corresponding element in source-matrix2 and saves the result in a destionation matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*src1</td><td>is the first source matrix </td></tr>
    <tr><td class="paramname">*src2</td><td>is the second source matrix </td></tr>
    <tr><td class="paramname">*dst</td><td>is the destination matrix, which must have the same ROI than src1 and src2 and must be of type uint8 </td></tr>
    <tr><td class="paramname">cmpOp</td><td>is the compare operator (cv::CMP_EQ, cv::CMP_GT, cv::CMP_GE, cv::CMP_LT, cv::CMP_LE, cv::CMP_NE) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>no comparison is possible for source matrices of type int8 (due to openCV-problems) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if source matrix is of type int8 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a4de34931d48e4275b0cd02538fb79863"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#a5dee1bec1740d52cf1ba8ff4dec6ae90">ito::CmpFunc</a>&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmpOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for compare function of type complex128 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since comparison is not defined for complex input types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00ce88e15908f79d00e95dfa580b70d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#a5dee1bec1740d52cf1ba8ff4dec6ae90">ito::CmpFunc</a>&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmpOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for compare function of type complex64 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since comparison is not defined for complex input types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a784dd21f0b5d7ce35191efc45d1c1417"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CmpFuncScalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float64 &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmpOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method which compares each element in source-matrix1 with its corresponding element in source-matrix2 and saves the result in a destionation matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*src1</td><td>is the first source matrix </td></tr>
    <tr><td class="paramname">*src2</td><td>is the second source matrix </td></tr>
    <tr><td class="paramname">*dst</td><td>is the destination matrix, which must have the same ROI than src1 and src2 and must be of type uint8 </td></tr>
    <tr><td class="paramname">cmpOp</td><td>is the compare operator (cv::CMP_EQ, cv::CMP_GT, cv::CMP_GE, cv::CMP_LT, cv::CMP_LE, cv::CMP_NE) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>no comparison is possible for source matrices of type int8 (due to openCV-problems) </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if source matrix is of type int8 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a83e786be3b0546035be54c891e0e1808"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CmpFuncScalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ito::complex64 &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmpOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for compare function of type complex64 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since comparison is not defined for complex input types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10f7fc946861f8806d9e62ec332a3459"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CmpFuncScalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ito::complex128 &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmpOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for compare function of type complex128 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since comparison is not defined for complex input types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab7900df15bdd04f8f3b229e3b03e126f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ConjFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method for calculating the conjugated value of each element within the ROI of this data object </p>
<p>This method is only valid for complex data types. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>avoid MatIterator <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if data type is not complex. This is done by template specialization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::conj </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8b1c451edd01ef3334d4293512e437df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> ito::convertCmplxTypeToRealType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td>
          <td class="paramname"><em>cmplxType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>method which returns the real data type of any given data type </p>
<p>If the given data type is already real, the same type is returned. Else the type of the real argument of the given complex type is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmplxType</td><td>is the input data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>see method's description </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if the input data type is unknown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8367d4e513da741ea508d4fb2cda270"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ConvertToFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dest_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>converts data in <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix ">DataObject</a> lhs to <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix ">DataObject</a> rhs with a given type </p>
<p>Every element of the source data object is copied to the destionation data object by using this transformation<br />
 elem_destination = static_cast&lt;newType&gt;(elem_source * alpha + beta)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;lhs</td><td>is the left-hand sided data object, whose data should be converted </td></tr>
    <tr><td class="paramname">&amp;rhs</td><td>is the destination data object, whose memory is firstly deleted, then newly allocated </td></tr>
    <tr><td class="paramname">dest_type</td><td>is the type-number of the destination element </td></tr>
    <tr><td class="paramname">alpha</td><td>scaling factor (default: 1.0) </td></tr>
    <tr><td class="paramname">beta</td><td>offset value (default: 0.0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception(CV_StsAssert)</td><td>if conversion type is unknown </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>convertTo, <a class="el" href="namespaceito.html#abee4c6255dbf062c6e84e716df007801" title="low-level templated method to cast each element of source matrix to another type. ...">CastFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ade4658756c87f46f61e4bd04b6db9a42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CopyMatFunc </td>
          <td>(</td>
          <td class="paramtype">const uchar **&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar **&amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>transposed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method that executes a shallow-copy of every matrix-plane in the source-vector and stores the copies in the destination-vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;src</td><td>is the source vector which contains matrix-planes of type cv::Mat_&lt;_Tp&gt; </td></tr>
    <tr><td class="paramname">&amp;dst</td><td>is the destination vector, where the shallow-copies are stored. dst should be empty at the beginning </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>operator =, <a class="el" href="classito_1_1_data_object.html#a32e74ff9c1cd0e9fc73d5f7705bce605" title="copy constructor for data object ">DataObject::DataObject(const DataObject&amp; copyConstr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af336f965d8dcb64d35de938c63e18e53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::copyParamVector </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramVecIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paramVecOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>makes a deep copy of a vector with values of type <a class="el" href="classito_1_1_param_base.html">ParamBase</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paramVecIn</td><td>is a pointer to a vector of ParamBase-values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">paramVecOut</td><td>is a reference to a vector which is first cleared and then filled with a deep copy of every element of paramVecIn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9596d29ad4cb556064117c73031bd0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::copyParamVector </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramVecIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paramVecOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>makes a deep copy of a vector with values of type <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins ">Param</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paramVecIn</td><td>is a pointer to a vector of Param-values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">paramVecOut</td><td>is a reference to a vector which is first cleared and then filled with a deep copy of every element of paramVecIn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1c6bd4bcdbd9f72e50bbbe132b204db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::copyParamVector </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramVecIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paramVecOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>makes a deep copy of a vector with values of type <a class="el" href="classito_1_1_param.html" title="class for parameter handling e.g. to pass paramters to plugins ">Param</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">paramVecIn</td><td>is a pointer to a vector of Param-values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">paramVecOut</td><td>is a reference to a vector which is first cleared and then filled with a deep copy of every element of paramVecIn (casted to <a class="el" href="classito_1_1_param_base.html">ito::ParamBase</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12bc247542bd015830ad21b2b6ead367"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CopyToFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>regionOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method for deeply copying the data of one matrix to another given matrix </p>
<p>In case of 'regionOnly' == false, the destination dataObject 'rhs' is always newly allocated before copying data and the tags as well as the axis descriptions etc. are also copied from the source object. If the source object has a ROI set, the entire object with all data outside of the ROI is copied and the ROI is applied to the destination object, too.</p>
<p>If 'regionOnly' == true, only data within a current ROI is copied to the destination object. In this case, the destination is only newly allocated if its current dimension, size or type do not fit to the source object. Else, data is copied into the existing memory. Tags and axis descriptions etc. are always copied to the destination object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;lhs</td><td>is the matrix whose data is copied </td></tr>
    <tr><td class="paramname">&amp;rhs</td><td>is the matrix where the data is copied to. The old data of rhs is deleted first </td></tr>
    <tr><td class="paramname">regionOnly,if</td><td>true, only the data of the ROI in lhs is copied, hence, the org-size of rhs corresponds to the ROI-size of lhs, else the whole data block is copied and the ROI of rhs is set to the ROI of lhs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>copyTo, <a class="el" href="namespaceito.html#a3a25d4f45b211c3ca1f9fc1ef395ed0f" title="templated method for create ">CreateFunc</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3a25d4f45b211c3ca1f9fc1ef395ed0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CreateFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>continuous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>continuousDataPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>templated method for create </p>
<p>creates or initializes matrix with given parameters</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dObj</td><td><a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix ">DataObject</a>, whose matrix is created here </td></tr>
    <tr><td class="paramname">dimensions</td><td>total number of dimensions (&gt;=1), if dimensions == 1, dimensions will be set to two and a matrix with dimension [1 x orginial dimension] is created </td></tr>
    <tr><td class="paramname">*sizes</td><td>vector with size of dimensions, each element gives the size of elements in each dimension </td></tr>
    <tr><td class="paramname">continuous,indicates</td><td>whether the data stored in this data object is stored in one continuous data block or not. if dimension &lt;= 2, matrix is always continuous be careful, continuous has not the same meaning than the continuous flag in opencv or numpy. </td></tr>
    <tr><td class="paramname">continuousDataPtr</td><td>if this pointer is NULL, new data will be allocated. Else the given data indicates data which will be used by this data object. only possible if continuous is true. m_ownflag will be set to 0 if this pointer is set </td></tr>
    <tr><td class="paramname">*steps</td><td>vector with size of dimensions, indicates how many bytes one has to move in order to get to the next element in the same dimension, the step-size for the last element must be equal to element-size (in byte) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>create </dd></dl>
<p>continuous </p>

</div>
</div>
<a class="anchor" id="af9df38c6970849400c840b0b767a5c9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::CreateFuncWithCVPlanes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat *&#160;</td>
          <td class="paramname"><em>planes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nrOfPlanes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>templated method for creation with given vector of cv::Mat-planes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dimensions</td><td>is the total number of dimensions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*sizes</td><td>is a vector whose length is equal to dimensions. Each entry indicates the size of the specific dimension. Each matrix-plane is allocated with the size of the last two sizes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>is the desired element data type (see tDataType) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">*planes</td><td>is an array of cv::Mat-planes which will be used as matrices for every single 2D-plane. Every Mat must have the same size and type. The type must correspond to the param type, the size must fit to the last two given sizes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nrOfPlanes</td><td>is the length of the planes-array. This value must be the same than (sizes[0]*sizes[1]*...*sizes[dimensions-2]) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>create </dd></dl>

</div>
</div>
<a class="anchor" id="a49a8ffb4244dbc37882593e3ae344e74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::createObjectFromXMLV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamReader &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>dObjIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>elementsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates an dataObject from the header of the xml-file  This function creates an dataObject from the header of the xml-file by parsing the XML-stream. The first start element, already read by the calling function must contain the attributes dims, dataType and dim0..dimn-2, dimX, dimY. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>stream The xml-Stream from the xml-file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dObjIn</td><td>Destination dataContainter of type dataObject with size / dims / type speficied in the input xml </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elementsize</td><td>Byte-Size of the current dataObjekt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#ad763de2bc627c32993a7a6e361497065">loadXML2DOBJ</a>, loadXML2EmptyDOBJ </dd></dl>
<p>&lt; Sizes of the new dataObject. Will be freed at end: </p>

</div>
</div>
<a class="anchor" id="ad8e8837df59dec7dcd384ebc68e258b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DeepCopyPartialFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method to copy the values of the ROI of matrix lhs to the ROI of matrix rhs. </p>
<p>the ROI of rhs must already correspond to the ROI of lhs, hence, rhs must have allocated data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;lhs</td><td>is the original data object </td></tr>
    <tr><td class="paramname">&amp;rhs</td><td>is the data object, where the values are copied to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>deepCopyPartial </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>avoid <a class="el" href="classito_1_1_d_obj_iterator.html" title="iterator through data object ">DObjIterator</a> for speed-up </dd></dl>

</div>
</div>
<a class="anchor" id="acd82fda76a04b3569bccb68ddf8cf382"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::DivFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method which does a element-wise division of elements in first source matrix by elements in second source matrix. </p>
<p>The result is stored in a result matrix, optionally the division can be scaled by a scaling factor, which is set to one by default. For fixed point numbers or complex values, a division by zero will throw an error. For floating-point values the following (matlab-like) implementation is used:</p>
<p>1.0/0.0 = Inf, 0.0/0.0 = Nan</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*src1</td><td>is the first source matrix </td></tr>
    <tr><td class="paramname">*src2</td><td>is the second source matrix </td></tr>
    <tr><td class="paramname">*res</td><td>is the result matrix, which must have the same size than the source matrices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="ad6f6a9e3246468144d9ea2e0bb1c7805"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#acd82fda76a04b3569bccb68ddf8cf382">ito::DivFunc</a>&lt; <a class="el" href="classito_1_1_rgba32.html">Rgba32</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method which does a element-wise division of elements in first source matrix by elements in second source matrix. </p>
<p>The result is stored in a result matrix, optionally the division can be scaled by a scaling factor, which is set to one by default. For fixed point numbers or complex values, a division by zero will throw an error. For floating-point values the following (matlab-like) implementation is used:</p>
<p>1.0/0.0 = Inf, 0.0/0.0 = Nan</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*src1</td><td>is the first source matrix </td></tr>
    <tr><td class="paramname">*src2</td><td>is the second source matrix </td></tr>
    <tr><td class="paramname">*res</td><td>is the result matrix, which must have the same size than the source matrices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a9b4dfe4f49c35f2a0d4028b5066a116a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ito::errOutInitParams </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function for error output </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>parameters expected by the plugin </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>parameter where the error occured </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reason</td><td>the reason for the error (e.g. parameter missing, wrong type, ...)</td></tr>
  </table>
  </dd>
</dl>
<p>Function used for writing error messages occured during the parsing of the parameters passed for the initialisation of a plugin. The function uses the cerr stream to "post" the error message. If possible the parameter where the error occured is marked with an arrow. Except the error all parameters necessary and optional including their type are written to the console. </p>

</div>
</div>
<a class="anchor" id="aa51a9284d0a30e2fac9926c85171ca82"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::EyeFunc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method for creating an eye-matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>indicates the size of the square matrix </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is a pointer to which the eye-matrix is assigned to. The eye matrix is of type cv::Mat_&lt;_Tp&gt; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a01723110515894b52457c2e3ffbb3d6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::findAndDeleteReservedInitKeyWords </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>kwds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>enableAutoLoadParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>kwds list with named python arguments </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">enableAutoLoadParams</td><td>if keyword autoLoadParams is found, value of this is set to kwds-item value else false it is set to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6700407b59c1df38ff5f7235e7246fe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::formatDoubleWithUnit </td>
          <td>(</td>
          <td class="paramtype">QStringList&#160;</td>
          <td class="paramname"><em>scaleThisUnitsOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>unitIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>dValOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>unitOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>&lt; Function to convert double values with unit to scaled values with scaled units (0.01m -&gt; 10mm) </p>
<p>Function generates the auto save filename from the plugin name and the dll-folder</p>
<p>Compared the abs(dValue) with the 10^(3N) and according to the results mu p M ... are added to the unit Allowed units are SI-Unit except kg and mm. If % is given as input unit, values are multiplied by 100 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">scaleThisUnitsOnly</td><td>List with scaleable units (e.g. mm, m) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">unitIn</td><td>Old unit (e.g. mm, m, %) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dVal</td><td>Double value (e.g. mm, m, %) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dValOut</td><td>Scaled value </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">unitOut</td><td>Scaled unit m -&gt; mm or  m </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a708f5dc838bfbc92c937b6e6c40df6df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::FreeFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method for freeing allocated data blocks </p>
<p>First, the header information of the corresponding data block is deleted. Then the reference counter of the data block is decremented. In the same way, the reference counter for every matrix-plane is incremented by calling the corresponding release-method. If the ref-counter is lower than zero no other instance needs this data block and it is deallocated if the m_owndata-flag is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>whose data block should be freed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>freeData </dd></dl>

</div>
</div>
<a class="anchor" id="aa872946454ba282dd90912cb19cce19b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ito::freeParams </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>cargt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&amp;&#160;</td>
          <td class="paramname"><em>cargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>frees parameter and parameter type arrays generated by the <a class="el" href="namespaceito.html#a8fe6cab8c18f8e06ec5b141d57ab1389">parseParams</a> function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>number of parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cargt</td><td>array with parameter types </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cargs</td><td>array with the parameter pointers / values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0</dd></dl>
<p>The function frees the arrays generated by the <a class="el" href="namespaceito.html#a8fe6cab8c18f8e06ec5b141d57ab1389">parseParams</a> function, i.e. the array with the parsed parameter values and the array with their types. </p>

</div>
</div>
<a class="anchor" id="a5f90e9d0def8c42d6675f889c410cedf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::generateAutoSaveParamFile </td>
          <td>(</td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>plugInName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QFile &amp;&#160;</td>
          <td class="paramname"><em>paramFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>loadXML2QLIST loads parameters from an XML-File and saves them to paramList </p>
<p>function for generates the plugin xml file handle </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fName</td><td>filename (is needed e.g. to get filename) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">paramFile</td><td>reference to unopened parameter file</td></tr>
  </table>
  </dd>
</dl>
<p>The function generates the xml parameter file name and returns the a QFile handle. The name has the same name as the plugin in the plugins directory. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#af0411cd240edb9847b61a997a958bc7a" title="saveQLIST2XML writes parameters from paramList to an XML-File ">loadXML2QLIST</a>, <a class="el" href="namespaceito.html#a7fa6f7375af9065c79ddb14d3c1d1f4a" title="mergeQLists copies parameters from newList to oldList and performs some checks ">saveQLIST2XML</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4c51786122c5ea8ab864ceafcc36bbad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> ito::getDataType </td>
          <td>(</td>
          <td class="paramtype">const _Tp *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>method which returns the value of enumeration <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>, which corresponds to the type of the given pointer parameter. </p>
<p>If the parameter type cannot be transformed into a value of <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>, an exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">any</td><td>pointer, whose type should be transformed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if the input data type is unknown </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#a055fafe5bca7e7bb1967fbe512c6bb98" title="method which returns the value of enumeration ito::tDataType, which corresponds to the template param...">getDataType2</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a055fafe5bca7e7bb1967fbe512c6bb98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> ito::getDataType2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>method which returns the value of enumeration <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>, which corresponds to the template parameter (must be a pointer). </p>
<p>If the template parameter cannot be transformed into a value of <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>, an exception is thrown.</p>
<p>Call is <a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> result = <a class="el" href="namespaceito.html#a055fafe5bca7e7bb1967fbe512c6bb98" title="method which returns the value of enumeration ito::tDataType, which corresponds to the template param...">getDataType2&lt;uint8*&gt;()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if the template parameter is unknown (e.g. no pointer). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#a4c51786122c5ea8ab864ceafcc36bbad" title="method which returns the value of enumeration ito::tDataType, which corresponds to the type of the gi...">getDataType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab89b2aaf2edbb230bb22d996d713f02d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::getExecFuncsInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>aib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>kwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns a list of execFunction available in a plugin similar to filterHelp </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aib</td><td>the plugin for which the execFuncs names are requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>2 Item-Vector with integer request for additional dictionary return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>python dictionary with list of functions or specific dictionary for one execFunc with the parameters' names, min, max, current value, (infostring) </dd></dl>

</div>
</div>
<a class="anchor" id="affacbb694efedc5072c323235f1cf83b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::getExecFuncsList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>aib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the names of extended Functionality available in a plugin </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aib</td><td>the plugin for which the parameter names are requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>python object with a string list with the execFuncs' names </dd></dl>

</div>
</div>
<a class="anchor" id="a2a69198fb9449e1750a65dabb3911cd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QMap&lt; QString, QString &gt; ito::getItomVersionMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called to get all version numbers that itom contains. </p>
<p>Use this function to get a map of all parts of itom that are used with their corresponding version.</p>
<dl class="section return"><dt>Returns</dt><dd>returns a QMap&lt;QString,QString&gt; containing the module and the version of a module. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f9082c16ab511f4da066735faff3262"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::getName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>addInObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the name of a python plugin </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addInObj</td><td>the plugin whoes name should be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the plugin name </dd></dl>

</div>
</div>
<a class="anchor" id="a2ef056717cc8a683562a568e7caa02cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::getParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>addInObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return a parameter value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addInObj</td><td>the addIn whoes parameter is requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>the parameter name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>python object with the parameter value on success (parameter exists), NULL otherwise</dd></dl>
<p>The function tries to retrieve the value of the parameter with the name given in args. If the parameter does not exist NULL is returned. To actually retrieve the value the getParam function of the plugin is invoked. </p>

</div>
</div>
<a class="anchor" id="ae5f62de950023c3db6e6f899aacc6bd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_param.html">ito::Param</a> * ito::getParamByName </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; <a class="el" href="classito_1_1_param.html">ito::Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> *&#160;</td>
          <td class="paramname"><em>retval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>brief returns a parameter from the parameter-vector, that fits to a specific name </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>description </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ab96008563f0d7b3cd050a05cfc0c0e06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::getParamInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>aib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns a dictionary with all meta information of one parameter </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aib</td><td>the plugin for which the parameter names are requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>1 Item-Vector with bool request for additional dictionary return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>python list of python tuple with the parameters' names, min, max, current value, (infostring) </dd></dl>

</div>
</div>
<a class="anchor" id="a9116ec57a2f79c788a4991e28b4617e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::getParamList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>aib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the names of the parameters available in a plugin </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aib</td><td>the plugin for which the parameter names are requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>python object with a string list with the parameters' names </dd></dl>

</div>
</div>
<a class="anchor" id="a1abfad65cf3b738c5d98938d20b9e7fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::getParamListInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>aib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the all informations of the parameters available in a plugin </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">aib</td><td>the plugin for which the parameter names are requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>1 Item-Vector with bool request for additional dictionary return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>python list of python tuple with the parameters' names, min, max, current value, (infostring) </dd></dl>

</div>
</div>
<a class="anchor" id="a26e60a4adfd0270199d3cb0b21230c29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::GetRangeFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dtop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dbottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dleft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dright</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method for saving a shallow copy of a source cv::Mat_ to a destination cv::Mat_ with respect to given row- and col-ranges </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&lt;em&gt;SrcMat</td><td>is the source matrix which is firstly cast to cv::Mat_&lt;_Tp&gt; </td></tr>
    <tr><td class="paramname">rowRange</td><td>is the desired row-range </td></tr>
    <tr><td class="paramname">colRange</td><td>is the desired col-range </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is the pointer to a destination matrix which is also cast to cv::Mat_&lt;_Tp&gt;* </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a3a0a019e83e6fd5dc76173c9334436b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a> ito::guessDataTypeFromCVMat </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> &amp;&#160;</td>
          <td class="paramname"><em>retval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>method which guesses the dataObject type from a given cv::Mat* </p>
<p>If the given data type is already real, the same type is returned. Else the type of the real argument of the given complex type is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>is the OpenCV matrix. </td></tr>
    <tr><td class="paramname">retval</td><td>an error value will be added if the type cannot be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix ">ito::DataObject</a> type that fits to the given matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a5293e802d23cc6b2d23d43b09bd598f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DATAOBJ_EXPORT <a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::imag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>high-level value which calculates the imaginary value of each element of the input source data object and returns the resulting data object </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new data object with imaginary values </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if undefined data type (e.g. real data types) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#a0e126a9e14968fd29e231b9efab55a3b" title="low-level, double templated method to save the element-wise argument of each element in source matrix...">ArgFunc</a></dd></dl>
<p>calculates the imaginary part of each element in the given data object and returns the result as new data object </p>

</div>
</div>
<a class="anchor" id="af94ef257b87ce7243e79b454cf1cd1f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CmplxTp , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ImagFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>resObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, double templated method to save the element-wise imaginary value of each element in source matrix to result matrix </p>
<p>This method takes the imaginary value of a complex valued input matrix and stores it in the equivalent real typed result matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is source matrix, must have complex type </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the resulting data object, which has the real data type which corresponds to the complex type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::abs </dd></dl>

</div>
</div>
<a class="anchor" id="a4d21d77614c0c51d5dc0d0cc34e06ea0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ito::isFinite </td>
          <td>(</td>
          <td class="paramtype">_Tp&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>method returns whether a given variable is finite. </p>
<p>For floating point variables, this method considers a variable to be finite if the bitmask is neither NaN nor Inf. For floating point values only parameters of type float32, float64, complex64 or complex128 are treated in the desired way. For integer types &ndash;&gt; always true</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is value to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value is neither Inf nor NaN, else false </dd></dl>

</div>
</div>
<a class="anchor" id="a8a1579e24007ee8c3c85fa3d65687a47"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ito::isInf </td>
          <td>(</td>
          <td class="paramtype">_Tp&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>method returns whether a given variable is Inf / not may be NaN. </p>
<p>For floating point variables, this method considers a variable to be Inf if the bitmask is Inf. For floating point values only parameters of type float32, float64, complex64 or complex128 are treated in the desired way. For integer types &ndash;&gt; always false</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is value to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value is Inf else false </dd></dl>

</div>
</div>
<a class="anchor" id="abdff8f7ba0e7ffb2c9ebc823b16b6f8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ito::isNaN </td>
          <td>(</td>
          <td class="paramtype">_Tp&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>method returns whether a given variable is NaN / not a Number but maybe Inf. </p>
<p>For floating point variables, this method considers a variable to be NaN if the bitmask is NaN. For floating point values only parameters of type float32, float64, complex64 or complex128 are treated in the desired way. For integer types &ndash;&gt; always false</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is value to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value is NaN else false </dd></dl>

</div>
</div>
<a class="anchor" id="a124cad7b70aa5f583649232eb051ba20"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ito::isNotZero </td>
          <td>(</td>
          <td class="paramtype">_Tp&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>method returns whether a given variable is not equal to zero. </p>
<p>For floating point variables, this method considers a variable not to be zero, if its value lie without the boundaries (-epsilon,epsilon). Epsilon is retrieved from std::numeric_limits&lt;_Tp&gt;::epsilon(). For floating point values only parameters of type float32, float64, complex64 or complex128 are treated in the desired way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>is value to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value is zero or within the epsilon boundaries, else false </dd></dl>

</div>
</div>
<a class="anchor" id="aa76021c3bc27c63380f8f54552d60b70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ito::isZeroValue </td>
          <td>(</td>
          <td class="paramtype">_Tp&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Tp&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>method returns whether a given variable is equal to zero. </p>
<p>For floating point variables, this method considers a variable to be zero, if its value lie within the boundaries (-epsilon,epsilon). Epsilon can for example be obtained by std::numeric_limits&lt;_Tp&gt;::epsilon(). For floating point values only parameters of type float32, float64, complex64 or complex128 are treated in the desired way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is value to check </td></tr>
    <tr><td class="paramname">epsilon</td><td>is epsilon boundary, for fixed-point values this value is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if value is zero or within the epsilon boundaries, else false </dd></dl>

</div>
</div>
<a class="anchor" id="a2c4b4e040bcfd696c06a402b072210e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::lineCutFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method to take a line cut across the planes of a dataObject. </p>
<p>This method takes a line cut across the planes of a 2d or 3d dataObject. The result is stored in a result matrix. The list containing coordinates of the start and endpoint is interpretated as followed: [x0,y0,x1,y1]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td>is source matrix </td></tr>
    <tr><td class="paramname">*coordinates</td><td>points to a int arrray containing len elements </td></tr>
    <tr><td class="paramname">*len</td><td>length of coordinates list </td></tr>
    <tr><td class="paramname">*res</td><td>result dataObject of the right shape </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a43463b798f2244f8f380ff8af5337c20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::loadDataFromXMLV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamReader &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>dObjIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function copies the CDATA from the xml-file to the allocated dataObject.  This function copies the CDATA from the xml-file to the allocated dataObject. The data was before packed (substitution of xml-registered characters) during saving and is unpacked here. The data is stored plane-wise. The function checks if the plane-size if the object is equal to the imported size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>stream The xml-Stream from the xml-file </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>dObjIn allocated dataObject </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementsize</td><td>Size of the each matrix-element</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#ad763de2bc627c32993a7a6e361497065">loadXML2DOBJ</a>, loadXML2EmptyDOBJ, DataObjectTags, <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix ">DataObject</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a99b23c44aedc092db34847ec3d850a7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::loadObjectHeaderFromXMLV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamReader &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>dObjIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function fills the MetaData (DataObjectTags) of an allocated dataObject from the values of an xml-file  This function fills the MetaData (DataObjectTags) of an allocated dataObject from the values of an xml-file. This includes the axis-Tags (offset, scale, unit, description), value-Tags ((offset), (scale), unit, description) and the rotation matrix. It does not include the tag-Space (std::map&lt;std::string, DataObjectTagType&gt; m_tags) (e.g. protocol ...) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">[in|out]</td><td>stream The xml-Stream from the xml-file </td></tr>
    <tr><td class="paramname">[in|out]</td><td>dObjIn allocated dataObject</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#ad763de2bc627c32993a7a6e361497065">loadXML2DOBJ</a>, loadXML2EmptyDOBJ, DataObjectTags, <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix ">DataObject</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4132d915f47775d5edcab7874885c27d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::loadTagSpaceFromXMLV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamReader &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>dObjIn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function fills the tagsSpace (DataObjectTags) of an allocated dataObject from the values of an xml-file  This function fills the tagsSpace (DataObjectTags) of an allocated dataObject from the values of an xml-file. This onlye includes the tag-Space (std::map&lt;std::string, DataObjectTagType&gt; m_tags) (e.g. protocol ...) and does not include the axis-Tags (offset, scale, unit, description), value-Tags ((offset), (scale), unit, description) and the rotation matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">[in|out]</td><td>stream The xml-Stream from the xml-file </td></tr>
    <tr><td class="paramname">[in|out]</td><td>dObjIn allocated dataObject</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#ad763de2bc627c32993a7a6e361497065">loadXML2DOBJ</a>, loadXML2EmptyDOBJ, DataObjectTags, <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix ">DataObject</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad763de2bc627c32993a7a6e361497065"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::loadXML2DOBJ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObjIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>folderFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyHeaderObjectFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appendEnding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[Out]</td><td>dObjIn Destination dataContainter of type dataObject </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">folderFileName</td><td>Folder and Filename of the Sourcefile</td></tr>
  </table>
  </dd>
</dl>
<p>This function loads data from a xml-file to a dataObject. The file must be compatible to the file-format describted before. There are to possilbe import methods:</p><ol type="1">
<li>onlyHeaderObjectFile == false tries to import a ido file with a itoDataObject-note/startelement.</li>
</ol>
<ol type="1">
<li>onlyHeaderObjectFile == true tries to import a idh file with a itoDataObjectHeader-note/startelement. The dataSpace will be ignored</li>
</ol>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#a49a8ffb4244dbc37882593e3ae344e74" title="This function creates an dataObject from the header of the xml-file  This function creates an dataObj...">createObjectFromXMLV1</a>, <a class="el" href="namespaceito.html#a99b23c44aedc092db34847ec3d850a7c" title="This function fills the MetaData (DataObjectTags) of an allocated dataObject from the values of an xm...">loadObjectHeaderFromXMLV1</a>, <a class="el" href="namespaceito.html#a4132d915f47775d5edcab7874885c27d" title="This function fills the tagsSpace (DataObjectTags) of an allocated dataObject from the values of an x...">loadTagSpaceFromXMLV1</a>, <a class="el" href="namespaceito.html#a43463b798f2244f8f380ff8af5337c20" title="This function copies the CDATA from the xml-file to the allocated dataObject.  This function copies t...">loadDataFromXMLV1</a> </dd></dl>
<p>&lt; Returnvalue for the complete function</p>
<p>&lt; Handle to the source data</p>
<p>&lt; Returnvalue for the complete function</p>
<p>&lt; Handle to the source data </p>

</div>
</div>
<a class="anchor" id="af3ff1acd7b8b3e2140db87852be40b77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::loadXML2QLIST </td>
          <td>(</td>
          <td class="paramtype">QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QFile &amp;&#160;</td>
          <td class="paramname"><em>paramFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">paramList</td><td>Empty List of Type QMap. If not empty this function will clear the list before reading </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Identifier of the plugin. Currently implemented as integer number only </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramFile</td><td>Filename of the file. The file will be opened/closed in this function</td></tr>
  </table>
  </dd>
</dl>
<p>This function reads the parameters for a plugin specified with id from an XML file. During initialisation an xml file with the same name as the plugin library in the plugin directory is used to load the plugin parameters. The xml file is checked for the current plugin-file version and type when opened. The parameters have in the calling function afterwards. </p>

</div>
</div>
<a class="anchor" id="aeb2d269d16022dc1e5835ad308bf5b4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DATAOBJ_EXPORT <a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::makeContinuous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>high-level method which copies an incontinuously organized data object to a continuously organized resulting data object, which is returned </p>
<p>If the given data object already is in a continuous form (e.g. 2D object or continuous representation for higher dimensions), a shallow copy to the given object is returned. In any other cases, a deep copy of the given object is returned, where the entire data block is continuously aligned in memory. Additionally, only values within the current region of interest are copied to the new, continous object (in order to safe memory).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td>is the source data object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>resulting data object </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#aca2f517b2e6d28b2664e7939d7eb7be6" title="low-level, templated method which copies an incontinuously organized data object to a continuously or...">MakeContinuousFunc</a></dd></dl>
<p>if the given data object is not continuously organized, copies the content to a new continuous data object </p>

</div>
</div>
<a class="anchor" id="aca2f517b2e6d28b2664e7939d7eb7be6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::MakeContinuousFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>resDObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method which copies an incontinuously organized data object to a continuously organized resulting data object </p>
<p>this templated helper function should only be called if dObj is non-continuous. This is already checked by the calling function makeContinuous The hidden data which is out of a possible roi will not be part of the new continuous matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td>is the source data object </td></tr>
    <tr><td class="paramname">&amp;resDObj</td><td>is the resulting data object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a487ae8b7490f1de2f8c400eab1859f58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::mergeQLists </td>
          <td>(</td>
          <td class="paramtype">QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>oldList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>newList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkAutoSave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteUnchangedParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>oldList Paramlist with all plugin-parameters, which will contain the merged parameters in the end </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>newList New parameter values to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">checkAutoSave</td><td>Flag to enable / disable autosave control to avoid obsolet parameters to overwrite exisiting parameters.</td></tr>
  </table>
  </dd>
</dl>
<p>This function compares the new list with the old list. If new list contains parameters which do not exist in the existing list, the paremeter is ignored and a warning is added to the errormessage stack. If the checkAutoSave parameter is true, parameters in oldList are not altered of the autosave is disabled. In this case a warning is returned. In case the paremters Type is not equal, a warning is returned and the paremeter is not altered. At the moment only parameters of numeric values and strings are merged. </p>

</div>
</div>
<a class="anchor" id="a1e0e8d58b54879f4392f4bfdffb8ff87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::NansFunc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method for creation of one-valued matrix-plane </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is the pointer to the already allocated cv::Mat_&lt;type&gt;-matrix-plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>zeros </dd></dl>

</div>
</div>
<a class="anchor" id="ade5f0c5a77029b4abc9e8336aece8c93"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#a1e0e8d58b54879f4392f4bfdffb8ff87">ito::NansFunc</a>&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, overloaded template method for creation of one-valued matrix-plane of complex64, complex128 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is the pointer to the already allocated cv::Mat_&lt;type&gt;-matrix-plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>zeros </dd></dl>

</div>
</div>
<a class="anchor" id="a4a608ef3329e9be21dc3ff3df53082ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_Tp ito::numberConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceito.html#acc7eee7faabd3db8463dc9b7922afdba">ito::tDataType</a>&#160;</td>
          <td class="paramname"><em>fromType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>templated method for converting a given scalar value to the data type, indicated by the template parameter </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fromType</td><td>is the data type of the given scalar </td></tr>
    <tr><td class="paramname">&lt;em&gt;scalar</td><td>is the pointer to the scalar value, casted to void </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted scalar value </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if the input data type is unknown or if the conversion failed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>saturate_cast </dd></dl>

</div>
</div>
<a class="anchor" id="ae79848c29f024a20a641706c8b2cd108"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::OnesFunc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method for creation of one-valued matrix-plane </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is the pointer to the already allocated cv::Mat_&lt;type&gt;-matrix-plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>zeros </dd></dl>

</div>
</div>
<a class="anchor" id="a2a31866f858f93852031f3afe301335b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#ae79848c29f024a20a641706c8b2cd108">ito::OnesFunc</a>&lt; <a class="el" href="classito_1_1_rgba32.html">ito::Rgba32</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, overloaded template method for creation of one-valued matrix-plane of RGBA32 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is the pointer to the already allocated cv::Mat_&lt;type&gt;-matrix-plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>zeros </dd></dl>

</div>
</div>
<a class="anchor" id="a6e47940e1e59401ab78b8844ef709634"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::OpMulFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObjRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>brief description </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>check for right definition of multiplication </dd></dl>

</div>
</div>
<a class="anchor" id="a6564539e64aa7be317c6ec9575bb04fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::OpScalarComplexMulFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const complex128 &amp;&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method which multiplies every element of Data Object with a factor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td></td></tr>
    <tr><td class="paramname">factor</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="abd31b9358f256cf6868667a0aa138c1b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::OpScalarMulFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float64 &amp;&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method which multiplies every element of Data Object with a factor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td></td></tr>
    <tr><td class="paramname">factor</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="aea20a9bf1563f8642db8062c912b2b2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::parseParamName </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>paramName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>hasIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>additionalTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>parses parameter name with respect to regular expression, assigned for parameter-communcation with plugins </p>
<p>This method parses any parameter-name with respect to the rules defined for possible names of plugin-parameters.</p>
<p>The regular expression used for the check is "^([a-zA-Z]+\\w*)(\\[(\\d+)\\]){0,1}(:(.*)){0,1}$"</p>
<p>Then the components are:</p>
<p>[0] full string [1] PARAMNAME [2] [INDEX] or empty-string if no index is given [3] INDEX or empty-string if no index is given [4] :ADDITIONALTAG or empty-string if no tag is given [5] ADDITIONALTAG or empty-string if no tag is given</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>is the raw parameter name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">paramName</td><td>is the real parameter name (first part of name; part before the first opening bracket ('[') or if not available the first colon (':')) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hasIndex</td><td>indicates whether the name contains an index part (defined by a number within two brackets (e.g. '[NUMBER]'), which has to be appended to the paramName </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">index</td><td>is the fixed-point index value or -1 if hasIndex is false </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">additionalTag</td><td>is the remaining string of name which is the part after the first colon (':'). If an index part exists, the first colon after the index part is taken. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8fe6cab8c18f8e06ec5b141d57ab1389"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ito::parseParams </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&amp;&#160;</td>
          <td class="paramname"><em>cargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>cargt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function that accepts a python parameter list and returns pointers to the parameters' values and a list with their types </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>list with python parameters </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>number of parameters passed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cargs</td><td>pointers to the parsed parameters </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cargt</td><td>list with the parameter's types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return 0 if all parameters passed could be parsed to a known type, -1 otherwise</dd></dl>
<p>The function accepts a list of python parameters and tries to parse them to make them available to c/c++ functions. The found parameters pointers are given back in the cargs array ant the parameters' types in the cargt array. To free the generated lists use the <a class="el" href="namespaceito.html#aa872946454ba282dd90912cb19cce19b">freeParams</a> function. </p>

</div>
</div>
<a class="anchor" id="afb4b7505de2474537f0ff7a5e678cf94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">ito::RetVal</a> ito::parsePosParams </td>
          <td>(</td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&amp;&#160;</td>
          <td class="paramname"><em>cargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>cargt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>axisVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>posVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>helper function to parse the positioning parameters for an actuator </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>arguments passed to the function (in python) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>cargs parsed argument values </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>cargt parsed argument types </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">axisVec</td><td>Vector with axes numbers </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">posVec</td><td>Vector with position values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk of parameters could be parsed, retError otherwise</dd></dl>
<p>Parses the parameters passed to a setPos command in python. For each axis that should be positioned an axis number and a position value are expected. </p>

</div>
</div>
<a class="anchor" id="a34793f8ffb88f9af5ab77176c5614dfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::planeStackFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>mats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method which stacks a sequence of dataObjects horizontally or vertically together . </p>
<p>The result is stored in a result matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*mats</td><td>the source sequence of dataObjects. All objects must be of the same type and contain the same number of planes. Also the shape of the axis along which is not stacked must be equal to all objects. </td></tr>
    <tr><td class="paramname">&amp;num</td><td>the number of dataObjects inclluded in mats </td></tr>
    <tr><td class="paramname">&amp;axis</td><td>defines the axis along the dataObjects will be stacked in the res dataObject. The parameter has to be one or two. </td></tr>
    <tr><td class="paramname">*res</td><td>is the result matrix (3d <a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix ">DataObject</a>), which must have a size that fits to the corresponding stack axis. Furthermore the cv::Mats must be continous </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a870a619f4f3ef4e483e8bf469d89ce97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::plugin_hideToolbox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>aib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the list of available parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>the actuator object (python)</td></tr>
  </table>
  </dd>
</dl>
<p>This method simply close the widget </p>

</div>
</div>
<a class="anchor" id="ac145e823451a24a203e1a201da54bbdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::plugin_showToolbox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>aib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns the list of available parameters </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">self</td><td>the actuator object (python)</td></tr>
  </table>
  </dd>
</dl>
<p>This method simply open the widget </p>

</div>
</div>
<a class="anchor" id="a436531932ee63c6830b212c7f5531ec1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ito::PyDoc_STRVAR </td>
          <td>(</td>
          <td class="paramtype">dataObjectInit_doc&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;dataObject(dims = [], dtype = \&quot;uint8\&quot;, continuous = 0, data = None) -&gt; dataObject \n\\n\Creates a new n-dimensional dataObject array. \n\\n\The :class:`dataObject` represents a multidimensional array of fixed-size items \n\(integer, floating-point or complex values) and contains&#160;</td>
          <td class="paramname"><em>further</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">meta\n\&#160;</td>
          <td class="paramname"><em>information</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">like&#160;</td>
          <td class="paramname"><em>units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">axis&#160;</td>
          <td class="paramname"><em>descriptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalings&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">general&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">...\n\Recently the following data &#160;</td>
          <td class="paramname"><em>types</em>dtype) are supported:\n\\n\*Integer(int8, uint8, int16, uint16, int32, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">\n\*Floating &#160;</td>
          <td class="paramname"><em>point</em>float32, float64(=&gt; double), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">\n\*Complex(complex64(2x float32), complex128(2x float64)).\n\*Color(rgba32(uint32 or uint[4] containing the four 8bit values[R, G, B, Alpha])).\n\\n\Arrays can also be constructed using some of the static pre-initialization methods\n\:meth:`zeros`&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">:meth:`ones`&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">:meth:`rand`or:meth:`randN`\n\(refer to the See Also section below).\n\\n\Parameters\n\-----------\n\dims:sequence of&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional\n\``dims``is a list or tuple indicating the size of each dimension.The length\n\of this sequence defines the dimension of this dataObject.As an&#160;</td>
          <td class="paramname"><em>example</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">\n\``&#160;</td>
          <td class="paramname"><em>dims</em> = <code>[2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">3]``creates a two-dimensional dataObject with two rows and three columns.\n\If``dims``is not&#160;</td>
          <td class="paramname"><em>given</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">an empty data object is created.\n\dtype:str&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional\n\Data type of each element in the array.Possible values are:\n\ 'int8'&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'uint8'&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'int16'&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'uint16'&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'int32'&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'float32'&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'float64'&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'complex64'&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">\n\ 'complex128'&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"> 'rgba32'.\n\continuous:int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional\n\The last two dimensions of a dataObject are always stored as continuous junk of&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">\n\denoted as plane.If``continuous``is set to``1``&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">even a dataObject with a dimension\n\``&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">2``will allocate one big block of memory and continuously stores the matrix data\n\there.\n\If``continuous``is&#160;</td>
          <td class="paramname"><em>0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">different junks of memory are allocated for each&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">the planes\n\are referenced by means of an index vector.This is recommended for large&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">since\n\the operating system might get trouble allocated one very big continuous junk of&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">\n\instead of multiple smaller ones.\n\data:int or float or complex or rgba or sequence of int or sequence of float or sequence of complex or dataObject or np.&#160;</td>
          <td class="paramname"><em>ndarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">optional\n\If``data``is a single&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">all values in the dataObject are set to this single value.\n\&#160;</td>
          <td class="paramname"><em>Else</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">the sequence or array-like object must have the same number of values than\n\the data object.These values will then be assigned to the new data object(filled row by row).\n\\n\Notes\n\------\n\The:class:`itom.dataObject`is a direct wrapper for the underlying C++class *dataObject *.\n\This array class mainly is based on the class *Mat *of the computer vision library(OpenCV).\n\\n\In order to handle huge&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">the data object can divide one array into chunks in memory.\n\Each subpart(called matrix-plane) is two-dimensional and covers data of the last two dimensions.\n\In C++-context each of these matrix-planes is of type cv::Mat_&lt; type &gt; and can be used with\n\every operator given by the openCV-framework(version 2.3.1 or higher).\n\\n\The dimensions of the matrix are structured descending.So if we assume to have a n-dimensional\n\matrix``A``&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">where each dimension has its size&#160;</td>
          <td class="paramname"><em>s_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">the dimensions order is&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">..&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">z&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">y&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">x and\n\the corresponding sizes of``A``are.\n\\n\In order to make the data object compatible to continuously organized data&#160;</td>
          <td class="paramname"><em>structures</em>[s_n, s_(n-1),s_(n-2),..., s_y, s_x], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">like\n\numpy-&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">it is also possible to have all matrix-planes in one data-block in memory\n\(not recommended for huge matrices).&#160;</td>
          <td class="paramname"><em>Nevertheless</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">the indicated data structure with the\n\two-dimensional sub-matrix-planes is still existing.The data organization is equal to the\n\one of&#160;</td>
          <td class="paramname"><em>openCV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hence&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">two-dimensional matrices are stored row-by-row(C-style)...\n\\n\In addition to&#160;</td>
          <td class="paramname"><em>OpenCV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">itom.dataObject supports complex valued data types for all operators and methods.\n\\n\Warning 'uint32'is currently not&#160;</td>
          <td class="paramname"><em>available</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">since it is not fully supported by the underlying OpenCV matrices.\n\\n\**Deep&#160;</td>
          <td class="paramname"><em>Copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Shallow Copy and ROI **\n\\n\It is possible to set a n-dimensional region of interest(ROI) to each&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">the virtual&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">\n\which will be delivered if the user asks for the matrix size.\n\To avoid copy operations where possible a&#160;</td>
          <td class="paramname"><em>simple</em> = <code>_Operator&#160;will&#160;also&#160;make&#160;a&#160;shallow&#160;copy&#160;of&#160;the&#160;object.\n\Shallow&#160;copies&#160;share&#160;the&#160;same&#160;data&#160;(elements&#160;and&#160;meta&#160;data)&#160;with&#160;the&#160;original&#160;object</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hence manipulations of one object will affect the\n\original object and all shallow copies.\n\\n\The opposite a deep copy of a dataObject(by sourceObject.copy()) creates a complete mew matrix with own meta data object.\n\\n\Example::\n\\n\#Create an object\n\&#160;</td>
          <td class="paramname"><em>dObj</em> = <code>dataObject([5,&#160;10,&#160;10],&#160;'int8')\n\&#160;&#160;&#160;&#160;\n\&#160;&#160;&#160;&#160;#&#160;Make&#160;a&#160;shallow&#160;copy&#160;\n\&#160;&#160;&#160;&#160;dObjShallow&#160;=&#160;dObj&#160;\n\&#160;&#160;&#160;&#160;\n\&#160;&#160;&#160;&#160;#&#160;Make&#160;a&#160;shallow&#160;copy&#160;on&#160;ROI\n\&#160;&#160;&#160;&#160;dObjROI&#160;=&#160;dObj[1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">:&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">:]\n\\n\#Set the value of elementto 0\n\&#160;</td>
          <td class="paramname"><em>dObj</em>[1, 0, 0][1, 0, 0] = <code>0\n\&#160;&#160;&#160;&#160;\n\&#160;&#160;&#160;&#160;#&#160;Make&#160;a&#160;deep&#160;copy&#160;of&#160;the&#160;dObjROI\n\&#160;&#160;&#160;&#160;dObjROICopy&#160;=&#160;dObjROI.copy()\n\&#160;&#160;&#160;&#160;\n\&#160;&#160;&#160;&#160;#&#160;Set&#160;the&#160;value&#160;of&#160;dObjROICopy&#160;element&#160;[0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">0] to 127 without effecting other objects\n\&#160;</td>
          <td class="paramname"><em>dObjROICopy</em>[0, 0, 0] = <code>127\n\\n\**Constructor**&#160;\n\\n\The&#160;function&#160;dataObject([dims&#160;[,&#160;dtype='uint8'[,&#160;continuous&#160;=&#160;0][,&#160;data&#160;=&#160;valueOrSequence]]])\n\creates&#160;a&#160;new&#160;itom-dataObject&#160;filled&#160;with&#160;undefined&#160;data.\n\If&#160;no&#160;parameters&#160;are&#160;given</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">an uninitilized <a class="el" href="classito_1_1_data_object.html">DataObject</a>(dims=0, no sizes) is created.\n\\n\As second possibility you can also use the copy-constructor 'dataObject(anyArray:Union[dataObject, np.ndarray], dtype:str= '', continuous:int=0)'&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">\n\where 'anyArray'must be any array-like structure which is parsable by the numpy-interface.If a dtype is given or if continuous is&#160;</td>
          <td class="paramname"><em>1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">\n\the new data object will be a type-casted(and/or continuous) copy of 'anyArray'.\n\\n\See Also\n\----------\n\ones:Static method to construct a data object filled with ones.\n\zeros:Static method to construct a data object filled with zeros.\n\nans:Static method to construct a data object(float or complex only) with NaNs.\n\rand:Static method to construct a randomly filled data object(uniform distribution).\n\randN:Static method to construct a randomly filled data object(gaussian distribution).&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>brief description </p>
<p>long description</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>description </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>description </dd></dl>
<dl class="section see"><dt>See also</dt><dd>(see also) keywords (comma-separated) </dd></dl>

</div>
</div>
<a class="anchor" id="a9d28eae15e9624a9b374e03abe6d8f83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::PyWidgetOrFilterHelp </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getWidgetHelp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>pArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>pKwds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>first try to catch a perfect match with existing filters</p>
<p>Now get the complete filterlist </p>

</div>
</div>
<a class="anchor" id="ac2f648a2c958cd46025c0fea3087da1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::RandFunc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>randMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method for creation of random-valued matrix-plane </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">type</td><td>is the desired data-element-type </td></tr>
    <tr><td class="paramname">randMode</td><td>switch mode between uniform distributed(false) and normal distributed noise(true) </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is the pointer to the already allocated cv::Mat_&lt;type&gt;-matrix-plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>zeros </dd></dl>

</div>
</div>
<a class="anchor" id="a194f174c066f155d01ffdbd3910e2b19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#ac2f648a2c958cd46025c0fea3087da1a">ito::RandFunc</a>&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>randMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for low-level, templated method for creation of random-valued matrix-plane of type complex128 </p>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#ac2f648a2c958cd46025c0fea3087da1a" title="low-level, templated method for creation of random-valued matrix-plane ">RandFunc</a>, zeros, ones </dd></dl>

</div>
</div>
<a class="anchor" id="a36e33be90b11da88529cd13863e68645"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#ac2f648a2c958cd46025c0fea3087da1a">ito::RandFunc</a>&lt; <a class="el" href="classito_1_1_rgba32.html">ito::Rgba32</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>randMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for low-level, templated method for creation of random-valued matrix-plane of type rgba32 </p>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#ac2f648a2c958cd46025c0fea3087da1a" title="low-level, templated method for creation of random-valued matrix-plane ">RandFunc</a>, zeros, ones </dd></dl>

</div>
</div>
<a class="anchor" id="ae98bfefe271214ccda435c4be975f5e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::readDoubleFromXML </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>Element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>Attrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isBinary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This helper function extracts a double from the xml-Attributes of the Stream  This helper function extracts a double from the xml-Attributes of the Stream copied by the caller with the attrStream = attrStream = stream.attributes();. the Function checks if the attribute exists and than tries to convert to the value of the attribute either from binary or with string to double functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attrStream</td><td>incomming attribute-stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Element</td><td>name of the element (only for error msg) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Attrib</td><td>name of the attribute to extract </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>val Must be filled with default value and is filled with value from the XML-Stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isBinary</td><td>Must be true if attribute value was stored as binary else false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#ad763de2bc627c32993a7a6e361497065">loadXML2DOBJ</a>, loadXML2EmptyDOBJ, <a class="el" href="namespaceito.html#a99b23c44aedc092db34847ec3d850a7c" title="This function fills the MetaData (DataObjectTags) of an allocated dataObject from the values of an xm...">loadObjectHeaderFromXMLV1</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa3fb95bb073f0055c98ee99e91b9c22a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::readStdStringFromXML </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>Element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString &amp;&#160;</td>
          <td class="paramname"><em>Attrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This helper function extracts a std::string from the xml-Attributes of the Stream  This helper function extracts a std::string from the xml-Attributes of the Stream copied by the caller with the attrStream = attrStream = stream.attributes();. the Function checks if the attribute exists and than tries to convert to the value of the attribute from QString to std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">attrStream</td><td>incomming attribute-stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Element</td><td>name of the element (only for error msg) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Attrib</td><td>name of the attribute to extract </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>val Must be filled with default value and is filled with value from the XML-Stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#ad763de2bc627c32993a7a6e361497065">loadXML2DOBJ</a>, loadXML2EmptyDOBJ, <a class="el" href="namespaceito.html#a99b23c44aedc092db34847ec3d850a7c" title="This function fills the MetaData (DataObjectTags) of an allocated dataObject from the values of an xm...">loadObjectHeaderFromXMLV1</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afecd6942c1876cc35f42046db0a098ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ito::readTillNext </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamReader &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>times</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxtimes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This helper function reads the stream till the next startElement.  The Qt-Function readNextStartElement sometimes stops at the end-element (:P). So the function tries to read until it reaches the next startelement but only for maxtimes trys the Function checks if the attribute exists and than tries to convert to the value of the attribute either from binary or with string to double functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>incomming xml-stream </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>times Counts of iterations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxtimes</td><td>maximal number of iterations to perform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#ad763de2bc627c32993a7a6e361497065">loadXML2DOBJ</a>, loadXML2EmptyDOBJ </dd></dl>

</div>
</div>
<a class="anchor" id="ad2992d0fdb1e60676a01bdc25477ea85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DATAOBJ_EXPORT <a class="el" href="classito_1_1_data_object.html">DataObject</a> ito::real </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> &amp;&#160;</td>
          <td class="paramname"><em>dObj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>high-level value which calculates the real value of each element of the input source data object and returns the resulting data object </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">&amp;dObj</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new data object with real values </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>if undefined data type (e.g. real data types) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#a0e126a9e14968fd29e231b9efab55a3b" title="low-level, double templated method to save the element-wise argument of each element in source matrix...">ArgFunc</a></dd></dl>
<p>calculates the real part of each element in the given data object and returns the result as new data object </p>

</div>
</div>
<a class="anchor" id="a5756b35dfcc4d0bec5d7c69451cfaebe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CmplxTp , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::RealFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>resObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, double templated method to save the element-wise real value of each element in source matrix to result matrix </p>
<p>This method takes the real value of a complex valued input matrix and stores it in the equivalent real typed result matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is source matrix, must have complex type </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the resulting data object, which has the real data type which corresponds to the complex type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::abs </dd></dl>

</div>
</div>
<a class="anchor" id="aca8826921e5df8a0a37e1a43ed2800cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::saveDOBJ2XML </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObjOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>folderFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyHeaderObjectFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doubleAsBinary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import a dataObject from harddrive, saved in the ITO-XML-Format (.ido or .idh) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dObjOut</td><td><a class="el" href="classito_1_1_data_object.html" title="dataObject contains a n-dimensional matrix ">DataObject</a> to save </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">folderFileName</td><td>Name of the folder and the filename e.g. c:\bla.xml or c://bla.xml </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doubleAsBinary</td><td>If true, double are exported as binary, by defaults they are saved as strings</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes data and meta data of a dataObject to the harddrive. The file format is based on xml. The data of the dataObject are converted to binary without XML-registed signs by QByteArray::toBase64()). The metaData and tagSpace are either saved as binary (QByteArray::toBase64()) or saves as strings with 15 signifiant digits (more than 32-Bit). So for most applications doubleAsBinary==false is enough.</p>
<p>Lyda </p><dl class="section date"><dt>Date</dt><dd>04.2012 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#a09c6b2139e9995dabe2dbbabd25bab48" title="This helper function writes the header of the Object to the xml stream.  This helper function writes ...">writeObjectHeaderToFileV1</a>, <a class="el" href="namespaceito.html#aad6e1f7022d1f9024c771f51f01f78da" title="This helper function writes the tags defined in the tagMap (DataObjectTags) from the Object to the xm...">writeObjectTagsToFileV1</a>, <a class="el" href="namespaceito.html#af96b552c35539676c8a13957de2183ad" title="This helper function writes the data(cv::mats) from the Object to the xml stream.  This helper functi...">writeObjectDataToFileV1</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1f0f29281bc5cb69fcd9759a369b09eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::saveQLIST2XML </td>
          <td>(</td>
          <td class="paramtype">QMap&lt; QString, <a class="el" href="classito_1_1_param.html">Param</a> &gt; *&#160;</td>
          <td class="paramname"><em>paramList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QString&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QFile &amp;&#160;</td>
          <td class="paramname"><em>paramFile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in/out]</td><td>paramList List of Type QMap with the parameters to save. The parameters are deleted during writing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Identifier of the plugin. Currently implemented as integer number only </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">paramFile</td><td>Filename of the file. The file will be opened/closed in this function</td></tr>
  </table>
  </dd>
</dl>
<p>This function writes the parameters of a plugin to an XML file. During plugin closing this function is executed with a file name with same name as the plugin library in the plugin directory The xml file is checked for the current plugin-file version and type when opened. In case of a type conflict the parameter is currently not saved. </p>
<p>&lt; passed all elements without success, so add new one </p>

</div>
</div>
<a class="anchor" id="a78e11ebe0a194e906b1d2ddfa780acc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CmplxTp , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::SetImagFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>valueObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, double templated method to save the element-wise real value of each element in source matrix to result matrix </p>
<p>This method takes the real value of a complex valued input matrix and stores it in the equivalent real typed result matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is source matrix, must have complex type </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the resulting data object, which has the real data type which corresponds to the complex type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::abs </dd></dl>

</div>
</div>
<a class="anchor" id="a8d52a7127228d59e411619e569fbee41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PyObject* ito::setParam </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_add_in_base.html">ito::AddInBase</a> *&#160;</td>
          <td class="paramname"><em>addInObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PyObject *&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set a parameter value </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addInObj</td><td>the addIn whoes parameter is requested </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>the parameter name and value in a python object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Py_Return_None on success, NULL otherwise</dd></dl>
<p>The function tries to set the value of the parameter with the name given in args. If the parameter does not exist or is incompatible with the value passed, NULL is returned. To actually set the value the setParam function of the plugin is invoked. </p>

</div>
</div>
<a class="anchor" id="a444878ac63ad03431280c47024a535d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _CmplxTp , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::SetRealFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>valueObj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, double templated method to save the element-wise real value of each element in source matrix to result matrix </p>
<p>This method takes the real value of a complex valued input matrix and stores it in the equivalent real typed result matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj</td><td>is source matrix, must have complex type </td></tr>
    <tr><td class="paramname">*resObj</td><td>is the resulting data object, which has the real data type which corresponds to the complex type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>std::abs </dd></dl>

</div>
</div>
<a class="anchor" id="a66a9c5dc6bb068b2ce6be93f0fcf4b9f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftLFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>shiftbit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method which element-wisely shifts the values of the source matrix by a certain value to the left </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td></td></tr>
    <tr><td class="paramname">shiftbit</td><td>are the number bits the values are shifted </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>for unsupported data types (template specialization) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="a23c24130d3ca6d2a459d5bf2a8a4b92b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#a66a9c5dc6bb068b2ce6be93f0fcf4b9f">ito::ShiftLFunc</a>&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for shift function of type complex128 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2674629cfb1e34316dd627781bfa3c0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#a66a9c5dc6bb068b2ce6be93f0fcf4b9f">ito::ShiftLFunc</a>&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for shift function of type complex64 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d19fd38859c027dcf514812e987c9ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#a66a9c5dc6bb068b2ce6be93f0fcf4b9f">ito::ShiftLFunc</a>&lt; ito::float32 &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for shift function of type float32 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8de5cddc9cbf637156d3acc27566e4b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#a66a9c5dc6bb068b2ce6be93f0fcf4b9f">ito::ShiftLFunc</a>&lt; ito::float64 &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for shift function of type float64 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a842490cbe28559727556af0e04bdc24a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#a66a9c5dc6bb068b2ce6be93f0fcf4b9f">ito::ShiftLFunc</a>&lt; <a class="el" href="classito_1_1_rgba32.html">ito::Rgba32</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for shift function of type rgba32 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8040457b6c031cbefb51fbdae76a3bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ShiftRFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char&#160;</td>
          <td class="paramname"><em>shiftbit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method which element-wisely shifts the values of the source matrix by a certain value to the right </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*src</td><td></td></tr>
    <tr><td class="paramname">shiftbit</td><td>are the number bits the values are shifted </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>for unsupported data types (template specialization) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>

</div>
</div>
<a class="anchor" id="af06888f8baac8366f96641426371bb39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#ab8040457b6c031cbefb51fbdae76a3bb">ito::ShiftRFunc</a>&lt; ito::complex128 &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for shift function of type complex128 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad405a0a85400adc16e1c3b1f4e1884b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#ab8040457b6c031cbefb51fbdae76a3bb">ito::ShiftRFunc</a>&lt; ito::complex64 &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for shift function of type complex64 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aabb30836cf7a7a0a3f21cf6fc35848eb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#ab8040457b6c031cbefb51fbdae76a3bb">ito::ShiftRFunc</a>&lt; ito::float32 &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for shift function of type float32 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b338e54a07664315beb473504a2c8d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#ab8040457b6c031cbefb51fbdae76a3bb">ito::ShiftRFunc</a>&lt; ito::float64 &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for shift function of type float64 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3098f35e70fda092a104ac6be8b223c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> <a class="el" href="namespaceito.html#ab8040457b6c031cbefb51fbdae76a3bb">ito::ShiftRFunc</a>&lt; <a class="el" href="classito_1_1_rgba32.html">ito::Rgba32</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>template specialisation for shift function of type rgba32 </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">cv::Exception</td><td>since shifting is not defined for that input type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1b438d0eb2715bbea3a573820950808"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::SubFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObjRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method for element-wise subtraction of values from second data object from values of first data object </p>
<p>dObjRes = dObj1 - dObj2</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*dObj1</td><td>is the first data object </td></tr>
    <tr><td class="paramname">*dObj2</td><td>is the second data object </td></tr>
    <tr><td class="paramname">*dObjRes</td><td>is the pointer to the data object, where the values will be written to. This data object must already be allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The size check for all data objects must be done before. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>operator -=, operator - </dd></dl>

</div>
</div>
<a class="anchor" id="af96b552c35539676c8a13957de2183ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::writeObjectDataToFileV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamWriter &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObjOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This helper function writes the data(cv::mats) from the Object to the xml stream.  This helper function writes the data(cv::mats) from the Object to the xml stream. Therefore the data is converted using QByteArray::toBase64() to avoid XML-conflict with the binary data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>stream outgoing xml-stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dObjOut</td><td>The allocated src-Object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">elementsize</td><td>Size of each matrix element in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#aca8826921e5df8a0a37e1a43ed2800cc" title="Import a dataObject from harddrive, saved in the ITO-XML-Format (.ido or .idh) ">saveDOBJ2XML</a>, saveDOBJSpecificData2XML </dd></dl>

</div>
</div>
<a class="anchor" id="a09c6b2139e9995dabe2dbbabd25bab48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::writeObjectHeaderToFileV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamWriter &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObjOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doubleAsBinary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>elementsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This helper function writes the header of the Object to the xml stream.  This helper function writes the header (dims, sizes, type) of an object and the metaData (complete DataObjectTags without tagsMap) from the Object to the xml stream. The values of the header are stored as string. The values of each axis-tag / value-tag / rotation matrix are in case of string-type directly written to the stream or in case of double converted to either strings directly (15 significat digits, &gt;32Bit) or stored as lostfree binary (QByteArray::toBase64() to avoid XML-conflict). WARNING: Do not change the header (dims, sizes, type) information or the value of tags exported as binary (d2b). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>stream outgoing xml-stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dObjOut</td><td>The allocated src-Object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doubleAsBinary</td><td>Toggle binary export for double</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#aca8826921e5df8a0a37e1a43ed2800cc" title="Import a dataObject from harddrive, saved in the ITO-XML-Format (.ido or .idh) ">saveDOBJ2XML</a>, saveDOBJSpecificData2XML, DataObjectTags </dd></dl>

</div>
</div>
<a class="anchor" id="aad6e1f7022d1f9024c771f51f01f78da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::writeObjectTagsToFileV1 </td>
          <td>(</td>
          <td class="paramtype">QXmlStreamWriter &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classito_1_1_data_object.html">DataObject</a> *&#160;</td>
          <td class="paramname"><em>dObjOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doubleAsBinary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This helper function writes the tags defined in the tagMap (DataObjectTags) from the Object to the xml stream.  This helper function writes the tags defined in the tagMap (DataObjectTags) from the Object to the xml stream. Therefore the values of each tag are in case of string-type directly written to the stream or in case of double converted to either strings directly (15 significat digits, &gt;32Bit) or stored as lostfree binary (QByteArray::toBase64() to avoid XML-conflict). WARNING: Do not change information or the value of tags exported as binary (d2b). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">[in|out]</td><td>stream outgoing xml-stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dObjOut</td><td>The allocated src-Object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">doubleAsBinary</td><td>Toggle binary export for double</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceito.html#aca8826921e5df8a0a37e1a43ed2800cc" title="Import a dataObject from harddrive, saved in the ITO-XML-Format (.ido or .idh) ">saveDOBJ2XML</a>, saveDOBJSpecificData2XML, DataObjectTags </dd></dl>

</div>
</div>
<a class="anchor" id="a9a14d1532a9547f01a41b57dd64e042a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classito_1_1_ret_val.html">RetVal</a> ito::ZerosFunc </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>sizeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar **&#160;</td>
          <td class="paramname"><em>dstMat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>low-level, templated method for creation of zero-valued matrix-plane </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeY</td><td>are the number of rows </td></tr>
    <tr><td class="paramname">sizeX</td><td>are the number of columns </td></tr>
    <tr><td class="paramname">**dstMat</td><td>is the pointer to the already allocated cv::Mat_&lt;type&gt;-matrix-plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>retOk </dd></dl>
<dl class="section see"><dt>See also</dt><dd>zeros </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a5f4e931b9ffb4d53504b835419bbf5d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tCoutFunc ito::fListCout[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">{</div>
<div class="line">   coutFunc&lt;int8&gt;,</div>
<div class="line">   coutFunc&lt;uint8&gt;,</div>
<div class="line">   coutFunc&lt;int16&gt;,</div>
<div class="line">   coutFunc&lt;uint16&gt;,</div>
<div class="line">   coutFunc&lt;int32&gt;,</div>
<div class="line">   coutFunc&lt;uint32&gt;,</div>
<div class="line">   coutFunc&lt;ito::float32&gt;,</div>
<div class="line">   coutFunc&lt;ito::float64&gt;,</div>
<div class="line">   coutFunc&lt;ito::complex64&gt;,</div>
<div class="line">   coutFunc&lt;ito::complex128&gt;,</div>
<div class="line">   coutFunc&lt;ito::Rgba32&gt;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0a87731c8a17f2acd5a5f3de4ae3f262"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ito::ITOM_API_FUNCS_GRAPH_ARR[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mnumberOfColorBars,     </div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetColorBarName,       </div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetColorBarIdx,        </div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.<a class="code" href="classito_1_1api_functions_graph.html#a9336f8beb9f2ca2bc468b3e5ae7e1cef">mgetFigure</a>,             </div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetPluginList,         </div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mstartLiveData,         </div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mstopLiveData,          </div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mconnectLiveData,       </div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mdisconnectLiveData,    </div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetColorBarIdxFromName,</div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetFigureSetting,      </div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetPluginWidget,       </div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.<a class="code" href="classito_1_1api_functions_graph.html#a525e56b5c315ca2c4f8da4a51404c88c">mgetFigureUIDByHandle</a>,  </div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mgetPlotHandleByID,     </div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.<a class="code" href="classito_1_1api_functions_graph.html#a0a60f970f03ac70d30f3ddec5e181e15">sendParamToPyWorkspaceThreadSafe</a>,       </div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.<a class="code" href="classito_1_1api_functions_graph.html#a0f9a769048627f270502dcf0e1cb39ba">sendParamsToPyWorkspaceThreadSafe</a>,      </div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;QPropertyHelper::readProperty,                                  </div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;QPropertyHelper::writeProperty,                                 </div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mConnectToOutputAndErrorStream,         </div>
<div class="line">        (<span class="keywordtype">void</span>*)&amp;singleApiFunctionsGraph.mDisconnectFromOutputAndErrorStream,    </div>
<div class="line">        NULL</div>
<div class="line">    }</div>
<div class="ttc" id="classito_1_1api_functions_graph_html_a525e56b5c315ca2c4f8da4a51404c88c"><div class="ttname"><a href="classito_1_1api_functions_graph.html#a525e56b5c315ca2c4f8da4a51404c88c">ito::apiFunctionsGraph::mgetFigureUIDByHandle</a></div><div class="ttdeci">static ito::RetVal mgetFigureUIDByHandle(QObject *figure, ito::uint32 &amp;figureUID)</div><div class="ttdoc">return the figure UID for the given figure </div><div class="ttdef"><b>Definition:</b> apiFunctionsGraph.cpp:472</div></div>
<div class="ttc" id="classito_1_1api_functions_graph_html_a9336f8beb9f2ca2bc468b3e5ae7e1cef"><div class="ttname"><a href="classito_1_1api_functions_graph.html#a9336f8beb9f2ca2bc468b3e5ae7e1cef">ito::apiFunctionsGraph::mgetFigure</a></div><div class="ttdeci">static ito::RetVal mgetFigure(const QString &amp;figCategoryName, const QString &amp;figClassName, ito::uint32 &amp;UID, QWidget **figure, QWidget *parent=NULL)</div><div class="ttdoc">tries to get an existing figure of a given UID (if UID > 0) or tries to open a new figure from the gi...</div><div class="ttdef"><b>Definition:</b> apiFunctionsGraph.cpp:163</div></div>
<div class="ttc" id="classito_1_1api_functions_graph_html_a0f9a769048627f270502dcf0e1cb39ba"><div class="ttname"><a href="classito_1_1api_functions_graph.html#a0f9a769048627f270502dcf0e1cb39ba">ito::apiFunctionsGraph::sendParamsToPyWorkspaceThreadSafe</a></div><div class="ttdeci">static ito::RetVal sendParamsToPyWorkspaceThreadSafe(const QStringList &amp;varnames, const QVector&lt; QSharedPointer&lt; ito::ParamBase &gt; &gt; &amp;values)</div><div class="ttdoc">function called by apiSendParamsToPyWorkspace </div><div class="ttdef"><b>Definition:</b> apiFunctionsGraph.cpp:527</div></div>
<div class="ttc" id="classito_1_1api_functions_graph_html_a0a60f970f03ac70d30f3ddec5e181e15"><div class="ttname"><a href="classito_1_1api_functions_graph.html#a0a60f970f03ac70d30f3ddec5e181e15">ito::apiFunctionsGraph::sendParamToPyWorkspaceThreadSafe</a></div><div class="ttdeci">static ito::RetVal sendParamToPyWorkspaceThreadSafe(const QString &amp;varname, const QSharedPointer&lt; ito::ParamBase &gt; &amp;value)</div><div class="ttdoc">function called by apiSendParamToPyWorkspace </div><div class="ttdef"><b>Definition:</b> apiFunctionsGraph.cpp:521</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1182d98e161dd3b539921d632f84038d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structito_1_1_py_c_map.html">ito::PyCMap</a>  ito::pyCMap[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    { <span class="stringliteral">&quot;QString&quot;</span>, <span class="stringliteral">&quot;str&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;QByteArray&quot;</span>, <span class="stringliteral">&quot;bytearray&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;ito::Shape&quot;</span>, <span class="stringliteral">&quot;shape&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;QVector&lt;ito::Shape&gt;&quot;</span>, <span class="stringliteral">&quot;seq. of shape&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;QSharedPointer&lt;ito::DataObject&gt;&quot;</span>, <span class="stringliteral">&quot;dataObject&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;QVector&lt;double&gt;&quot;</span>, <span class="stringliteral">&quot;seq. of float&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;double&quot;</span>, <span class="stringliteral">&quot;float&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;QVector&lt;float&gt;&quot;</span>, <span class="stringliteral">&quot;seq. of float&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;QFont&quot;</span>, <span class="stringliteral">&quot;font&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;QColor&quot;</span>, <span class="stringliteral">&quot;color str, rgba or hex&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;QPointer&lt;ito::AddInDataIO&gt;&quot;</span>, <span class="stringliteral">&quot;dataIO&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;QPointer&lt;ito::AddInActuator&gt;&quot;</span>, <span class="stringliteral">&quot;actuator&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;QPointer&lt;ito::AddInBase&gt;&quot;</span>, <span class="stringliteral">&quot;dataIO or actuator&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;QStringList&quot;</span>, <span class="stringliteral">&quot;seq. of str&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;ito::AutoInterval&quot;</span>, <span class="stringliteral">&quot;autoInterval&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;ito::ItomPlotHandle&quot;</span>, <span class="stringliteral">&quot;uiItem&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;QRegion&quot;</span>, <span class="stringliteral">&quot;region&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;QTime&quot;</span>, <span class="stringliteral">&quot;datetime.time&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;QDate&quot;</span>, <span class="stringliteral">&quot;datetime.date&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;QDateTime&quot;</span>, <span class="stringliteral">&quot;datetime.datetime&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;QVector&lt;int&gt;&quot;</span>, <span class="stringliteral">&quot;seq. of int&quot;</span> },</div>
<div class="line">    { <span class="stringliteral">&quot;QVector3D&quot;</span>, <span class="stringliteral">&quot;seq. of 3 floats&quot;</span> },</div>
<div class="line">    { 0, 0 }</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceito.html">ito</a></li>
    <li class="footer">Generated on Thu Mar 4 2021 12:27:43 for itom by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9 </li>
  </ul>
</div>
</body>
</html>
